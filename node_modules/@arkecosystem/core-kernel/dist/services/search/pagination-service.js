"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("@arkecosystem/crypto");
const ioc_1 = require("../../ioc");
const utils_1 = require("../../utils");
let PaginationService = class PaginationService {
    getEmptyPage() {
        return { results: [], totalCount: 0, meta: { totalCountIsEstimate: false } };
    }
    getPage(pagination, sorting, items) {
        // todo: Array.from(items) can be avoided.
        // todo: There is no reason to sort items that will not be included into result.
        // todo: Only pagination.offset + pagination.limit items have to be kept in memory.
        const total = Array.from(items).sort((a, b) => this.compare(a, b, sorting));
        return {
            results: total.slice(pagination.offset, pagination.offset + pagination.limit),
            totalCount: total.length,
            meta: { totalCountIsEstimate: false },
        };
    }
    compare(a, b, sorting) {
        for (const { property, direction } of sorting) {
            let valueA = utils_1.get(a, property);
            let valueB = utils_1.get(b, property);
            // undefined and null are always at the end regardless of direction
            if (typeof valueA === "undefined" && typeof valueB === "undefined")
                return 0;
            if (typeof valueA === "undefined" && typeof valueB !== "undefined")
                return 1;
            if (typeof valueA !== "undefined" && typeof valueB === "undefined")
                return -1;
            if (valueA === null && valueB === null)
                return 0;
            if (valueA === null && valueB !== null)
                return 1;
            if (valueA !== null && valueB === null)
                return -1;
            if (direction === "desc") {
                [valueA, valueB] = [valueB, valueA];
            }
            if ((typeof valueA === "boolean" && typeof valueB === "boolean") ||
                (typeof valueA === "string" && typeof valueB === "string") ||
                (typeof valueA === "number" && typeof valueB === "number") ||
                (typeof valueA === "bigint" && typeof valueB === "bigint")) {
                if (valueA < valueB)
                    return -1;
                if (valueA > valueB)
                    return 1;
                continue;
            }
            if (valueA instanceof crypto_1.Utils.BigNumber && valueB instanceof crypto_1.Utils.BigNumber) {
                if (valueA.isLessThan(valueB))
                    return -1;
                if (valueA.isGreaterThan(valueB))
                    return 1;
                continue;
            }
            if (typeof valueA !== typeof valueB) {
                throw new Error(`Mismatched types '${typeof valueA}' and '${typeof valueB}' at '${property}'`);
            }
            else {
                throw new Error(`Unexpected type at '${property}'`);
            }
        }
        return 0;
    }
};
PaginationService = __decorate([
    ioc_1.injectable()
], PaginationService);
exports.PaginationService = PaginationService;
//# sourceMappingURL=pagination-service.js.map