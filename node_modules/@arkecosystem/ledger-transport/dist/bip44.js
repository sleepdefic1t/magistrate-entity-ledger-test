"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const TransportErrors = __importStar(require("./errors"));
/**
 * Static builder for handling the parsing of Bip44 Paths.
 *
 * BIP44 is a particular application of BIP43.
 * It defines a hierarchy for deterministic wallets based on BIP32,
 * and the purpose scheme described in BIP43.
 *
 * A Bip44 path defines the following levels:
 * - m / purpose' / coin_type' / account' / change / address_index
 *
 * https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
 * https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki
 * https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
 *
 * @example const bip44Bytes = Bip44Path.fromString("44'/111'/0'/0/0").toBytes()
 * @example const bip44Bytes = Bip44Path.fromString("m/44'/111'/0'/0/0").toBytes()
 */
class Bip44Path {
    /**
     * Private constructor.
     * Ensures precondition that 'fromString' is called before 'toBytes'.
     *
     * @param {number[]} elements a bip44 path as an array of elements
     */
    constructor(elements) {
        this._elements = [];
        this._elements = elements;
    }
    /**
     * Parses a Bip44 path-string, storing the path as elements,
     * and returns a Bip44Path instance.
     *
     * Elements are stored as a 4-byte/uint32 Big-Endian-packed number array.
     *
     * @param {string} path a bip44 path as a string
     * @throws {Error} if the path-string is null
     * @throws {Error} if the path formatting is invalid
     * @returns {Bip44Path} a new instance containing parsed path elements
     */
    static fromString(path) {
        if (!path.toString().match(new RegExp(this.REGEXP_VALID_BIP44, "g"))) {
            throw new TransportErrors.Bip44PathError(path);
        }
        return this.pathToElements(path.replace("m/", ""));
    }
    /**
     * Parses and stores a Bip44 Path-string as an array of elements to the 'Bip44Path' instance.
     *
     * @param {string} path a bip44 path as a string
     * @throws {Error} if the path-string is null
     * @throws {Error} if the path-string has a length of '0'
     * @returns {Bip44Path} a new instance containing parsed path elements
     */
    static pathToElements(path) {
        const _elements = [];
        for (const level of path.split("/")) {
            let element = parseInt(level, 10);
            if (level.length > 1 && level.endsWith("'")) {
                // Use hardening
                element += this.HARDENING;
            }
            _elements.push(element);
        }
        return new Bip44Path(_elements);
    }
    /**
     * Get the bytes of a Parsed Bip44 Element Array.
     *
     * @returns {Buffer} a buffer of bytes representing the path
     * @throws {Error} if the internal bip44 element array has a length of '0'
     * @returns {Buffer} a byte buffer of parsed bip44 path elements
     */
    toBytes() {
        const payload = Buffer.alloc(1 + this._elements.length * 4);
        payload[0] = this._elements.length;
        let index = 0;
        for (const element of this._elements) {
            payload.writeUInt32BE(element, 1 + index * 4);
            index += 1;
        }
        return payload;
    }
}
exports.Bip44Path = Bip44Path;
exports.Path = Bip44Path;
Bip44Path.HARDENING = 0x80000000;
Bip44Path.REGEXP_VALID_BIP44 = "^((m/)?(44'?)){1}(/[0-9]+'?){2}(/[0-9]+){2}$";
//# sourceMappingURL=bip44.js.map