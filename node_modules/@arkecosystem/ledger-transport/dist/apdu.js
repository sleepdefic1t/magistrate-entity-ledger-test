"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const TransportErrors = __importStar(require("./errors"));
/**
 * APDU Header Flags
 *
 * Describes the APDU Class, Instruction-Type, Parameter 1, and Parameter 2.
 *
 * APDU Header:  ({ CLA + INS + P1 + P2 })
 * - CLA:  Apdu Class
 * - INS:  Instruction Type
 * - P1:   Instruction Parameter 1
 * - P2:   Instruction Parameter 2
 *
 * Instruction Types:
 * - INS_GET_PUBLIC_KEY:    Get a PublicKey from a Ledger Device
 * - INS_GET_VERSION:       Get the ARK Application Version from a Ledger Device
 * - INS_SIGN_TRANSACTION:  Sign a Transaction using a Ledger Device
 * - INS_SIGN_MESSAGE:      Sign a Message using a Ledger Device
 *
 * App / PublicKey Context:
 * P1: User Approval
 * - P1_NON_CONFIRM:  Do NOT request user approval
 * - P1_CONFIRM:      Request user approval
 *
 * P2: ChainCode
 * - P2_NO_CHAINCODE:  Don't use a ChainCode
 * - P2_CHAINCODE:     Use a Chaincode
 *
 * Signing Context:
 * P1: Payload Segment
 * - P1_SINGLE:  N(1) where N === 1
 * - P1_FIRST:   N(1) where N > 1
 * - P1_MORE:    N(2)..N-1 where N > 2
 * - P1_LAST:    Nth where N > 1
 *
 * P2:
 * - P2_ECDSA: Use Ecdsa Signatures
 * - P2_SCHNORR_LEG: Use Schnorr (bcrypto-v4.1.0) Signatures
 *
 */
var ApduFlag;
(function (ApduFlag) {
    /** APDU Class */
    ApduFlag[ApduFlag["CLA"] = 224] = "CLA";
    /** App / PublicKey Context */
    ApduFlag[ApduFlag["INS_GET_PUBLIC_KEY"] = 2] = "INS_GET_PUBLIC_KEY";
    ApduFlag[ApduFlag["INS_GET_VERSION"] = 6] = "INS_GET_VERSION";
    ApduFlag[ApduFlag["P1_NON_CONFIRM"] = 0] = "P1_NON_CONFIRM";
    ApduFlag[ApduFlag["P1_CONFIRM"] = 1] = "P1_CONFIRM";
    ApduFlag[ApduFlag["P2_NO_CHAINCODE"] = 0] = "P2_NO_CHAINCODE";
    ApduFlag[ApduFlag["P2_CHAINCODE"] = 1] = "P2_CHAINCODE";
    /** Signing Context */
    ApduFlag[ApduFlag["INS_SIGN_TRANSACTION"] = 4] = "INS_SIGN_TRANSACTION";
    ApduFlag[ApduFlag["INS_SIGN_MESSAGE"] = 8] = "INS_SIGN_MESSAGE";
    ApduFlag[ApduFlag["P1_SINGLE"] = 128] = "P1_SINGLE";
    ApduFlag[ApduFlag["P1_FIRST"] = 0] = "P1_FIRST";
    ApduFlag[ApduFlag["P1_MORE"] = 1] = "P1_MORE";
    ApduFlag[ApduFlag["P1_LAST"] = 129] = "P1_LAST";
    ApduFlag[ApduFlag["P2_ECDSA"] = 64] = "P2_ECDSA";
    ApduFlag[ApduFlag["P2_SCHNORR_LEG"] = 80] = "P2_SCHNORR_LEG";
})(ApduFlag = exports.ApduFlag || (exports.ApduFlag = {}));
exports.Flag = ApduFlag;
/**
 * Create and manage an Apdu payload instance for sending to a Ledger device.
 *
 * @example const response = await new Apdu(CLA, INS, P1, P2, Payload).send(this.transport);
 */
class Apdu {
    /**
     * Construct an Apdu instance.
     *
     * @param {number} cla a class byte
     * @param {number} ins an instruction byte
     * @param {number} p1 a parameter-1 byte
     * @param {number} p2 a parameter-2 byte
     * @param {Buffer} payload an optional payload
     * @throws {PayloadLengthError} if the payload is too big to be processed
     */
    constructor(cla, ins, p1, p2, payload = Buffer.alloc(0)) {
        this.CHUNK_MAX = 10;
        this.CHUNK_SIZE = 255;
        this.PAYLOAD_MAX = this.CHUNK_MAX * this.CHUNK_SIZE;
        if (payload && payload.length > this.PAYLOAD_MAX) {
            throw new TransportErrors.PayloadLengthError(payload.length, this.PAYLOAD_MAX);
        }
        this.cla = cla;
        this.ins = ins;
        this.p1 = p1;
        this.p2 = p2;
        this._payload = payload;
    }
    /**
     * Send a large Apdu payload in chunks for handling by a Ledger device.
     *
     * @param {LedgerTransport} transport the transport instance over which the apdu call is sent
     * @returns {Promise<Buffer>} the apdu response, e.g. from a Ledger device
     */
    async send(transport) {
        const chunks = this.getChunks(this._payload, this.CHUNK_SIZE);
        const promises = [];
        let index = 0;
        for (const chunk of chunks) {
            promises.push(await transport.send(this.cla, this.ins, this.getChunkSegmentFlag(index, chunks.length), this.p2, chunk));
            index += 1;
        }
        return Buffer.concat(promises.map((r) => r.slice(0, r.length - 2)));
    }
    /**
     * Split the Apdu Payload into a Chunked Array.
     *
     * @param {Buffer} payload the bytes to be chunked
     * @param {number} chunkSize the element size by which to split the payload
     * @returns {Buffer[]} the chunked payload of an Apdu instance
     */
    getChunks(payload, chunkSize) {
        return this._payload.length <= this.CHUNK_SIZE
            ? [this._payload]
            : Array.from({ length: Math.ceil(payload.length / chunkSize) }, (v, i) => payload.slice(i * chunkSize, i * chunkSize + chunkSize));
    }
    /**
     * Get the Segment Flag (P1) of a given chunk.
     *
     * @param {Buffer} index the index of the current chunk
     * @param {Buffer} length total length of the payload
     * @returns {ApduFlag} which segment of a payload is being sent
     */
    getChunkSegmentFlag(index, length) {
        /** set the payload segment flag */
        if (index > 0 && index < length - 1) {
            /** N(2)..N-1 where N > 2 */
            return ApduFlag.P1_MORE;
        }
        else if (index === length - 1 && length > 1) {
            /** Nth where N > 1 */
            return ApduFlag.P1_LAST;
        }
        else if (index === 0 && length > 1) {
            /** N(1) where N > 1 */
            return ApduFlag.P1_FIRST;
        }
        else {
            return this.p1;
        }
    }
}
exports.Apdu = Apdu;
exports.Builder = Apdu;
//# sourceMappingURL=apdu.js.map