var ArkCrypto = (function (exports, _classCallCheck$1, _createClass$1, _regeneratorRuntime, _toConsumableArray, _asyncToGenerator, _typeof, _assertThisInitialized, _inherits, _possibleConstructorReturn, _getPrototypeOf, _wrapNativeSuper, _slicedToArray, _get, _construct, _defineProperty$2) {
  'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck$1);
  var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass$1);
  var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
  var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
  var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
  var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
  var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
  var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
  var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
  var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
  var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);
  var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
  var _get__default = /*#__PURE__*/_interopDefaultLegacy(_get);
  var _construct__default = /*#__PURE__*/_interopDefaultLegacy(_construct);
  var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty$2);

  var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;

  function init() {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray(b64) {
    if (!inited) {
      init();
    }

    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice


    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

    arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 0xFF;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    if (!inited) {
      init();
    }

    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3
    // go through the array every three bytes, we'll deal with trailing stuff later

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    } // pad the end with zeros, but make sure to not forget the extra bytes


    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 0x3F];
      output += lookup[tmp << 2 & 0x3F];
      output += '=';
    }

    parts.push(output);
    return parts.join('');
  }

  function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;
  var isArray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;
  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */

  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length');
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }

      that.length = length;
    }

    return that;
  }
  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */


  function Buffer(arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length);
    } // Common case.


    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error('If encoding is specified then the first argument must be a string');
      }

      return allocUnsafe(this, arg);
    }

    return from(this, arg, encodingOrOffset, length);
  }
  Buffer.poolSize = 8192; // not used by this implementation
  // TODO: Legacy, not needed anymore. Remove in next major version.

  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr;
  };

  function from(that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number');
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset);
    }

    return fromObject(that, value);
  }
  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/


  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }

  function alloc(that, size, fill, encoding) {
    assertSize(size);

    if (size <= 0) {
      return createBuffer(that, size);
    }

    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    }

    return createBuffer(that, size);
  }
  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/


  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };

  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }

    return that;
  }
  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */


  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */


  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size);
  };

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that;
  }

  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);

    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }

    return that;
  }

  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds');
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }

    return that;
  }

  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that;
      }

      obj.copy(that, 0, 0, len);
      return that;
    }

    if (obj) {
      if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0);
        }

        return fromArrayLike(that, obj);
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
  }

  function checked(length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }

    return length | 0;
  }
  Buffer.isBuffer = isBuffer;

  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }

  Buffer.compare = function compare(a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      buf.copy(buffer, pos);
      pos += buf.length;
    }

    return buffer;
  };

  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0; // Use a for loop to avoid recursion

    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;

        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length;

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;

        case 'hex':
          return len >>> 1;

        case 'base64':
          return base64ToBytes(string).length;

        default:
          if (loweredCase) return utf8ToBytes(string).length; // assume utf8

          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

    if (start === undefined || start < 0) {
      start = 0;
    } // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.


    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.


  Buffer.prototype._isBuffer = true;

  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }

    return this;
  };

  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }

    return this;
  };

  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }

    return this;
  };

  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = INSPECT_MAX_BYTES;

    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }

    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer');
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf


  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1; // Normalize byteOffset

    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }

    byteOffset = +byteOffset; // Coerce to Number.

    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    } // Normalize byteOffset: negative offsets start from the end of the buffer


    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    } // Normalize val


    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    } // Finally, search either indexOf (if dir is true) or lastIndexOf


    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }

      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]

      if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }

      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();

      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }

        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;

    if (dir) {
      var foundIndex = -1;

      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

      for (i = byteOffset; i >= 0; i--) {
        var found = true;

        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }

        if (found) return i;
      }
    }

    return -1;
  }

  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;

    if (!length) {
      length = remaining;
    } else {
      length = Number(length);

      if (length > remaining) {
        length = remaining;
      }
    } // must be an even number of digits


    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }

    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }

    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0; // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0; // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;

      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      } // legacy write(string, encoding, offset, length) - remove in v0.13

    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;

    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }

            break;

          case 2:
            secondByte = buf[i + 1];

            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }

        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety


  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;

    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    } // Decode in chunks to avoid "call stack size exceeded".


    var res = '';
    var i = 0;

    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }

    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }

    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }

    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';

    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }

    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';

    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }

    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf;

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);

      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf;
  };
  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */


  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }

    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }

    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }

    return len;
  }; // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])


  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (code < 256) {
          val = code;
        }
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } // Invalid ranges are not set to a default, so can range check early.


    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  }; // HELPER FUNCTIONS
  // ================


  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

    if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

    while (str.length % 4 !== 0) {
      str = str + '=';
    }

    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i); // is surrogate component

      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } // valid lead


          leadSurrogate = codePoint;
          continue;
        } // 2 leads in a row


        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        } // valid surrogate pair


        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null; // encode utf8

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }

    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  }

  function isnan(val) {
    return val !== val; // eslint-disable-line no-self-compare
  } // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually


  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }

  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
  } // For Node v0.10 support. Remove this eventually.


  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
  }

  /*!
   * assert.js - assertions for javascript
   * Copyright (c) 2018, Christopher Jeffrey (MIT License).
   * https://github.com/chjj/bsert
   */

  function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var AssertionError = /*#__PURE__*/function (_Error) {
    _inherits__default['default'](AssertionError, _Error);

    var _super = _createSuper(AssertionError);

    function AssertionError(options) {
      var _this;

      _classCallCheck__default['default'](this, AssertionError);

      if (typeof options === 'string') options = {
        message: options
      };
      if (options === null || _typeof__default['default'](options) !== 'object') options = {};
      var message = null;
      var operator = 'fail';
      var generatedMessage = Boolean(options.generatedMessage);
      if (options.message != null) message = toString$1(options.message);
      if (typeof options.operator === 'string') operator = options.operator;

      if (message == null) {
        if (operator === 'fail') {
          message = 'Assertion failed.';
        } else {
          var a = stringify(options.actual);
          var b = stringify(options.expected);
          message = "".concat(a, " ").concat(operator, " ").concat(b);
        }

        generatedMessage = true;
      }

      _this = _super.call(this, message);
      var start = _this.constructor;
      if (typeof options.stackStartFunction === 'function') start = options.stackStartFunction;else if (typeof options.stackStartFn === 'function') start = options.stackStartFn;
      _this.type = 'AssertionError';
      _this.name = 'AssertionError [ERR_ASSERTION]';
      _this.code = 'ERR_ASSERTION';
      _this.generatedMessage = generatedMessage;
      _this.actual = options.actual;
      _this.expected = options.expected;
      _this.operator = operator;
      if (Error.captureStackTrace) Error.captureStackTrace(_assertThisInitialized__default['default'](_this), start);
      return _this;
    }

    return AssertionError;
  }( /*#__PURE__*/_wrapNativeSuper__default['default'](Error));
  /*
   * Assert
   */


  function assert(value, message) {
    if (!value) {
      var generatedMessage = false;

      if (arguments.length === 0) {
        message = 'No value argument passed to `assert()`.';
        generatedMessage = true;
      } else if (message == null) {
        message = 'Assertion failed.';
        generatedMessage = true;
      } else if (isError(message)) {
        throw message;
      }

      throw new AssertionError({
        message: message,
        actual: value,
        expected: true,
        operator: '==',
        generatedMessage: generatedMessage,
        stackStartFn: assert
      });
    }
  }

  function equal(actual, expected, message) {
    if (!Object.is(actual, expected)) {
      if (isError(message)) throw message;
      throw new AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: 'strictEqual',
        stackStartFn: equal
      });
    }
  }

  function notEqual(actual, expected, message) {
    if (Object.is(actual, expected)) {
      if (isError(message)) throw message;
      throw new AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: 'notStrictEqual',
        stackStartFn: notEqual
      });
    }
  }

  function fail(message) {
    var generatedMessage = false;
    if (isError(message)) throw message;

    if (message == null) {
      message = 'Assertion failed.';
      generatedMessage = true;
    }

    throw new AssertionError({
      message: message,
      actual: false,
      expected: true,
      operator: 'fail',
      generatedMessage: generatedMessage,
      stackStartFn: fail
    });
  }

  function throws(func, expected, message) {
    if (typeof expected === 'string') {
      message = expected;
      expected = undefined;
    }

    var thrown = false;
    var err = null;
    enforce(typeof func === 'function', 'func', 'function');

    try {
      func();
    } catch (e) {
      thrown = true;
      err = e;
    }

    if (!thrown) {
      var generatedMessage = false;

      if (message == null) {
        message = 'Missing expected exception.';
        generatedMessage = true;
      }

      throw new AssertionError({
        message: message,
        actual: undefined,
        expected: expected,
        operator: 'throws',
        generatedMessage: generatedMessage,
        stackStartFn: throws
      });
    }

    if (!testError(err, expected, message, throws)) throw err;
  }

  function doesNotThrow(func, expected, message) {
    if (typeof expected === 'string') {
      message = expected;
      expected = undefined;
    }

    var thrown = false;
    var err = null;
    enforce(typeof func === 'function', 'func', 'function');

    try {
      func();
    } catch (e) {
      thrown = true;
      err = e;
    }

    if (!thrown) return;

    if (testError(err, expected, message, doesNotThrow)) {
      var generatedMessage = false;

      if (message == null) {
        message = 'Got unwanted exception.';
        generatedMessage = true;
      }

      throw new AssertionError({
        message: message,
        actual: err,
        expected: expected,
        operator: 'doesNotThrow',
        generatedMessage: generatedMessage,
        stackStartFn: doesNotThrow
      });
    }

    throw err;
  }

  function rejects(_x, _x2, _x3) {
    return _rejects.apply(this, arguments);
  }

  function _rejects() {
    _rejects = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(func, expected, message) {
      var thrown, err, generatedMessage;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (typeof expected === 'string') {
                message = expected;
                expected = undefined;
              }

              thrown = false;
              err = null;
              if (typeof func !== 'function') enforce(isPromise(func), 'func', 'promise');
              _context.prev = 4;

              if (!isPromise(func)) {
                _context.next = 10;
                break;
              }

              _context.next = 8;
              return func;

            case 8:
              _context.next = 12;
              break;

            case 10:
              _context.next = 12;
              return func();

            case 12:
              _context.next = 18;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](4);
              thrown = true;
              err = _context.t0;

            case 18:
              if (thrown) {
                _context.next = 22;
                break;
              }

              generatedMessage = false;

              if (message == null) {
                message = 'Missing expected rejection.';
                generatedMessage = true;
              }

              throw new AssertionError({
                message: message,
                actual: undefined,
                expected: expected,
                operator: 'rejects',
                generatedMessage: generatedMessage,
                stackStartFn: rejects
              });

            case 22:
              if (testError(err, expected, message, rejects)) {
                _context.next = 24;
                break;
              }

              throw err;

            case 24:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[4, 14]]);
    }));
    return _rejects.apply(this, arguments);
  }

  function doesNotReject(_x4, _x5, _x6) {
    return _doesNotReject.apply(this, arguments);
  }

  function _doesNotReject() {
    _doesNotReject = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(func, expected, message) {
      var thrown, err, generatedMessage;
      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (typeof expected === 'string') {
                message = expected;
                expected = undefined;
              }

              thrown = false;
              err = null;
              if (typeof func !== 'function') enforce(isPromise(func), 'func', 'promise');
              _context2.prev = 4;

              if (!isPromise(func)) {
                _context2.next = 10;
                break;
              }

              _context2.next = 8;
              return func;

            case 8:
              _context2.next = 12;
              break;

            case 10:
              _context2.next = 12;
              return func();

            case 12:
              _context2.next = 18;
              break;

            case 14:
              _context2.prev = 14;
              _context2.t0 = _context2["catch"](4);
              thrown = true;
              err = _context2.t0;

            case 18:
              if (thrown) {
                _context2.next = 20;
                break;
              }

              return _context2.abrupt("return");

            case 20:
              if (!testError(err, expected, message, doesNotReject)) {
                _context2.next = 24;
                break;
              }

              generatedMessage = false;

              if (message == null) {
                message = 'Got unwanted rejection.';
                generatedMessage = true;
              }

              throw new AssertionError({
                message: message,
                actual: undefined,
                expected: expected,
                operator: 'doesNotReject',
                generatedMessage: generatedMessage,
                stackStartFn: doesNotReject
              });

            case 24:
              throw err;

            case 25:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[4, 14]]);
    }));
    return _doesNotReject.apply(this, arguments);
  }

  function ifError(err) {
    if (err != null) {
      var message = 'ifError got unwanted exception: ';

      if (_typeof__default['default'](err) === 'object' && typeof err.message === 'string') {
        if (err.message.length === 0 && err.constructor) message += err.constructor.name;else message += err.message;
      } else {
        message += stringify(err);
      }

      throw new AssertionError({
        message: message,
        actual: err,
        expected: null,
        operator: 'ifError',
        generatedMessage: true,
        stackStartFn: ifError
      });
    }
  }

  function deepEqual(actual, expected, message) {
    if (!isDeepEqual(actual, expected, false)) {
      if (isError(message)) throw message;
      throw new AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: 'deepStrictEqual',
        stackStartFn: deepEqual
      });
    }
  }

  function notDeepEqual(actual, expected, message) {
    if (isDeepEqual(actual, expected, true)) {
      if (isError(message)) throw message;
      throw new AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: 'notDeepStrictEqual',
        stackStartFn: notDeepEqual
      });
    }
  }

  function bufferEqual(actual, expected, enc, message) {
    if (!isEncoding(enc)) {
      message = enc;
      enc = null;
    }

    if (enc == null) enc = 'hex';
    expected = bufferize(actual, expected, enc);
    enforce(isBuffer$1(actual), 'actual', 'buffer');
    enforce(isBuffer$1(expected), 'expected', 'buffer');

    if (actual !== expected && !actual.equals(expected)) {
      if (isError(message)) throw message;
      throw new AssertionError({
        message: message,
        actual: actual.toString(enc),
        expected: expected.toString(enc),
        operator: 'bufferEqual',
        stackStartFn: bufferEqual
      });
    }
  }

  function notBufferEqual(actual, expected, enc, message) {
    if (!isEncoding(enc)) {
      message = enc;
      enc = null;
    }

    if (enc == null) enc = 'hex';
    expected = bufferize(actual, expected, enc);
    enforce(isBuffer$1(actual), 'actual', 'buffer');
    enforce(isBuffer$1(expected), 'expected', 'buffer');

    if (actual === expected || actual.equals(expected)) {
      if (isError(message)) throw message;
      throw new AssertionError({
        message: message,
        actual: actual.toString(enc),
        expected: expected.toString(enc),
        operator: 'notBufferEqual',
        stackStartFn: notBufferEqual
      });
    }
  }

  function enforce(value, name, type) {
    if (!value) {
      var msg;

      if (name == null) {
        msg = 'Invalid type for parameter.';
      } else {
        if (type == null) msg = "Invalid type for \"".concat(name, "\".");else msg = "\"".concat(name, "\" must be a(n) ").concat(type, ".");
      }

      var err = new TypeError(msg);
      if (Error.captureStackTrace) Error.captureStackTrace(err, enforce);
      throw err;
    }
  }

  function range(value, name) {
    if (!value) {
      var msg = name != null ? "\"".concat(name, "\" is out of range.") : 'Parameter is out of range.';
      var err = new RangeError(msg);
      if (Error.captureStackTrace) Error.captureStackTrace(err, range);
      throw err;
    }
  }
  /*
   * Stringification
   */


  function stringify(value) {
    switch (_typeof__default['default'](value)) {
      case 'undefined':
        return 'undefined';

      case 'object':
        if (value === null) return 'null';
        return "[".concat(objectName(value), "]");

      case 'boolean':
        return "".concat(value);

      case 'number':
        return "".concat(value);

      case 'string':
        if (value.length > 80) value = "".concat(value.substring(0, 77), "...");
        return JSON.stringify(value);

      case 'symbol':
        return tryString(value);

      case 'function':
        return "[".concat(funcName(value), "]");

      case 'bigint':
        return "".concat(value, "n");

      default:
        return "[".concat(_typeof__default['default'](value), "]");
    }
  }

  function toString$1(value) {
    if (typeof value === 'string') return value;
    if (isError(value)) return tryString(value);
    return stringify(value);
  }

  function tryString(value) {
    try {
      return String(value);
    } catch (e) {
      return 'Object';
    }
  }
  /*
   * Error Testing
   */


  function testError(err, expected, message, func) {
    if (expected == null) return true;
    if (isRegExp(expected)) return expected.test(err);

    if (typeof expected !== 'function') {
      if (func === doesNotThrow || func === doesNotReject) throw new TypeError('"expected" must not be an object.');
      if (_typeof__default['default'](expected) !== 'object') throw new TypeError('"expected" must be an object.');
      var generatedMessage = false;

      if (message == null) {
        var name = func === rejects ? 'rejection' : 'exception';
        message = "Missing expected ".concat(name, ".");
        generatedMessage = true;
      }

      if (err == null || _typeof__default['default'](err) !== 'object') {
        throw new AssertionError({
          actual: err,
          expected: expected,
          message: message,
          operator: func.name,
          generatedMessage: generatedMessage,
          stackStartFn: func
        });
      }

      var keys = Object.keys(expected);
      if (isError(expected)) keys.push('name', 'message');
      if (keys.length === 0) throw new TypeError('"expected" may not be an empty object.');

      for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
        var key = _keys[_i];
        var expect = expected[key];
        var value = err[key];

        if (typeof value === 'string' && isRegExp(expect) && expect.test(value)) {
          continue;
        }

        if (key in err && isDeepEqual(value, expect, false)) continue;
        throw new AssertionError({
          actual: err,
          expected: expected,
          message: message,
          operator: func.name,
          generatedMessage: generatedMessage,
          stackStartFn: func
        });
      }

      return true;
    }

    if (expected.prototype !== undefined && err instanceof expected) return true;
    if (Error.isPrototypeOf(expected)) return false;
    return expected.call({}, err) === true;
  }
  /*
   * Comparisons
   */


  function isDeepEqual(x, y, fail) {
    try {
      return compare(x, y, null);
    } catch (e) {
      return fail;
    }
  }

  function compare(a, b, cache) {
    // Primitives.
    if (Object.is(a, b)) return true;
    if (!isObject(a) || !isObject(b)) return false; // Semi-primitives.

    if (objectString(a) !== objectString(b)) return false;
    if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
    if (isBuffer$1(a) && isBuffer$1(b)) return a.equals(b);
    if (isDate(a)) return Object.is(a.getTime(), b.getTime());

    if (isRegExp(a)) {
      return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;
    }

    if (isError(a)) {
      if (a.message !== b.message) return false;
    }

    if (isArrayBuffer(a)) {
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    }

    if (isView(a) && !isBuffer$1(a)) {
      if (isBuffer$1(b)) return false;
      var x = new Uint8Array(a.buffer);
      var y = new Uint8Array(b.buffer);
      if (x.length !== y.length) return false;

      for (var i = 0; i < x.length; i++) {
        if (x[i] !== y[i]) return false;
      }

      return true;
    }

    if (isSet(a)) {
      if (a.size !== b.size) return false;
      var keys = new Set([].concat(_toConsumableArray__default['default'](a), _toConsumableArray__default['default'](b)));
      return keys.size === a.size;
    } // Recursive.


    if (!cache) {
      cache = {
        a: new Map(),
        b: new Map(),
        p: 0
      };
    } else {
      var aa = cache.a.get(a);

      if (aa != null) {
        var bb = cache.b.get(b);
        if (bb != null) return aa === bb;
      }

      cache.p += 1;
    }

    cache.a.set(a, cache.p);
    cache.b.set(b, cache.p);
    var ret = recurse(a, b, cache);
    cache.a.delete(a);
    cache.b.delete(b);
    return ret;
  }

  function recurse(a, b, cache) {
    if (isMap(a)) {
      if (a.size !== b.size) return false;

      var _keys2 = new Set([].concat(_toConsumableArray__default['default'](a.keys()), _toConsumableArray__default['default'](b.keys())));

      if (_keys2.size !== a.size) return false;

      var _iterator = _createForOfIteratorHelper(_keys2),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          if (!compare(a.get(key), b.get(key), cache)) return false;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return true;
    }

    if (isArray$1(a)) {
      if (a.length !== b.length) return false;

      for (var i = 0; i < a.length; i++) {
        if (!compare(a[i], b[i], cache)) return false;
      }

      return true;
    }

    var ak = ownKeys(a);
    var bk = ownKeys(b);
    if (ak.length !== bk.length) return false;
    var keys = new Set([].concat(_toConsumableArray__default['default'](ak), _toConsumableArray__default['default'](bk)));
    if (keys.size !== ak.length) return false;

    var _iterator2 = _createForOfIteratorHelper(keys),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _key = _step2.value;
        if (!compare(a[_key], b[_key], cache)) return false;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return true;
  }

  function ownKeys(obj) {
    var keys = Object.keys(obj);
    if (!Object.getOwnPropertySymbols) return keys;
    if (!Object.getOwnPropertyDescriptor) return keys;
    var symbols = Object.getOwnPropertySymbols(obj);

    var _iterator3 = _createForOfIteratorHelper(symbols),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var symbol = _step3.value;
        var desc = Object.getOwnPropertyDescriptor(obj, symbol);
        if (desc && desc.enumerable) keys.push(symbol);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return keys;
  }
  /*
   * Helpers
   */


  function objectString(obj) {
    if (obj === undefined) return '[object Undefined]';
    if (obj === null) return '[object Null]';

    try {
      return Object.prototype.toString.call(obj);
    } catch (e) {
      return '[object Object]';
    }
  }

  function objectType(obj) {
    return objectString(obj).slice(8, -1);
  }

  function objectName(obj) {
    var type = objectType(obj);
    if (obj == null) return type;
    if (type !== 'Object' && type !== 'Error') return type;
    var ctor, name;

    try {
      ctor = obj.constructor;
    } catch (e) {
    }

    if (ctor == null) return type;

    try {
      name = ctor.name;
    } catch (e) {
      return type;
    }

    if (typeof name !== 'string' || name.length === 0) return type;
    return name;
  }

  function funcName(func) {
    var name;

    try {
      name = func.name;
    } catch (e) {
    }

    if (typeof name !== 'string' || name.length === 0) return 'Function';
    return "Function: ".concat(name);
  }

  function isArray$1(obj) {
    return Array.isArray(obj);
  }

  function isArrayBuffer(obj) {
    return obj instanceof ArrayBuffer;
  }

  function isBuffer$1(obj) {
    return isObject(obj) && typeof obj.writeUInt32LE === 'function' && typeof obj.equals === 'function';
  }

  function isDate(obj) {
    return obj instanceof Date;
  }

  function isError(obj) {
    return obj instanceof Error;
  }

  function isMap(obj) {
    return obj instanceof Map;
  }

  function isObject(obj) {
    return obj && _typeof__default['default'](obj) === 'object';
  }

  function isPromise(obj) {
    return obj instanceof Promise;
  }

  function isRegExp(obj) {
    return obj instanceof RegExp;
  }

  function isSet(obj) {
    return obj instanceof Set;
  }

  function isView(obj) {
    return ArrayBuffer.isView(obj);
  }

  function isEncoding(enc) {
    if (typeof enc !== 'string') return false;

    switch (enc) {
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'hex':
      case 'latin1':
      case 'ucs2':
      case 'utf8':
      case 'utf16le':
        return true;
    }

    return false;
  }

  function bufferize(actual, expected, enc) {
    if (typeof expected === 'string') {
      if (!isBuffer$1(actual)) return null;
      var _constructor = actual.constructor;
      if (!_constructor || typeof _constructor.from !== 'function') return null;
      if (!isEncoding(enc)) return null;
      if (enc === 'hex' && expected.length & 1) return null;

      var raw = _constructor.from(expected, enc);

      if (enc === 'hex' && raw.length !== expected.length >>> 1) return null;
      return raw;
    }

    return expected;
  }
  /*
   * API
   */


  assert.AssertionError = AssertionError;
  assert.assert = assert;
  assert.strict = assert;
  assert.ok = assert;
  assert.equal = equal;
  assert.notEqual = notEqual;
  assert.strictEqual = equal;
  assert.notStrictEqual = notEqual;
  assert.fail = fail;
  assert.throws = throws;
  assert.doesNotThrow = doesNotThrow;
  assert.rejects = rejects;
  assert.doesNotReject = doesNotReject;
  assert.ifError = ifError;
  assert.deepEqual = deepEqual;
  assert.notDeepEqual = notDeepEqual;
  assert.deepStrictEqual = deepEqual;
  assert.notDeepStrictEqual = notDeepEqual;
  assert.bufferEqual = bufferEqual;
  assert.notBufferEqual = notBufferEqual;
  assert.enforce = enforce;
  assert.range = range;
  /*
   * Expose
   */

  var assert_1 = assert;

  /*
   * Constants
   */


  var CHARSET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  var TABLE = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1, -1, -1, -1, -1, -1, 9, 10, 11, 12, 13, 14, 15, 16, -1, 17, 18, 19, 20, 21, -1, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1, -1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, -1, -1, -1, -1, -1];
  /**
   * Encode a base58 string.
   * @see https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp
   * @param {Buffer} data
   * @returns {String}
   */

  var encode = function encode(data) {
    assert_1(Buffer.isBuffer(data));
    var zeroes = 0;
    var i = 0;

    for (; i < data.length; i++) {
      if (data[i] !== 0) break;
      zeroes += 1;
    }

    var b58 = Buffer.allocUnsafe((data.length * 138 / 100 | 0) + 1);
    b58.fill(0);
    var length = 0;

    for (; i < data.length; i++) {
      var carry = data[i];
      var j = 0;

      for (var k = b58.length - 1; k >= 0; k--, j++) {
        if (carry === 0 && j >= length) break;
        carry += 256 * b58[k];
        b58[k] = carry % 58;
        carry = carry / 58 | 0;
      }

      assert_1(carry === 0);
      length = j;
    }

    i = b58.length - length;

    while (i < b58.length && b58[i] === 0) {
      i += 1;
    }

    var str = '';

    for (var _j = 0; _j < zeroes; _j++) {
      str += '1';
    }

    for (; i < b58.length; i++) {
      str += CHARSET[b58[i]];
    }

    return str;
  };
  /**
   * Decode a base58 string.
   * @see https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp
   * @param {String} str
   * @returns {Buffer}
   * @throws on non-base58 character.
   */


  var decode = function decode(str) {
    assert_1(typeof str === 'string');
    var zeroes = 0;
    var i = 0;

    for (; i < str.length; i++) {
      if (str[i] !== '1') break;
      zeroes += 1;
    }

    var b256 = Buffer.allocUnsafe((str.length * 733 / 1000 | 0) + 1);
    b256.fill(0);
    var length = 0;

    for (; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      var v = ch & 0xff80 ? -1 : TABLE[ch];
      if (v === -1) throw new Error('Non-base58 character.');
      var carry = v;
      var _j2 = 0;

      for (var k = b256.length - 1; k >= 0; k--, _j2++) {
        if (carry === 0 && _j2 >= length) break;
        carry += 58 * b256[k];
        b256[k] = carry & 0xff;
        carry >>>= 8;
      }

      assert_1(carry === 0);
      length = _j2;
    }

    i = 0;

    while (i < b256.length && b256[i] === 0) {
      i += 1;
    }

    var out = Buffer.allocUnsafe(zeroes + (b256.length - i));
    var j;

    for (j = 0; j < zeroes; j++) {
      out[j] = 0;
    }

    while (i < b256.length) {
      out[j++] = b256[i++];
    }

    return out;
  };
  /**
   * Test whether the string is a base58 string.
   * @param {String} str
   * @returns {Buffer}
   */


  var test = function test(str) {
    if (typeof str !== 'string') return false;

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch & 0xff80) return false;
      if (TABLE[ch] === -1) return false;
    }

    return true;
  };

  var base58Browser = {
    encode: encode,
    decode: decode,
    test: test
  };

  /**
   * Constants
   */


  var POOL66 = Buffer.allocUnsafe(66);

  /**
   * U64
   */


  var U64 = /*#__PURE__*/function () {
    function U64(hi, lo) {
      _classCallCheck__default['default'](this, U64);

      this.hi = hi | 0;
      this.lo = lo | 0;
    }

    _createClass__default['default'](U64, [{
      key: "ushrn32",
      value: function ushrn32(bits) {
        bits &= 63;
        var lo = this.lo;
        if (bits === 0) return lo;

        if (bits < 32) {
          lo >>>= bits;
          lo |= this.hi << 32 - bits;
        } else {
          lo = this.hi >>> bits - 32;
        }

        return lo;
      }
    }]);

    return U64;
  }();
  /**
   * Constants
   */


  var POOL105 = Buffer.allocUnsafe(105);
  var CHECKSUM_MASK = new U64(0x00000007, 0xffffffff);
  var GENERATOR = [new U64(0x00000098, 0xf2bc8e61), new U64(0x00000079, 0xb76d99e2), new U64(0x000000f3, 0x3e5fb3c4), new U64(0x000000ae, 0x2eabe2a8), new U64(0x0000001e, 0x4f43e470)];

  var base58 = base58Browser;

  //
  // Main
  //
  function memoize(fn, options) {
    var cache = options && options.cache ? options.cache : cacheDefault;
    var serializer = options && options.serializer ? options.serializer : serializerDefault;
    var strategy = options && options.strategy ? options.strategy : strategyDefault;
    return strategy(fn, {
      cache: cache,
      serializer: serializer
    });
  } //
  // Strategy
  //


  function isPrimitive(value) {
    return value == null || typeof value === 'number' || typeof value === 'boolean'; // || typeof value === "string" 'unsafe' primitive for our needs
  }

  function monadic(fn, cache, serializer, arg) {
    var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
    var computedValue = cache.get(cacheKey);

    if (typeof computedValue === 'undefined') {
      computedValue = fn.call(this, arg);
      cache.set(cacheKey, computedValue);
    }

    return computedValue;
  }

  function variadic(fn, cache, serializer) {
    var args = Array.prototype.slice.call(arguments, 3);
    var cacheKey = serializer(args);
    var computedValue = cache.get(cacheKey);

    if (typeof computedValue === 'undefined') {
      computedValue = fn.apply(this, args);
      cache.set(cacheKey, computedValue);
    }

    return computedValue;
  }

  function assemble(fn, context, strategy, cache, serialize) {
    return strategy.bind(context, fn, cache, serialize);
  }

  function strategyDefault(fn, options) {
    var strategy = fn.length === 1 ? monadic : variadic;
    return assemble(fn, this, strategy, options.cache.create(), options.serializer);
  }

  function strategyVariadic(fn, options) {
    var strategy = variadic;
    return assemble(fn, this, strategy, options.cache.create(), options.serializer);
  }

  function strategyMonadic(fn, options) {
    var strategy = monadic;
    return assemble(fn, this, strategy, options.cache.create(), options.serializer);
  } //
  // Serializer
  //


  function serializerDefault() {
    return JSON.stringify(arguments);
  } //
  // Cache
  //


  function ObjectWithoutPrototypeCache() {
    this.cache = Object.create(null);
  }

  ObjectWithoutPrototypeCache.prototype.has = function (key) {
    return key in this.cache;
  };

  ObjectWithoutPrototypeCache.prototype.get = function (key) {
    return this.cache[key];
  };

  ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
    this.cache[key] = value;
  };

  var cacheDefault = {
    create: function create() {
      return new ObjectWithoutPrototypeCache();
    }
  }; //
  // API
  //

  var src = memoize;
  var strategies = {
    variadic: strategyVariadic,
    monadic: strategyMonadic
  };
  src.strategies = strategies;

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var CryptoError = /*#__PURE__*/function (_Error) {
    _inherits__default['default'](CryptoError, _Error);

    var _super = _createSuper$1(CryptoError);

    function CryptoError(message) {
      var _this;

      _classCallCheck__default['default'](this, CryptoError);

      _this = _super.call(this, message);
      Object.defineProperty(_assertThisInitialized__default['default'](_this), "message", {
        enumerable: false,
        value: message
      });
      Object.defineProperty(_assertThisInitialized__default['default'](_this), "name", {
        enumerable: false,
        value: _this.constructor.name
      });
      Error.captureStackTrace(_assertThisInitialized__default['default'](_this), _this.constructor);
      return _this;
    }

    return CryptoError;
  }( /*#__PURE__*/_wrapNativeSuper__default['default'](Error));
  var NetworkVersionError = /*#__PURE__*/function (_CryptoError) {
    _inherits__default['default'](NetworkVersionError, _CryptoError);

    var _super2 = _createSuper$1(NetworkVersionError);

    function NetworkVersionError(expected, given) {
      _classCallCheck__default['default'](this, NetworkVersionError);

      return _super2.call(this, "Expected version to be ".concat(expected, ", but got ").concat(given, "."));
    }

    return NetworkVersionError;
  }(CryptoError);
  var PrivateKeyLengthError = /*#__PURE__*/function (_CryptoError2) {
    _inherits__default['default'](PrivateKeyLengthError, _CryptoError2);

    var _super3 = _createSuper$1(PrivateKeyLengthError);

    function PrivateKeyLengthError(expected, given) {
      _classCallCheck__default['default'](this, PrivateKeyLengthError);

      return _super3.call(this, "Expected length to be ".concat(expected, ", but got ").concat(given, "."));
    }

    return PrivateKeyLengthError;
  }(CryptoError);
  var PublicKeyError = /*#__PURE__*/function (_CryptoError3) {
    _inherits__default['default'](PublicKeyError, _CryptoError3);

    var _super4 = _createSuper$1(PublicKeyError);

    function PublicKeyError(given) {
      _classCallCheck__default['default'](this, PublicKeyError);

      return _super4.call(this, "Expected ".concat(given, " to be a valid public key."));
    }

    return PublicKeyError;
  }(CryptoError);
  var AddressNetworkError = /*#__PURE__*/function (_CryptoError4) {
    _inherits__default['default'](AddressNetworkError, _CryptoError4);

    var _super5 = _createSuper$1(AddressNetworkError);

    function AddressNetworkError(what) {
      _classCallCheck__default['default'](this, AddressNetworkError);

      return _super5.call(this, what);
    }

    return AddressNetworkError;
  }(CryptoError);
  var InvalidMultiSignatureAssetError = /*#__PURE__*/function (_CryptoError5) {
    _inherits__default['default'](InvalidMultiSignatureAssetError, _CryptoError5);

    var _super6 = _createSuper$1(InvalidMultiSignatureAssetError);

    function InvalidMultiSignatureAssetError() {
      _classCallCheck__default['default'](this, InvalidMultiSignatureAssetError);

      return _super6.call(this, "The multi signature asset is invalid.");
    }

    return InvalidMultiSignatureAssetError;
  }(CryptoError);
  var InvalidBase58ChecksumError = /*#__PURE__*/function (_CryptoError6) {
    _inherits__default['default'](InvalidBase58ChecksumError, _CryptoError6);

    var _super7 = _createSuper$1(InvalidBase58ChecksumError);

    function InvalidBase58ChecksumError() {
      _classCallCheck__default['default'](this, InvalidBase58ChecksumError);

      return _super7.call(this, "Invalid checksum for base58 string.");
    }

    return InvalidBase58ChecksumError;
  }(CryptoError);

  var errors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CryptoError: CryptoError,
    NetworkVersionError: NetworkVersionError,
    PrivateKeyLengthError: PrivateKeyLengthError,
    PublicKeyError: PublicKeyError,
    AddressNetworkError: AddressNetworkError,
    InvalidMultiSignatureAssetError: InvalidMultiSignatureAssetError,
    InvalidBase58ChecksumError: InvalidBase58ChecksumError
  });

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  /*!
   * assert.js - assert for bcrypto
   * Copyright (c) 2020, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  /*
   * Assert
   */

  function assert$1(val, msg) {
    if (!val) {
      var err = new Error(msg || 'Assertion failed');
      if (Error.captureStackTrace) Error.captureStackTrace(err, assert$1);
      throw err;
    }
  }
  /*
   * Expose
   */


  var assert_1$1 = assert$1;

  /*
   * Constants
   */


  var BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
  /**
   * ChaCha20
   */

  var ChaCha20 = /*#__PURE__*/function () {
    /**
     * Create a ChaCha20 context.
     * @constructor
     */
    function ChaCha20() {
      _classCallCheck__default['default'](this, ChaCha20);

      this.state = new Uint32Array(16);
      this.stream = new Uint32Array(16);
      this.bytes = new Uint8Array(this.stream.buffer);
      this.pos = -1;
      if (BIG_ENDIAN) this.bytes = Buffer.alloc(64);
    }
    /**
     * Initialize chacha20 with a key, nonce, and counter.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @param {Number} counter
     */


    _createClass__default['default'](ChaCha20, [{
      key: "init",
      value: function init(key, nonce, counter) {
        if (counter == null) counter = 0;
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(Buffer.isBuffer(nonce));
        assert_1$1(Number.isSafeInteger(counter));
        if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');

        if (nonce.length >= 24) {
          key = ChaCha20.derive(key, nonce.slice(0, 16));
          nonce = nonce.slice(16);
        }

        this.state[0] = 0x61707865;
        this.state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
        this.state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
        this.state[3] = 0x6b206574;
        this.state[4] = readU32(key, 0);
        this.state[5] = readU32(key, 4);
        this.state[6] = readU32(key, 8);
        this.state[7] = readU32(key, 12);
        this.state[8] = readU32(key, 16 % key.length);
        this.state[9] = readU32(key, 20 % key.length);
        this.state[10] = readU32(key, 24 % key.length);
        this.state[11] = readU32(key, 28 % key.length);
        this.state[12] = counter >>> 0;

        if (nonce.length === 8) {
          this.state[13] = counter / 0x100000000 >>> 0;
          this.state[14] = readU32(nonce, 0);
          this.state[15] = readU32(nonce, 4);
        } else if (nonce.length === 12) {
          this.state[13] = readU32(nonce, 0);
          this.state[14] = readU32(nonce, 4);
          this.state[15] = readU32(nonce, 8);
        } else if (nonce.length === 16) {
          this.state[12] = readU32(nonce, 0);
          this.state[13] = readU32(nonce, 4);
          this.state[14] = readU32(nonce, 8);
          this.state[15] = readU32(nonce, 12);
        } else {
          throw new RangeError('Invalid nonce size.');
        }

        this.pos = 0;
        return this;
      }
      /**
       * Encrypt/decrypt data.
       * @param {Buffer} data - Will be mutated.
       * @returns {Buffer}
       */

    }, {
      key: "encrypt",
      value: function encrypt(data) {
        assert_1$1(Buffer.isBuffer(data));
        if (this.pos === -1) throw new Error('Context is not initialized.');

        for (var i = 0; i < data.length; i++) {
          if ((this.pos & 63) === 0) {
            this._block();

            this.pos = 0;
          }

          data[i] ^= this.bytes[this.pos++];
        }

        return data;
      }
      /**
       * Stir the stream.
       */

    }, {
      key: "_block",
      value: function _block() {
        for (var i = 0; i < 16; i++) {
          this.stream[i] = this.state[i];
        }

        for (var _i = 0; _i < 10; _i++) {
          qround(this.stream, 0, 4, 8, 12);
          qround(this.stream, 1, 5, 9, 13);
          qround(this.stream, 2, 6, 10, 14);
          qround(this.stream, 3, 7, 11, 15);
          qround(this.stream, 0, 5, 10, 15);
          qround(this.stream, 1, 6, 11, 12);
          qround(this.stream, 2, 7, 8, 13);
          qround(this.stream, 3, 4, 9, 14);
        }

        for (var _i2 = 0; _i2 < 16; _i2++) {
          this.stream[_i2] += this.state[_i2];
        }

        if (BIG_ENDIAN) {
          for (var _i3 = 0; _i3 < 16; _i3++) {
            writeU32(this.bytes, this.stream[_i3], _i3 * 4);
          }
        }

        this.state[12] += 1;
        if (this.state[12] === 0) this.state[13] += 1;
      }
      /**
       * Destroy context.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 16; i++) {
          this.state[i] = 0;
          this.stream[i] = 0;
        }

        if (BIG_ENDIAN) {
          for (var _i4 = 0; _i4 < 64; _i4++) {
            this.bytes[_i4] = 0;
          }
        }

        this.pos = -1;
        return this;
      }
      /**
       * Derive key with XChaCha20.
       * @param {Buffer} key
       * @param {Buffer} nonce
       * @returns {Buffer}
       */

    }], [{
      key: "derive",
      value: function derive(key, nonce) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(Buffer.isBuffer(nonce));
        if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');
        if (nonce.length !== 16) throw new RangeError('Invalid nonce size.');
        var state = new Uint32Array(16);
        state[0] = 0x61707865;
        state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
        state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
        state[3] = 0x6b206574;
        state[4] = readU32(key, 0);
        state[5] = readU32(key, 4);
        state[6] = readU32(key, 8);
        state[7] = readU32(key, 12);
        state[8] = readU32(key, 16 % key.length);
        state[9] = readU32(key, 20 % key.length);
        state[10] = readU32(key, 24 % key.length);
        state[11] = readU32(key, 28 % key.length);
        state[12] = readU32(nonce, 0);
        state[13] = readU32(nonce, 4);
        state[14] = readU32(nonce, 8);
        state[15] = readU32(nonce, 12);

        for (var i = 0; i < 10; i++) {
          qround(state, 0, 4, 8, 12);
          qround(state, 1, 5, 9, 13);
          qround(state, 2, 6, 10, 14);
          qround(state, 3, 7, 11, 15);
          qround(state, 0, 5, 10, 15);
          qround(state, 1, 6, 11, 12);
          qround(state, 2, 7, 8, 13);
          qround(state, 3, 4, 9, 14);
        }

        var out = Buffer.alloc(32);
        writeU32(out, state[0], 0);
        writeU32(out, state[1], 4);
        writeU32(out, state[2], 8);
        writeU32(out, state[3], 12);
        writeU32(out, state[12], 16);
        writeU32(out, state[13], 20);
        writeU32(out, state[14], 24);
        writeU32(out, state[15], 28);
        return out;
      }
    }]);

    return ChaCha20;
  }();
  /*
   * Static
   */


  ChaCha20.native = 0;
  /*
   * Helpers
   */

  function qround(x, a, b, c, d) {
    x[a] += x[b];
    x[d] = rotl32(x[d] ^ x[a], 16);
    x[c] += x[d];
    x[b] = rotl32(x[b] ^ x[c], 12);
    x[a] += x[b];
    x[d] = rotl32(x[d] ^ x[a], 8);
    x[c] += x[d];
    x[b] = rotl32(x[b] ^ x[c], 7);
  }

  function rotl32(w, b) {
    return w << b | w >>> 32 - b;
  }

  function readU32(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }

  function writeU32(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var chacha20 = ChaCha20;

  /**
   * Poly1305
   */


  var Poly1305 = /*#__PURE__*/function () {
    /**
     * Create a Poly1305 context.
     * @constructor
     */
    function Poly1305() {
      _classCallCheck__default['default'](this, Poly1305);

      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.buffer = Buffer.alloc(16);
      this.fin = -1;
      this.leftover = 0;
    }
    /**
     * Initialize poly1305 with a key.
     * @param {Buffer} key
     */


    _createClass__default['default'](Poly1305, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key) && key.length >= 32); // r &= 0xffffffc0ffffffc0ffffffc0fffffff

        var t0 = readU16(key, 0);
        var t1 = readU16(key, 2);
        var t2 = readU16(key, 4);
        var t3 = readU16(key, 6);
        var t4 = readU16(key, 8);
        var t5 = readU16(key, 10);
        var t6 = readU16(key, 12);
        var t7 = readU16(key, 14);
        this.r[0] = t0 & 0x1fff;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
        this.r[5] = t4 >>> 1 & 0x1ffe;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
        this.r[9] = t7 >>> 5 & 0x007f; // h = 0

        for (var i = 0; i < 10; i++) {
          this.h[i] = 0;
        } // Save pad for later.


        for (var _i = 0; _i < 8; _i++) {
          this.pad[_i] = readU16(key, 16 + 2 * _i);
        }

        this.fin = 0;
        this.leftover = 0;
        return this;
      }
      /**
       * Process 16 byte blocks.
       * @private
       * @param {Buffer} data - Blocks.
       * @param {Number} bytes - Size.
       * @param {Number} m - Offset pointer.
       */

    }, {
      key: "_blocks",
      value: function _blocks(data, bytes, m) {
        var hibit = this.fin ? 0 : 1 << 11; // 1 << 128

        var d = new Uint32Array(10);

        while (bytes >= 16) {
          // h += m[i]
          var t0 = readU16(data, m + 0);
          var t1 = readU16(data, m + 2);
          var t2 = readU16(data, m + 4);
          var t3 = readU16(data, m + 6);
          var t4 = readU16(data, m + 8);
          var t5 = readU16(data, m + 10);
          var t6 = readU16(data, m + 12);
          var t7 = readU16(data, m + 14);
          this.h[0] += t0 & 0x1fff;
          this.h[1] += (t0 >>> 13 | t1 << 3) & 0x1fff;
          this.h[2] += (t1 >>> 10 | t2 << 6) & 0x1fff;
          this.h[3] += (t2 >>> 7 | t3 << 9) & 0x1fff;
          this.h[4] += (t3 >>> 4 | t4 << 12) & 0x1fff;
          this.h[5] += t4 >>> 1 & 0x1fff;
          this.h[6] += (t4 >>> 14 | t5 << 2) & 0x1fff;
          this.h[7] += (t5 >>> 11 | t6 << 5) & 0x1fff;
          this.h[8] += (t6 >>> 8 | t7 << 8) & 0x1fff;
          this.h[9] += t7 >>> 5 | hibit; // h *= r, (partial) h %= p

          var c = 0;

          for (var i = 0; i < 10; i++) {
            d[i] = c;

            for (var j = 0; j < 10; j++) {
              var a = this.h[j];
              if (j <= i) a *= this.r[i - j];else a *= 5 * this.r[i + 10 - j];
              d[i] += a; // Sum(h[i] * r[i] * 5) will overflow
              // slightly above 6 products with an
              // unclamped r, so carry at 5.

              if (j === 4) {
                c = d[i] >>> 13;
                d[i] &= 0x1fff;
              }
            }

            c += d[i] >>> 13;
            d[i] &= 0x1fff;
          }

          c = (c << 2) + c; // c *= 5

          c += d[0];
          d[0] = c & 0x1fff;
          c = c >>> 13;
          d[1] += c;

          for (var _i2 = 0; _i2 < 10; _i2++) {
            this.h[_i2] = d[_i2];
          }

          m += 16;
          bytes -= 16;
        }
      }
      /**
       * Update the MAC with data (will be
       * processed as 16 byte blocks).
       * @param {Buffer} data
       */

    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));
        if (this.fin === -1) throw new Error('Context is not initialized.');
        var bytes = data.length;
        var m = 0; // Handle leftover.

        if (this.leftover) {
          var want = 16 - this.leftover;
          if (want > bytes) want = bytes;

          for (var i = 0; i < want; i++) {
            this.buffer[this.leftover + i] = data[m + i];
          }

          bytes -= want;
          m += want;
          this.leftover += want;
          if (this.leftover < 16) return this;

          this._blocks(this.buffer, 16, 0);

          this.leftover = 0;
        } // Process full blocks.


        if (bytes >= 16) {
          var _want = bytes & ~(16 - 1);

          this._blocks(data, _want, m);

          m += _want;
          bytes -= _want;
        } // Store leftover.


        if (bytes) {
          for (var _i3 = 0; _i3 < bytes; _i3++) {
            this.buffer[this.leftover + _i3] = data[m + _i3];
          }

          this.leftover += bytes;
        }

        return this;
      }
      /**
       * Finalize and return a 16-byte MAC.
       * @returns {Buffer}
       */

    }, {
      key: "final",
      value: function final() {
        if (this.fin === -1) throw new Error('Context is not initialized.');
        var mac = Buffer.alloc(16);
        var g = new Uint16Array(10); // Process the remaining block.

        if (this.leftover) {
          var i = this.leftover;
          this.buffer[i++] = 1;

          for (; i < 16; i++) {
            this.buffer[i] = 0;
          }

          this.fin = 1;

          this._blocks(this.buffer, 16, 0);
        } // Fully carry h.


        var c = this.h[1] >>> 13;
        this.h[1] &= 0x1fff;

        for (var _i4 = 2; _i4 < 10; _i4++) {
          this.h[_i4] += c;
          c = this.h[_i4] >>> 13;
          this.h[_i4] &= 0x1fff;
        }

        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 0x1fff;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 0x1fff;
        this.h[2] += c; // Compute h + -p.

        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;

        for (var _i5 = 1; _i5 < 10; _i5++) {
          g[_i5] = this.h[_i5] + c;
          c = g[_i5] >>> 13;
          g[_i5] &= 0x1fff;
        } // Select h if h < p, or h + -p if h >= p.


        var mask = (c ^ 1) - 1;

        for (var _i6 = 0; _i6 < 10; _i6++) {
          g[_i6] &= mask;
        }

        mask = ~mask;

        for (var _i7 = 0; _i7 < 10; _i7++) {
          this.h[_i7] = this.h[_i7] & mask | g[_i7];
        } // h = h % (2^128)


        this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff; // mac = (h + pad) % (2^128)

        var f = this.h[0] + this.pad[0];
        this.h[0] = f;

        for (var _i8 = 1; _i8 < 8; _i8++) {
          f = this.h[_i8] + this.pad[_i8] + (f >>> 16);
          this.h[_i8] = f;
        }

        for (var _i9 = 0; _i9 < 8; _i9++) {
          writeU16(mac, this.h[_i9], _i9 * 2);
        } // Zero out the state.


        this.destroy();
        return mac;
      }
      /**
       * Destroy the context.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 10; i++) {
          this.r[i] = 0;
          this.h[i] = 0;
        }

        for (var _i10 = 0; _i10 < 8; _i10++) {
          this.pad[_i10] = 0;
        }

        for (var _i11 = 0; _i11 < 16; _i11++) {
          this.buffer[_i11] = 0;
        }

        this.fin = -1;
        this.leftover = 0;
      }
      /**
       * Finalize and verify MAC against tag.
       * @param {Buffer} tag
       * @returns {Boolean}
       */

    }, {
      key: "verify",
      value: function verify(tag) {
        assert_1$1(Buffer.isBuffer(tag));
        assert_1$1(tag.length === 16);
        var mac = this.final();
        var z = 0;

        for (var i = 0; i < 16; i++) {
          z |= mac[i] ^ tag[i];
        }

        return z - 1 >>> 31 !== 0;
      }
    }]);

    return Poly1305;
  }();
  /*
   * Static
   */


  Poly1305.native = 0;
  /*
   * Helpers
   */

  function readU16(data, off) {
    return data[off++] + data[off] * 0x100;
  }

  function writeU16(dst, num, off) {
    dst[off++] = num;
    dst[off++] = num >>> 8;
    return off;
  }
  /*
   * Expose
   */


  var poly1305 = Poly1305;

  /*
   * Constants
   */


  var zero16 = Buffer.alloc(16, 0x00);
  /**
   * AEAD
   */

  var AEAD = /*#__PURE__*/function () {
    /**
     * Create an AEAD context.
     * @constructor
     */
    function AEAD() {
      _classCallCheck__default['default'](this, AEAD);

      this.chacha = new chacha20();
      this.poly = new poly1305();
      this.key = Buffer.alloc(64);
      this.mode = -1;
      this.aadLen = 0;
      this.cipherLen = 0;
    }
    /**
     * Initialize the AEAD with a key and iv.
     * @param {Buffer} key
     * @param {Buffer} iv - IV / packet sequence number.
     */


    _createClass__default['default'](AEAD, [{
      key: "init",
      value: function init(key, iv) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(Buffer.isBuffer(iv));
        this.key.fill(0);
        this.chacha.init(key, iv, 0);
        this.chacha.encrypt(this.key);
        this.poly.init(this.key);
        this.mode = 0;
        this.aadLen = 0;
        this.cipherLen = 0;
        return this;
      }
      /**
       * Update the aad (will be finalized
       * on an encrypt/decrypt call).
       * @param {Buffer} aad
       */

    }, {
      key: "aad",
      value: function aad(data) {
        if (this.mode === -1) throw new Error('Context is not initialized.');
        if (this.mode !== 0) throw new Error('Invalid state for aad.');
        this.poly.update(data);
        this.aadLen += data.length;
        return this;
      }
      /**
       * Encrypt a piece of data.
       * @param {Buffer} data
       */

    }, {
      key: "encrypt",
      value: function encrypt(data) {
        if (this.mode === -1) throw new Error('Context is not initialized.');
        if (this.mode !== 0 && this.mode !== 1) throw new Error('Invalid state for encrypt.');

        if (this.mode === 0) {
          this._pad16(this.aadLen);

          this.mode = 1;
        }

        this.chacha.encrypt(data);
        this.poly.update(data);
        this.cipherLen += data.length;
        return data;
      }
      /**
       * Decrypt a piece of data.
       * @param {Buffer} data
       */

    }, {
      key: "decrypt",
      value: function decrypt(data) {
        assert_1$1(Buffer.isBuffer(data));
        if (this.mode === -1) throw new Error('Context is not initialized.');
        if (this.mode !== 0 && this.mode !== 2) throw new Error('Invalid state for decrypt.');

        if (this.mode === 0) {
          this._pad16(this.aadLen);

          this.mode = 2;
        }

        this.cipherLen += data.length;
        this.poly.update(data);
        this.chacha.encrypt(data);
        return data;
      }
      /**
       * Authenticate data without decrypting.
       * @param {Buffer} data
       */

    }, {
      key: "auth",
      value: function auth(data) {
        assert_1$1(Buffer.isBuffer(data));
        if (this.mode === -1) throw new Error('Context is not initialized.');
        if (this.mode !== 0 && this.mode !== 3) throw new Error('Invalid state for auth.');

        if (this.mode === 0) {
          this._pad16(this.aadLen);

          this.mode = 3;
        }

        this.cipherLen += data.length;
        this.poly.update(data);
        return data;
      }
      /**
       * Finalize the aead and generate a MAC.
       * @returns {Buffer} MAC
       */

    }, {
      key: "final",
      value: function final() {
        if (this.mode === -1) throw new Error('Context is not initialized.');
        var len = Buffer.alloc(16);
        writeU64(len, this.aadLen, 0);
        writeU64(len, this.cipherLen, 8);
        if (this.mode === 0) this._pad16(this.aadLen);

        this._pad16(this.cipherLen);

        this.poly.update(len);
        var mac = this.poly.final();
        this.destroy();
        return mac;
      }
      /**
       * Destroy the context.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this.chacha.destroy();
        this.poly.destroy();

        for (var i = 0; i < 64; i++) {
          this.key[i] = 0;
        }

        this.mode = -1;
        this.aadLen = 0;
        this.cipherLen = 0;
        return this;
      }
      /**
       * Finalize and verify MAC against tag.
       * @param {Buffer} tag
       * @returns {Boolean}
       */

    }, {
      key: "verify",
      value: function verify(tag) {
        assert_1$1(Buffer.isBuffer(tag));
        assert_1$1(tag.length === 16);
        var mac = this.final();
        var z = 0;

        for (var i = 0; i < 16; i++) {
          z |= mac[i] ^ tag[i];
        }

        return z - 1 >>> 31 !== 0;
      }
      /**
       * Pad a chunk before updating mac.
       * @private
       * @param {Number} size
       */

    }, {
      key: "_pad16",
      value: function _pad16(size) {
        var pos = size & 15;
        if (pos > 0) this.poly.update(zero16.slice(0, 16 - pos));
      }
      /**
       * Encrypt a piece of data.
       * @param {Buffer} key
       * @param {Buffer} iv
       * @param {Buffer} msg
       * @param {Buffer?} aad
       * @returns {Buffer} tag
       */

    }], [{
      key: "encrypt",
      value: function encrypt(key, iv, msg, aad) {
        var aead = new AEAD();
        aead.init(key, iv);
        if (aad) aead.aad(aad);
        aead.encrypt(msg);
        return aead.final();
      }
      /**
       * Decrypt a piece of data.
       * @param {Buffer} key
       * @param {Buffer} iv
       * @param {Buffer} msg
       * @param {Buffer} tag
       * @param {Buffer?} aad
       * @returns {Boolean}
       */

    }, {
      key: "decrypt",
      value: function decrypt(key, iv, msg, tag, aad) {
        var aead = new AEAD();
        aead.init(key, iv);
        if (aad) aead.aad(aad);
        aead.decrypt(msg);
        return aead.verify(tag);
      }
      /**
       * Authenticate data without decrypting.
       * @param {Buffer} key
       * @param {Buffer} iv
       * @param {Buffer} msg
       * @param {Buffer} tag
       * @param {Buffer?} aad
       * @returns {Boolean}
       */

    }, {
      key: "auth",
      value: function auth(key, iv, msg, tag, aad) {
        var aead = new AEAD();
        aead.init(key, iv);
        if (aad) aead.aad(aad);
        aead.auth(msg);
        return aead.verify(tag);
      }
    }]);

    return AEAD;
  }();
  /*
   * Static
   */


  AEAD.native = chacha20.native;
  /*
   * Helpers
   */

  function writeU32$1(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }

  function writeU64(dst, num, off) {
    var hi = num * (1 / 0x100000000) >>> 0;
    var lo = num >>> 0;
    writeU32$1(dst, lo, off + 0);
    writeU32$1(dst, hi, off + 4);
    return off + 8;
  }
  /*
   * Expose
   */


  var aead = AEAD;

  var aeadBrowser = aead;

  /*
   * Constants
   */


  var TE0 = new Uint32Array([0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a]);
  var TE1 = new Uint32Array([0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616]);
  var TE2 = new Uint32Array([0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16]);
  var TE3 = new Uint32Array([0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c]);
  var TD0 = new Uint32Array([0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742]);
  var TD1 = new Uint32Array([0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857]);
  var TD2 = new Uint32Array([0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8]);
  var TD3 = new Uint32Array([0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0]);
  var TD4 = new Uint8Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]);
  var RCON = new Uint32Array([0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000]);
  /**
   * AES
   */

  var AES = /*#__PURE__*/function () {
    function AES() {
      var bits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 256;

      _classCallCheck__default['default'](this, AES);

      assert_1$1(bits >>> 0 === bits);
      this.bits = bits;
      this.rounds = getRounds(bits);
      this.key = null;
      this.encKey = null;
      this.decKey = null;
    }

    _createClass__default['default'](AES, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        if (key.length !== this.bits >>> 3) throw new Error('Invalid key size.');
        this.destroy();
        this.key = Buffer.from(key);
        this.encKey = null;
        this.decKey = null;
        return this;
      }
    }, {
      key: "createEncryptKey",
      value: function createEncryptKey() {
        if (!this.key) throw new Error('Cipher is not initialized.');
        var ukey = this.key;
        if (ukey.length !== this.bits >>> 3) throw new Error('Invalid key size.');
        var key = new Uint32Array(60);
        key[0] = readU32$1(ukey, 0);
        key[1] = readU32$1(ukey, 4);
        key[2] = readU32$1(ukey, 8);
        key[3] = readU32$1(ukey, 12);
        var p = 0;
        var i = 0;

        if (this.bits === 128) {
          for (;;) {
            var tmp = key[p + 3];
            key[p + 4] = key[p] ^ TE2[tmp >>> 16 & 0xff] & 0xff000000 ^ TE3[tmp >>> 8 & 0xff] & 0x00ff0000 ^ TE0[tmp >>> 0 & 0xff] & 0x0000ff00 ^ TE1[tmp >>> 24 & 0xff] & 0x000000ff ^ RCON[i];
            key[p + 5] = key[p + 1] ^ key[p + 4];
            key[p + 6] = key[p + 2] ^ key[p + 5];
            key[p + 7] = key[p + 3] ^ key[p + 6];
            i += 1;
            if (i === 10) break;
            p += 4;
          }

          return key;
        }

        key[p + 4] = readU32$1(ukey, 16);
        key[p + 5] = readU32$1(ukey, 20);

        if (this.bits === 192) {
          for (;;) {
            var _tmp = key[p + 5];
            key[p + 6] = key[p] ^ TE2[_tmp >>> 16 & 0xff] & 0xff000000 ^ TE3[_tmp >>> 8 & 0xff] & 0x00ff0000 ^ TE0[_tmp >>> 0 & 0xff] & 0x0000ff00 ^ TE1[_tmp >>> 24 & 0xff] & 0x000000ff ^ RCON[i];
            key[p + 7] = key[p + 1] ^ key[p + 6];
            key[p + 8] = key[p + 2] ^ key[p + 7];
            key[p + 9] = key[p + 3] ^ key[p + 8];
            i += 1;
            if (i === 8) break;
            key[p + 10] = key[p + 4] ^ key[p + 9];
            key[p + 11] = key[p + 5] ^ key[p + 10];
            p += 6;
          }

          return key;
        }

        key[p + 6] = readU32$1(ukey, 24);
        key[p + 7] = readU32$1(ukey, 28);

        if (this.bits === 256) {
          for (;;) {
            var _tmp2 = key[p + 7];
            key[p + 8] = key[p] ^ TE2[_tmp2 >>> 16 & 0xff] & 0xff000000 ^ TE3[_tmp2 >>> 8 & 0xff] & 0x00ff0000 ^ TE0[_tmp2 >>> 0 & 0xff] & 0x0000ff00 ^ TE1[_tmp2 >>> 24 & 0xff] & 0x000000ff ^ RCON[i];
            key[p + 9] = key[p + 1] ^ key[p + 8];
            key[p + 10] = key[p + 2] ^ key[p + 9];
            key[p + 11] = key[p + 3] ^ key[p + 10];
            i += 1;
            if (i === 7) break;
            _tmp2 = key[p + 11];
            key[p + 12] = key[p + 4] ^ TE2[_tmp2 >>> 24 & 0xff] & 0xff000000 ^ TE3[_tmp2 >>> 16 & 0xff] & 0x00ff0000 ^ TE0[_tmp2 >>> 8 & 0xff] & 0x0000ff00 ^ TE1[_tmp2 >>> 0 & 0xff] & 0x000000ff;
            key[p + 13] = key[p + 5] ^ key[p + 12];
            key[p + 14] = key[p + 6] ^ key[p + 13];
            key[p + 15] = key[p + 7] ^ key[p + 14];
            p += 8;
          }

          return key;
        }

        throw new Error('Bad key size.');
      }
    }, {
      key: "createDecryptKey",
      value: function createDecryptKey() {
        // First, start with an encryption schedule.
        var key = this.createEncryptKey();
        var p = 0; // Invert the order of the round keys.

        for (var i = 0, j = 4 * this.rounds; i < j; i += 4, j -= 4) {
          var tmp = key[p + i + 0];
          key[p + i + 0] = key[p + j + 0];
          key[p + j + 0] = tmp;
          tmp = key[p + i + 1];
          key[p + i + 1] = key[p + j + 1];
          key[p + j + 1] = tmp;
          tmp = key[p + i + 2];
          key[p + i + 2] = key[p + j + 2];
          key[p + j + 2] = tmp;
          tmp = key[p + i + 3];
          key[p + i + 3] = key[p + j + 3];
          key[p + j + 3] = tmp;
        } // Apply the inverse MixColumn transform to
        // all round keys but the first and the last.


        for (var _i = 1; _i < this.rounds; _i++) {
          p += 4;
          key[p + 0] = TD0[TE1[key[p + 0] >>> 24 & 0xff] & 0xff] ^ TD1[TE1[key[p + 0] >>> 16 & 0xff] & 0xff] ^ TD2[TE1[key[p + 0] >>> 8 & 0xff] & 0xff] ^ TD3[TE1[key[p + 0] >>> 0 & 0xff] & 0xff];
          key[p + 1] = TD0[TE1[key[p + 1] >>> 24 & 0xff] & 0xff] ^ TD1[TE1[key[p + 1] >>> 16 & 0xff] & 0xff] ^ TD2[TE1[key[p + 1] >>> 8 & 0xff] & 0xff] ^ TD3[TE1[key[p + 1] >>> 0 & 0xff] & 0xff];
          key[p + 2] = TD0[TE1[key[p + 2] >>> 24 & 0xff] & 0xff] ^ TD1[TE1[key[p + 2] >>> 16 & 0xff] & 0xff] ^ TD2[TE1[key[p + 2] >>> 8 & 0xff] & 0xff] ^ TD3[TE1[key[p + 2] >>> 0 & 0xff] & 0xff];
          key[p + 3] = TD0[TE1[key[p + 3] >>> 24 & 0xff] & 0xff] ^ TD1[TE1[key[p + 3] >>> 16 & 0xff] & 0xff] ^ TD2[TE1[key[p + 3] >>> 8 & 0xff] & 0xff] ^ TD3[TE1[key[p + 3] >>> 0 & 0xff] & 0xff];
        }

        return key;
      }
    }, {
      key: "getEncryptKey",
      value: function getEncryptKey() {
        if (!this.encKey) this.encKey = this.createEncryptKey();
        return this.encKey;
      }
    }, {
      key: "getDecryptKey",
      value: function getDecryptKey() {
        if (!this.decKey) this.decKey = this.createDecryptKey();
        return this.decKey;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        var key = this.getEncryptKey(); // Map byte array block to cipher
        // state and add initial round key.

        var s0 = readU32$1(input, ipos + 0) ^ key[0];
        var s1 = readU32$1(input, ipos + 4) ^ key[1];
        var s2 = readU32$1(input, ipos + 8) ^ key[2];
        var s3 = readU32$1(input, ipos + 12) ^ key[3]; // Nr - 1 full rounds

        var r = this.rounds >>> 1;
        var p = 0;
        var t0, t1, t2, t3;

        for (;;) {
          t0 = TE0[s0 >>> 24 & 0xff] ^ TE1[s1 >>> 16 & 0xff] ^ TE2[s2 >>> 8 & 0xff] ^ TE3[s3 >>> 0 & 0xff] ^ key[p + 4];
          t1 = TE0[s1 >>> 24 & 0xff] ^ TE1[s2 >>> 16 & 0xff] ^ TE2[s3 >>> 8 & 0xff] ^ TE3[s0 >>> 0 & 0xff] ^ key[p + 5];
          t2 = TE0[s2 >>> 24 & 0xff] ^ TE1[s3 >>> 16 & 0xff] ^ TE2[s0 >>> 8 & 0xff] ^ TE3[s1 >>> 0 & 0xff] ^ key[p + 6];
          t3 = TE0[s3 >>> 24 & 0xff] ^ TE1[s0 >>> 16 & 0xff] ^ TE2[s1 >>> 8 & 0xff] ^ TE3[s2 >>> 0 & 0xff] ^ key[p + 7];
          p += 8;
          r -= 1;
          if (r === 0) break;
          s0 = TE0[t0 >>> 24 & 0xff] ^ TE1[t1 >>> 16 & 0xff] ^ TE2[t2 >>> 8 & 0xff] ^ TE3[t3 >>> 0 & 0xff] ^ key[p + 0];
          s1 = TE0[t1 >>> 24 & 0xff] ^ TE1[t2 >>> 16 & 0xff] ^ TE2[t3 >>> 8 & 0xff] ^ TE3[t0 >>> 0 & 0xff] ^ key[p + 1];
          s2 = TE0[t2 >>> 24 & 0xff] ^ TE1[t3 >>> 16 & 0xff] ^ TE2[t0 >>> 8 & 0xff] ^ TE3[t1 >>> 0 & 0xff] ^ key[p + 2];
          s3 = TE0[t3 >>> 24 & 0xff] ^ TE1[t0 >>> 16 & 0xff] ^ TE2[t1 >>> 8 & 0xff] ^ TE3[t2 >>> 0 & 0xff] ^ key[p + 3];
        } // Apply last round and map cipher
        // state to byte array block.


        s0 = TE2[t0 >>> 24 & 0xff] & 0xff000000 ^ TE3[t1 >>> 16 & 0xff] & 0x00ff0000 ^ TE0[t2 >>> 8 & 0xff] & 0x0000ff00 ^ TE1[t3 >>> 0 & 0xff] & 0x000000ff ^ key[p + 0];
        s1 = TE2[t1 >>> 24 & 0xff] & 0xff000000 ^ TE3[t2 >>> 16 & 0xff] & 0x00ff0000 ^ TE0[t3 >>> 8 & 0xff] & 0x0000ff00 ^ TE1[t0 >>> 0 & 0xff] & 0x000000ff ^ key[p + 1];
        s2 = TE2[t2 >>> 24 & 0xff] & 0xff000000 ^ TE3[t3 >>> 16 & 0xff] & 0x00ff0000 ^ TE0[t0 >>> 8 & 0xff] & 0x0000ff00 ^ TE1[t1 >>> 0 & 0xff] & 0x000000ff ^ key[p + 2];
        s3 = TE2[t3 >>> 24 & 0xff] & 0xff000000 ^ TE3[t0 >>> 16 & 0xff] & 0x00ff0000 ^ TE0[t1 >>> 8 & 0xff] & 0x0000ff00 ^ TE1[t2 >>> 0 & 0xff] & 0x000000ff ^ key[p + 3];
        writeU32$2(output, s0, opos + 0);
        writeU32$2(output, s1, opos + 4);
        writeU32$2(output, s2, opos + 8);
        writeU32$2(output, s3, opos + 12);
        return this;
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        var key = this.getDecryptKey(); // Map byte array block to cipher
        // state and add initial round key.

        var s0 = readU32$1(input, ipos + 0) ^ key[0];
        var s1 = readU32$1(input, ipos + 4) ^ key[1];
        var s2 = readU32$1(input, ipos + 8) ^ key[2];
        var s3 = readU32$1(input, ipos + 12) ^ key[3]; // Nr - 1 full rounds

        var r = this.rounds >>> 1;
        var p = 0;
        var t0, t1, t2, t3;

        for (;;) {
          t0 = TD0[s0 >>> 24 & 0xff] ^ TD1[s3 >>> 16 & 0xff] ^ TD2[s2 >>> 8 & 0xff] ^ TD3[s1 >>> 0 & 0xff] ^ key[p + 4];
          t1 = TD0[s1 >>> 24 & 0xff] ^ TD1[s0 >>> 16 & 0xff] ^ TD2[s3 >>> 8 & 0xff] ^ TD3[s2 >>> 0 & 0xff] ^ key[p + 5];
          t2 = TD0[s2 >>> 24 & 0xff] ^ TD1[s1 >>> 16 & 0xff] ^ TD2[s0 >>> 8 & 0xff] ^ TD3[s3 >>> 0 & 0xff] ^ key[p + 6];
          t3 = TD0[s3 >>> 24 & 0xff] ^ TD1[s2 >>> 16 & 0xff] ^ TD2[s1 >>> 8 & 0xff] ^ TD3[s0 >>> 0 & 0xff] ^ key[p + 7];
          p += 8;
          r -= 1;
          if (r === 0) break;
          s0 = TD0[t0 >>> 24 & 0xff] ^ TD1[t3 >>> 16 & 0xff] ^ TD2[t2 >>> 8 & 0xff] ^ TD3[t1 >>> 0 & 0xff] ^ key[p + 0];
          s1 = TD0[t1 >>> 24 & 0xff] ^ TD1[t0 >>> 16 & 0xff] ^ TD2[t3 >>> 8 & 0xff] ^ TD3[t2 >>> 0 & 0xff] ^ key[p + 1];
          s2 = TD0[t2 >>> 24 & 0xff] ^ TD1[t1 >>> 16 & 0xff] ^ TD2[t0 >>> 8 & 0xff] ^ TD3[t3 >>> 0 & 0xff] ^ key[p + 2];
          s3 = TD0[t3 >>> 24 & 0xff] ^ TD1[t2 >>> 16 & 0xff] ^ TD2[t1 >>> 8 & 0xff] ^ TD3[t0 >>> 0 & 0xff] ^ key[p + 3];
        } // Apply last round and map cipher
        // state to byte array block.


        s0 = TD4[t0 >>> 24 & 0xff] << 24 ^ TD4[t3 >>> 16 & 0xff] << 16 ^ TD4[t2 >>> 8 & 0xff] << 8 ^ TD4[t1 >>> 0 & 0xff] << 0 ^ key[p + 0];
        s1 = TD4[t1 >>> 24 & 0xff] << 24 ^ TD4[t0 >>> 16 & 0xff] << 16 ^ TD4[t3 >>> 8 & 0xff] << 8 ^ TD4[t2 >>> 0 & 0xff] << 0 ^ key[p + 1];
        s2 = TD4[t2 >>> 24 & 0xff] << 24 ^ TD4[t1 >>> 16 & 0xff] << 16 ^ TD4[t0 >>> 8 & 0xff] << 8 ^ TD4[t3 >>> 0 & 0xff] << 0 ^ key[p + 2];
        s3 = TD4[t3 >>> 24 & 0xff] << 24 ^ TD4[t2 >>> 16 & 0xff] << 16 ^ TD4[t1 >>> 8 & 0xff] << 8 ^ TD4[t0 >>> 0 & 0xff] << 0 ^ key[p + 3];
        writeU32$2(output, s0, opos + 0);
        writeU32$2(output, s1, opos + 4);
        writeU32$2(output, s2, opos + 8);
        writeU32$2(output, s3, opos + 12);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.key) {
          for (var i = 0; i < this.key.length; i++) {
            this.key[i] = 0;
          }
        }

        if (this.encKey) {
          for (var _i2 = 0; _i2 < 60; _i2++) {
            this.encKey[_i2] = 0;
          }
        }

        if (this.decKey) {
          for (var _i3 = 0; _i3 < 60; _i3++) {
            this.decKey[_i3] = 0;
          }
        }

        this.key = null;
        this.encKey = null;
        this.decKey = null;
        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 16;
      }
    }]);

    return AES;
  }();
  /*
   * Helpers
   */


  function getRounds(bits) {
    switch (bits) {
      case 128:
        return 10;

      case 192:
        return 12;

      case 256:
        return 14;

      default:
        throw new Error('Bad key size.');
    }
  }

  function readU32$1(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function writeU32$2(dst, num, off) {
    dst[off++] = num >>> 24;
    dst[off++] = num >>> 16;
    dst[off++] = num >>> 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var aes = AES;

  /*
   * Constants
   */


  var PADDING = Buffer.alloc(16, 0x00);
  var FINALIZED = -1;
  var REDUCTION = new Uint16Array([0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0, 0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0]);
  /**
   * GHASH
   */

  var GHASH = /*#__PURE__*/function () {
    function GHASH() {
      _classCallCheck__default['default'](this, GHASH);

      this.state = new Uint32Array(4);
      this.block = Buffer.alloc(16);
      this.size = FINALIZED;
      this.adLen = 0;
      this.ctLen = 0;
      this.table = new Array(16);

      for (var i = 0; i < 16; i++) {
        this.table[i] = new Uint32Array(4);
      }
    }

    _createClass__default['default'](GHASH, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length === 16);

        for (var i = 0; i < 4; i++) {
          this.state[i] = 0;
        }

        this.size = 0;
        this.adLen = 0;
        this.ctLen = 0;

        for (var _i = 0; _i < 16; _i++) {
          for (var j = 0; j < 4; j++) {
            this.table[_i][j] = 0;
          }
        }

        var x = new Uint32Array(4);
        x[1] = readU32$2(key, 0);
        x[0] = readU32$2(key, 4);
        x[3] = readU32$2(key, 8);
        x[2] = readU32$2(key, 12);
        this.table[reverse(1)] = x;

        for (var _i2 = 2; _i2 < 16; _i2 += 2) {
          this.table[reverse(_i2)] = this.double(this.table[reverse(_i2 >>> 1)]);
          this.table[reverse(_i2 + 1)] = this.add(this.table[reverse(_i2)], x);
        }

        return this;
      }
    }, {
      key: "absorb",
      value: function absorb(data) {
        this._absorb(data, data.length);

        return this;
      }
    }, {
      key: "_absorb",
      value: function _absorb(data, len) {
        assert_1$1(this.size !== FINALIZED, 'Context is not initialized.');
        var pos = this.size & 15;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 16 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 16) return;
          this.transform(this.block, 0);
        }

        while (len >= 16) {
          this.transform(data, off);
          off += 16;
          len -= 16;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
    }, {
      key: "transform",
      value: function transform(block, off) {
        this.state[1] ^= readU32$2(block, off + 0);
        this.state[0] ^= readU32$2(block, off + 4);
        this.state[3] ^= readU32$2(block, off + 8);
        this.state[2] ^= readU32$2(block, off + 12);
        this.mul(this.state);
      }
    }, {
      key: "pad",
      value: function pad() {
        var pos = this.size & 15;
        if (pos !== 0) this._absorb(PADDING, 16 - pos);
      }
    }, {
      key: "aad",
      value: function aad(data) {
        assert_1$1(Buffer.isBuffer(data));
        assert_1$1(this.ctLen === 0);
        this.adLen += data.length;
        return this.absorb(data);
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));
        if (data.length === 0) return this;
        if (this.ctLen === 0) this.pad();
        this.ctLen += data.length;
        return this.absorb(data);
      }
    }, {
      key: "final",
      value: function final() {
        var out = Buffer.alloc(16);
        this.pad();
        var adLen = this.adLen * 8;
        var ctLen = this.ctLen * 8;
        this.state[1] ^= hi32(adLen);
        this.state[0] ^= lo32(adLen);
        this.state[3] ^= hi32(ctLen);
        this.state[2] ^= lo32(ctLen);
        this.mul(this.state);
        writeU32$3(out, this.state[1], 0);
        writeU32$3(out, this.state[0], 4);
        writeU32$3(out, this.state[3], 8);
        writeU32$3(out, this.state[2], 12);

        for (var i = 0; i < 4; i++) {
          this.state[i] = 0;
        }

        for (var _i3 = 0; _i3 < 16; _i3++) {
          this.block[_i3] = 0;
        }

        this.size = FINALIZED;
        this.adLen = 0;
        this.ctLen = 0;

        for (var _i4 = 0; _i4 < 16; _i4++) {
          for (var j = 0; j < 4; j++) {
            this.table[_i4][j] = 0;
          }
        }

        return out;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 4; i++) {
          this.state[i] = 0;
        }

        for (var _i5 = 0; _i5 < 16; _i5++) {
          this.block[_i5] = 0;
        }

        this.size = FINALIZED;
        this.adLen = 0;
        this.ctLen = 0;

        for (var _i6 = 0; _i6 < 16; _i6++) {
          for (var j = 0; j < 4; j++) {
            this.table[_i6][j] = 0;
          }
        }
      }
    }, {
      key: "add",
      value: function add(x, y) {
        assert_1$1(x instanceof Uint32Array);
        assert_1$1(x.length === 4);
        assert_1$1(y instanceof Uint32Array);
        assert_1$1(y.length === 4);
        var z = new Uint32Array(4);
        z[0] = x[0] ^ y[0];
        z[1] = x[1] ^ y[1];
        z[2] = x[2] ^ y[2];
        z[3] = x[3] ^ y[3];
        return z;
      }
    }, {
      key: "double",
      value: function double(x) {
        assert_1$1(x instanceof Uint32Array);
        assert_1$1(x.length === 4);
        var d = new Uint32Array(4);
        var msb = (x[2] & 1) === 1;
        var v;
        d[3] = x[3];
        d[2] = x[2];
        v = d[3] & 1;
        d[3] >>>= 1;
        d[2] >>>= 1;
        d[2] |= v << 31;
        d[3] |= (x[0] & 1) << 31;
        d[1] = x[1];
        d[0] = x[0];
        v = d[1] & 1;
        d[1] >>>= 1;
        d[0] >>>= 1;
        d[0] |= v << 31;

        if (msb) {
          d[1] ^= 0xe1000000;
          d[0] ^= 0x00000000;
        }

        return d;
      }
    }, {
      key: "mul",
      value: function mul(y) {
        assert_1$1(y instanceof Uint32Array);
        assert_1$1(y.length === 4);
        var z = new Uint32Array(4);
        var w = new Uint32Array(2);
        var v, t;

        for (var i = 0; i < 2; i++) {
          w[0] = y[2];
          w[1] = y[3];

          if (i === 1) {
            w[0] = y[0];
            w[1] = y[1];
          }

          for (var j = 0; j < 64; j += 4) {
            var msw = z[2] & 0x0f;
            v = z[3] & 0x0f;
            z[3] >>>= 4;
            z[2] >>>= 4;
            z[2] |= v << 28;
            z[3] |= z[0] << 28;
            v = z[1] & 0x0f;
            z[1] >>>= 4;
            z[0] >>>= 4;
            z[0] |= v << 28;
            z[1] ^= REDUCTION[msw] << 16;
            t = this.table[w[0] & 0x0f];
            z[0] ^= t[0];
            z[1] ^= t[1];
            z[2] ^= t[2];
            z[3] ^= t[3];
            v = w[1] & 0x0f;
            w[1] >>>= 4;
            w[0] >>>= 4;
            w[0] |= v << 28;
          }
        }

        y[0] = z[0];
        y[1] = z[1];
        y[2] = z[2];
        y[3] = z[3];
      }
    }]);

    return GHASH;
  }();
  /*
   * Helpers
   */


  function hi32(num) {
    return num * (1 / 0x100000000) >>> 0;
  }

  function lo32(num) {
    return num >>> 0;
  }

  function reverse(i) {
    i = i << 2 & 0x0c | i >>> 2 & 0x03;
    i = i << 1 & 0x0a | i >>> 1 & 0x05;
    return i;
  }

  function readU32$2(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off++];
  }

  function writeU32$3(dst, num, off) {
    dst[off++] = num >>> 24;
    dst[off++] = num >>> 16;
    dst[off++] = num >>> 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var ghash = GHASH;

  function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /*
   * Constants
   */


  var EMPTY = Buffer.alloc(0); // Shifted by four.

  var polyTable = new Uint32Array([0x00001b, // 8
  0x000087, // 16
  0x000425, // 32
  0x000000, 0x000125, // 64
  0x000000, 0x000000, 0x000000, 0x080043 // 128
  ]);
  /*
   * Mode
   */

  var Mode = /*#__PURE__*/function () {
    function Mode(ctx) {
      _classCallCheck__default['default'](this, Mode);

      assert_1$1(ctx && typeof ctx.encrypt === 'function');
      assert_1$1(typeof ctx.blockSize === 'number');
      this.ctx = ctx;
    }

    _createClass__default['default'](Mode, [{
      key: "init",
      value: function init(key, iv) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "update",
      value: function update(data) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "crypt",
      value: function crypt(output, input) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "final",
      value: function final() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "destroy",
      value: function destroy() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "setAutoPadding",
      value: function setAutoPadding(padding) {
        assert_1$1(typeof padding === 'boolean');

        this._setAutoPadding(padding);

        return this;
      }
    }, {
      key: "setAAD",
      value: function setAAD(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._setAAD(data);

        return this;
      }
    }, {
      key: "setCCM",
      value: function setCCM(msgLen, tagLen, aad) {
        assert_1$1(msgLen >>> 0 === msgLen);
        assert_1$1(tagLen >>> 0 === tagLen);
        assert_1$1(aad == null || Buffer.isBuffer(aad));

        this._setCCM(msgLen, tagLen, aad);

        return this;
      }
    }, {
      key: "getAuthTag",
      value: function getAuthTag() {
        return this._getAuthTag();
      }
    }, {
      key: "setAuthTag",
      value: function setAuthTag(tag) {
        assert_1$1(Buffer.isBuffer(tag));

        this._setAuthTag(tag);

        return this;
      }
    }, {
      key: "_setAutoPadding",
      value: function _setAutoPadding(padding) {
        throw new Error('Not available.');
      }
    }, {
      key: "_setAAD",
      value: function _setAAD(data) {
        throw new Error('Cipher is not authenticated.');
      }
    }, {
      key: "_setCCM",
      value: function _setCCM(msgLen, tagLen, aad) {
        throw new Error('Not available.');
      }
    }, {
      key: "_getAuthTag",
      value: function _getAuthTag() {
        throw new Error('Cipher is not authenticated.');
      }
    }, {
      key: "_setAuthTag",
      value: function _setAuthTag(tag) {
        throw new Error('Cipher is not authenticated.');
      }
    }, {
      key: "blockSize",
      get: function get() {
        return this.ctx.blockSize;
      }
    }]);

    return Mode;
  }();
  /**
   * Block Mode
   */


  var Block = /*#__PURE__*/function (_Mode) {
    _inherits__default['default'](Block, _Mode);

    var _super = _createSuper$2(Block);

    function Block(ctx, unpad) {
      var _this;

      _classCallCheck__default['default'](this, Block);

      _this = _super.call(this, ctx);
      _this.padding = true;
      _this.unpad = unpad;
      _this.block = Buffer.alloc(_this.blockSize);
      _this.blockPos = -1;
      _this.last = null;
      _this.lastSize = 0;
      if (unpad) _this.last = Buffer.alloc(_this.blockSize);
      return _this;
    }

    _createClass__default['default'](Block, [{
      key: "init",
      value: function init(key, iv) {
        if (iv == null) iv = EMPTY;
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(Buffer.isBuffer(iv));
        this.ctx.init(key);
        this.blockPos = 0;
        this.lastSize = 0;

        this._init(key, iv);

        return this;
      }
    }, {
      key: "_updateSize",
      value: function _updateSize(ilen) {
        if (this.blockPos + ilen < this.blockSize) return 0;
        var olen = 0;
        if (this.unpad) olen += this.lastSize;

        if (this.blockPos > 0) {
          ilen -= this.blockSize - this.blockPos;
          olen += this.blockSize;
        }

        if (ilen >= this.blockSize) olen += ilen - ilen % this.blockSize;
        assert_1$1(olen >= this.blockSize);
        return olen;
      }
    }, {
      key: "update",
      value: function update(input) {
        assert_1$1(Buffer.isBuffer(input));
        if (this.blockPos === -1) throw new Error('Cipher is not initialized.');

        var olen = this._updateSize(input.length);

        var output = Buffer.alloc(olen);

        if (this.blockPos + input.length < this.blockSize) {
          this.blockPos += input.copy(this.block, this.blockPos, 0, input.length);
          return output;
        }

        var ilen = input.length;
        var ipos = 0;
        var opos = 0;
        if (this.unpad) opos += this.last.copy(output, opos, 0, this.lastSize);

        if (this.blockPos > 0) {
          var want = this.blockSize - this.blockPos;
          ipos += input.copy(this.block, this.blockPos, ipos, ipos + want);
          ilen -= want;

          this._update(output, opos, this.block, 0);

          opos += this.blockSize;
          this.blockPos = 0;
        }

        while (ilen >= this.blockSize) {
          this._update(output, opos, input, ipos);

          ipos += this.blockSize;
          ilen -= this.blockSize;
          opos += this.blockSize;
        }

        if (ilen > 0) this.blockPos = input.copy(this.block, 0, ipos, ipos + ilen);
        assert_1$1(opos === olen);

        if (this.unpad) {
          this.lastSize = output.copy(this.last, 0, olen - this.blockSize, olen);
          return output.slice(0, olen - this.blockSize);
        }

        return output;
      }
    }, {
      key: "crypt",
      value: function crypt(output, input) {
        assert_1$1(Buffer.isBuffer(output));
        assert_1$1(Buffer.isBuffer(input));
        assert_1$1(output.length === input.length);
        if (this.blockPos === -1) throw new Error('Cipher is not initialized.');
        if (this.unpad || this.blockPos !== 0) throw new Error('Cannot crypt while buffering.');
        if (input.length % this.blockSize !== 0) throw new Error('Input must be a multiple of the block size.');
        var size = this.blockSize;
        var len = input.length;
        var pos = 0;

        while (len > 0) {
          this._update(output, pos, input, pos);

          pos += size;
          len -= size;
        }

        return output;
      }
    }, {
      key: "final",
      value: function final() {
        if (this.blockPos === -1) throw new Error('Cipher is not initialized.');

        try {
          return this._final();
        } finally {
          this.destroy();
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.ctx.destroy();
        this.blockPos = -1;
        this.lastSize = 0;

        for (var i = 0; i < this.blockSize; i++) {
          this.block[i] = 0;
        }

        if (this.unpad) {
          for (var _i = 0; _i < this.blockSize; _i++) {
            this.last[_i] = 0;
          }
        }

        this._destroy();

        return this;
      }
    }, {
      key: "_init",
      value: function _init(key, iv) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_final",
      value: function _final() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        throw new Error('Not implemented.');
      }
    }]);

    return Block;
  }(Mode);
  /*
   * Stream Mode
   */


  var Stream = /*#__PURE__*/function (_Mode2) {
    _inherits__default['default'](Stream, _Mode2);

    var _super2 = _createSuper$2(Stream);

    function Stream(ctx) {
      var _this2;

      _classCallCheck__default['default'](this, Stream);

      _this2 = _super2.call(this, ctx);
      _this2.pos = -1;
      return _this2;
    }

    _createClass__default['default'](Stream, [{
      key: "init",
      value: function init(key, iv) {
        if (iv == null) iv = EMPTY;
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(Buffer.isBuffer(iv));
        this.ctx.init(key);
        this.pos = 0;

        this._init(key, iv);

        return this;
      }
    }, {
      key: "update",
      value: function update(input) {
        assert_1$1(Buffer.isBuffer(input));
        if (this.pos === -1) throw new Error('Cipher is not initialized.');
        var output = Buffer.alloc(input.length);

        this._crypt(output, input);

        return output;
      }
    }, {
      key: "crypt",
      value: function crypt(output, input) {
        assert_1$1(Buffer.isBuffer(output));
        assert_1$1(Buffer.isBuffer(input));
        assert_1$1(output.length === input.length);
        if (this.pos === -1) throw new Error('Cipher is not initialized.');

        this._crypt(output, input);

        return output;
      }
    }, {
      key: "final",
      value: function final() {
        if (this.pos === -1) throw new Error('Cipher is not initialized.');

        try {
          return this._final();
        } finally {
          this.destroy();
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.ctx.destroy();
        this.pos = -1;

        this._destroy();

        return this;
      }
    }, {
      key: "_init",
      value: function _init(key, iv) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_crypt",
      value: function _crypt(output, input) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_final",
      value: function _final() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        throw new Error('Not implemented.');
      }
    }]);

    return Stream;
  }(Mode);
  /**
   * Raw Cipher
   */


  var RawCipher = /*#__PURE__*/function (_Block) {
    _inherits__default['default'](RawCipher, _Block);

    var _super3 = _createSuper$2(RawCipher);

    function RawCipher(ctx) {
      _classCallCheck__default['default'](this, RawCipher);

      return _super3.call(this, ctx, false);
    }

    _createClass__default['default'](RawCipher, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === 0);
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        this.ctx.encrypt(output, opos, input, ipos);
      }
    }, {
      key: "_final",
      value: function _final() {
        if (this.blockPos !== 0) throw new Error('Bad encrypt (trailing bytes).');
        return Buffer.alloc(0);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        return;
      }
    }]);

    return RawCipher;
  }(Block);
  /**
   * Raw Decipher
   */


  var RawDecipher = /*#__PURE__*/function (_Block2) {
    _inherits__default['default'](RawDecipher, _Block2);

    var _super4 = _createSuper$2(RawDecipher);

    function RawDecipher(ctx) {
      _classCallCheck__default['default'](this, RawDecipher);

      return _super4.call(this, ctx, false);
    }

    _createClass__default['default'](RawDecipher, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === 0);
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        this.ctx.decrypt(output, opos, input, ipos);
      }
    }, {
      key: "_final",
      value: function _final() {
        if (this.blockPos !== 0) throw new Error('Bad decrypt (trailing bytes).');
        return Buffer.alloc(0);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        return;
      }
    }]);

    return RawDecipher;
  }(Block);
  /**
   * PKCS#7 Cipher
   */


  var PKCS7Cipher = /*#__PURE__*/function (_Block3) {
    _inherits__default['default'](PKCS7Cipher, _Block3);

    var _super5 = _createSuper$2(PKCS7Cipher);

    function PKCS7Cipher(ctx) {
      _classCallCheck__default['default'](this, PKCS7Cipher);

      return _super5.call(this, ctx, false);
    }

    _createClass__default['default'](PKCS7Cipher, [{
      key: "_final",
      value: function _final() {
        if (!this.padding) {
          if (this.blockPos !== 0) throw new Error('Bad encrypt (trailing bytes).');
          return Buffer.alloc(0);
        }

        var left = this.blockSize - this.blockPos;
        var block = Buffer.from(this.block);

        for (var i = this.blockPos; i < this.blockSize; i++) {
          block[i] = left;
        }

        this._update(block, 0, block, 0);

        return block;
      }
    }, {
      key: "_setAutoPadding",
      value: function _setAutoPadding(padding) {
        this.padding = padding;
      }
    }]);

    return PKCS7Cipher;
  }(Block);
  /**
   * PKCS#7 Decipher
   */


  var PKCS7Decipher = /*#__PURE__*/function (_Block4) {
    _inherits__default['default'](PKCS7Decipher, _Block4);

    var _super6 = _createSuper$2(PKCS7Decipher);

    function PKCS7Decipher(ctx) {
      _classCallCheck__default['default'](this, PKCS7Decipher);

      return _super6.call(this, ctx, true);
    }

    _createClass__default['default'](PKCS7Decipher, [{
      key: "_final",
      value: function _final() {
        if (this.blockPos !== 0) throw new Error('Bad decrypt (trailing bytes).');
        if (!this.padding) return Buffer.alloc(0);
        if (this.lastSize === 0) throw new Error('Bad decrypt (no data).');
        assert_1$1(this.lastSize === this.last.length);
        assert_1$1(this.lastSize === this.blockSize);
        var block = Buffer.from(this.last);
        var left = block[block.length - 1];
        var res = 1; // left != 0

        res &= left - 1 >>> 31 ^ 1; // left <= block_size

        res &= left - this.blockSize - 1 >>> 31; // left = 0 if left == 0 or left > block_size

        left &= -res; // Verify padding in constant time.

        var end = this.blockSize - left;

        for (var i = 0; i < this.blockSize; i++) {
          var ch = block[i]; // i < end or ch == left

          res &= i - end >>> 31 | (ch ^ left) - 1 >>> 31;
        }

        if (!res) throw new Error('Bad decrypt (padding).');
        return block.slice(0, end);
      }
    }, {
      key: "_setAutoPadding",
      value: function _setAutoPadding(padding) {
        if (this.lastSize !== 0 || this.blockPos !== 0) throw new Error('Cannot set auto padding.');
        this.padding = padding;
        this.unpad = padding;
      }
    }]);

    return PKCS7Decipher;
  }(Block);
  /**
   * ECB Cipher
   */


  var ECBCipher = /*#__PURE__*/function (_PKCS7Cipher) {
    _inherits__default['default'](ECBCipher, _PKCS7Cipher);

    var _super7 = _createSuper$2(ECBCipher);

    function ECBCipher(ctx) {
      _classCallCheck__default['default'](this, ECBCipher);

      return _super7.call(this, ctx);
    }

    _createClass__default['default'](ECBCipher, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === 0);
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        this.ctx.encrypt(output, opos, input, ipos);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        return;
      }
    }]);

    return ECBCipher;
  }(PKCS7Cipher);
  /**
   * ECB Decipher
   */


  var ECBDecipher = /*#__PURE__*/function (_PKCS7Decipher) {
    _inherits__default['default'](ECBDecipher, _PKCS7Decipher);

    var _super8 = _createSuper$2(ECBDecipher);

    function ECBDecipher(ctx) {
      _classCallCheck__default['default'](this, ECBDecipher);

      return _super8.call(this, ctx);
    }

    _createClass__default['default'](ECBDecipher, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === 0);
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        this.ctx.decrypt(output, opos, input, ipos);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        return;
      }
    }]);

    return ECBDecipher;
  }(PKCS7Decipher);
  /**
   * CBC Cipher
   */


  var CBCCipher = /*#__PURE__*/function (_PKCS7Cipher2) {
    _inherits__default['default'](CBCCipher, _PKCS7Cipher2);

    var _super9 = _createSuper$2(CBCCipher);

    function CBCCipher(ctx) {
      var _this3;

      _classCallCheck__default['default'](this, CBCCipher);

      _this3 = _super9.call(this, ctx);
      _this3.prev = Buffer.alloc(_this3.blockSize);
      return _this3;
    }

    _createClass__default['default'](CBCCipher, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === this.blockSize);
        iv.copy(this.prev, 0);
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        for (var i = 0; i < this.blockSize; i++) {
          this.prev[i] ^= input[ipos + i];
        }

        this.ctx.encrypt(output, opos, this.prev, 0);
        output.copy(this.prev, 0, opos, opos + this.blockSize);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < this.blockSize; i++) {
          this.prev[i] = 0;
        }
      }
    }]);

    return CBCCipher;
  }(PKCS7Cipher);
  /**
   * CBC Decipher
   */


  var CBCDecipher = /*#__PURE__*/function (_PKCS7Decipher2) {
    _inherits__default['default'](CBCDecipher, _PKCS7Decipher2);

    var _super10 = _createSuper$2(CBCDecipher);

    function CBCDecipher(ctx) {
      var _this4;

      _classCallCheck__default['default'](this, CBCDecipher);

      _this4 = _super10.call(this, ctx);
      _this4.prev = Buffer.alloc(_this4.blockSize);
      _this4.tmp = Buffer.alloc(_this4.blockSize);
      return _this4;
    }

    _createClass__default['default'](CBCDecipher, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === this.blockSize);
        iv.copy(this.prev, 0);
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        if (overlap(output, opos, input, ipos)) {
          this.prev.copy(this.tmp, 0);
          input.copy(this.prev, 0, ipos, ipos + this.blockSize);
          this.ctx.decrypt(output, opos, input, ipos);

          for (var i = 0; i < this.blockSize; i++) {
            output[opos + i] ^= this.tmp[i];
          }
        } else {
          this.ctx.decrypt(output, opos, input, ipos);

          for (var _i2 = 0; _i2 < this.blockSize; _i2++) {
            output[opos + _i2] ^= this.prev[_i2];
          }

          input.copy(this.prev, 0, ipos, ipos + this.blockSize);
        }
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < this.blockSize; i++) {
          this.prev[i] = 0;
          this.tmp[i] = 0;
        }
      }
    }]);

    return CBCDecipher;
  }(PKCS7Decipher);
  /**
   * CTS Cipher
   */


  var CTSCipher = /*#__PURE__*/function (_Block5) {
    _inherits__default['default'](CTSCipher, _Block5);

    var _super11 = _createSuper$2(CTSCipher);

    function CTSCipher(ctx) {
      var _this5;

      _classCallCheck__default['default'](this, CTSCipher);

      _this5 = _super11.call(this, ctx, true);
      _this5.prev = Buffer.alloc(_this5.blockSize);
      return _this5;
    }

    _createClass__default['default'](CTSCipher, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === this.blockSize);
        iv.copy(this.prev, 0);
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        for (var i = 0; i < this.blockSize; i++) {
          this.prev[i] ^= input[ipos + i];
        }

        this.ctx.encrypt(output, opos, this.prev, 0);
        output.copy(this.prev, 0, opos, opos + this.blockSize);
      }
    }, {
      key: "_final",
      value: function _final() {
        if (!this.padding) {
          if (this.blockPos !== 0) throw new Error('Bad encrypt (trailing bytes).');
          return Buffer.alloc(0);
        }

        if (this.lastSize === 0) throw new Error('Bad encrypt (no data).');

        for (var i = 0; i < this.blockPos; i++) {
          this.prev[i] ^= this.block[i];
        }

        this.ctx.encrypt(this.prev, 0, this.prev, 0);
        var last = this.last.slice(0, this.blockPos);
        return Buffer.concat([this.prev, last]);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < this.blockSize; i++) {
          this.prev[i] = 0;
        }
      }
    }, {
      key: "_setAutoPadding",
      value: function _setAutoPadding(padding) {
        if (this.lastSize !== 0 || this.blockPos !== 0) throw new Error('Cannot set auto padding.');
        this.padding = padding;
        this.unpad = padding;
      }
    }]);

    return CTSCipher;
  }(Block);
  /**
   * CTS Decipher
   */


  var CTSDecipher = /*#__PURE__*/function (_Block6) {
    _inherits__default['default'](CTSDecipher, _Block6);

    var _super12 = _createSuper$2(CTSDecipher);

    function CTSDecipher(ctx) {
      var _this6;

      _classCallCheck__default['default'](this, CTSDecipher);

      _this6 = _super12.call(this, ctx, true);
      _this6.prev = Buffer.alloc(_this6.blockSize);
      _this6.tmp = Buffer.alloc(_this6.blockSize);
      return _this6;
    }

    _createClass__default['default'](CTSDecipher, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === this.blockSize);
        iv.copy(this.prev, 0);
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        if (overlap(output, opos, input, ipos)) {
          this.prev.copy(this.tmp, 0);
          input.copy(this.prev, 0, ipos, ipos + this.blockSize);
          this.ctx.decrypt(output, opos, input, ipos);

          for (var i = 0; i < this.blockSize; i++) {
            output[opos + i] ^= this.tmp[i];
          }
        } else {
          this.ctx.decrypt(output, opos, input, ipos);

          for (var _i3 = 0; _i3 < this.blockSize; _i3++) {
            output[opos + _i3] ^= this.prev[_i3];
          }

          input.copy(this.prev, 0, ipos, ipos + this.blockSize);
        }
      }
    }, {
      key: "_final",
      value: function _final() {
        if (!this.padding) {
          if (this.blockPos !== 0) throw new Error('Bad decrypt (trailing bytes).');
          return Buffer.alloc(0);
        }

        if (this.lastSize === 0) throw new Error('Bad decrypt (no data).');
        var tmp = Buffer.alloc(this.blockSize);
        this.ctx.decrypt(this.prev, 0, this.prev, 0); // Recreate the previous (x2) ciphertext (`this.tmp`),
        // which is normally only available on overlap.

        for (var i = 0; i < this.blockSize; i++) {
          tmp[i] = this.last[i] ^ this.prev[i];
        }

        for (var _i4 = 0; _i4 < this.blockPos; _i4++) {
          this.last[_i4] = this.block[_i4];
          this.block[_i4] ^= this.prev[_i4];
        }

        for (var _i5 = this.blockPos; _i5 < this.blockSize; _i5++) {
          this.last[_i5] = this.prev[_i5];
        }

        this.ctx.decrypt(this.last, 0, this.last, 0);

        for (var _i6 = 0; _i6 < this.blockSize; _i6++) {
          this.last[_i6] ^= tmp[_i6];
        }

        var block = this.block.slice(0, this.blockPos);
        return Buffer.concat([this.last, block]);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < this.blockSize; i++) {
          this.prev[i] = 0;
          this.tmp[i] = 0;
        }
      }
    }, {
      key: "_setAutoPadding",
      value: function _setAutoPadding(padding) {
        if (this.lastSize !== 0 || this.blockPos !== 0) throw new Error('Cannot set auto padding.');
        this.padding = padding;
        this.unpad = padding;
      }
    }]);

    return CTSDecipher;
  }(Block);
  /**
   * XTS
   */


  var XTS = /*#__PURE__*/function (_Block7) {
    _inherits__default['default'](XTS, _Block7);

    var _super13 = _createSuper$2(XTS);

    function XTS(ctx, encrypt) {
      var _this7;

      _classCallCheck__default['default'](this, XTS);

      _this7 = _super13.call(this, ctx, true);
      _this7.encrypt = encrypt;
      _this7.poly = polyTable[_this7.blockSize >>> 4];
      _this7.tweak = Buffer.alloc(_this7.blockSize);
      _this7.prev = Buffer.alloc(_this7.blockSize);
      return _this7;
    }

    _createClass__default['default'](XTS, [{
      key: "init",
      value: function init(key, iv) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(Buffer.isBuffer(iv));
        assert_1$1(key.length > 0 && (key.length & 1) === 0);
        assert_1$1(iv.length === this.blockSize);
        var size = key.length >>> 1;
        var k1 = key.slice(0, size);
        var k2 = key.slice(size);
        if (safeEqual(k1, k2, size)) throw new Error('XTS keys are equal.');
        this.ctx.init(k2);
        this.ctx.encrypt(this.tweak, 0, iv, 0);
        this.ctx.init(k1);
        this.blockPos = 0;
        this.lastSize = 0;
        return this;
      }
    }, {
      key: "_shift",
      value: function _shift() {
        var cy = 0;
        if (!this.encrypt) this.tweak.copy(this.prev, 0);

        for (var i = 0; i < this.blockSize; i++) {
          var c = this.tweak[i] >> 7;
          this.tweak[i] <<= 1;
          this.tweak[i] |= cy;
          cy = c;
        }

        cy = -cy & 0xff;
        this.tweak[2] ^= this.poly >> 16 & cy;
        this.tweak[1] ^= this.poly >> 8 & cy;
        this.tweak[0] ^= this.poly >> 0 & cy;
      }
    }, {
      key: "_update",
      value: function _update(output, opos, input, ipos) {
        for (var i = 0; i < this.blockSize; i++) {
          output[opos + i] = input[ipos + i] ^ this.tweak[i];
        }

        if (this.encrypt) this.ctx.encrypt(output, opos, output, opos);else this.ctx.decrypt(output, opos, output, opos);

        for (var _i7 = 0; _i7 < this.blockSize; _i7++) {
          output[opos + _i7] ^= this.tweak[_i7];
        }

        this._shift();
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < this.blockSize; i++) {
          this.tweak[i] = 0;
          this.prev[i] = 0;
        }
      }
    }, {
      key: "_setAutoPadding",
      value: function _setAutoPadding(padding) {
        if (this.lastSize !== 0 || this.blockPos !== 0) throw new Error('Cannot set auto padding.');
        this.padding = padding;
        this.unpad = padding;
      }
    }]);

    return XTS;
  }(Block);
  /*
   * XTS Cipher
   */


  var XTSCipher = /*#__PURE__*/function (_XTS) {
    _inherits__default['default'](XTSCipher, _XTS);

    var _super14 = _createSuper$2(XTSCipher);

    function XTSCipher(ctx) {
      _classCallCheck__default['default'](this, XTSCipher);

      return _super14.call(this, ctx, true);
    }

    _createClass__default['default'](XTSCipher, [{
      key: "_final",
      value: function _final() {
        if (!this.padding) {
          if (this.blockPos !== 0) throw new Error('Bad encrypt (trailing bytes).');
          return Buffer.alloc(0);
        }

        if (this.lastSize === 0) throw new Error('Bad encrypt (no data).');
        if (this.blockPos === 0) return Buffer.from(this.last); // Use ciphertext stealing for partial blocks.

        var out = Buffer.alloc(this.blockPos);

        for (var i = 0; i < this.blockPos; i++) {
          out[i] = this.last[i];
          this.last[i] = this.block[i];
        }

        for (var _i8 = 0; _i8 < this.blockSize; _i8++) {
          this.last[_i8] ^= this.tweak[_i8];
        }

        this.ctx.encrypt(this.last, 0, this.last, 0);

        for (var _i9 = 0; _i9 < this.blockSize; _i9++) {
          this.last[_i9] ^= this.tweak[_i9];
        }

        return Buffer.concat([this.last, out]);
      }
    }]);

    return XTSCipher;
  }(XTS);
  /*
   * XTS Decipher
   */


  var XTSDecipher = /*#__PURE__*/function (_XTS2) {
    _inherits__default['default'](XTSDecipher, _XTS2);

    var _super15 = _createSuper$2(XTSDecipher);

    function XTSDecipher(ctx) {
      _classCallCheck__default['default'](this, XTSDecipher);

      return _super15.call(this, ctx, false);
    }

    _createClass__default['default'](XTSDecipher, [{
      key: "_final",
      value: function _final() {
        if (!this.padding) {
          if (this.blockPos !== 0) throw new Error('Bad decrypt (trailing bytes).');
          return Buffer.alloc(0);
        }

        if (this.lastSize === 0) throw new Error('Bad decrypt (no data).');
        if (this.blockPos === 0) return Buffer.from(this.last); // Undo Block mode object's behavior of
        // running _update on the last full block.
        // Could avoid this somehow in the future.

        for (var i = 0; i < this.blockSize; i++) {
          this.last[i] ^= this.prev[i];
        }

        this.ctx.encrypt(this.last, 0, this.last, 0);

        for (var _i10 = 0; _i10 < this.blockSize; _i10++) {
          this.last[_i10] ^= this.prev[_i10];
        } // Recreate the last partial plaintext
        // block (out) and the last ciphertext
        // block (last).


        for (var _i11 = 0; _i11 < this.blockSize; _i11++) {
          this.last[_i11] ^= this.tweak[_i11];
        }

        this.ctx.decrypt(this.last, 0, this.last, 0);

        for (var _i12 = 0; _i12 < this.blockSize; _i12++) {
          this.last[_i12] ^= this.tweak[_i12];
        }

        var out = Buffer.alloc(this.blockPos);

        for (var _i13 = 0; _i13 < this.blockPos; _i13++) {
          out[_i13] = this.last[_i13];
          this.last[_i13] = this.block[_i13];
        } // Now decrypt the last ciphertext block.


        for (var _i14 = 0; _i14 < this.blockSize; _i14++) {
          this.last[_i14] ^= this.prev[_i14];
        }

        this.ctx.decrypt(this.last, 0, this.last, 0);

        for (var _i15 = 0; _i15 < this.blockSize; _i15++) {
          this.last[_i15] ^= this.prev[_i15];
        }

        return Buffer.concat([this.last, out]);
      }
    }]);

    return XTSDecipher;
  }(XTS);
  /**
   * CTR
   */


  var CTR = /*#__PURE__*/function (_Stream) {
    _inherits__default['default'](CTR, _Stream);

    var _super16 = _createSuper$2(CTR);

    function CTR(ctx) {
      var _this8;

      _classCallCheck__default['default'](this, CTR);

      _this8 = _super16.call(this, ctx);
      _this8.state = Buffer.alloc(_this8.blockSize);
      _this8.ctr = Buffer.alloc(_this8.blockSize);
      return _this8;
    }

    _createClass__default['default'](CTR, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === this.blockSize);
        iv.copy(this.ctr, 0);
      }
    }, {
      key: "_increment",
      value: function _increment() {
        for (var i = this.ctr.length - 1; i >= 0; i--) {
          this.ctr[i] += 1;
          if (this.ctr[i] !== 0x00) break;
        }
      }
    }, {
      key: "_crypt",
      value: function _crypt(output, input) {
        var mask = this.blockSize - 1;

        for (var i = 0; i < input.length; i++) {
          if ((this.pos & mask) === 0) {
            this.ctx.encrypt(this.state, 0, this.ctr, 0);

            this._increment();

            this.pos = 0;
          }

          output[i] = input[i] ^ this.state[this.pos++];
        }
      }
    }, {
      key: "_final",
      value: function _final() {
        return Buffer.alloc(0);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < this.blockSize; i++) {
          this.state[i] = 0;
          this.ctr[i] = 0;
        }
      }
    }]);

    return CTR;
  }(Stream);
  /**
   * CTR Cipher
   */


  var CTRCipher = /*#__PURE__*/function (_CTR) {
    _inherits__default['default'](CTRCipher, _CTR);

    var _super17 = _createSuper$2(CTRCipher);

    function CTRCipher(ctx) {
      _classCallCheck__default['default'](this, CTRCipher);

      return _super17.call(this, ctx);
    }

    return CTRCipher;
  }(CTR);
  /**
   * CTR Decipher
   */


  var CTRDecipher = /*#__PURE__*/function (_CTR2) {
    _inherits__default['default'](CTRDecipher, _CTR2);

    var _super18 = _createSuper$2(CTRDecipher);

    function CTRDecipher(ctx) {
      _classCallCheck__default['default'](this, CTRDecipher);

      return _super18.call(this, ctx);
    }

    return CTRDecipher;
  }(CTR);
  /**
   * CFB
   */


  var CFB = /*#__PURE__*/function (_Stream2) {
    _inherits__default['default'](CFB, _Stream2);

    var _super19 = _createSuper$2(CFB);

    function CFB(ctx) {
      var _this9;

      _classCallCheck__default['default'](this, CFB);

      _this9 = _super19.call(this, ctx);
      _this9.state = Buffer.alloc(_this9.blockSize);
      _this9.prev = Buffer.alloc(_this9.blockSize);
      return _this9;
    }

    _createClass__default['default'](CFB, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length === this.blockSize);
        iv.copy(this.prev, 0);
      }
    }, {
      key: "_final",
      value: function _final() {
        return Buffer.alloc(0);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < this.blockSize; i++) {
          this.state[i] = 0;
          this.prev[i] = 0;
        }
      }
    }]);

    return CFB;
  }(Stream);
  /**
   * CFB Cipher
   */


  var CFBCipher = /*#__PURE__*/function (_CFB) {
    _inherits__default['default'](CFBCipher, _CFB);

    var _super20 = _createSuper$2(CFBCipher);

    function CFBCipher(ctx) {
      _classCallCheck__default['default'](this, CFBCipher);

      return _super20.call(this, ctx);
    }

    _createClass__default['default'](CFBCipher, [{
      key: "_crypt",
      value: function _crypt(output, input) {
        var mask = this.blockSize - 1;

        for (var i = 0; i < input.length; i++) {
          if ((this.pos & mask) === 0) {
            this.ctx.encrypt(this.state, 0, this.prev, 0);
            this.pos = 0;
          }

          output[i] = input[i] ^ this.state[this.pos];
          this.prev[this.pos] = output[i];
          this.pos += 1;
        }
      }
    }]);

    return CFBCipher;
  }(CFB);
  /**
   * CFB Decipher
   */


  var CFBDecipher = /*#__PURE__*/function (_CFB2) {
    _inherits__default['default'](CFBDecipher, _CFB2);

    var _super21 = _createSuper$2(CFBDecipher);

    function CFBDecipher(ctx) {
      _classCallCheck__default['default'](this, CFBDecipher);

      return _super21.call(this, ctx);
    }

    _createClass__default['default'](CFBDecipher, [{
      key: "_crypt",
      value: function _crypt(output, input) {
        var mask = this.blockSize - 1;

        for (var i = 0; i < input.length; i++) {
          if ((this.pos & mask) === 0) {
            this.ctx.encrypt(this.state, 0, this.prev, 0);
            this.pos = 0;
          }

          this.prev[this.pos] = input[i];
          output[i] = input[i] ^ this.state[this.pos];
          this.pos += 1;
        }
      }
    }]);

    return CFBDecipher;
  }(CFB);
  /**
   * OFB
   */


  var OFB = /*#__PURE__*/function (_Stream3) {
    _inherits__default['default'](OFB, _Stream3);

    var _super22 = _createSuper$2(OFB);

    function OFB(ctx) {
      var _this10;

      _classCallCheck__default['default'](this, OFB);

      _this10 = _super22.call(this, ctx);
      _this10.state = Buffer.alloc(_this10.blockSize);
      return _this10;
    }

    _createClass__default['default'](OFB, [{
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(Buffer.isBuffer(iv));
        assert_1$1(iv.length === this.blockSize);
        iv.copy(this.state, 0);
      }
    }, {
      key: "_crypt",
      value: function _crypt(output, input) {
        var mask = this.blockSize - 1;

        for (var i = 0; i < input.length; i++) {
          if ((this.pos & mask) === 0) {
            this.ctx.encrypt(this.state, 0, this.state, 0);
            this.pos = 0;
          }

          output[i] = input[i] ^ this.state[this.pos++];
        }
      }
    }, {
      key: "_final",
      value: function _final() {
        return Buffer.alloc(0);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < this.blockSize; i++) {
          this.state[i] = 0;
        }
      }
    }]);

    return OFB;
  }(Stream);
  /**
   * OFB Cipher
   */


  var OFBCipher = /*#__PURE__*/function (_OFB) {
    _inherits__default['default'](OFBCipher, _OFB);

    var _super23 = _createSuper$2(OFBCipher);

    function OFBCipher(ctx) {
      _classCallCheck__default['default'](this, OFBCipher);

      return _super23.call(this, ctx);
    }

    return OFBCipher;
  }(OFB);
  /**
   * OFB Decipher
   */


  var OFBDecipher = /*#__PURE__*/function (_OFB2) {
    _inherits__default['default'](OFBDecipher, _OFB2);

    var _super24 = _createSuper$2(OFBDecipher);

    function OFBDecipher(ctx) {
      _classCallCheck__default['default'](this, OFBDecipher);

      return _super24.call(this, ctx);
    }

    return OFBDecipher;
  }(OFB);
  /**
   * GCM
   */


  var GCM = /*#__PURE__*/function (_Stream4) {
    _inherits__default['default'](GCM, _Stream4);

    var _super25 = _createSuper$2(GCM);

    function GCM(ctx, encrypt) {
      var _this11;

      _classCallCheck__default['default'](this, GCM);

      assert_1$1(ctx.blockSize === 16);
      _this11 = _super25.call(this, ctx);
      _this11.encrypt = encrypt;
      _this11.hash = new ghash();
      _this11.ctr = Buffer.alloc(16);
      _this11.state = Buffer.alloc(16);
      _this11.key = Buffer.alloc(16);
      _this11.mask = Buffer.alloc(16);
      _this11.tag = null;
      _this11.mac = null;
      return _this11;
    }

    _createClass__default['default'](GCM, [{
      key: "_init",
      value: function _init(key, iv) {
        for (var i = 0; i < 16; i++) {
          this.ctr[i] = 0;
          this.key[i] = 0;
          this.mask[i] = 0;
        }

        this._encipher(this.key, this.key);

        this.hash.init(this.key); // Full round of ghash with same key.

        if (iv.length !== 12) {
          this.hash.update(iv);
          iv = this.hash.final();
          this.hash.init(this.key);
        }

        iv.copy(this.ctr, 0);

        if (iv.length === 12) {
          this.ctr[12] = 0x00;
          this.ctr[13] = 0x00;
          this.ctr[14] = 0x00;
          this.ctr[15] = 0x01;
        }

        this._encipher(this.mask, this.mask);

        this.tag = null;
        this.mac = null;
        return this;
      }
    }, {
      key: "_increment",
      value: function _increment() {
        var cy = 1;
        var i = 4;

        while (i--) {
          cy += this.ctr[12 + i];
          this.ctr[12 + i] = cy;
          cy >>= 8;
        }
      }
    }, {
      key: "_encipher",
      value: function _encipher(output, input) {
        for (var i = 0; i < input.length; i++) {
          if ((this.pos & 15) === 0) {
            this.ctx.encrypt(this.state, 0, this.ctr, 0);

            this._increment();

            this.pos = 0;
          }

          output[i] = input[i] ^ this.state[this.pos++];
        }
      }
    }, {
      key: "_crypt",
      value: function _crypt(output, input) {
        if (this.encrypt) {
          this._encipher(output, input);

          this.hash.update(output);
        } else {
          this.hash.update(input);

          this._encipher(output, input);
        }
      }
    }, {
      key: "_final",
      value: function _final() {
        var mac = this.hash.final();

        for (var i = 0; i < 16; i++) {
          mac[i] ^= this.mask[i];
        }

        if (this.encrypt) {
          this.mac = mac;
          return Buffer.alloc(0);
        }

        if (!this.tag) throw new Error('No tag provided.');
        if (!safeEqual(mac, this.tag, this.tag.length)) throw new Error('Invalid tag.');
        return Buffer.alloc(0);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this.hash.destroy();

        for (var i = 0; i < 16; i++) {
          this.ctr[i] = 0;
          this.state[i] = 0;
          this.key[i] = 0;
          this.mask[i] = 0;
        }

        if (this.tag) {
          for (var _i16 = 0; _i16 < this.tag.length; _i16++) {
            this.tag[_i16] = 0;
          }

          this.tag = null;
        }
      }
    }, {
      key: "_setAAD",
      value: function _setAAD(data) {
        if (this.pos === -1) throw new Error('Cipher is not initialized.');
        this.hash.aad(data);
        return this;
      }
    }, {
      key: "_getAuthTag",
      value: function _getAuthTag() {
        if (!this.encrypt) throw new Error('Must be a cipher context.');
        if (!this.mac) throw new Error('Cipher is not finalized.');
        return Buffer.from(this.mac);
      }
    }, {
      key: "_setAuthTag",
      value: function _setAuthTag(tag) {
        if (this.encrypt) throw new Error('Must be a decipher context.');
        if (this.pos === -1) throw new Error('Cipher is not initialized.');

        if (tag.length !== 4 && tag.length !== 8 && (tag.length < 12 || tag.length > 16)) {
          throw new RangeError('Invalid tag size.');
        }

        this.tag = Buffer.from(tag);
        return this;
      }
    }]);

    return GCM;
  }(Stream);
  /**
   * GCM Cipher
   */


  var GCMCipher = /*#__PURE__*/function (_GCM) {
    _inherits__default['default'](GCMCipher, _GCM);

    var _super26 = _createSuper$2(GCMCipher);

    function GCMCipher(ctx) {
      _classCallCheck__default['default'](this, GCMCipher);

      return _super26.call(this, ctx, true);
    }

    return GCMCipher;
  }(GCM);
  /**
   * GCM Decipher
   */


  var GCMDecipher = /*#__PURE__*/function (_GCM2) {
    _inherits__default['default'](GCMDecipher, _GCM2);

    var _super27 = _createSuper$2(GCMDecipher);

    function GCMDecipher(ctx) {
      _classCallCheck__default['default'](this, GCMDecipher);

      return _super27.call(this, ctx, false);
    }

    return GCMDecipher;
  }(GCM);
  /**
   * CBC-MAC
   */


  var CBCMAC = /*#__PURE__*/function () {
    function CBCMAC(ctx) {
      _classCallCheck__default['default'](this, CBCMAC);

      this.ctx = ctx;
      this.size = ctx.blockSize;
      this.mac = Buffer.alloc(this.size);
      this.pos = -1;
    }

    _createClass__default['default'](CBCMAC, [{
      key: "init",
      value: function init() {
        this.mac.fill(0);
        this.pos = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));
        if (this.pos === -1) throw new Error('Context is not initialized.');

        for (var i = 0; i < data.length; i++) {
          this.mac[this.pos++] ^= data[i];

          if (this.pos === this.size) {
            this.ctx.encrypt(this.mac, 0, this.mac, 0);
            this.pos = 0;
          }
        }
      }
    }, {
      key: "pad",
      value: function pad() {
        if (this.pos > 0) {
          this.ctx.encrypt(this.mac, 0, this.mac, 0);
          this.pos = 0;
        }
      }
    }, {
      key: "final",
      value: function final() {
        if (this.pos === -1) throw new Error('Context is not initialized.');
        this.pad();
        this.pos = -1;
        return Buffer.from(this.mac);
      }
    }]);

    return CBCMAC;
  }();
  /**
   * CCM
   * https://tools.ietf.org/html/rfc3610
   */


  var CCM = /*#__PURE__*/function (_Stream5) {
    _inherits__default['default'](CCM, _Stream5);

    var _super28 = _createSuper$2(CCM);

    function CCM(ctx, encrypt) {
      var _this12;

      _classCallCheck__default['default'](this, CCM);

      assert_1$1(ctx.blockSize === 16);
      _this12 = _super28.call(this, ctx);
      _this12.encrypt = encrypt;
      _this12.hash = new CBCMAC(ctx);
      _this12.state = Buffer.alloc(16);
      _this12.ctr = Buffer.alloc(16);
      _this12.tagLen = 0;
      _this12.iv = null;
      _this12.mac = null;
      _this12.tag = null;
      return _this12;
    }

    _createClass__default['default'](CCM, [{
      key: "_increment",
      value: function _increment() {
        for (var i = 15; i >= 1; i--) {
          this.ctr[i] += 1;
          if (this.ctr[i] !== 0x00) break;
        }
      }
    }, {
      key: "_encipher",
      value: function _encipher(output, input) {
        for (var i = 0; i < input.length; i++) {
          if ((this.pos & 15) === 0) {
            this.ctx.encrypt(this.state, 0, this.ctr, 0);

            this._increment();

            this.pos = 0;
          }

          output[i] = input[i] ^ this.state[this.pos++];
        }
      }
    }, {
      key: "_init",
      value: function _init(key, iv) {
        // sjcl compat: no upper limit on l(N).
        if (iv.length < 7) throw new RangeError('Invalid nonce length.');
        if (iv.length > 13) iv = iv.slice(0, 13);
        this.iv = Buffer.from(iv);
        this.pos = -1;
        this.tagLen = 0;
        this.mac = null;
        this.tag = null;
      }
    }, {
      key: "_setCCM",
      value: function _setCCM(msgLen, tagLen, aad) {
        if (!this.iv) throw new Error('Cipher is not initialized.'); // Compute L, M, and N.

        var lm = msgLen;
        var L = Math.ceil((32 - Math.clz32(lm)) / 8);
        if (L < 2) L = 2;
        var M = tagLen;
        var N = 15 - L;
        var Adata = (aad && aad.length > 0) | 0;
        var block = Buffer.alloc(16);
        if (M < 4 || M > 16 || (M & 1) !== 0) throw new RangeError('Invalid tag length.'); // Compute flags.

        block[0] = 64 * Adata + 8 * ((M - 2) / 2) + (L - 1); // sjcl compat: clamp nonces to 15-L.

        this.iv.copy(block, 1, 0, Math.min(N, this.iv.length)); // Serialize message length.

        for (var i = 15; i >= 1 + N; i--) {
          block[i] = lm & 0xff;
          lm >>>= 8;
        }

        assert_1$1(lm === 0);
        this.hash.init();
        this.hash.update(block);

        if (Adata) {
          if (aad.length < 0xff00) {
            var buf = Buffer.alloc(2);
            buf[0] = aad.length >>> 8;
            buf[1] = aad.length >>> 0;
            this.hash.update(buf);
          } else if (aad.length < 0xffffffff) {
            var _buf = Buffer.alloc(6);

            _buf[0] = 0xff;
            _buf[1] = 0xfe;
            _buf[2] = aad.length >>> 24;
            _buf[3] = aad.length >>> 16;
            _buf[4] = aad.length >>> 8;
            _buf[5] = aad.length >>> 0;
            this.hash.update(_buf);
          } else {
            throw new RangeError('Invalid AAD length.');
          }

          this.hash.update(aad);
          this.hash.pad();
        }

        block[0] &= 7;
        block[15] = 1;

        for (var _i17 = 14; _i17 >= 1 + N; _i17--) {
          block[_i17] = 0;
        }

        block.copy(this.ctr, 0);
        this.pos = 0;
        this.tagLen = M;
        this.iv = null;
      }
    }, {
      key: "_crypt",
      value: function _crypt(output, input) {
        if (this.encrypt) {
          this.hash.update(input);

          this._encipher(output, input);
        } else {
          this._encipher(output, input);

          this.hash.update(output);
        }
      }
    }, {
      key: "_final",
      value: function _final() {
        var mac = this.hash.final(); // Recreate S_0.

        var i = 16 - ((this.ctr[0] & 7) + 1);

        while (i < 16) {
          this.ctr[i++] = 0;
        }

        this.pos = 0;

        this._encipher(mac, mac);

        if (this.encrypt) {
          this.mac = mac.slice(0, this.tagLen);
          return Buffer.alloc(0);
        }

        if (!this.tag) throw new Error('No tag provided.');
        if (!safeEqual(mac, this.tag, this.tagLen)) throw new Error('Invalid tag.');
        return Buffer.alloc(0);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < 16; i++) {
          this.state[i] = 0;
          this.ctr[i] = 0;
        }

        this.tagLen = 0;
        this.iv = null;
        this.tag = null;
      }
    }, {
      key: "_getAuthTag",
      value: function _getAuthTag() {
        if (!this.encrypt) throw new Error('Must be a cipher context.');
        if (!this.mac) throw new Error('Cipher is not finalized.');
        return Buffer.from(this.mac);
      }
    }, {
      key: "_setAuthTag",
      value: function _setAuthTag(tag) {
        if (this.encrypt) throw new Error('Must be a decipher context.');
        if (this.pos === -1) throw new Error('Cipher is not initialized.');
        if (this.tagLen === 0 || tag.length !== this.tagLen) throw new RangeError('Invalid tag size.');
        this.tag = Buffer.from(tag);
        return this;
      }
    }]);

    return CCM;
  }(Stream);
  /**
   * CCM Cipher
   */


  var CCMCipher = /*#__PURE__*/function (_CCM) {
    _inherits__default['default'](CCMCipher, _CCM);

    var _super29 = _createSuper$2(CCMCipher);

    function CCMCipher(ctx) {
      _classCallCheck__default['default'](this, CCMCipher);

      return _super29.call(this, ctx, true);
    }

    return CCMCipher;
  }(CCM);
  /**
   * CCM Decipher
   */


  var CCMDecipher = /*#__PURE__*/function (_CCM2) {
    _inherits__default['default'](CCMDecipher, _CCM2);

    var _super30 = _createSuper$2(CCMDecipher);

    function CCMDecipher(ctx) {
      _classCallCheck__default['default'](this, CCMDecipher);

      return _super30.call(this, ctx, false);
    }

    return CCMDecipher;
  }(CCM);
  /**
   * CMAC
   * https://tools.ietf.org/html/rfc4493
   */


  var CMAC = /*#__PURE__*/function () {
    function CMAC(ctx) {
      _classCallCheck__default['default'](this, CMAC);

      this.ctx = ctx;
      this.poly = polyTable[ctx.blockSize >>> 4];
      this.size = ctx.blockSize;
      this.mac = Buffer.alloc(this.size);
      this.pos = -1;
    }

    _createClass__default['default'](CMAC, [{
      key: "init",
      value: function init(flag) {
        this.mac.fill(0);
        this.pos = 0;

        if (flag != null) {
          this.mac[this.size - 1] ^= flag;
          this.pos = this.size;
        }

        return this;
      }
    }, {
      key: "shift",
      value: function shift(dst, src) {
        var cy = 0;

        for (var i = this.size - 1; i >= 0; i--) {
          var c = src[i] >> 7;
          dst[i] = src[i] << 1 | cy;
          cy = c;
        }

        cy = -cy & 0xff;
        dst[this.size - 3] ^= this.poly >> 16 & cy;
        dst[this.size - 2] ^= this.poly >> 8 & cy;
        dst[this.size - 1] ^= this.poly >> 0 & cy;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));
        if (this.pos === -1) throw new Error('Context is not initialized.');

        for (var i = 0; i < data.length; i++) {
          if (this.pos === this.size) {
            this.ctx.encrypt(this.mac, 0, this.mac, 0);
            this.pos = 0;
          }

          this.mac[this.pos++] ^= data[i];
        }
      }
    }, {
      key: "final",
      value: function final() {
        if (this.pos === -1) throw new Error('Context is not initialized.');
        var k = Buffer.alloc(this.size);
        this.ctx.encrypt(k, 0, k, 0);
        this.shift(k, k);

        if (this.pos < this.size) {
          this.mac[this.pos] ^= 0x80;
          this.shift(k, k);
        }

        for (var i = 0; i < this.size; i++) {
          this.mac[i] ^= k[i];
        }

        this.ctx.encrypt(this.mac, 0, this.mac, 0);
        this.pos = -1;
        return Buffer.from(this.mac);
      }
    }]);

    return CMAC;
  }();
  /**
   * EAX
   */


  var EAX = /*#__PURE__*/function (_Stream6) {
    _inherits__default['default'](EAX, _Stream6);

    var _super31 = _createSuper$2(EAX);

    function EAX(ctx, encrypt) {
      var _this13;

      _classCallCheck__default['default'](this, EAX);

      _this13 = _super31.call(this, ctx);
      _this13.encrypt = encrypt;
      _this13.hash1 = new CMAC(ctx);
      _this13.hash2 = new CMAC(ctx);
      _this13.state = Buffer.alloc(_this13.blockSize);
      _this13.ctr = Buffer.alloc(_this13.blockSize);
      _this13.mask = Buffer.alloc(_this13.blockSize);
      _this13.mac = null;
      _this13.tag = null;
      return _this13;
    }

    _createClass__default['default'](EAX, [{
      key: "_increment",
      value: function _increment() {
        var i = this.blockSize;
        var cy = 1;

        while (i--) {
          cy += this.ctr[i];
          this.ctr[i] = cy;
          cy >>= 8;
        }
      }
    }, {
      key: "_encipher",
      value: function _encipher(output, input) {
        var mask = this.blockSize - 1;

        for (var i = 0; i < input.length; i++) {
          if ((this.pos & mask) === 0) {
            this.ctx.encrypt(this.state, 0, this.ctr, 0);

            this._increment();

            this.pos = 0;
          }

          output[i] = input[i] ^ this.state[this.pos++];
        }
      }
    }, {
      key: "_init",
      value: function _init(key, iv) {
        assert_1$1(iv.length > 0);
        this.hash1.init(0);
        this.hash1.update(iv);
        this.mask = this.hash1.final();
        this.mask.copy(this.ctr, 0);
        this.hash1.init(1);
        this.hash2.init(2);
        this.mac = null;
        this.tag = null;
      }
    }, {
      key: "_crypt",
      value: function _crypt(output, input) {
        if (this.encrypt) {
          this._encipher(output, input);

          this.hash2.update(output);
        } else {
          this.hash2.update(input);

          this._encipher(output, input);
        }
      }
    }, {
      key: "_final",
      value: function _final() {
        var mac = Buffer.alloc(this.blockSize);
        var mac1 = this.hash1.final();
        var mac2 = this.hash2.final();

        for (var i = 0; i < this.blockSize; i++) {
          mac[i] = mac1[i] ^ mac2[i] ^ this.mask[i];
        }

        if (this.encrypt) {
          this.mac = mac;
          return Buffer.alloc(0);
        }

        if (!this.tag) throw new Error('No tag provided.');
        if (!safeEqual(mac, this.tag, this.tag.length)) throw new Error('Invalid tag.');
        return Buffer.alloc(0);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        for (var i = 0; i < this.blockSize; i++) {
          this.state[i] = 0;
          this.ctr[i] = 0;
          this.mask[i] = 0;
        }

        this.tag = null;
      }
    }, {
      key: "_setAAD",
      value: function _setAAD(data) {
        if (this.pos === -1) throw new Error('Cipher is not initialized.');
        this.hash1.update(data);
        return this;
      }
    }, {
      key: "_getAuthTag",
      value: function _getAuthTag() {
        if (!this.encrypt) throw new Error('Must be a cipher context.');
        if (!this.mac) throw new Error('Cipher is not finalized.');
        return Buffer.from(this.mac);
      }
    }, {
      key: "_setAuthTag",
      value: function _setAuthTag(tag) {
        if (this.encrypt) throw new Error('Must be a decipher context.');
        if (this.pos === -1) throw new Error('Cipher is not initialized.');
        if (tag.length === 0 || tag.length > this.blockSize) throw new RangeError('Invalid tag size.');
        this.tag = Buffer.from(tag);
        return this;
      }
    }]);

    return EAX;
  }(Stream);
  /**
   * EAX Cipher
   */


  var EAXCipher = /*#__PURE__*/function (_EAX) {
    _inherits__default['default'](EAXCipher, _EAX);

    var _super32 = _createSuper$2(EAXCipher);

    function EAXCipher(ctx) {
      _classCallCheck__default['default'](this, EAXCipher);

      return _super32.call(this, ctx, true);
    }

    return EAXCipher;
  }(EAX);
  /**
   * EAX Decipher
   */


  var EAXDecipher = /*#__PURE__*/function (_EAX2) {
    _inherits__default['default'](EAXDecipher, _EAX2);

    var _super33 = _createSuper$2(EAXDecipher);

    function EAXDecipher(ctx) {
      _classCallCheck__default['default'](this, EAXDecipher);

      return _super33.call(this, ctx, false);
    }

    return EAXDecipher;
  }(EAX);
  /*
   * Helpers
   */


  function get(name) {
    var encrypt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    assert_1$1(typeof name === 'string');
    assert_1$1(typeof encrypt === 'boolean');

    switch (name) {
      case 'RAW':
        return encrypt ? RawCipher : RawDecipher;

      case 'ECB':
        return encrypt ? ECBCipher : ECBDecipher;

      case 'CBC':
        return encrypt ? CBCCipher : CBCDecipher;

      case 'CTS':
        return encrypt ? CTSCipher : CTSDecipher;

      case 'XTS':
        return encrypt ? XTSCipher : XTSDecipher;

      case 'CTR':
        return encrypt ? CTRCipher : CTRDecipher;

      case 'CFB':
        return encrypt ? CFBCipher : CFBDecipher;

      case 'OFB':
        return encrypt ? OFBCipher : OFBDecipher;

      case 'GCM':
        return encrypt ? GCMCipher : GCMDecipher;

      case 'CCM':
        return encrypt ? CCMCipher : CCMDecipher;

      case 'EAX':
        return encrypt ? EAXCipher : EAXDecipher;

      default:
        throw new Error("Unknown mode: ".concat(name, "."));
    }
  }

  function overlap(output, opos, input, ipos) {
    return output.buffer === input.buffer && output.byteOffset === input.byteOffset && opos === ipos;
  }

  function safeEqual(x, y, len) {
    var z = 0;

    for (var i = 0; i < len; i++) {
      z |= x[i] ^ y[i];
    }

    return z - 1 >>> 31;
  }
  /*
   * Expose
   */


  var Mode_1 = Mode;
  var Block_1 = Block;
  var Stream_1 = Stream;
  var RawCipher_1 = RawCipher;
  var RawDecipher_1 = RawDecipher;
  var PKCS7Cipher_1 = PKCS7Cipher;
  var PKCS7Decipher_1 = PKCS7Decipher;
  var ECBCipher_1 = ECBCipher;
  var ECBDecipher_1 = ECBDecipher;
  var CBCCipher_1 = CBCCipher;
  var CBCDecipher_1 = CBCDecipher;
  var CTSCipher_1 = CTSCipher;
  var CTSDecipher_1 = CTSDecipher;
  var XTS_1 = XTS;
  var XTSCipher_1 = XTSCipher;
  var XTSDecipher_1 = XTSDecipher;
  var CTR_1 = CTR;
  var CTRCipher_1 = CTRCipher;
  var CTRDecipher_1 = CTRDecipher;
  var CFB_1 = CFB;
  var CFBCipher_1 = CFBCipher;
  var CFBDecipher_1 = CFBDecipher;
  var OFB_1 = OFB;
  var OFBCipher_1 = OFBCipher;
  var OFBDecipher_1 = OFBDecipher;
  var GCM_1 = GCM;
  var GCMCipher_1 = GCMCipher;
  var GCMDecipher_1 = GCMDecipher;
  var CBCMAC_1 = CBCMAC;
  var CCM_1 = CCM;
  var CCMCipher_1 = CCMCipher;
  var CCMDecipher_1 = CCMDecipher;
  var CMAC_1 = CMAC;
  var EAX_1 = EAX;
  var EAXCipher_1 = EAXCipher;
  var EAXDecipher_1 = EAXDecipher;
  var get_1 = get;
  var modes = {
    Mode: Mode_1,
    Block: Block_1,
    Stream: Stream_1,
    RawCipher: RawCipher_1,
    RawDecipher: RawDecipher_1,
    PKCS7Cipher: PKCS7Cipher_1,
    PKCS7Decipher: PKCS7Decipher_1,
    ECBCipher: ECBCipher_1,
    ECBDecipher: ECBDecipher_1,
    CBCCipher: CBCCipher_1,
    CBCDecipher: CBCDecipher_1,
    CTSCipher: CTSCipher_1,
    CTSDecipher: CTSDecipher_1,
    XTS: XTS_1,
    XTSCipher: XTSCipher_1,
    XTSDecipher: XTSDecipher_1,
    CTR: CTR_1,
    CTRCipher: CTRCipher_1,
    CTRDecipher: CTRDecipher_1,
    CFB: CFB_1,
    CFBCipher: CFBCipher_1,
    CFBDecipher: CFBDecipher_1,
    OFB: OFB_1,
    OFBCipher: OFBCipher_1,
    OFBDecipher: OFBDecipher_1,
    GCM: GCM_1,
    GCMCipher: GCMCipher_1,
    GCMDecipher: GCMDecipher_1,
    CBCMAC: CBCMAC_1,
    CCM: CCM_1,
    CCMCipher: CCMCipher_1,
    CCMDecipher: CCMDecipher_1,
    CMAC: CMAC_1,
    EAX: EAX_1,
    EAXCipher: EAXCipher_1,
    EAXDecipher: EAXDecipher_1,
    get: get_1
  };

  var CBCCipher$1 = modes.CBCCipher,
      CBCDecipher$1 = modes.CBCDecipher;
  /**
   * Encrypt data with aes 256 cbc.
   * @param {Buffer} data
   * @param {Buffer} key
   * @param {Buffer} iv
   * @returns {Buffer}
   */

  function encipher(data, key, iv) {
    var ctx = new CBCCipher$1(new aes(256));
    ctx.init(key, iv);
    return Buffer.concat([ctx.update(data), ctx.final()]);
  }
  /**
   * Decrypt data with aes 256 cbc.
   * @param {Buffer} data
   * @param {Buffer} key
   * @param {Buffer} iv
   * @returns {Buffer}
   */


  function decipher(data, key, iv) {
    var ctx = new CBCDecipher$1(new aes(256));
    ctx.init(key, iv);
    return Buffer.concat([ctx.update(data), ctx.final()]);
  }
  /*
   * Expose
   */


  var native_1 = 0;
  var encipher_1 = encipher;
  var decipher_1 = decipher;
  var aes$1 = {
    native: native_1,
    encipher: encipher_1,
    decipher: decipher_1
  };

  var aesBrowser = aes$1;

  /**
   * ARC4
   */


  var ARC4 = /*#__PURE__*/function () {
    function ARC4() {
      _classCallCheck__default['default'](this, ARC4);

      this.s = new Uint32Array(256);
      this.i = -1;
      this.j = -1;
    }

    _createClass__default['default'](ARC4, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        var k = key.length;
        if (k < 1 || k > 256) throw new Error('Invalid key size.');
        var s = this.s;

        for (var i = 0; i < 256; i++) {
          s[i] = i;
        }

        var j = 0;

        for (var _i = 0; _i < 256; _i++) {
          j += s[_i] + key[_i % k];
          j &= 0xff;
          var _ref = [s[j], s[_i]];
          s[_i] = _ref[0];
          s[j] = _ref[1];
        }

        this.i = 0;
        this.j = 0;
        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(data) {
        assert_1$1(Buffer.isBuffer(data));
        if (this.i === -1) throw new Error('Context is not initialized.');
        var s = this.s;
        var i = this.i,
            j = this.j;
        var x, y;

        for (var k = 0; k < data.length; k++) {
          i = i + 1 & 0xff;
          x = s[i];
          j = j + x & 0xff;
          y = s[j];
          s[i] = y;
          s[j] = x;
          data[k] ^= s[x + y & 0xff];
        }

        this.i = i;
        this.j = j;
        return data;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 256; i++) {
          this.s[i] = 0;
        }

        this.i = -1;
        this.j = -1;
        return this;
      }
    }]);

    return ARC4;
  }();
  /*
   * Static
   */


  ARC4.native = 0;
  /*
   * Expose
   */

  var arc4 = ARC4;

  var arc4Browser = arc4;

  /**
   * HMAC
   */


  var HMAC = /*#__PURE__*/function () {
    /**
     * Create an HMAC.
     * @param {Function} Hash
     * @param {Number} size
     * @param {Array} [x=[]]
     * @param {Array} [y=[]]
     */
    function HMAC(Hash, size) {
      var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

      _classCallCheck__default['default'](this, HMAC);

      assert_1$1(typeof Hash === 'function');
      assert_1$1(size >>> 0 === size);
      assert_1$1(Array.isArray(x));
      assert_1$1(Array.isArray(y));
      this.hash = Hash;
      this.size = size;
      this.x = x;
      this.y = y;
      this.inner = new Hash();
      this.outer = new Hash();
    }
    /**
     * Initialize HMAC context.
     * @param {Buffer} data
     */


    _createClass__default['default'](HMAC, [{
      key: "init",
      value: function init(key) {
        var _this$inner, _this$outer;

        assert_1$1(Buffer.isBuffer(key)); // Shorten key

        if (key.length > this.size) {
          var Hash = this.hash;
          var h = new Hash();
          h.init.apply(h, _toConsumableArray__default['default'](this.x));
          h.update(key);
          key = h.final.apply(h, _toConsumableArray__default['default'](this.y));
          assert_1$1(key.length <= this.size);
        } // Pad key


        var pad = Buffer.alloc(this.size);

        for (var i = 0; i < key.length; i++) {
          pad[i] = key[i] ^ 0x36;
        }

        for (var _i = key.length; _i < pad.length; _i++) {
          pad[_i] = 0x36;
        }

        (_this$inner = this.inner).init.apply(_this$inner, _toConsumableArray__default['default'](this.x));

        this.inner.update(pad);

        for (var _i2 = 0; _i2 < key.length; _i2++) {
          pad[_i2] = key[_i2] ^ 0x5c;
        }

        for (var _i3 = key.length; _i3 < pad.length; _i3++) {
          pad[_i3] = 0x5c;
        }

        (_this$outer = this.outer).init.apply(_this$outer, _toConsumableArray__default['default'](this.x));

        this.outer.update(pad);
        return this;
      }
      /**
       * Update HMAC context.
       * @param {Buffer} data
       */

    }, {
      key: "update",
      value: function update(data) {
        this.inner.update(data);
        return this;
      }
      /**
       * Finalize HMAC context.
       * @returns {Buffer}
       */

    }, {
      key: "final",
      value: function final() {
        var _this$inner2, _this$outer2;

        this.outer.update((_this$inner2 = this.inner).final.apply(_this$inner2, _toConsumableArray__default['default'](this.y)));
        return (_this$outer2 = this.outer).final.apply(_this$outer2, _toConsumableArray__default['default'](this.y));
      }
    }]);

    return HMAC;
  }();
  /*
   * Expose
   */


  var hmac = HMAC;

  /*
   * Constants
   */


  var FINALIZED$1 = -1;
  var DESC = Buffer.alloc(16, 0x00);
  var PADDING$1 = Buffer.alloc(128, 0x00);
  PADDING$1[0] = 0x80;
  var K = new Uint32Array([0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817]);
  /**
   * SHA512
   */

  var SHA512 = /*#__PURE__*/function () {
    function SHA512() {
      _classCallCheck__default['default'](this, SHA512);

      this.state = new Uint32Array(16);
      this.msg = new Uint32Array(160);
      this.block = Buffer.alloc(128);
      this.size = FINALIZED$1;
    }

    _createClass__default['default'](SHA512, [{
      key: "init",
      value: function init() {
        this.state[0] = 0x6a09e667;
        this.state[1] = 0xf3bcc908;
        this.state[2] = 0xbb67ae85;
        this.state[3] = 0x84caa73b;
        this.state[4] = 0x3c6ef372;
        this.state[5] = 0xfe94f82b;
        this.state[6] = 0xa54ff53a;
        this.state[7] = 0x5f1d36f1;
        this.state[8] = 0x510e527f;
        this.state[9] = 0xade682d1;
        this.state[10] = 0x9b05688c;
        this.state[11] = 0x2b3e6c1f;
        this.state[12] = 0x1f83d9ab;
        this.state[13] = 0xfb41bd6b;
        this.state[14] = 0x5be0cd19;
        this.state[15] = 0x137e2179;
        this.size = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._update(data, data.length);

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return this._final(Buffer.alloc(64));
      }
    }, {
      key: "_update",
      value: function _update(data, len) {
        assert_1$1(this.size !== FINALIZED$1, 'Context is not initialized.');
        var pos = this.size & 127;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 128 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 128) return;

          this._transform(this.block, 0);
        }

        while (len >= 128) {
          this._transform(data, off);

          off += 128;
          len -= 128;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
      /**
       * Finalize SHA512 context.
       * @private
       * @param {Buffer} out
       * @returns {Buffer}
       */

    }, {
      key: "_final",
      value: function _final(out) {
        assert_1$1(this.size !== FINALIZED$1, 'Context is not initialized.');
        var pos = this.size & 127;
        var len = this.size * 8;
        writeU32$4(DESC, len * (1 / 0x100000000) >>> 0, 8);
        writeU32$4(DESC, len >>> 0, 12);

        this._update(PADDING$1, 1 + (239 - pos & 127));

        this._update(DESC, 16);

        for (var i = 0; i < 16; i++) {
          writeU32$4(out, this.state[i], i * 4);
          this.state[i] = 0;
        }

        for (var _i = 0; _i < 160; _i++) {
          this.msg[_i] = 0;
        }

        for (var _i2 = 0; _i2 < 128; _i2++) {
          this.block[_i2] = 0;
        }

        this.size = FINALIZED$1;
        return out;
      }
    }, {
      key: "_prepare",
      value: function _prepare(chunk, pos) {
        var W = this.msg;
        var i = 0;

        for (; i < 32; i++) {
          W[i] = readU32$3(chunk, pos + i * 4);
        }

        for (; i < 160; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i + 0] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
          W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
      }
    }, {
      key: "_transform",
      value: function _transform(chunk, pos) {
        var W = this.msg;

        this._prepare(chunk, pos);

        var ah = this.state[0];
        var al = this.state[1];
        var bh = this.state[2];
        var bl = this.state[3];
        var ch = this.state[4];
        var cl = this.state[5];
        var dh = this.state[6];
        var dl = this.state[7];
        var eh = this.state[8];
        var el = this.state[9];
        var fh = this.state[10];
        var fl = this.state[11];
        var gh = this.state[12];
        var gl = this.state[13];
        var hh = this.state[14];
        var hl = this.state[15];

        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = K[i + 0];
          var c3_lo = K[i + 1];
          var c4_hi = W[i + 0];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }

        sum64(this.state, 0, ah, al);
        sum64(this.state, 2, bh, bl);
        sum64(this.state, 4, ch, cl);
        sum64(this.state, 6, dh, dl);
        sum64(this.state, 8, eh, el);
        sum64(this.state, 10, fh, fl);
        sum64(this.state, 12, gh, gl);
        sum64(this.state, 14, hh, hl);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA512();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(SHA512, 128);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return SHA512.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 64);
        assert_1$1(Buffer.isBuffer(right) && right.length === 64);
        return SHA512.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = SHA512.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return SHA512.hmac().init(key).update(data).final();
      }
    }]);

    return SHA512;
  }();
  /*
   * Static
   */


  SHA512.native = 0;
  SHA512.id = 'SHA512';
  SHA512.size = 64;
  SHA512.bits = 512;
  SHA512.blockSize = 128;
  SHA512.zero = Buffer.alloc(64, 0x00);
  SHA512.ctx = new SHA512();
  /*
   * Helpers
   */

  function sum64(buf, pos, ah, al) {
    var bh = buf[pos + 0];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al) + ah + bh;
    buf[pos + 0] = hi >>> 0;
    buf[pos + 1] = lo;
  }

  function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al) + ah + bh;
    return hi >>> 0;
  }

  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }

  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al;
    lo = lo + cl >>> 0;
    carry += lo < cl;
    lo = lo + dl >>> 0;
    carry += lo < dl;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }

  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }

  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al;
    lo = lo + cl >>> 0;
    carry += lo < cl;
    lo = lo + dl >>> 0;
    carry += lo < dl;
    lo = lo + el >>> 0;
    carry += lo < el;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }

  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }

  function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
  }

  function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }

  function shr64_hi(ah, al, num) {
    return ah >>> num;
  }

  function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }

  function ch64_hi(xh, xl, yh, yl, zh, zl) {
    var r = xh & yh ^ ~xh & zh;
    return r >>> 0;
  }

  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    return r >>> 0;
  }

  function maj64_hi(xh, xl, yh, yl, zh, zl) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    return r >>> 0;
  }

  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    return r >>> 0;
  }

  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2); // 34

    var c2_hi = rotr64_hi(xl, xh, 7); // 39

    var r = c0_hi ^ c1_hi ^ c2_hi;
    return r >>> 0;
  }

  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2); // 34

    var c2_lo = rotr64_lo(xl, xh, 7); // 39

    var r = c0_lo ^ c1_lo ^ c2_lo;
    return r >>> 0;
  }

  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9); // 41

    var r = c0_hi ^ c1_hi ^ c2_hi;
    return r >>> 0;
  }

  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9); // 41

    var r = c0_lo ^ c1_lo ^ c2_lo;
    return r >>> 0;
  }

  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    return r >>> 0;
  }

  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    return r >>> 0;
  }

  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29); // 61

    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    return r >>> 0;
  }

  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29); // 61

    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    return r >>> 0;
  }

  function readU32$3(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function writeU32$4(data, num, off) {
    data[off++] = num >>> 24;
    data[off++] = num >>> 16;
    data[off++] = num >>> 8;
    data[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var sha512 = SHA512;

  var sha512Browser = sha512;

  /*
   * Constants
   */


  var S0 = new Uint32Array([0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239, 0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0, 0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe, 0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463, 0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c, 0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf, 0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af, 0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915, 0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a]);
  var S1 = new Uint32Array([0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1, 0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509, 0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84, 0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061, 0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7]);
  var S2 = new Uint32Array([0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068, 0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b, 0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b, 0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c, 0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564, 0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b, 0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc, 0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0]);
  var S3 = new Uint32Array([0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22, 0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28, 0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048, 0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd, 0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e, 0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6]);
  var P = new Uint32Array([0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b]);
  /**
   * Blowfish
   */

  var Blowfish = /*#__PURE__*/function () {
    function Blowfish() {
      _classCallCheck__default['default'](this, Blowfish);

      this.S = [new Uint32Array(S0.length), new Uint32Array(S1.length), new Uint32Array(S2.length), new Uint32Array(S3.length)];
      this.P = new Uint32Array(P.length);
      this.block = new Uint32Array(2);
      this.off = 0;
    }

    _createClass__default['default'](Blowfish, [{
      key: "init",
      value: function init(key, salt) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length >= 1 && key.length <= 72);

        if (salt != null) {
          assert_1$1(Buffer.isBuffer(salt));
          assert_1$1(salt.length <= 1096);
        }

        copy(this.S[0], S0);
        copy(this.S[1], S1);
        copy(this.S[2], S2);
        copy(this.S[3], S3);
        copy(this.P, P);
        this.off = 0;
        if (salt && salt.length > 0) this.expandstate(key, salt);else this.expand0state(key);
        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        var d = this.block;
        d[0] = readU32$4(input, ipos + 0);
        d[1] = readU32$4(input, ipos + 4);
        this.encipher(d, 0);
        writeU32$5(output, d[0], opos + 0);
        writeU32$5(output, d[1], opos + 4);
        return this;
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        var d = this.block;
        d[0] = readU32$4(input, ipos + 0);
        d[1] = readU32$4(input, ipos + 4);
        this.decipher(d, 0);
        writeU32$5(output, d[0], opos + 0);
        writeU32$5(output, d[1], opos + 4);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        cleanse(this.S[0]);
        cleanse(this.S[1]);
        cleanse(this.S[2]);
        cleanse(this.S[3]);
        cleanse(this.P);
        cleanse(this.block);
        this.off = 0;
        return this;
      }
    }, {
      key: "encipher",
      value: function encipher(x, off) {
        var S = this.S;
        var P = this.P;
        var l = x[off + 0] ^ P[0];
        var r = x[off + 1];
        r ^= substitute(S, l) ^ P[1];
        l ^= substitute(S, r) ^ P[2];
        r ^= substitute(S, l) ^ P[3];
        l ^= substitute(S, r) ^ P[4];
        r ^= substitute(S, l) ^ P[5];
        l ^= substitute(S, r) ^ P[6];
        r ^= substitute(S, l) ^ P[7];
        l ^= substitute(S, r) ^ P[8];
        r ^= substitute(S, l) ^ P[9];
        l ^= substitute(S, r) ^ P[10];
        r ^= substitute(S, l) ^ P[11];
        l ^= substitute(S, r) ^ P[12];
        r ^= substitute(S, l) ^ P[13];
        l ^= substitute(S, r) ^ P[14];
        r ^= substitute(S, l) ^ P[15];
        l ^= substitute(S, r) ^ P[16];
        x[off + 0] = r ^ P[17];
        x[off + 1] = l;
      }
    }, {
      key: "decipher",
      value: function decipher(x, off) {
        var S = this.S;
        var P = this.P;
        var l = x[off + 0] ^ P[17];
        var r = x[off + 1];
        r ^= substitute(S, l) ^ P[16];
        l ^= substitute(S, r) ^ P[15];
        r ^= substitute(S, l) ^ P[14];
        l ^= substitute(S, r) ^ P[13];
        r ^= substitute(S, l) ^ P[12];
        l ^= substitute(S, r) ^ P[11];
        r ^= substitute(S, l) ^ P[10];
        l ^= substitute(S, r) ^ P[9];
        r ^= substitute(S, l) ^ P[8];
        l ^= substitute(S, r) ^ P[7];
        r ^= substitute(S, l) ^ P[6];
        l ^= substitute(S, r) ^ P[5];
        r ^= substitute(S, l) ^ P[4];
        l ^= substitute(S, r) ^ P[3];
        r ^= substitute(S, l) ^ P[2];
        l ^= substitute(S, r) ^ P[1];
        x[off + 0] = r ^ P[0];
        x[off + 1] = l;
      }
    }, {
      key: "stream2word",
      value: function stream2word(data) {
        if (data.length === 0) {
          this.off = 0;
          return 0;
        }

        var word = data[(this.off + 0) % data.length] * 0x1000000 + data[(this.off + 1) % data.length] * 0x0010000 + data[(this.off + 2) % data.length] * 0x0000100 + data[(this.off + 3) % data.length] * 0x0000001;
        this.off = (this.off + 4) % data.length;
        return word;
      }
    }, {
      key: "expand0state",
      value: function expand0state(key) {
        var d = new Uint32Array(2);
        this.off = 0;

        for (var i = 0; i < 18; i++) {
          this.P[i] ^= this.stream2word(key);
        }

        this.off = 0;

        for (var _i = 0; _i < 18; _i += 2) {
          this.encipher(d, 0);
          this.P[_i + 0] = d[0];
          this.P[_i + 1] = d[1];
        }

        for (var _i2 = 0; _i2 < 4; _i2++) {
          for (var k = 0; k < 256; k += 2) {
            this.encipher(d, 0);
            this.S[_i2][k + 0] = d[0];
            this.S[_i2][k + 1] = d[1];
          }
        }
      }
    }, {
      key: "expandstate",
      value: function expandstate(key, data) {
        var d = new Uint32Array(2);
        this.off = 0;

        for (var i = 0; i < 18; i++) {
          this.P[i] ^= this.stream2word(key);
        }

        this.off = 0;

        for (var _i3 = 0; _i3 < 18; _i3 += 2) {
          d[0] ^= this.stream2word(data);
          d[1] ^= this.stream2word(data);
          this.encipher(d, 0);
          this.P[_i3 + 0] = d[0];
          this.P[_i3 + 1] = d[1];
        }

        for (var _i4 = 0; _i4 < 4; _i4++) {
          for (var k = 0; k < 256; k += 2) {
            d[0] ^= this.stream2word(data);
            d[1] ^= this.stream2word(data);
            this.encipher(d, 0);
            this.S[_i4][k + 0] = d[0];
            this.S[_i4][k + 1] = d[1];
          }
        }

        this.off = 0;
      }
    }, {
      key: "enc",
      value: function enc(data) {
        var blocks = data.length >>> 1;

        for (var i = 0; i < blocks; i++) {
          this.encipher(data, i * 2);
        }
      }
    }, {
      key: "dec",
      value: function dec(data) {
        var blocks = data.length >>> 1;

        for (var i = 0; i < blocks; i++) {
          this.decipher(data, i * 2);
        }
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 8;
      }
    }]);

    return Blowfish;
  }();
  /*
   * Helpers
   */


  function substitute(S, x) {
    return (S[0][x >>> 24 & 0xff] + S[1][x >>> 16 & 0xff] ^ S[2][x >>> 8 & 0xff]) + S[3][x >>> 0 & 0xff];
  }

  function copy(dst, src) {
    for (var i = 0; i < src.length; i++) {
      dst[i] = src[i];
    }
  }

  function cleanse(arr) {
    for (var i = 0; i < arr.length; i++) {
      arr[i] = 0;
    }
  }

  function readU32$4(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function writeU32$5(dst, num, off) {
    dst[off++] = num >>> 24;
    dst[off++] = num >>> 16;
    dst[off++] = num >>> 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var blowfish = Blowfish;

  /*
   * Constants
   */


  var CIPHERTEXT192 = Buffer.from('OrpheanBeholderScryDoubt', 'binary');
  var BCRYPT_BLOCKS192 = 6;
  var BCRYPT_SIZE192 = 24;
  var BCRYPT_SALT192 = 16;
  var BCRYPT_HASH192 = 23;
  var CIPHERTEXT256 = Buffer.from('OxychromaticBlowfishSwatDynamite', 'binary');
  var BCRYPT_BLOCKS256 = 8;
  var BCRYPT_SIZE256 = 32;
  var NUL = Buffer.alloc(1, 0x00);
  /*
   * Bcrypt
   */

  function hash192(pass, salt, rounds) {
    if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');
    if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
    if (salt == null) salt = Buffer.alloc(0);
    assert_1$1(Buffer.isBuffer(pass));
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(rounds >>> 0 === rounds);
    if (rounds < 4 || rounds > 31) throw new RangeError('Invalid rounds.');
    return _hash192(Buffer.alloc(BCRYPT_SIZE192), pass, salt, rounds);
  }

  function derive(pass, salt, rounds) {
    var minor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'b';
    if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');
    if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
    assert_1$1(Buffer.isBuffer(pass));
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(rounds >>> 0 === rounds);
    assert_1$1(typeof minor === 'string');
    if (salt.length !== BCRYPT_SALT192) throw new RangeError('Invalid salt length.');

    switch (minor) {
      case 'a':
        pass = Buffer.concat([pass, NUL]);
        pass = pass.slice(0, pass.length & 0xff);
        break;

      case 'b':
        if (pass.length > 72) pass = pass.slice(0, 73);else pass = Buffer.concat([pass, NUL]);
        break;

      default:
        throw new Error('Invalid minor version.');
    }

    return hash192(pass, salt, rounds).slice(0, BCRYPT_HASH192);
  }

  function generate(pass, salt, rounds) {
    var minor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'b';

    if (typeof salt === 'string') {
      var _decode = decode64(salt, 0, BCRYPT_SALT192),
          _decode2 = _slicedToArray__default['default'](_decode, 2),
          i = _decode2[0],
          data = _decode2[1];

      if (i !== salt.length || data == null) throw new Error('Invalid salt string.');
      salt = data;
    }

    var hash = derive(pass, salt, rounds, minor);
    return encode$1(minor, rounds, salt, hash);
  }

  function verify(pass, record) {
    var _decode3 = decode$1(record),
        _decode4 = _slicedToArray__default['default'](_decode3, 4),
        minor = _decode4[0],
        rounds = _decode4[1],
        salt = _decode4[2],
        expect = _decode4[3];

    var hash = derive(pass, salt, rounds, minor);
    var res = 0;

    for (var i = 0; i < BCRYPT_HASH192; i++) {
      res |= hash[i] ^ expect[i];
    }

    return res - 1 >>> 31 !== 0;
  }
  /*
   * PBKDF
   */


  function hash256(pass, salt, rounds) {
    if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');
    if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
    if (salt == null) salt = Buffer.alloc(0);
    assert_1$1(Buffer.isBuffer(pass));
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(rounds >>> 0 === rounds);
    if (rounds < 4 || rounds > 31) throw new RangeError('Invalid rounds.');
    return _hash256(Buffer.alloc(BCRYPT_SIZE256), pass, salt, rounds);
  }

  function pbkdf(pass, salt, rounds, size) {
    if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');
    if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
    if (salt == null) salt = Buffer.alloc(0);
    assert_1$1(Buffer.isBuffer(pass));
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(rounds >>> 0 === rounds);
    assert_1$1(size >>> 0 === size);
    var out = Buffer.alloc(BCRYPT_SIZE256);
    var tmpout = Buffer.alloc(BCRYPT_SIZE256);
    var countsalt = Buffer.alloc(salt.length + 4);
    var key = Buffer.alloc(size);

    if (rounds < 1 || pass.length === 0 || salt.length === 0 || size === 0 || size > Math.pow(out.length, 2) || salt.length > 1 << 20) {
      throw new Error('Invalid bcrypt parameters.');
    }

    var stride = (size + out.length - 1) / out.length >>> 0;
    var amount = (size + stride - 1) / stride >>> 0;
    salt.copy(countsalt, 0);
    var sha2pass = sha512Browser.digest(pass);
    var sha2salt = Buffer.alloc(0);
    var keylen = size;
    var amt = amount;

    for (var count = 1; keylen > 0; count++) {
      countsalt[salt.length + 0] = count >>> 24;
      countsalt[salt.length + 1] = count >>> 16;
      countsalt[salt.length + 2] = count >>> 8;
      countsalt[salt.length + 3] = count;
      sha2salt = sha512Browser.digest(countsalt);

      _hash256(tmpout, sha2pass, sha2salt, 6);

      tmpout.copy(out, 0);

      for (var _i = 1; _i < rounds; _i++) {
        sha2salt = sha512Browser.digest(tmpout);

        _hash256(tmpout, sha2pass, sha2salt, 6);

        for (var j = 0; j < out.length; j++) {
          out[j] ^= tmpout[j];
        }
      }

      amt = Math.min(amt, keylen);
      var i = 0;

      for (; i < amt; i++) {
        var dest = i * stride + (count - 1);
        if (dest >= size) break;
        key[dest] = out[i];
      }

      keylen -= i;
    }

    return key;
  }

  function pbkdfAsync(_x, _x2, _x3, _x4) {
    return _pbkdfAsync.apply(this, arguments);
  }
  /*
   * Hashing
   */


  function _pbkdfAsync() {
    _pbkdfAsync = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(pass, salt, rounds, size) {
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", pbkdf(pass, salt, rounds, size));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _pbkdfAsync.apply(this, arguments);
  }

  function _hash192(out, pass, salt, rounds) {
    var state = new blowfish();
    var cdata = new Uint32Array(BCRYPT_BLOCKS192);
    state.init(pass, salt);
    var r = Math.pow(2, rounds);

    for (var i = 0; i < r; i++) {
      state.expand0state(pass);
      state.expand0state(salt);
    }

    for (var _i2 = 0; _i2 < BCRYPT_BLOCKS192; _i2++) {
      cdata[_i2] = state.stream2word(CIPHERTEXT192);
    }

    for (var _i3 = 0; _i3 < 64; _i3++) {
      state.enc(cdata);
    }

    for (var _i4 = 0; _i4 < BCRYPT_BLOCKS192; _i4++) {
      out[4 * _i4 + 0] = cdata[_i4] >>> 24;
      out[4 * _i4 + 1] = cdata[_i4] >>> 16;
      out[4 * _i4 + 2] = cdata[_i4] >>> 8;
      out[4 * _i4 + 3] = cdata[_i4];
    }

    return out;
  }

  function _hash256(out, pass, salt, rounds) {
    var state = new blowfish();
    var cdata = new Uint32Array(BCRYPT_BLOCKS256);
    state.init(pass, salt);
    var r = Math.pow(2, rounds);

    for (var i = 0; i < r; i++) {
      state.expand0state(salt);
      state.expand0state(pass);
    }

    for (var _i5 = 0; _i5 < BCRYPT_BLOCKS256; _i5++) {
      cdata[_i5] = state.stream2word(CIPHERTEXT256);
    }

    for (var _i6 = 0; _i6 < 64; _i6++) {
      state.enc(cdata);
    }

    for (var _i7 = 0; _i7 < BCRYPT_BLOCKS256; _i7++) {
      out[4 * _i7 + 3] = cdata[_i7] >>> 24;
      out[4 * _i7 + 2] = cdata[_i7] >>> 16;
      out[4 * _i7 + 1] = cdata[_i7] >>> 8;
      out[4 * _i7 + 0] = cdata[_i7];
    }

    return out;
  }
  /*
   * Encoding
   */


  function encode$1(minor, rounds, salt, hash) {
    assert_1$1(typeof minor === 'string');
    assert_1$1(rounds >>> 0 === rounds);
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(Buffer.isBuffer(hash));
    assert_1$1(minor === 'a' || minor === 'b');
    assert_1$1(rounds >= 4 && rounds <= 31);
    assert_1$1(salt.length === BCRYPT_SALT192);
    assert_1$1(hash.length === BCRYPT_HASH192);
    var logr = rounds.toString(10);
    if (rounds < 10) logr = '0' + logr;
    return "$2".concat(minor, "$").concat(logr, "$").concat(encode64(salt)).concat(encode64(hash));
  }

  function decode$1(str) {
    assert_1$1(typeof str === 'string');
    if (str.length < 46) throw new Error('Invalid bcrypt string.');
    if (str[0] !== '$' || str[1] !== '2') throw new Error('Invalid major version.');
    var minor = str[2];

    switch (minor) {
      case 'a':
      case 'b':
        break;

      default:
        throw new Error('Invalid minor version.');
    }

    if (str[3] !== '$') throw new Error('Invalid bcrypt string.');
    var p = str.charCodeAt(4) - 0x30;
    var q = str.charCodeAt(5) - 0x30;
    if (p < 0 || p > 9 || q < 0 || q > 9) throw new Error('Invalid bcrypt string.');
    var rounds = p * 10 + q;
    if (rounds < 4 || rounds > 31) throw new Error('Invalid log rounds.');
    if (str[6] !== '$') throw new Error('Invalid bcrypt string.');
    var i = 7;
    var salt, hash;

    var _decode5 = decode64(str, i, BCRYPT_SALT192);

    var _decode6 = _slicedToArray__default['default'](_decode5, 2);

    i = _decode6[0];
    salt = _decode6[1];
    if (salt == null) throw new Error('Invalid salt.');

    var _decode7 = decode64(str, i, BCRYPT_HASH192);

    var _decode8 = _slicedToArray__default['default'](_decode7, 2);

    i = _decode8[0];
    hash = _decode8[1];
    if (hash == null) throw new Error('Invalid hash.');
    if (i !== str.length) throw new Error('Invalid bcrypt string.');
    return [minor, rounds, salt, hash];
  }
  /*
   * Base64
   */


  var CHARSET$1 = './ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var TABLE$1 = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, -1, -1, -1, -1, -1];

  function encode64(data) {
    assert_1$1(Buffer.isBuffer(data));
    var p = 0;
    var s = '';
    var a, b;

    while (p < data.length) {
      a = data[p++];
      s += CHARSET$1[a >>> 2];
      a = (a & 3) << 4;

      if (p >= data.length) {
        s += CHARSET$1[a];
        break;
      }

      b = data[p++];
      a |= b >>> 4 & 15;
      s += CHARSET$1[a];
      a = (b & 0x0f) << 2;

      if (p >= data.length) {
        s += CHARSET$1[a];
        break;
      }

      b = data[p++];
      a |= b >>> 6 & 3;
      s += CHARSET$1[a];
      s += CHARSET$1[b & 63];
    }

    return s;
  }

  function decode64(s, i, len) {
    assert_1$1(typeof s === 'string');
    assert_1$1(i >>> 0 === i);
    assert_1$1(len >>> 0 === len);
    var data = Buffer.alloc(len);
    var p = 0;
    var a, b, c, d;

    while (p < len) {
      a = unbase64(s, i++);
      if (a === -1) return [i, null];
      b = unbase64(s, i++);
      if (b === -1) return [i, null];
      data[p++] = a << 2 | (b & 48) >>> 4;
      if (p >= len) break;
      c = unbase64(s, i++);
      if (c === -1) return [i, null];
      data[p++] = (b & 15) << 4 | (c & 60) >>> 2;
      if (p >= len) break;
      d = unbase64(s, i++);
      if (d === -1) return [i, null];
      data[p++] = (c & 3) << 6 | d;
    }

    return [i, data];
  }

  function unbase64(s, i) {
    if (i >= s.length) return -1;
    var ch = s.charCodeAt(i);
    if (ch & 0xff80) return -1;
    return TABLE$1[ch];
  }
  /*
   * Expose
   */


  var native_1$1 = 0;
  var hash192_1 = hash192;
  var derive_1 = derive;
  var generate_1 = generate;
  var verify_1 = verify;
  var hash256_1 = hash256;
  var pbkdf_1 = pbkdf;
  var pbkdfAsync_1 = pbkdfAsync;
  var bcrypt = {
    native: native_1$1,
    hash192: hash192_1,
    derive: derive_1,
    generate: generate_1,
    verify: verify_1,
    hash256: hash256_1,
    pbkdf: pbkdf_1,
    pbkdfAsync: pbkdfAsync_1
  };

  var bcryptBrowser = bcrypt;

  /*
   * Constants
   */


  var FINALIZED$2 = 0x80000000;
  var IV = new Uint32Array([0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19]);
  var SIGMA = new Uint8Array([0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x1c, 0x14, 0x08, 0x10, 0x12, 0x1e, 0x1a, 0x0c, 0x02, 0x18, 0x00, 0x04, 0x16, 0x0e, 0x0a, 0x06, 0x16, 0x10, 0x18, 0x00, 0x0a, 0x04, 0x1e, 0x1a, 0x14, 0x1c, 0x06, 0x0c, 0x0e, 0x02, 0x12, 0x08, 0x0e, 0x12, 0x06, 0x02, 0x1a, 0x18, 0x16, 0x1c, 0x04, 0x0c, 0x0a, 0x14, 0x08, 0x00, 0x1e, 0x10, 0x12, 0x00, 0x0a, 0x0e, 0x04, 0x08, 0x14, 0x1e, 0x1c, 0x02, 0x16, 0x18, 0x0c, 0x10, 0x06, 0x1a, 0x04, 0x18, 0x0c, 0x14, 0x00, 0x16, 0x10, 0x06, 0x08, 0x1a, 0x0e, 0x0a, 0x1e, 0x1c, 0x02, 0x12, 0x18, 0x0a, 0x02, 0x1e, 0x1c, 0x1a, 0x08, 0x14, 0x00, 0x0e, 0x0c, 0x06, 0x12, 0x04, 0x10, 0x16, 0x1a, 0x16, 0x0e, 0x1c, 0x18, 0x02, 0x06, 0x12, 0x0a, 0x00, 0x1e, 0x08, 0x10, 0x0c, 0x04, 0x14, 0x0c, 0x1e, 0x1c, 0x12, 0x16, 0x06, 0x00, 0x10, 0x18, 0x04, 0x1a, 0x0e, 0x02, 0x08, 0x14, 0x0a, 0x14, 0x04, 0x10, 0x08, 0x0e, 0x0c, 0x02, 0x0a, 0x1e, 0x16, 0x12, 0x1c, 0x06, 0x18, 0x1a, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x1c, 0x14, 0x08, 0x10, 0x12, 0x1e, 0x1a, 0x0c, 0x02, 0x18, 0x00, 0x04, 0x16, 0x0e, 0x0a, 0x06]);
  /**
   * BLAKE2b
   */

  var BLAKE2b = /*#__PURE__*/function () {
    function BLAKE2b() {
      _classCallCheck__default['default'](this, BLAKE2b);

      this.state = new Uint32Array(16);
      this.V = new Uint32Array(32);
      this.M = new Uint32Array(32);
      this.block = Buffer.alloc(128);
      this.size = 32;
      this.count = 0;
      this.pos = FINALIZED$2;
    }

    _createClass__default['default'](BLAKE2b, [{
      key: "init",
      value: function init(size, key) {
        if (size == null) size = 32;
        assert_1$1(size >>> 0 === size);
        assert_1$1(key == null || Buffer.isBuffer(key));
        if (size === 0 || size > 64) throw new Error('Bad output length.');
        if (key && key.length > 64) throw new Error('Bad key length.');
        var klen = key ? key.length : 0;

        for (var i = 0; i < 16; i++) {
          this.state[i] = IV[i];
        }

        this.size = size;
        this.count = 0;
        this.pos = 0;
        this.state[0] ^= 0x01010000 ^ klen << 8 ^ this.size;

        if (klen > 0) {
          var block = Buffer.alloc(128, 0x00);
          key.copy(block, 0);
          this.update(block);
        }

        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));
        assert_1$1(!(this.pos & FINALIZED$2), 'Context is not initialized.');
        var off = 0;
        var len = data.length;

        if (len > 0) {
          var left = this.pos;
          var fill = 128 - left;

          if (len > fill) {
            this.pos = 0;
            data.copy(this.block, left, off, off + fill);
            this.count += 128;

            this._compress(this.block, 0, false);

            off += fill;
            len -= fill;

            while (len > 128) {
              this.count += 128;

              this._compress(data, off, false);

              off += 128;
              len -= 128;
            }
          }

          data.copy(this.block, this.pos, off, off + len);
          this.pos += len;
        }

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        assert_1$1(!(this.pos & FINALIZED$2), 'Context is not initialized.');
        this.count += this.pos;
        this.block.fill(0, this.pos, 128);

        this._compress(this.block, 0, true);

        this.pos = FINALIZED$2;
        var out = Buffer.alloc(this.size);

        for (var i = 0; i < this.size; i++) {
          out[i] = this.state[i >>> 2] >>> 8 * (i & 3);
        }

        for (var _i = 0; _i < 16; _i++) {
          this.state[_i] = 0;
        }

        for (var _i2 = 0; _i2 < 32; _i2++) {
          this.V[_i2] = 0;
          this.M[_i2] = 0;
        }

        for (var _i3 = 0; _i3 < 128; _i3++) {
          this.block[_i3] = 0;
        }

        return out;
      }
    }, {
      key: "_compress",
      value: function _compress(block, off, last) {
        var V = this.V,
            M = this.M;

        for (var i = 0; i < 16; i++) {
          V[i] = this.state[i];
          V[i + 16] = IV[i];
        } // uint128


        V[24] ^= this.count;
        V[25] ^= this.count * (1 / 0x100000000);
        V[26] ^= 0;
        V[27] ^= 0;

        if (last) {
          // last block
          V[28] ^= -1;
          V[29] ^= -1; // last node

          V[29] ^= 0;
          V[30] ^= 0;
        }

        for (var _i4 = 0; _i4 < 32; _i4++) {
          M[_i4] = readU32$5(block, off);
          off += 4;
        }

        for (var _i5 = 0; _i5 < 12; _i5++) {
          G(V, M, 0, 8, 16, 24, SIGMA[_i5 * 16 + 0], SIGMA[_i5 * 16 + 1]);
          G(V, M, 2, 10, 18, 26, SIGMA[_i5 * 16 + 2], SIGMA[_i5 * 16 + 3]);
          G(V, M, 4, 12, 20, 28, SIGMA[_i5 * 16 + 4], SIGMA[_i5 * 16 + 5]);
          G(V, M, 6, 14, 22, 30, SIGMA[_i5 * 16 + 6], SIGMA[_i5 * 16 + 7]);
          G(V, M, 0, 10, 20, 30, SIGMA[_i5 * 16 + 8], SIGMA[_i5 * 16 + 9]);
          G(V, M, 2, 12, 22, 24, SIGMA[_i5 * 16 + 10], SIGMA[_i5 * 16 + 11]);
          G(V, M, 4, 14, 16, 26, SIGMA[_i5 * 16 + 12], SIGMA[_i5 * 16 + 13]);
          G(V, M, 6, 8, 18, 28, SIGMA[_i5 * 16 + 14], SIGMA[_i5 * 16 + 15]);
        }

        for (var _i6 = 0; _i6 < 16; _i6++) {
          this.state[_i6] ^= V[_i6] ^ V[_i6 + 16];
        }
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2b();
      }
    }, {
      key: "hmac",
      value: function hmac$1(size) {
        return new hmac(BLAKE2b, 128, [size]);
      }
    }, {
      key: "digest",
      value: function digest(data, size, key) {
        var ctx = BLAKE2b.ctx;
        ctx.init(size, key);
        ctx.update(data);
        return ctx.final();
      }
    }, {
      key: "root",
      value: function root(left, right, size, key) {
        if (size == null) size = 32;
        assert_1$1(Buffer.isBuffer(left) && left.length === size);
        assert_1$1(Buffer.isBuffer(right) && right.length === size);
        var ctx = BLAKE2b.ctx;
        ctx.init(size, key);
        ctx.update(left);
        ctx.update(right);
        return ctx.final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, size, key) {
        var ctx = BLAKE2b.ctx;
        ctx.init(size, key);
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key, size) {
        return BLAKE2b.hmac(size).init(key).update(data).final();
      }
    }]);

    return BLAKE2b;
  }();
  /*
   * Static
   */


  BLAKE2b.native = 0;
  BLAKE2b.id = 'BLAKE2B256';
  BLAKE2b.size = 32;
  BLAKE2b.bits = 256;
  BLAKE2b.blockSize = 128;
  BLAKE2b.zero = Buffer.alloc(32, 0x00);
  BLAKE2b.ctx = new BLAKE2b();
  /*
   * Helpers
   */

  function sum64i(v, a, b) {
    var o0 = v[a + 0] + v[b + 0];
    var o1 = v[a + 1] + v[b + 1];
    var c = o0 >= 0x100000000 | 0;
    v[a + 0] = o0;
    v[a + 1] = o1 + c;
  }

  function sum64w(v, a, b0, b1) {
    var o0 = v[a + 0] + b0;
    var o1 = v[a + 1] + b1;
    var c = o0 >= 0x100000000 | 0;
    v[a + 0] = o0;
    v[a + 1] = o1 + c;
  }

  function G(v, m, a, b, c, d, ix, iy) {
    var x0 = m[ix + 0];
    var x1 = m[ix + 1];
    var y0 = m[iy + 0];
    var y1 = m[iy + 1];
    sum64i(v, a, b);
    sum64w(v, a, x0, x1);
    var xor0 = v[d + 0] ^ v[a + 0];
    var xor1 = v[d + 1] ^ v[a + 1];
    v[d + 0] = xor1;
    v[d + 1] = xor0;
    sum64i(v, c, d);
    var xor2 = v[b + 0] ^ v[c + 0];
    var xor3 = v[b + 1] ^ v[c + 1];
    v[b + 0] = xor2 >>> 24 ^ xor3 << 8;
    v[b + 1] = xor3 >>> 24 ^ xor2 << 8;
    sum64i(v, a, b);
    sum64w(v, a, y0, y1);
    var xor4 = v[d + 0] ^ v[a + 0];
    var xor5 = v[d + 1] ^ v[a + 1];
    v[d + 0] = xor4 >>> 16 ^ xor5 << 16;
    v[d + 1] = xor5 >>> 16 ^ xor4 << 16;
    sum64i(v, c, d);
    var xor6 = v[b + 0] ^ v[c + 0];
    var xor7 = v[b + 1] ^ v[c + 1];
    v[b + 0] = xor7 >>> 31 ^ xor6 << 1;
    v[b + 1] = xor6 >>> 31 ^ xor7 << 1;
  }

  function readU32$5(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }
  /*
   * Expose
   */


  var blake2b = BLAKE2b;

  var blake2bBrowser = blake2b;

  function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * BLAKE2b160
   */


  var BLAKE2b160 = /*#__PURE__*/function (_BLAKE2b) {
    _inherits__default['default'](BLAKE2b160, _BLAKE2b);

    var _super = _createSuper$3(BLAKE2b160);

    function BLAKE2b160() {
      _classCallCheck__default['default'](this, BLAKE2b160);

      return _super.call(this);
    }

    _createClass__default['default'](BLAKE2b160, [{
      key: "init",
      value: function init(key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b160.prototype), "init", this).call(this, 20, key);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2b160();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b160), "hmac", this).call(this, 20);
      }
    }, {
      key: "digest",
      value: function digest(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b160), "digest", this).call(this, data, 20, key);
      }
    }, {
      key: "root",
      value: function root(left, right, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b160), "root", this).call(this, left, right, 20, key);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b160), "multi", this).call(this, x, y, z, 20, key);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b160), "mac", this).call(this, data, key, 20);
      }
    }]);

    return BLAKE2b160;
  }(blake2bBrowser);
  /*
   * Static
   */


  BLAKE2b160.native = blake2bBrowser.native;
  BLAKE2b160.id = 'BLAKE2B160';
  BLAKE2b160.size = 20;
  BLAKE2b160.bits = 160;
  BLAKE2b160.blockSize = 128;
  BLAKE2b160.zero = Buffer.alloc(20, 0x00);
  BLAKE2b160.ctx = new BLAKE2b160();
  /*
   * Expose
   */

  var blake2b160 = BLAKE2b160;

  function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * BLAKE2b256
   */


  var BLAKE2b256 = /*#__PURE__*/function (_BLAKE2b) {
    _inherits__default['default'](BLAKE2b256, _BLAKE2b);

    var _super = _createSuper$4(BLAKE2b256);

    function BLAKE2b256() {
      _classCallCheck__default['default'](this, BLAKE2b256);

      return _super.call(this);
    }

    _createClass__default['default'](BLAKE2b256, [{
      key: "init",
      value: function init(key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b256.prototype), "init", this).call(this, 32, key);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2b256();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b256), "hmac", this).call(this, 32);
      }
    }, {
      key: "digest",
      value: function digest(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b256), "digest", this).call(this, data, 32, key);
      }
    }, {
      key: "root",
      value: function root(left, right, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b256), "root", this).call(this, left, right, 32, key);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b256), "multi", this).call(this, x, y, z, 32, key);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b256), "mac", this).call(this, data, key, 32);
      }
    }]);

    return BLAKE2b256;
  }(blake2bBrowser);
  /*
   * Static
   */


  BLAKE2b256.native = blake2bBrowser.native;
  BLAKE2b256.id = 'BLAKE2B256';
  BLAKE2b256.size = 32;
  BLAKE2b256.bits = 256;
  BLAKE2b256.blockSize = 128;
  BLAKE2b256.zero = Buffer.alloc(32, 0x00);
  BLAKE2b256.ctx = new BLAKE2b256();
  /*
   * Expose
   */

  var blake2b256 = BLAKE2b256;

  function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * BLAKE2b384
   */


  var BLAKE2b384 = /*#__PURE__*/function (_BLAKE2b) {
    _inherits__default['default'](BLAKE2b384, _BLAKE2b);

    var _super = _createSuper$5(BLAKE2b384);

    function BLAKE2b384() {
      _classCallCheck__default['default'](this, BLAKE2b384);

      return _super.call(this);
    }

    _createClass__default['default'](BLAKE2b384, [{
      key: "init",
      value: function init(key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b384.prototype), "init", this).call(this, 48, key);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2b384();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b384), "hmac", this).call(this, 48);
      }
    }, {
      key: "digest",
      value: function digest(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b384), "digest", this).call(this, data, 48, key);
      }
    }, {
      key: "root",
      value: function root(left, right, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b384), "root", this).call(this, left, right, 48, key);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b384), "multi", this).call(this, x, y, z, 48, key);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b384), "mac", this).call(this, data, key, 48);
      }
    }]);

    return BLAKE2b384;
  }(blake2bBrowser);
  /*
   * Static
   */


  BLAKE2b384.native = blake2bBrowser.native;
  BLAKE2b384.id = 'BLAKE2B384';
  BLAKE2b384.size = 48;
  BLAKE2b384.bits = 384;
  BLAKE2b384.blockSize = 128;
  BLAKE2b384.zero = Buffer.alloc(48, 0x00);
  BLAKE2b384.ctx = new BLAKE2b384();
  /*
   * Expose
   */

  var blake2b384 = BLAKE2b384;

  function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * BLAKE2b512
   */


  var BLAKE2b512 = /*#__PURE__*/function (_BLAKE2b) {
    _inherits__default['default'](BLAKE2b512, _BLAKE2b);

    var _super = _createSuper$6(BLAKE2b512);

    function BLAKE2b512() {
      _classCallCheck__default['default'](this, BLAKE2b512);

      return _super.call(this);
    }

    _createClass__default['default'](BLAKE2b512, [{
      key: "init",
      value: function init(key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b512.prototype), "init", this).call(this, 64, key);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2b512();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b512), "hmac", this).call(this, 64);
      }
    }, {
      key: "digest",
      value: function digest(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b512), "digest", this).call(this, data, 64, key);
      }
    }, {
      key: "root",
      value: function root(left, right, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b512), "root", this).call(this, left, right, 64, key);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b512), "multi", this).call(this, x, y, z, 64, key);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2b512), "mac", this).call(this, data, key, 64);
      }
    }]);

    return BLAKE2b512;
  }(blake2bBrowser);
  /*
   * Static
   */


  BLAKE2b512.native = blake2bBrowser.native;
  BLAKE2b512.id = 'BLAKE2B512';
  BLAKE2b512.size = 64;
  BLAKE2b512.bits = 512;
  BLAKE2b512.blockSize = 128;
  BLAKE2b512.zero = Buffer.alloc(64, 0x00);
  BLAKE2b512.ctx = new BLAKE2b512();
  /*
   * Expose
   */

  var blake2b512 = BLAKE2b512;

  /*
   * Constants
   */


  var FINALIZED$3 = 0x80000000;
  var IV$1 = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
  var SIGMA$1 = new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x0e, 0x0a, 0x04, 0x08, 0x09, 0x0f, 0x0d, 0x06, 0x01, 0x0c, 0x00, 0x02, 0x0b, 0x07, 0x05, 0x03, 0x0b, 0x08, 0x0c, 0x00, 0x05, 0x02, 0x0f, 0x0d, 0x0a, 0x0e, 0x03, 0x06, 0x07, 0x01, 0x09, 0x04, 0x07, 0x09, 0x03, 0x01, 0x0d, 0x0c, 0x0b, 0x0e, 0x02, 0x06, 0x05, 0x0a, 0x04, 0x00, 0x0f, 0x08, 0x09, 0x00, 0x05, 0x07, 0x02, 0x04, 0x0a, 0x0f, 0x0e, 0x01, 0x0b, 0x0c, 0x06, 0x08, 0x03, 0x0d, 0x02, 0x0c, 0x06, 0x0a, 0x00, 0x0b, 0x08, 0x03, 0x04, 0x0d, 0x07, 0x05, 0x0f, 0x0e, 0x01, 0x09, 0x0c, 0x05, 0x01, 0x0f, 0x0e, 0x0d, 0x04, 0x0a, 0x00, 0x07, 0x06, 0x03, 0x09, 0x02, 0x08, 0x0b, 0x0d, 0x0b, 0x07, 0x0e, 0x0c, 0x01, 0x03, 0x09, 0x05, 0x00, 0x0f, 0x04, 0x08, 0x06, 0x02, 0x0a, 0x06, 0x0f, 0x0e, 0x09, 0x0b, 0x03, 0x00, 0x08, 0x0c, 0x02, 0x0d, 0x07, 0x01, 0x04, 0x0a, 0x05, 0x0a, 0x02, 0x08, 0x04, 0x07, 0x06, 0x01, 0x05, 0x0f, 0x0b, 0x09, 0x0e, 0x03, 0x0c, 0x0d, 0x00]);
  /**
   * BLAKE2s
   */

  var BLAKE2s = /*#__PURE__*/function () {
    function BLAKE2s() {
      _classCallCheck__default['default'](this, BLAKE2s);

      this.state = new Uint32Array(8);
      this.V = new Uint32Array(16);
      this.M = new Uint32Array(16);
      this.block = Buffer.alloc(64);
      this.size = 32;
      this.count = 0;
      this.pos = FINALIZED$3;
    }

    _createClass__default['default'](BLAKE2s, [{
      key: "init",
      value: function init(size, key) {
        if (size == null) size = 32;
        assert_1$1(size >>> 0 === size);
        assert_1$1(key == null || Buffer.isBuffer(key));
        if (size === 0 || size > 32) throw new Error('Bad output length.');
        if (key && key.length > 32) throw new Error('Bad key length.');
        var klen = key ? key.length : 0;

        for (var i = 0; i < 8; i++) {
          this.state[i] = IV$1[i];
        }

        this.size = size;
        this.count = 0;
        this.pos = 0;
        this.state[0] ^= 0x01010000 ^ klen << 8 ^ this.size;

        if (klen > 0) {
          var block = Buffer.alloc(64, 0x00);
          key.copy(block, 0);
          this.update(block);
        }

        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));
        assert_1$1(!(this.pos & FINALIZED$3), 'Context is not initialized.');
        var off = 0;
        var len = data.length;

        if (len > 0) {
          var left = this.pos;
          var fill = 64 - left;

          if (len > fill) {
            this.pos = 0;
            data.copy(this.block, left, off, off + fill);
            this.count += 64;

            this._compress(this.block, 0, false);

            off += fill;
            len -= fill;

            while (len > 64) {
              this.count += 64;

              this._compress(data, off, false);

              off += 64;
              len -= 64;
            }
          }

          data.copy(this.block, this.pos, off, off + len);
          this.pos += len;
        }

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        assert_1$1(!(this.pos & FINALIZED$3), 'Context is not initialized.');
        this.count += this.pos;
        this.block.fill(0, this.pos, 64);

        this._compress(this.block, 0, true);

        this.pos = FINALIZED$3;
        var out = Buffer.alloc(this.size);

        for (var i = 0; i < this.size; i++) {
          out[i] = this.state[i >>> 2] >>> 8 * (i & 3);
        }

        for (var _i = 0; _i < 8; _i++) {
          this.state[_i] = 0;
        }

        for (var _i2 = 0; _i2 < 16; _i2++) {
          this.V[_i2] = 0;
          this.M[_i2] = 0;
        }

        for (var _i3 = 0; _i3 < 64; _i3++) {
          this.block[_i3] = 0;
        }

        return out;
      }
    }, {
      key: "_compress",
      value: function _compress(block, off, last) {
        var V = this.V,
            M = this.M;

        for (var i = 0; i < 8; i++) {
          V[i] = this.state[i];
          V[i + 8] = IV$1[i];
        } // uint64


        V[12] ^= this.count;
        V[13] ^= this.count * (1 / 0x100000000);

        if (last) {
          // last block
          V[14] ^= -1; // last node

          V[15] ^= 0;
        }

        for (var _i4 = 0; _i4 < 16; _i4++) {
          M[_i4] = readU32$6(block, off);
          off += 4;
        }

        for (var _i5 = 0; _i5 < 10; _i5++) {
          G$1(V, M, 0, 4, 8, 12, SIGMA$1[_i5 * 16 + 0], SIGMA$1[_i5 * 16 + 1]);
          G$1(V, M, 1, 5, 9, 13, SIGMA$1[_i5 * 16 + 2], SIGMA$1[_i5 * 16 + 3]);
          G$1(V, M, 2, 6, 10, 14, SIGMA$1[_i5 * 16 + 4], SIGMA$1[_i5 * 16 + 5]);
          G$1(V, M, 3, 7, 11, 15, SIGMA$1[_i5 * 16 + 6], SIGMA$1[_i5 * 16 + 7]);
          G$1(V, M, 0, 5, 10, 15, SIGMA$1[_i5 * 16 + 8], SIGMA$1[_i5 * 16 + 9]);
          G$1(V, M, 1, 6, 11, 12, SIGMA$1[_i5 * 16 + 10], SIGMA$1[_i5 * 16 + 11]);
          G$1(V, M, 2, 7, 8, 13, SIGMA$1[_i5 * 16 + 12], SIGMA$1[_i5 * 16 + 13]);
          G$1(V, M, 3, 4, 9, 14, SIGMA$1[_i5 * 16 + 14], SIGMA$1[_i5 * 16 + 15]);
        }

        for (var _i6 = 0; _i6 < 8; _i6++) {
          this.state[_i6] ^= V[_i6] ^ V[_i6 + 8];
        }
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2s();
      }
    }, {
      key: "hmac",
      value: function hmac$1(size) {
        return new hmac(BLAKE2s, 64, [size]);
      }
    }, {
      key: "digest",
      value: function digest(data, size, key) {
        var ctx = BLAKE2s.ctx;
        ctx.init(size, key);
        ctx.update(data);
        return ctx.final();
      }
    }, {
      key: "root",
      value: function root(left, right, size, key) {
        if (size == null) size = 32;
        assert_1$1(Buffer.isBuffer(left) && left.length === size);
        assert_1$1(Buffer.isBuffer(right) && right.length === size);
        var ctx = BLAKE2s.ctx;
        ctx.init(size, key);
        ctx.update(left);
        ctx.update(right);
        return ctx.final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, size, key) {
        var ctx = BLAKE2s.ctx;
        ctx.init(size, key);
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key, size) {
        return BLAKE2s.hmac(size).init(key).update(data).final();
      }
    }]);

    return BLAKE2s;
  }();
  /*
   * Static
   */


  BLAKE2s.native = 0;
  BLAKE2s.id = 'BLAKE2S256';
  BLAKE2s.size = 32;
  BLAKE2s.bits = 256;
  BLAKE2s.blockSize = 64;
  BLAKE2s.zero = Buffer.alloc(32, 0x00);
  BLAKE2s.ctx = new BLAKE2s();
  /*
   * Helpers
   */

  function rotr32(x, y) {
    return x >>> y ^ x << 32 - y;
  }

  function G$1(v, m, a, b, c, d, ix, iy) {
    var x = m[ix];
    var y = m[iy];
    v[a] = v[a] + v[b] + x;
    v[d] = rotr32(v[d] ^ v[a], 16);
    v[c] = v[c] + v[d];
    v[b] = rotr32(v[b] ^ v[c], 12);
    v[a] = v[a] + v[b] + y;
    v[d] = rotr32(v[d] ^ v[a], 8);
    v[c] = v[c] + v[d];
    v[b] = rotr32(v[b] ^ v[c], 7);
  }

  function readU32$6(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }
  /*
   * Expose
   */


  var blake2s = BLAKE2s;

  var blake2sBrowser = blake2s;

  function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * BLAKE2s128
   */


  var BLAKE2s128 = /*#__PURE__*/function (_BLAKE2s) {
    _inherits__default['default'](BLAKE2s128, _BLAKE2s);

    var _super = _createSuper$7(BLAKE2s128);

    function BLAKE2s128() {
      _classCallCheck__default['default'](this, BLAKE2s128);

      return _super.call(this);
    }

    _createClass__default['default'](BLAKE2s128, [{
      key: "init",
      value: function init(key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s128.prototype), "init", this).call(this, 16, key);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2s128();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s128), "hmac", this).call(this, 16);
      }
    }, {
      key: "digest",
      value: function digest(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s128), "digest", this).call(this, data, 16, key);
      }
    }, {
      key: "root",
      value: function root(left, right, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s128), "root", this).call(this, left, right, 16, key);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s128), "multi", this).call(this, x, y, z, 16, key);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s128), "mac", this).call(this, data, key, 16);
      }
    }]);

    return BLAKE2s128;
  }(blake2sBrowser);
  /*
   * Static
   */


  BLAKE2s128.native = blake2sBrowser.native;
  BLAKE2s128.id = 'BLAKE2S128';
  BLAKE2s128.size = 16;
  BLAKE2s128.bits = 128;
  BLAKE2s128.blockSize = 64;
  BLAKE2s128.zero = Buffer.alloc(16, 0x00);
  BLAKE2s128.ctx = new BLAKE2s128();
  /*
   * Expose
   */

  var blake2s128 = BLAKE2s128;

  function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * BLAKE2s160
   */


  var BLAKE2s160 = /*#__PURE__*/function (_BLAKE2s) {
    _inherits__default['default'](BLAKE2s160, _BLAKE2s);

    var _super = _createSuper$8(BLAKE2s160);

    function BLAKE2s160() {
      _classCallCheck__default['default'](this, BLAKE2s160);

      return _super.call(this);
    }

    _createClass__default['default'](BLAKE2s160, [{
      key: "init",
      value: function init(key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s160.prototype), "init", this).call(this, 20, key);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2s160();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s160), "hmac", this).call(this, 20);
      }
    }, {
      key: "digest",
      value: function digest(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s160), "digest", this).call(this, data, 20, key);
      }
    }, {
      key: "root",
      value: function root(left, right, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s160), "root", this).call(this, left, right, 20, key);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s160), "multi", this).call(this, x, y, z, 20, key);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s160), "mac", this).call(this, data, key, 20);
      }
    }]);

    return BLAKE2s160;
  }(blake2sBrowser);
  /*
   * Static
   */


  BLAKE2s160.native = blake2sBrowser.native;
  BLAKE2s160.id = 'BLAKE2S160';
  BLAKE2s160.size = 20;
  BLAKE2s160.bits = 160;
  BLAKE2s160.blockSize = 64;
  BLAKE2s160.zero = Buffer.alloc(20, 0x00);
  BLAKE2s160.ctx = new BLAKE2s160();
  /*
   * Expose
   */

  var blake2s160 = BLAKE2s160;

  function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * BLAKE2s224
   */


  var BLAKE2s224 = /*#__PURE__*/function (_BLAKE2s) {
    _inherits__default['default'](BLAKE2s224, _BLAKE2s);

    var _super = _createSuper$9(BLAKE2s224);

    function BLAKE2s224() {
      _classCallCheck__default['default'](this, BLAKE2s224);

      return _super.call(this);
    }

    _createClass__default['default'](BLAKE2s224, [{
      key: "init",
      value: function init(key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s224.prototype), "init", this).call(this, 28, key);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2s224();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s224), "hmac", this).call(this, 28);
      }
    }, {
      key: "digest",
      value: function digest(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s224), "digest", this).call(this, data, 28, key);
      }
    }, {
      key: "root",
      value: function root(left, right, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s224), "root", this).call(this, left, right, 28, key);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s224), "multi", this).call(this, x, y, z, 28, key);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s224), "mac", this).call(this, data, key, 28);
      }
    }]);

    return BLAKE2s224;
  }(blake2sBrowser);
  /*
   * Static
   */


  BLAKE2s224.native = blake2sBrowser.native;
  BLAKE2s224.id = 'BLAKE2S224';
  BLAKE2s224.size = 28;
  BLAKE2s224.bits = 224;
  BLAKE2s224.blockSize = 64;
  BLAKE2s224.zero = Buffer.alloc(28, 0x00);
  BLAKE2s224.ctx = new BLAKE2s224();
  /*
   * Expose
   */

  var blake2s224 = BLAKE2s224;

  function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * BLAKE2s256
   */


  var BLAKE2s256 = /*#__PURE__*/function (_BLAKE2s) {
    _inherits__default['default'](BLAKE2s256, _BLAKE2s);

    var _super = _createSuper$a(BLAKE2s256);

    function BLAKE2s256() {
      _classCallCheck__default['default'](this, BLAKE2s256);

      return _super.call(this);
    }

    _createClass__default['default'](BLAKE2s256, [{
      key: "init",
      value: function init(key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s256.prototype), "init", this).call(this, 32, key);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new BLAKE2s256();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s256), "hmac", this).call(this, 32);
      }
    }, {
      key: "digest",
      value: function digest(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s256), "digest", this).call(this, data, 32, key);
      }
    }, {
      key: "root",
      value: function root(left, right, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s256), "root", this).call(this, left, right, 32, key);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s256), "multi", this).call(this, x, y, z, 32, key);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](BLAKE2s256), "mac", this).call(this, data, key, 32);
      }
    }]);

    return BLAKE2s256;
  }(blake2sBrowser);
  /*
   * Static
   */


  BLAKE2s256.native = blake2sBrowser.native;
  BLAKE2s256.id = 'BLAKE2S256';
  BLAKE2s256.size = 32;
  BLAKE2s256.bits = 256;
  BLAKE2s256.blockSize = 64;
  BLAKE2s256.zero = Buffer.alloc(32, 0x00);
  BLAKE2s256.ctx = new BLAKE2s256();
  /*
   * Expose
   */

  var blake2s256 = BLAKE2s256;

  var BigInteger = createCommonjsModule(function (module) {
    var bigInt = function (undefined$1) {

      var BASE = 1e7,
          LOG_BASE = 7,
          MAX_INT = 9007199254740992,
          MAX_INT_ARR = smallToArray(MAX_INT),
          DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      var supportsNativeBigInt = typeof BigInt === "function";

      function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
      }

      function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
      }

      BigInteger.prototype = Object.create(Integer.prototype);

      function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
      }

      SmallInteger.prototype = Object.create(Integer.prototype);

      function NativeBigInt(value) {
        this.value = value;
      }

      NativeBigInt.prototype = Object.create(Integer.prototype);

      function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
      }

      function smallToArray(n) {
        // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7) return [n];
        if (n < 1e14) return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
      }

      function arrayToSmall(arr) {
        // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;

        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
          switch (length) {
            case 0:
              return 0;

            case 1:
              return arr[0];

            case 2:
              return arr[0] + arr[1] * BASE;

            default:
              return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
          }
        }

        return arr;
      }

      function trim(v) {
        var i = v.length;

        while (v[--i] === 0) {
        }

        v.length = i + 1;
      }

      function createArray(length) {
        // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;

        while (++i < length) {
          x[i] = 0;
        }

        return x;
      }

      function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
      }

      function add(a, b) {
        // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum,
            i;

        for (i = 0; i < l_b; i++) {
          sum = a[i] + b[i] + carry;
          carry = sum >= base ? 1 : 0;
          r[i] = sum - carry * base;
        }

        while (i < l_a) {
          sum = a[i] + carry;
          carry = sum === base ? 1 : 0;
          r[i++] = sum - carry * base;
        }

        if (carry > 0) r.push(carry);
        return r;
      }

      function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
      }

      function addSmall(a, carry) {
        // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum,
            i;

        for (i = 0; i < l; i++) {
          sum = a[i] - base + carry;
          carry = Math.floor(sum / base);
          r[i] = sum - carry * base;
          carry += 1;
        }

        while (carry > 0) {
          r[i++] = carry % base;
          carry = Math.floor(carry / base);
        }

        return r;
      }

      BigInteger.prototype.add = function (v) {
        var n = parseValue(v);

        if (this.sign !== n.sign) {
          return this.subtract(n.negate());
        }

        var a = this.value,
            b = n.value;

        if (n.isSmall) {
          return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }

        return new BigInteger(addAny(a, b), this.sign);
      };

      BigInteger.prototype.plus = BigInteger.prototype.add;

      SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;

        if (a < 0 !== n.sign) {
          return this.subtract(n.negate());
        }

        var b = n.value;

        if (n.isSmall) {
          if (isPrecise(a + b)) return new SmallInteger(a + b);
          b = smallToArray(Math.abs(b));
        }

        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
      };

      SmallInteger.prototype.plus = SmallInteger.prototype.add;

      NativeBigInt.prototype.add = function (v) {
        return new NativeBigInt(this.value + parseValue(v).value);
      };

      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;

      function subtract(a, b) {
        // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i,
            difference;

        for (i = 0; i < b_l; i++) {
          difference = a[i] - borrow - b[i];

          if (difference < 0) {
            difference += base;
            borrow = 1;
          } else borrow = 0;

          r[i] = difference;
        }

        for (i = b_l; i < a_l; i++) {
          difference = a[i] - borrow;
          if (difference < 0) difference += base;else {
            r[i++] = difference;
            break;
          }
          r[i] = difference;
        }

        for (; i < a_l; i++) {
          r[i] = a[i];
        }

        trim(r);
        return r;
      }

      function subtractAny(a, b, sign) {
        var value;

        if (compareAbs(a, b) >= 0) {
          value = subtract(a, b);
        } else {
          value = subtract(b, a);
          sign = !sign;
        }

        value = arrayToSmall(value);

        if (typeof value === "number") {
          if (sign) value = -value;
          return new SmallInteger(value);
        }

        return new BigInteger(value, sign);
      }

      function subtractSmall(a, b, sign) {
        // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i,
            difference;

        for (i = 0; i < l; i++) {
          difference = a[i] + carry;
          carry = Math.floor(difference / base);
          difference %= base;
          r[i] = difference < 0 ? difference + base : difference;
        }

        r = arrayToSmall(r);

        if (typeof r === "number") {
          if (sign) r = -r;
          return new SmallInteger(r);
        }

        return new BigInteger(r, sign);
      }

      BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);

        if (this.sign !== n.sign) {
          return this.add(n.negate());
        }

        var a = this.value,
            b = n.value;
        if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
      };

      BigInteger.prototype.minus = BigInteger.prototype.subtract;

      SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;

        if (a < 0 !== n.sign) {
          return this.add(n.negate());
        }

        var b = n.value;

        if (n.isSmall) {
          return new SmallInteger(a - b);
        }

        return subtractSmall(b, Math.abs(a), a >= 0);
      };

      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

      NativeBigInt.prototype.subtract = function (v) {
        return new NativeBigInt(this.value - parseValue(v).value);
      };

      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;

      BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
      };

      SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
      };

      NativeBigInt.prototype.negate = function () {
        return new NativeBigInt(-this.value);
      };

      BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
      };

      SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
      };

      NativeBigInt.prototype.abs = function () {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
      };

      function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product,
            carry,
            i,
            a_i,
            b_j;

        for (i = 0; i < a_l; ++i) {
          a_i = a[i];

          for (var j = 0; j < b_l; ++j) {
            b_j = b[j];
            product = a_i * b_j + r[i + j];
            carry = Math.floor(product / base);
            r[i + j] = product - carry * base;
            r[i + j + 1] += carry;
          }
        }

        trim(r);
        return r;
      }

      function multiplySmall(a, b) {
        // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product,
            i;

        for (i = 0; i < l; i++) {
          product = a[i] * b + carry;
          carry = Math.floor(product / base);
          r[i] = product - carry * base;
        }

        while (carry > 0) {
          r[i++] = carry % base;
          carry = Math.floor(carry / base);
        }

        return r;
      }

      function shiftLeft(x, n) {
        var r = [];

        while (n-- > 0) {
          r.push(0);
        }

        return r.concat(x);
      }

      function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);
        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);
        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);
        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
      } // The following function is derived from a surface fit of a graph plotting the performance difference
      // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.


      function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
      }

      BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            sign = this.sign !== n.sign,
            abs;

        if (n.isSmall) {
          if (b === 0) return Integer[0];
          if (b === 1) return this;
          if (b === -1) return this.negate();
          abs = Math.abs(b);

          if (abs < BASE) {
            return new BigInteger(multiplySmall(a, abs), sign);
          }

          b = smallToArray(abs);
        }

        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
          return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
      };

      BigInteger.prototype.times = BigInteger.prototype.multiply;

      function multiplySmallAndArray(a, b, sign) {
        // a >= 0
        if (a < BASE) {
          return new BigInteger(multiplySmall(b, a), sign);
        }

        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
      }

      SmallInteger.prototype._multiplyBySmall = function (a) {
        if (isPrecise(a.value * this.value)) {
          return new SmallInteger(a.value * this.value);
        }

        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
      };

      BigInteger.prototype._multiplyBySmall = function (a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
      };

      SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
      };

      SmallInteger.prototype.times = SmallInteger.prototype.multiply;

      NativeBigInt.prototype.multiply = function (v) {
        return new NativeBigInt(this.value * parseValue(v).value);
      };

      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;

      function square(a) {
        //console.assert(2 * BASE * BASE < MAX_INT);
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product,
            carry,
            i,
            a_i,
            a_j;

        for (i = 0; i < l; i++) {
          a_i = a[i];
          carry = 0 - a_i * a_i;

          for (var j = i; j < l; j++) {
            a_j = a[j];
            product = 2 * (a_i * a_j) + r[i + j] + carry;
            carry = Math.floor(product / base);
            r[i + j] = product - carry * base;
          }

          r[i + l] = carry;
        }

        trim(r);
        return r;
      }

      BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
      };

      SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
      };

      NativeBigInt.prototype.square = function (v) {
        return new NativeBigInt(this.value * this.value);
      };

      function divMod1(a, b) {
        // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
        lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit,
            shift,
            carry,
            borrow,
            i,
            l,
            q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];

        for (shift = a_l - b_l; shift >= 0; shift--) {
          quotientDigit = base - 1;

          if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
            quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
          } // quotientDigit <= base - 1


          carry = 0;
          borrow = 0;
          l = divisor.length;

          for (i = 0; i < l; i++) {
            carry += quotientDigit * divisor[i];
            q = Math.floor(carry / base);
            borrow += remainder[shift + i] - (carry - q * base);
            carry = q;

            if (borrow < 0) {
              remainder[shift + i] = borrow + base;
              borrow = -1;
            } else {
              remainder[shift + i] = borrow;
              borrow = 0;
            }
          }

          while (borrow !== 0) {
            quotientDigit -= 1;
            carry = 0;

            for (i = 0; i < l; i++) {
              carry += remainder[shift + i] - base + divisor[i];

              if (carry < 0) {
                remainder[shift + i] = carry + base;
                carry = 0;
              } else {
                remainder[shift + i] = carry;
                carry = 1;
              }
            }

            borrow += carry;
          }

          result[shift] = quotientDigit;
        } // denormalization


        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
      }

      function divMod2(a, b) {
        // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess,
            xlen,
            highx,
            highy,
            check;

        while (a_l) {
          part.unshift(a[--a_l]);
          trim(part);

          if (compareAbs(part, b) < 0) {
            result.push(0);
            continue;
          }

          xlen = part.length;
          highx = part[xlen - 1] * base + part[xlen - 2];
          highy = b[b_l - 1] * base + b[b_l - 2];

          if (xlen > b_l) {
            highx = (highx + 1) * base;
          }

          guess = Math.ceil(highx / highy);

          do {
            check = multiplySmall(b, guess);
            if (compareAbs(check, part) <= 0) break;
            guess--;
          } while (guess);

          result.push(guess);
          part = subtract(part, check);
        }

        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
      }

      function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i,
            q,
            remainder,
            divisor;
        remainder = 0;

        for (i = length - 1; i >= 0; --i) {
          divisor = remainder * base + value[i];
          q = truncate(divisor / lambda);
          remainder = divisor - q * lambda;
          quotient[i] = q | 0;
        }

        return [quotient, remainder | 0];
      }

      function divModAny(self, v) {
        var value,
            n = parseValue(v);

        if (supportsNativeBigInt) {
          return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
        }

        var a = self.value,
            b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");

        if (self.isSmall) {
          if (n.isSmall) {
            return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
          }

          return [Integer[0], self];
        }

        if (n.isSmall) {
          if (b === 1) return [self, Integer[0]];
          if (b == -1) return [self.negate(), Integer[0]];
          var abs = Math.abs(b);

          if (abs < BASE) {
            value = divModSmall(a, abs);
            quotient = arrayToSmall(value[0]);
            var remainder = value[1];
            if (self.sign) remainder = -remainder;

            if (typeof quotient === "number") {
              if (self.sign !== n.sign) quotient = -quotient;
              return [new SmallInteger(quotient), new SmallInteger(remainder)];
            }

            return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
          }

          b = smallToArray(abs);
        }

        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]]; // divMod1 is faster on smaller input sizes

        if (a.length + b.length <= 200) value = divMod1(a, b);else value = divMod2(a, b);
        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;

        if (typeof quotient === "number") {
          if (qSign) quotient = -quotient;
          quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);

        if (typeof mod === "number") {
          if (mSign) mod = -mod;
          mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);

        return [quotient, mod];
      }

      BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
          quotient: result[0],
          remainder: result[1]
        };
      };

      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;

      BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
      };

      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
        return new NativeBigInt(this.value / parseValue(v).value);
      };

      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

      BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
      };

      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
        return new NativeBigInt(this.value % parseValue(v).value);
      };

      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

      BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value,
            x,
            y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];

        if (n.sign) {
          return Integer[0];
        }

        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");

        if (this.isSmall) {
          if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
        }

        x = this;
        y = Integer[1];

        while (true) {
          if (b & 1 === 1) {
            y = y.times(x);
            --b;
          }

          if (b === 0) break;
          b /= 2;
          x = x.square();
        }

        return y;
      };

      SmallInteger.prototype.pow = BigInteger.prototype.pow;

      NativeBigInt.prototype.pow = function (v) {
        var n = parseValue(v);
        var a = this.value,
            b = n.value;

        var _0 = BigInt(0),
            _1 = BigInt(1),
            _2 = BigInt(2);

        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];

        while (true) {
          if ((b & _1) === _1) {
            y = y.times(x);
            --b;
          }

          if (b === _0) break;
          b /= _2;
          x = x.square();
        }

        return y;
      };

      BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);

        if (exp.isNegative()) {
          exp = exp.multiply(Integer[-1]);
          base = base.modInv(mod);
        }

        while (exp.isPositive()) {
          if (base.isZero()) return Integer[0];
          if (exp.isOdd()) r = r.multiply(base).mod(mod);
          exp = exp.divide(2);
          base = base.square().mod(mod);
        }

        return r;
      };

      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

      function compareAbs(a, b) {
        if (a.length !== b.length) {
          return a.length > b.length ? 1 : -1;
        }

        for (var i = a.length - 1; i >= 0; i--) {
          if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }

        return 0;
      }

      BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
      };

      SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;

        if (n.isSmall) {
          b = Math.abs(b);
          return a === b ? 0 : a > b ? 1 : -1;
        }

        return -1;
      };

      NativeBigInt.prototype.compareAbs = function (v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
      };

      BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
          return -1;
        }

        if (v === -Infinity) {
          return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;

        if (this.sign !== n.sign) {
          return n.sign ? 1 : -1;
        }

        if (n.isSmall) {
          return this.sign ? -1 : 1;
        }

        return compareAbs(a, b) * (this.sign ? -1 : 1);
      };

      BigInteger.prototype.compareTo = BigInteger.prototype.compare;

      SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
          return -1;
        }

        if (v === -Infinity) {
          return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;

        if (n.isSmall) {
          return a == b ? 0 : a > b ? 1 : -1;
        }

        if (a < 0 !== n.sign) {
          return a < 0 ? -1 : 1;
        }

        return a < 0 ? 1 : -1;
      };

      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

      NativeBigInt.prototype.compare = function (v) {
        if (v === Infinity) {
          return -1;
        }

        if (v === -Infinity) {
          return 1;
        }

        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
      };

      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;

      BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
      };

      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

      BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
      };

      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

      BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
      };

      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

      BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
      };

      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

      BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
      };

      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

      BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
      };

      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

      BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
      };

      SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
      };

      NativeBigInt.prototype.isEven = function () {
        return (this.value & BigInt(1)) === BigInt(0);
      };

      BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
      };

      SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
      };

      NativeBigInt.prototype.isOdd = function () {
        return (this.value & BigInt(1)) === BigInt(1);
      };

      BigInteger.prototype.isPositive = function () {
        return !this.sign;
      };

      SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
      };

      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;

      BigInteger.prototype.isNegative = function () {
        return this.sign;
      };

      SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
      };

      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;

      BigInteger.prototype.isUnit = function () {
        return false;
      };

      SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
      };

      NativeBigInt.prototype.isUnit = function () {
        return this.abs().value === BigInt(1);
      };

      BigInteger.prototype.isZero = function () {
        return false;
      };

      SmallInteger.prototype.isZero = function () {
        return this.value === 0;
      };

      NativeBigInt.prototype.isZero = function () {
        return this.value === BigInt(0);
      };

      BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
      };

      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

      function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true; // we don't know if it's prime: let the other functions figure it out
      }

      function millerRabinTest(n, a) {
        var nPrev = n.prev(),
            b = nPrev,
            r = 0,
            d,
            i,
            x;

        while (b.isEven()) {
          b = b.divide(2), r++;
        }

        next: for (i = 0; i < a.length; i++) {
          if (n.lesser(a[i])) continue;
          x = bigInt(a[i]).modPow(b, n);
          if (x.isUnit() || x.equals(nPrev)) continue;

          for (d = r - 1; d != 0; d--) {
            x = x.square().mod(n);
            if (x.isUnit()) return false;
            if (x.equals(nPrev)) continue next;
          }

          return false;
        }

        return true;
      } // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2


      BigInteger.prototype.isPrime = function (strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64) return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);

        for (var a = [], i = 0; i < t; i++) {
          a.push(bigInt(i + 2));
        }

        return millerRabinTest(n, a);
      };

      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

      BigInteger.prototype.isProbablePrime = function (iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1) return isPrime;
        var n = this.abs();
        var t = iterations === undefined$1 ? 5 : iterations;

        for (var a = [], i = 0; i < t; i++) {
          a.push(bigInt.randBetween(2, n.minus(2), rng));
        }

        return millerRabinTest(n, a);
      };

      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

      BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero,
            newT = bigInt.one,
            r = parseValue(n),
            newR = this.abs(),
            q,
            lastT,
            lastR;

        while (!newR.isZero()) {
          q = r.divide(newR);
          lastT = t;
          lastR = r;
          t = newT;
          r = newR;
          newT = lastT.subtract(q.multiply(newT));
          newR = lastR.subtract(q.multiply(newR));
        }

        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");

        if (t.compare(0) === -1) {
          t = t.add(n);
        }

        if (this.isNegative()) {
          return t.negate();
        }

        return t;
      };

      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

      BigInteger.prototype.next = function () {
        var value = this.value;

        if (this.sign) {
          return subtractSmall(value, 1, this.sign);
        }

        return new BigInteger(addSmall(value, 1), this.sign);
      };

      SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
      };

      NativeBigInt.prototype.next = function () {
        return new NativeBigInt(this.value + BigInt(1));
      };

      BigInteger.prototype.prev = function () {
        var value = this.value;

        if (this.sign) {
          return new BigInteger(addSmall(value, 1), true);
        }

        return subtractSmall(value, 1, this.sign);
      };

      SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
      };

      NativeBigInt.prototype.prev = function () {
        return new NativeBigInt(this.value - BigInt(1));
      };

      var powersOfTwo = [1];

      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) {
        powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
      }

      var powers2Length = powersOfTwo.length,
          highestPower2 = powersOfTwo[powers2Length - 1];

      function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
      }

      BigInteger.prototype.shiftLeft = function (v) {
        var n = parseValue(v).toJSNumber();

        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }

        if (n < 0) return this.shiftRight(-n);
        var result = this;
        if (result.isZero()) return result;

        while (n >= powers2Length) {
          result = result.multiply(highestPower2);
          n -= powers2Length - 1;
        }

        return result.multiply(powersOfTwo[n]);
      };

      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

      BigInteger.prototype.shiftRight = function (v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();

        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }

        if (n < 0) return this.shiftLeft(-n);
        var result = this;

        while (n >= powers2Length) {
          if (result.isZero() || result.isNegative() && result.isUnit()) return result;
          remQuo = divModAny(result, highestPower2);
          result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
          n -= powers2Length - 1;
        }

        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
      };

      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

      function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(),
            ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0,
            yDigit = 0;
        var xDivMod = null,
            yDivMod = null;
        var result = [];

        while (!xRem.isZero() || !yRem.isZero()) {
          xDivMod = divModAny(xRem, highestPower2);
          xDigit = xDivMod[1].toJSNumber();

          if (xSign) {
            xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
          }

          yDivMod = divModAny(yRem, highestPower2);
          yDigit = yDivMod[1].toJSNumber();

          if (ySign) {
            yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
          }

          xRem = xDivMod[0];
          yRem = yDivMod[0];
          result.push(fn(xDigit, yDigit));
        }

        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);

        for (var i = result.length - 1; i >= 0; i -= 1) {
          sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }

        return sum;
      }

      BigInteger.prototype.not = function () {
        return this.negate().prev();
      };

      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;

      BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) {
          return a & b;
        });
      };

      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;

      BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) {
          return a | b;
        });
      };

      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;

      BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) {
          return a ^ b;
        });
      };

      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
      var LOBMASK_I = 1 << 30,
          LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;

      function roughLOB(n) {
        // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value,
            x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
      }

      function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
          var tmp = integerLogarithm(value, base.square(base));
          var p = tmp.p;
          var e = tmp.e;
          var t = p.multiply(base);
          return t.compareTo(value) <= 0 ? {
            p: t,
            e: e * 2 + 1
          } : {
            p: p,
            e: e * 2
          };
        }

        return {
          p: bigInt(1),
          e: 0
        };
      }

      BigInteger.prototype.bitLength = function () {
        var n = this;

        if (n.compareTo(bigInt(0)) < 0) {
          n = n.negate().subtract(bigInt(1));
        }

        if (n.compareTo(bigInt(0)) === 0) {
          return bigInt(0);
        }

        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
      };

      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;

      function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
      }

      function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
      }

      function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1],
            d,
            t;

        while (a.isEven() && b.isEven()) {
          d = min(roughLOB(a), roughLOB(b));
          a = a.divide(d);
          b = b.divide(d);
          c = c.multiply(d);
        }

        while (a.isEven()) {
          a = a.divide(roughLOB(a));
        }

        do {
          while (b.isEven()) {
            b = b.divide(roughLOB(b));
          }

          if (a.greater(b)) {
            t = b;
            b = a;
            a = t;
          }

          b = b.subtract(a);
        } while (!b.isZero());

        return c.isUnit() ? a : a.multiply(c);
      }

      function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
      }

      function randBetween(a, b, rng) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng || Math.random;
        var low = min(a, b),
            high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [],
            restricted = true;

        for (var i = 0; i < digits.length; i++) {
          var top = restricted ? digits[i] : BASE;
          var digit = truncate(usedRNG() * top);
          result.push(digit);
          if (digit < top) restricted = false;
        }

        return low.add(Integer.fromArray(result, BASE, false));
      }

      var parseBase = function parseBase(text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);

        if (!caseSensitive) {
          text = text.toLowerCase();
          alphabet = alphabet.toLowerCase();
        }

        var length = text.length;
        var i;
        var absBase = Math.abs(base);
        var alphabetValues = {};

        for (i = 0; i < alphabet.length; i++) {
          alphabetValues[alphabet[i]] = i;
        }

        for (i = 0; i < length; i++) {
          var c = text[i];
          if (c === "-") continue;

          if (c in alphabetValues) {
            if (alphabetValues[c] >= absBase) {
              if (c === "1" && absBase === 1) continue;
              throw new Error(c + " is not a valid digit in base " + base + ".");
            }
          }
        }

        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";

        for (i = isNegative ? 1 : 0; i < text.length; i++) {
          var c = text[i];
          if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));else if (c === "<") {
            var start = i;

            do {
              i++;
            } while (text[i] !== ">" && i < text.length);

            digits.push(parseValue(text.slice(start + 1, i)));
          } else throw new Error(c + " is not a valid character");
        }

        return parseBaseFromArray(digits, base, isNegative);
      };

      function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0],
            pow = Integer[1],
            i;

        for (i = digits.length - 1; i >= 0; i--) {
          val = val.add(digits[i].times(pow));
          pow = pow.times(base);
        }

        return isNegative ? val.negate() : val;
      }

      function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;

        if (digit < alphabet.length) {
          return alphabet[digit];
        }

        return "<" + digit + ">";
      }

      function toBase(n, base) {
        base = bigInt(base);

        if (base.isZero()) {
          if (n.isZero()) return {
            value: [0],
            isNegative: false
          };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }

        if (base.equals(-1)) {
          if (n.isZero()) return {
            value: [0],
            isNegative: false
          };
          if (n.isNegative()) return {
            value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
            isNegative: false
          };
          var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
          arr.unshift([1]);
          return {
            value: [].concat.apply([], arr),
            isNegative: false
          };
        }

        var neg = false;

        if (n.isNegative() && base.isPositive()) {
          neg = true;
          n = n.abs();
        }

        if (base.isUnit()) {
          if (n.isZero()) return {
            value: [0],
            isNegative: false
          };
          return {
            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
            isNegative: neg
          };
        }

        var out = [];
        var left = n,
            divmod;

        while (left.isNegative() || left.compareAbs(base) >= 0) {
          divmod = left.divmod(base);
          left = divmod.quotient;
          var digit = divmod.remainder;

          if (digit.isNegative()) {
            digit = base.minus(digit).abs();
            left = left.next();
          }

          out.push(digit.toJSNumber());
        }

        out.push(left.toJSNumber());
        return {
          value: out.reverse(),
          isNegative: neg
        };
      }

      function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
          return stringify(x, alphabet);
        }).join('');
      }

      BigInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
      };

      SmallInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
      };

      NativeBigInt.prototype.toArray = function (radix) {
        return toBase(this, radix);
      };

      BigInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined$1) radix = 10;
        if (radix !== 10) return toBaseString(this, radix, alphabet);
        var v = this.value,
            l = v.length,
            str = String(v[--l]),
            zeros = "0000000",
            digit;

        while (--l >= 0) {
          digit = String(v[l]);
          str += zeros.slice(digit.length) + digit;
        }

        var sign = this.sign ? "-" : "";
        return sign + str;
      };

      SmallInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined$1) radix = 10;
        if (radix != 10) return toBaseString(this, radix, alphabet);
        return String(this.value);
      };

      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;

      NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () {
        return this.toString();
      };

      BigInteger.prototype.valueOf = function () {
        return parseInt(this.toString(), 10);
      };

      BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

      SmallInteger.prototype.valueOf = function () {
        return this.value;
      };

      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;

      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
        return parseInt(this.toString(), 10);
      };

      function parseStringValue(v) {
        if (isPrecise(+v)) {
          var x = +v;
          if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
          throw new Error("Invalid integer: " + v);
        }

        var sign = v[0] === "-";
        if (sign) v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));

        if (split.length === 2) {
          var exp = split[1];
          if (exp[0] === "+") exp = exp.slice(1);
          exp = +exp;
          if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
          var text = split[0];
          var decimalPlace = text.indexOf(".");

          if (decimalPlace >= 0) {
            exp -= text.length - decimalPlace - 1;
            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
          }

          if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
          text += new Array(exp + 1).join("0");
          v = text;
        }

        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);

        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }

        var r = [],
            max = v.length,
            l = LOG_BASE,
            min = max - l;

        while (max > 0) {
          r.push(+v.slice(min, max));
          min -= l;
          if (min < 0) min = 0;
          max -= l;
        }

        trim(r);
        return new BigInteger(r, sign);
      }

      function parseNumberValue(v) {
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(v));
        }

        if (isPrecise(v)) {
          if (v !== truncate(v)) throw new Error(v + " is not an integer.");
          return new SmallInteger(v);
        }

        return parseStringValue(v.toString());
      }

      function parseValue(v) {
        if (typeof v === "number") {
          return parseNumberValue(v);
        }

        if (typeof v === "string") {
          return parseStringValue(v);
        }

        if (typeof v === "bigint") {
          return new NativeBigInt(v);
        }

        return v;
      } // Pre-define numbers in range [-999,999]


      for (var i = 0; i < 1000; i++) {
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
      } // Backwards compatibility


      Integer.one = Integer[1];
      Integer.zero = Integer[0];
      Integer.minusOne = Integer[-1];
      Integer.max = max;
      Integer.min = min;
      Integer.gcd = gcd;
      Integer.lcm = lcm;

      Integer.isInstance = function (x) {
        return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
      };

      Integer.randBetween = randBetween;

      Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
      };

      return Integer;
    }(); // Node.js check


    if ( module.hasOwnProperty("exports")) {
      module.exports = bigInt;
    } //amd check
  });

  /*!
   * custom.js - custom inspect symbol for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */

  var custom = 'inspect';
  var customBrowser = {
    custom: custom
  };

  function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _createForOfIteratorHelper$1(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var custom$1 = customBrowser.custom;
  /*
   * Constants
   */

  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
  var groupSizes = [0x00, 0x19, 0x10, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05];
  var groupBases = [0x00000000, 0x02000000, 0x0290d741, 0x01000000, 0x02e90edd, 0x039aa400, 0x0267bf47, 0x01000000, 0x0290d741, 0x00989680, 0x012959c3, 0x0222c000, 0x03bd7765, 0x0072e440, 0x00adcea1, 0x01000000, 0x01704f61, 0x0206fc40, 0x02cddcf9, 0x03d09000, 0x003e5185, 0x004ea360, 0x006235f7, 0x00798000, 0x009502f9, 0x00b54ba0, 0x00daf26b, 0x01069c00, 0x0138f9ad, 0x0172c9e0, 0x01b4d89f, 0x02000000, 0x025528a1, 0x02b54a20, 0x03216b93, 0x039aa400];
  var primes = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  };
  var modes$1 = {
    NONE: 0,
    QUO: 1,
    REM: 2,
    BOTH: 3,
    EUCLID: 4,
    ALL: 7
  };
  var WND_WIDTH = 4;
  var WND_SIZE = 1 << WND_WIDTH - 1;
  var HAS_BIGINT = typeof BigInteger === 'function';
  /**
   * BN
   */

  var BN = /*#__PURE__*/function () {
    function BN(num, base, endian) {
      _classCallCheck__default['default'](this, BN);

      this.words = [0];
      this.length = 1;
      this.negative = 0;
      this.red = null;
      this.from(num, base, endian);
    }
    /*
     * Addition Engine
     */


    _createClass__default['default'](BN, [{
      key: "_iadd",
      value: function _iadd(a, b) {
        var carry = 0;
        var i = 0; // a.length > b.length

        if (a.length < b.length) {
          var _ref = [b, a];
          a = _ref[0];
          b = _ref[1];
        }

        if (a !== this) this._alloc(a.length);

        for (; i < b.length; i++) {
          var r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }

        for (; carry !== 0 && i < a.length; i++) {
          var _r = (a.words[i] | 0) + carry;

          this.words[i] = _r & 0x3ffffff;
          carry = _r >>> 26;
        }

        this.length = a.length;

        if (carry !== 0) {
          this._alloc(this.length + 1);

          this.words[this.length++] = carry;
        } else if (a !== this) {
          // Copy the rest of the words.
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        } // Note: we shouldn't need to strip here.


        return this;
      }
    }, {
      key: "_iaddn",
      value: function _iaddn(num) {
        this.words[0] += num;
        if (this.words[0] < 0x4000000) return this; // Carry.

        var i = 0;

        this._alloc(this.length + 1);

        this.words[this.length] = 0;

        for (; i < this.length && this.words[i] >= 0x4000000; i++) {
          this.words[i] -= 0x4000000;
          this.words[i + 1] += 1;
        }

        this.length = Math.max(this.length, i + 1); // Note: we shouldn't need to strip here.

        return this;
      }
      /*
       * Addition
       */

    }, {
      key: "iadd",
      value: function iadd(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');

        if (this.negative === num.negative) {
          // x + y == x + y
          // (-x) + (-y) == -(x + y)
          this._iadd(this, num);
        } else {
          // x + (-y) == x - y == -(y - x)
          // (-x) + y == y - x == -(x - y)
          var cmp = this.ucmp(num); // x + (-x) == (-x) + x == 0

          if (cmp === 0) {
            this.words[0] = 0;
            this.length = 1;
            this.negative = 0;
            return this;
          }

          if (cmp < 0) {
            this._isub(num, this);

            this.negative ^= 1;
          } else {
            this._isub(this, num);
          }
        }

        return this;
      }
    }, {
      key: "iaddn",
      value: function iaddn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        var negative = num < 0 | 0;
        if (negative) num = -num;

        if (this.negative === negative) {
          // x + y == x + y
          // (-x) + (-y) == -(x + y)
          this._iaddn(num);
        } else {
          // x + (-y) == x - y == -(y - x)
          // (-x) + y == y - x == -(x - y)
          if (this.length === 1 && this.words[0] < num) {
            this.words[0] = num - this.words[0];
            this.negative ^= 1;
          } else {
            this._isubn(num);
          }
        }

        return this;
      }
    }, {
      key: "add",
      value: function add(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        if (num.length > this.length) return num.clone().iadd(this);
        return this.clone().iadd(num);
      }
    }, {
      key: "addn",
      value: function addn(num) {
        return this.clone().iaddn(num);
      }
      /*
       * Subtraction Engine
       */

    }, {
      key: "_isub",
      value: function _isub(a, b) {
        var carry = 0;
        var i = 0; // a > b

        assert$2(a.length >= b.length);
        if (a !== this) this._alloc(a.length);

        for (; i < b.length; i++) {
          var r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }

        for (; carry !== 0 && i < a.length; i++) {
          var _r2 = (a.words[i] | 0) + carry;

          carry = _r2 >> 26;
          this.words[i] = _r2 & 0x3ffffff;
        }

        assert$2(carry === 0); // Copy rest of the words.

        if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = Math.max(this.length, i);
        return this._strip();
      }
    }, {
      key: "_isubn",
      value: function _isubn(num) {
        this.words[0] -= num;
        if (this.words[0] >= 0) return this._normalize();
        assert$2(this.length !== 1); // Carry.

        this._alloc(this.length + 1);

        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 0x4000000;
          this.words[i + 1] -= 1;
        }

        this.words[this.length] = 0;
        return this._strip();
      }
      /*
       * Subtraction
       */

    }, {
      key: "isub",
      value: function isub(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');

        if (this.negative !== num.negative) {
          // x - (-y) == x + y
          // (-x) - y == -(x + y)
          this._iadd(this, num);
        } else {
          // x - y == x - y == -(y - x)
          // (-x) - (-y) == y - x == -(x - y)
          var cmp = this.ucmp(num); // x - x == 0

          if (cmp === 0) {
            this.words[0] = 0;
            this.length = 1;
            this.negative = 0;
            return this;
          }

          if (cmp < 0) {
            this._isub(num, this);

            this.negative ^= 1;
          } else {
            this._isub(this, num);
          }
        }

        return this;
      }
    }, {
      key: "isubn",
      value: function isubn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        var negative = num < 0 | 0;
        if (negative) num = -num;

        if (this.negative !== negative) {
          // x - (-y) == x + y
          // (-x) - y == -(x + y)
          this._iaddn(num);
        } else {
          // x - y == x - y == -(y - x)
          // (-x) - (-y) == y - x == -(x - y)
          if (this.length === 1 && this.words[0] < num) {
            this.words[0] = num - this.words[0];
            this.negative ^= 1;
          } else {
            this._isubn(num);
          }
        }

        return this;
      }
    }, {
      key: "sub",
      value: function sub(num) {
        return this.clone().isub(num);
      }
    }, {
      key: "subn",
      value: function subn(num) {
        return this.clone().isubn(num);
      }
      /*
       * Multiplication Engine
       */

    }, {
      key: "_mul",
      value: function _mul(num, out) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        enforce$1(BN.isBN(out), 'out', 'bignum');
        if (this.length === 10 && num.length === 10) return comb10MulTo(this, num, out);
        var len = this.length + num.length;
        if (len < 63) return smallMulTo(this, num, out);
        if (len < 1024) return bigMulTo(this, num, out);
        return jumboMulTo(this, num, out);
      }
      /*
       * Multiplication
       */

    }, {
      key: "imul",
      value: function imul(num) {
        return this.mul(num)._move(this);
      }
    }, {
      key: "imuln",
      value: function imuln(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        var neg = num < 0 | 0;
        if (neg) num = -num; // Carry.

        var carry = 0;

        for (var i = 0; i < this.length; i++) {
          var w = this.words[i] * num;
          var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
          carry >>= 26;
          carry += w / 0x4000000 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 0x3ffffff;
        }

        this.negative ^= neg;

        if (carry !== 0) {
          this._alloc(this.length + 1);

          this.words[this.length++] = carry;
        } else {
          this._strip();
        }

        return this;
      }
    }, {
      key: "mul",
      value: function mul(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var len = this.length + num.length;
        var out = new BN();
        out.words = new Array(len);

        for (var i = 0; i < len; i++) {
          out.words[i] = 0;
        }

        return this._mul(num, out);
      }
    }, {
      key: "muln",
      value: function muln(num) {
        return this.clone().imuln(num);
      }
      /*
       * Multiplication + Shift
       */

    }, {
      key: "mulShift",
      value: function mulShift(num, bits) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        enforce$1(bits >>> 0 === bits, 'bits', 'uint32');
        var r = this.mul(num);
        var b = r.utestn(bits - 1);
        r.iushrn(bits);
        if (this.negative ^ num.negative) return r.isubn(b);
        return r.iaddn(b);
      }
      /*
       * Division Engine
       */

    }, {
      key: "_div",
      value: function _div(num, flags) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        assert$2((flags & modes$1.ALL) === flags);
        assert$2(flags !== modes$1.NONE);
        var a = this;
        var b = num;
        nonzero(!b.isZero());
        if (a.isZero()) return [new BN(0), new BN(0)];
        var as = a.negative;
        var bs = b.negative;
        a.negative = 0;
        b.negative = 0;
        var q = null;
        var r = null;

        if (a.ucmp(b) < 0) {
          if (flags & modes$1.QUO) q = new BN(0);
          if (flags & modes$1.REM) r = a.clone();
        } else if (b.length === 1) {
          if (flags & modes$1.QUO) q = a.quon(b.words[0]);
          if (flags & modes$1.REM) r = a.remn(b.words[0]);
        } else {
          var _a$_wordDiv = a._wordDiv(b, flags);

          var _a$_wordDiv2 = _slicedToArray__default['default'](_a$_wordDiv, 2);

          q = _a$_wordDiv2[0];
          r = _a$_wordDiv2[1];
        }

        a.negative = as;
        b.negative = bs;

        if (flags & modes$1.QUO) {
          q.negative = a.negative ^ b.negative;

          q._normalize();
        }

        if (flags & modes$1.REM) {
          r.negative = a.negative;

          r._normalize();
        }

        if (flags & modes$1.EUCLID) {
          if (flags & modes$1.QUO) {
            assert$2((flags & modes$1.REM) !== 0);

            if (r.negative !== 0) {
              if (b.negative !== 0) q.iaddn(1);else q.isubn(1);
            }
          }

          if (flags & modes$1.REM) {
            if (r.negative !== 0) {
              if (b.negative !== 0) r.isub(b);else r.iadd(b);
            }
          }
        }

        return [q, r];
      }
    }, {
      key: "_wordDiv",
      value: function _wordDiv(num, flags) {
        var a = this.clone();
        var b = num;
        var q = null;
        var hi; // Normalize.

        var word = b.words[b.length - 1] | 0;
        var shift = 26 - countBits(word);

        if (shift !== 0) {
          b = b.clone();
          a.iushln(shift);
          b.iushln(shift);
          hi = b.words[b.length - 1] | 0;
        } else {
          hi = word;
        } // Initialize quotient.


        var m = a.length - b.length;
        assert$2(m >= 0);

        if (flags & modes$1.QUO) {
          q = new BN(0);
          q.length = m + 1;
          q.words = new Array(q.length);

          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        } // Diff.


        var d = a.clone();

        d._ishlnsubmul(b, 1, m);

        if (d.negative === 0) {
          if (q) q.words[m] = 1;
          a = d;
        } // Divide.


        for (var j = m - 1; j >= 0; j--) {
          var ahi = a.words[b.length + j];
          var alo = a.words[b.length + j - 1];
          var quo = (ahi * 0x4000000 + alo) / hi | 0;
          var qj = Math.min(quo, 0x3ffffff);

          a._ishlnsubmul(b, qj, j);

          while (a.negative !== 0) {
            qj -= 1;
            a.negative = 0;

            a._ishlnsubmul(b, 1, j);

            a.ineg();
          }

          if (q) q.words[j] = qj;
        } // Strip.


        if (q) q._strip(); // Denormalize.
        // Note: we shouldn't need to strip `a` here.

        if (flags & modes$1.REM && shift !== 0) a.iushrn(shift);
        return [q, a];
      }
    }, {
      key: "_ishlnsubmul",
      value: function _ishlnsubmul(num, mul, shift) {
        var carry = 0;
        var i = 0;

        this._expand(num.length + shift);

        for (; i < num.length; i++) {
          var k = (this.words[i + shift] | 0) + carry;
          var r = num.words[i] * mul;
          var w = k - (r & 0x3ffffff);
          carry = (w >> 26) - (r / 0x4000000 | 0);
          this.words[i + shift] = w & 0x3ffffff;
        }

        for (; i < this.length - shift; i++) {
          var _w = (this.words[i + shift] | 0) + carry;

          carry = _w >> 26;
          this.words[i + shift] = _w & 0x3ffffff;
        }

        if (carry === 0) return this._strip(); // Subtraction overflow.

        assert$2(carry === -1);
        carry = 0;

        for (var _i = 0; _i < this.length; _i++) {
          var _w2 = -(this.words[_i] | 0) + carry;

          carry = _w2 >> 26;
          this.words[_i] = _w2 & 0x3ffffff;
        }

        this.negative = 1;
        return this._strip();
      }
      /*
       * Truncation Division + Modulo
       */

    }, {
      key: "quorem",
      value: function quorem(num) {
        return this._div(num, modes$1.BOTH);
      }
      /*
       * Truncation Division
       */

    }, {
      key: "iquo",
      value: function iquo(num) {
        return this.quo(num)._move(this);
      }
    }, {
      key: "iquon",
      value: function iquon(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        nonzero(num !== 0);
        var neg = num < 0 | 0;
        if (neg) num = -num;
        var carry = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 0x4000000;
          this.words[i] = w / num | 0;
          carry = w % num;
        }

        this.negative ^= neg;
        return this._strip();
      }
    }, {
      key: "quo",
      value: function quo(num) {
        return this._div(num, modes$1.QUO)[0];
      }
    }, {
      key: "quon",
      value: function quon(num) {
        return this.clone().iquon(num);
      }
      /*
       * Truncation Modulo
       */

    }, {
      key: "irem",
      value: function irem(num) {
        return this.rem(num)._move(this);
      }
    }, {
      key: "iremn",
      value: function iremn(num) {
        var m = this.remrn(num);
        if (m < 0) m = -m;
        this.words[0] = m;
        this.length = 1;
        return this._normalize();
      }
    }, {
      key: "rem",
      value: function rem(num) {
        return this._div(num, modes$1.REM)[1];
      }
    }, {
      key: "remn",
      value: function remn(num) {
        return this.clone().iremn(num);
      }
    }, {
      key: "remrn",
      value: function remrn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        nonzero(num !== 0);
        if (num < 0) num = -num;
        var p = (1 << 26) % num;
        var acc = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }

        return this.negative !== 0 ? -acc | 0 : acc;
      }
      /*
       * Euclidean Division + Modulo
       */

    }, {
      key: "divmod",
      value: function divmod(num) {
        return this._div(num, modes$1.BOTH | modes$1.EUCLID);
      }
      /*
       * Euclidean Division
       */

    }, {
      key: "idiv",
      value: function idiv(num) {
        return this.div(num)._move(this);
      }
    }, {
      key: "idivn",
      value: function idivn(num) {
        if (this.negative === 0) return this.iquon(num);
        var r = this.remrn(num);
        this.iquon(num);

        if (r < 0) {
          if (num < 0) this.iaddn(1);else this.isubn(1);
        }

        return this;
      }
    }, {
      key: "div",
      value: function div(num) {
        return this._div(num, modes$1.BOTH | modes$1.EUCLID)[0];
      }
    }, {
      key: "divn",
      value: function divn(num) {
        return this.clone().idivn(num);
      }
      /*
       * Euclidean Modulo
       */

    }, {
      key: "imod",
      value: function imod(num) {
        if (this.ucmp(num) < 0) {
          if (this.negative !== 0) {
            this._isub(num, this);

            this.negative = 0;
          }

          return this;
        }

        return this.mod(num)._move(this);
      }
    }, {
      key: "imodn",
      value: function imodn(num) {
        this.words[0] = this.modrn(num);
        this.length = 1;
        this.negative = 0;
        return this;
      }
    }, {
      key: "mod",
      value: function mod(num) {
        return this._div(num, modes$1.REM | modes$1.EUCLID)[1];
      }
    }, {
      key: "modn",
      value: function modn(num) {
        return this.clone().imodn(num);
      }
    }, {
      key: "modrn",
      value: function modrn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        var r = this.remrn(num);

        if (r < 0) {
          if (num < 0) r -= num;else r += num;
        }

        return r;
      }
      /*
       * Round Division
       */

    }, {
      key: "divRound",
      value: function divRound(num) {
        var _this$quorem = this.quorem(num),
            _this$quorem2 = _slicedToArray__default['default'](_this$quorem, 2),
            q = _this$quorem2[0],
            r = _this$quorem2[1]; // Fast case - exact division.


        if (r.isZero()) return q;
        var bit = num.words[0] & 1;
        num.iushrn(1);
        var cmp = r.ucmp(num);
        num.iushln(1);
        num.words[0] |= bit; // Round down.

        if (cmp < 0 || num.isOdd() && cmp === 0) return q; // Round up.

        if (this.negative ^ num.negative) return q.isubn(1);
        return q.iaddn(1);
      }
      /*
       * Exponentiation
       */

    }, {
      key: "ipow",
      value: function ipow(num) {
        return this.pow(num)._move(this);
      }
    }, {
      key: "ipown",
      value: function ipown(num) {
        return this.pown(num)._move(this);
      }
    }, {
      key: "pow",
      value: function pow(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var b = countBits(num.words[num.length - 1]);
        var r = new BN(1);

        for (var i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];

          for (var j = b - 1; j >= 0; j--) {
            r = r.sqr();
            if (word >> j & 1) r = r.mul(this);
          }

          b = 26;
        }

        return r;
      }
    }, {
      key: "pown",
      value: function pown(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        if (num < 0) num = -num;
        if (num === 0) return new BN(1);
        if (num === 1) return this.clone();
        var bits = countBits(num);
        var r = this;

        for (var i = bits - 2; i >= 0; i--) {
          r = r.sqr();
          if (num >> i & 1) r = r.mul(this);
        }

        return r;
      }
    }, {
      key: "isqr",
      value: function isqr() {
        return this.imul(this);
      }
    }, {
      key: "sqr",
      value: function sqr() {
        return this.mul(this);
      }
      /*
       * Roots Engine
       */

    }, {
      key: "_rootrem",
      value: function _rootrem(pow, rem) {
        enforce$1(pow >>> 0 === pow, 'num', 'uint32');
        if (pow === 0) throw new RangeError('Zeroth root.');
        if (~pow & this.negative) throw new RangeError('Negative with even root.');
        if (this.ucmpn(1) <= 0) return [this.clone(), new BN(0)];
        var u = new BN(0);
        var t = BN.shift(1, this.bitLength() / pow + 1 | 0);
        var v, r;
        if (this.negative !== 0) t.ineg();

        if (pow === 2) {
          do {
            u = t;
            t = this.quo(u);
            t.iadd(u);
            t.iushrn(1);
          } while (t.ucmp(u) < 0);
        } else {
          do {
            u = t;
            t = u.pown(pow - 1);
            t = this.quo(t);
            v = u.muln(pow - 1);
            t.iadd(v);
            t = t.quon(pow);
          } while (t.ucmp(u) < 0);
        }

        if (rem) {
          t = u.pown(pow);
          r = this.sub(t);
        }

        return [u, r];
      }
      /*
       * Roots
       */

    }, {
      key: "rootrem",
      value: function rootrem(pow) {
        return this._rootrem(pow, 1);
      }
    }, {
      key: "iroot",
      value: function iroot(pow) {
        return this.root(pow)._move(this);
      }
    }, {
      key: "root",
      value: function root(pow) {
        return this._rootrem(pow, 0)[0];
      }
    }, {
      key: "isPower",
      value: function isPower(pow) {
        enforce$1(pow >>> 0 === pow, 'num', 'uint32');
        if (pow === 0 || ~pow & this.negative) return false;

        var _this$rootrem = this.rootrem(pow),
            _this$rootrem2 = _slicedToArray__default['default'](_this$rootrem, 2),
            r = _this$rootrem2[1];

        return r.sign() === 0;
      }
    }, {
      key: "sqrtrem",
      value: function sqrtrem() {
        return this.rootrem(2);
      }
    }, {
      key: "isqrt",
      value: function isqrt() {
        return this.sqrt()._move(this);
      }
    }, {
      key: "sqrt",
      value: function sqrt() {
        return this.root(2);
      }
    }, {
      key: "isSquare",
      value: function isSquare() {
        return this.isPower(2);
      }
      /*
       * AND
       */

    }, {
      key: "iand",
      value: function iand(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var x = this;
        var y = num;
        if (x === y) return x;
        if ((x.negative | y.negative) === 0) return x.iuand(y);

        if ((x.negative & y.negative) === 1) {
          // (-x) & (-y) == ~(x-1) & ~(y-1)
          //             == ~((x-1) | (y-1))
          //             == -(((x-1) | (y-1)) + 1)
          x.iaddn(1);
          y.iaddn(1);
          x.iuor(y);
          x.isubn(1);
          y.isubn(1);
          return x;
        } // Assume x is the positive number.


        if (x.negative !== 0) {
          var _ref2 = [y.clone(), x];
          x = _ref2[0];
          y = _ref2[1];
        } // x & (-y) == x & ~(y-1)
        //          == x & ~(y-1)


        var width = x.bitLength();
        y.iaddn(1);
        y.inotn(width);
        x.iuand(y);
        y.inotn(width);
        y.isubn(1);
        return x._move(this);
      }
    }, {
      key: "iandn",
      value: function iandn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        if ((this.negative | num < 0) !== 0) return this.iand(new BN(num));
        this.words[0] &= num;
        this.length = 1;
        return this;
      }
    }, {
      key: "and",
      value: function and(num) {
        return this.clone().iand(num);
      }
    }, {
      key: "andn",
      value: function andn(num) {
        return this.clone().iandn(num);
      }
    }, {
      key: "andrn",
      value: function andrn(num) {
        enforce$1(isSMI(num), 'num', 'smi');

        if ((this.negative | num < 0) !== 0) {
          var n = this.iand(new BN(num));
          if (n.length > 1) throw new RangeError('Number exceeds 26 bits.');
          return n.negative !== 0 ? -n.words[0] : n.words[0];
        }

        return this.words[0] & num;
      }
      /*
       * Unsigned AND
       */

    }, {
      key: "iuand",
      value: function iuand(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        this.length = Math.min(this.length, num.length);

        for (var i = 0; i < this.length; i++) {
          this.words[i] &= num.words[i];
        }

        return this._strip();
      }
    }, {
      key: "iuandn",
      value: function iuandn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        this.words[0] &= Math.abs(num);
        this.length = 1;
        return this._normalize();
      }
    }, {
      key: "uand",
      value: function uand(num) {
        return this.clone().iuand(num);
      }
    }, {
      key: "uandn",
      value: function uandn(num) {
        return this.clone().iuandn(num);
      }
    }, {
      key: "uandrn",
      value: function uandrn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        var n = this.words[0] & Math.abs(num);
        return this.negative !== 0 ? -n | 0 : n;
      }
      /*
       * OR
       */

    }, {
      key: "ior",
      value: function ior(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var x = this;
        var y = num;
        if (x === y) return x;
        if ((x.negative | y.negative) === 0) return x.iuor(y);

        if ((x.negative & y.negative) === 1) {
          // (-x) | (-y) == ~(x-1) | ~(y-1)
          //             == ~((x-1) & (y-1))
          //             == -(((x-1) & (y-1)) + 1)
          x.iaddn(1);
          y.iaddn(1);
          x.iuand(y);
          x.isubn(1);
          y.isubn(1);
          return x;
        } // Assume x is the positive number.


        y = y.clone();

        if (x.negative !== 0) {
          var _ref3 = [y, x];
          x = _ref3[0];
          y = _ref3[1];
        } // x | (-y) == x | ~(y-1)
        //          == ~((y-1) & ~x)
        //          == -(((y-1) & ~x) + 1)


        y.iaddn(1);
        x.inotn(y.bitLength());
        y.iuand(x);
        y.isubn(1);
        return y._move(this);
      }
    }, {
      key: "iorn",
      value: function iorn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        if ((this.negative | num < 0) !== 0) return this.ior(new BN(num));
        this.words[0] |= num;
        return this;
      }
    }, {
      key: "or",
      value: function or(num) {
        return this.clone().ior(num);
      }
    }, {
      key: "orn",
      value: function orn(num) {
        return this.clone().iorn(num);
      }
      /*
       * Unsigned OR
       */

    }, {
      key: "iuor",
      value: function iuor(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');

        this._expand(num.length);

        for (var i = 0; i < num.length; i++) {
          this.words[i] |= num.words[i];
        } // Note: we shouldn't need to strip here.


        return this;
      }
    }, {
      key: "iuorn",
      value: function iuorn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        this.words[0] |= Math.abs(num);
        return this;
      }
    }, {
      key: "uor",
      value: function uor(num) {
        return this.clone().iuor(num);
      }
    }, {
      key: "uorn",
      value: function uorn(num) {
        return this.clone().iuorn(num);
      }
      /*
       * XOR
       */

    }, {
      key: "ixor",
      value: function ixor(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var x = this;
        var y = num;

        if (x === y) {
          x.words[0] = 0;
          x.length = 1;
          x.negative = 0;
          return x;
        }

        if ((x.negative | y.negative) === 0) return x.iuxor(y);

        if ((x.negative & y.negative) === 1) {
          // (-x) ^ (-y) == ~(x-1) ^ ~(y-1)
          //             == (x-1) ^ (y-1)
          x.iaddn(1);
          y.iaddn(1);
          x.iuxor(y);
          x.ineg();
          y.isubn(1);
          return x;
        } // Assume x is the positive number.


        if (x.negative !== 0) {
          var _ref4 = [y.clone(), x];
          x = _ref4[0];
          y = _ref4[1];
        } // x ^ (-y) == x ^ ~(y-1)
        //          == ~(x ^ (y-1))
        //          == -((x ^ (y-1)) + 1)


        y.iaddn(1);
        x.iuxor(y);
        x.iaddn(1);
        x.ineg();
        y.isubn(1);
        return x._move(this);
      }
    }, {
      key: "ixorn",
      value: function ixorn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        if ((this.negative | num < 0) !== 0) return this.ixor(new BN(num));
        this.words[0] ^= num;
        return this;
      }
    }, {
      key: "xor",
      value: function xor(num) {
        return this.clone().ixor(num);
      }
    }, {
      key: "xorn",
      value: function xorn(num) {
        return this.clone().ixorn(num);
      }
      /*
       * Unsigned XOR
       */

    }, {
      key: "iuxor",
      value: function iuxor(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var a = this;
        var b = num;

        if (a.length < b.length) {
          var _ref5 = [b, a];
          a = _ref5[0];
          b = _ref5[1];
        }

        var i = 0;

        for (; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }

        if (a !== this) {
          this._alloc(a.length);

          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = a.length;
        return this._strip();
      }
    }, {
      key: "iuxorn",
      value: function iuxorn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        this.words[0] ^= Math.abs(num);
        return this._normalize();
      }
    }, {
      key: "uxor",
      value: function uxor(num) {
        return this.clone().iuxor(num);
      }
    }, {
      key: "uxorn",
      value: function uxorn(num) {
        return this.clone().iuxorn(num);
      }
      /*
       * NOT
       */

    }, {
      key: "inot",
      value: function inot() {
        if (this.negative !== 0) {
          // ~(-x) == ~(~(x-1)) == x-1
          this.ineg().isubn(1);
        } else {
          // ~x == -x-1 == -(x+1)
          this.iaddn(1).ineg();
        }

        return this;
      }
    }, {
      key: "not",
      value: function not() {
        return this.clone().inot();
      }
    }, {
      key: "inotn",
      value: function inotn(width) {
        enforce$1(width >>> 0 === width, 'width', 'uint32');
        var r = width % 26;
        var s = Math.ceil(width / 26);
        var i = 0; // Extend the buffer with leading zeroes.

        this._expand(s);

        if (r > 0) s -= 1; // Handle complete words.

        for (; i < s; i++) {
          this.words[i] ^= 0x3ffffff;
        } // Handle the residue.


        if (r > 0) this.words[i] ^= (1 << r) - 1; // And remove leading zeroes.

        return this._strip();
      }
    }, {
      key: "notn",
      value: function notn(width) {
        return this.clone().inotn(width);
      }
      /*
       * Left Shift
       */

    }, {
      key: "ishl",
      value: function ishl(num) {
        enforce$1(BN.isBN(num), 'bits', 'bignum');
        enforce$1(num.bitLength() <= 32, 'bits', 'uint32');
        return this.ishln(num.toNumber());
      }
    }, {
      key: "ishln",
      value: function ishln(bits) {
        return this.iushln(bits);
      }
    }, {
      key: "shl",
      value: function shl(num) {
        return this.clone().ishl(num);
      }
    }, {
      key: "shln",
      value: function shln(bits) {
        return this.clone().ishln(bits);
      }
      /*
       * Unsigned Left Shift
       */

    }, {
      key: "iushl",
      value: function iushl(num) {
        enforce$1(BN.isBN(num), 'bits', 'bignum');
        enforce$1(num.bitLength() <= 32, 'bits', 'uint32');
        return this.iushln(num.toNumber());
      }
    }, {
      key: "iushln",
      value: function iushln(bits) {
        enforce$1(bits >>> 0 === bits, 'bits', 'uint32');
        var r = bits % 26;
        var s = (bits - r) / 26;
        var mask = (1 << r) - 1 << 26 - r;

        if (r !== 0) {
          var carry = 0;

          for (var i = 0; i < this.length; i++) {
            var ncarry = this.words[i] & mask;
            var c = (this.words[i] | 0) - ncarry << r;
            this.words[i] = c | carry;
            carry = ncarry >>> 26 - r;
          }

          if (carry !== 0) {
            this._alloc(this.length + 1);

            this.words[this.length++] = carry;
          }
        }

        if (s !== 0) {
          this._alloc(this.length + s);

          for (var _i2 = this.length - 1; _i2 >= 0; _i2--) {
            this.words[_i2 + s] = this.words[_i2];
          }

          for (var _i3 = 0; _i3 < s; _i3++) {
            this.words[_i3] = 0;
          }

          this.length += s;
        }

        return this._strip();
      }
    }, {
      key: "ushl",
      value: function ushl(num) {
        return this.clone().iushl(num);
      }
    }, {
      key: "ushln",
      value: function ushln(bits) {
        return this.clone().iushln(bits);
      }
      /*
       * Right Shift Engine
       */

    }, {
      key: "_split",
      value: function _split(bits, output) {
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = (1 << r) - 1; // Extended mode, copy masked part.

        if (output) {
          output._alloc(s);

          for (var i = 0; i < s; i++) {
            output.words[i] = this.words[i];
          }

          output.length = s;
        }

        if (s === 0) ; else if (this.length > s) {
          this.length -= s;

          for (var _i4 = 0; _i4 < this.length; _i4++) {
            this.words[_i4] = this.words[_i4 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }

        var carry = 0;

        if (r !== 0) {
          for (var _i5 = this.length - 1; _i5 >= 0; _i5--) {
            var word = this.words[_i5] | 0;
            this.words[_i5] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
        } // Push carried bits as a mask.


        if (output) {
          if (carry !== 0) {
            output._alloc(output.length + 1);

            output.words[output.length++] = carry;
          } else {
            if (output.length === 0) output.words[output.length++] = 0;

            output._strip();
          }
        }

        return this._strip();
      }
      /*
       * Right Shift
       */

    }, {
      key: "ishr",
      value: function ishr(num) {
        enforce$1(BN.isBN(num), 'bits', 'bignum');
        enforce$1(num.bitLength() <= 32, 'bits', 'uint32');
        return this.ishrn(num.toNumber());
      }
    }, {
      key: "ishrn",
      value: function ishrn(bits) {
        enforce$1(bits >>> 0 === bits, 'bits', 'uint32');

        if (this.negative !== 0) {
          // (-x) >> y == ~(x-1) >> y
          //           == ~((x-1) >> y)
          //           == -(((x-1) >> y) + 1)
          this.iaddn(1);
          this.iushrn(bits);
          this.isubn(1);
          return this;
        }

        return this.iushrn(bits);
      }
    }, {
      key: "shr",
      value: function shr(num) {
        return this.clone().ishr(num);
      }
    }, {
      key: "shrn",
      value: function shrn(bits) {
        return this.clone().ishrn(bits);
      }
      /*
       * Unsigned Right Shift
       */

    }, {
      key: "iushr",
      value: function iushr(num) {
        enforce$1(BN.isBN(num), 'bits', 'bignum');
        enforce$1(num.bitLength() <= 32, 'bits', 'uint32');
        return this.iushrn(num.toNumber());
      }
    }, {
      key: "iushrn",
      value: function iushrn(bits) {
        enforce$1(bits >>> 0 === bits, 'bits', 'uint32');
        return this._split(bits, null);
      }
    }, {
      key: "ushr",
      value: function ushr(num) {
        return this.clone().iushr(num);
      }
    }, {
      key: "ushrn",
      value: function ushrn(bits) {
        return this.clone().iushrn(bits);
      }
      /*
       * Bit Manipulation
       */

    }, {
      key: "setn",
      value: function setn(bit, val) {
        enforce$1(bit >>> 0 === bit, 'bit', 'uint32');

        if (this.negative !== 0) {
          this.iaddn(1);
          this.usetn(bit, !val);
          this.isubn(1);
          return this;
        }

        return this.usetn(bit, val);
      }
    }, {
      key: "usetn",
      value: function usetn(bit, val) {
        enforce$1(bit >>> 0 === bit, 'bit', 'uint32');
        var r = bit % 26;
        var s = (bit - r) / 26;

        this._expand(s + 1);

        if (val) this.words[s] |= 1 << r;else this.words[s] &= ~(1 << r);
        return this._strip();
      }
    }, {
      key: "testn",
      value: function testn(bit) {
        enforce$1(bit >>> 0 === bit, 'bit', 'uint32');
        var r = bit % 26;
        var s = (bit - r) / 26; // Fast case: bit is much higher than all existing words.

        if (this.length <= s) return this.negative; // Check bit and return.

        var w = this.words[s];
        var val = w >> r & 1;

        if (this.negative !== 0) {
          if (r > 0 && w & (1 << r) - 1) return val ^ 1;
          var j = s;

          while (j--) {
            if (this.words[j] > 0) return val ^ 1;
          }
        }

        return val;
      }
    }, {
      key: "utestn",
      value: function utestn(bit) {
        enforce$1(bit >>> 0 === bit, 'bit', 'uint32');
        var r = bit % 26;
        var s = (bit - r) / 26; // Fast case: bit is much higher than all existing words.

        if (this.length <= s) return 0; // Check bit and return.

        return this.words[s] >> r & 1;
      }
    }, {
      key: "imaskn",
      value: function imaskn(bits) {
        enforce$1(bits >>> 0 === bits, 'bits', 'uint32');

        if (this.negative !== 0) {
          this.iaddn(1);
          this.inotn(bits + 1);
          this.ineg();
        }

        return this.iumaskn(bits);
      }
    }, {
      key: "maskn",
      value: function maskn(bits) {
        return this.clone().imaskn(bits);
      }
    }, {
      key: "iumaskn",
      value: function iumaskn(bits) {
        enforce$1(bits >>> 0 === bits, 'bits', 'uint32');
        var r = bits % 26;
        var s = (bits - r) / 26;
        if (this.length <= s) return this;
        if (r !== 0) s += 1;
        this.length = Math.min(s, this.length);
        if (r !== 0) this.words[this.length - 1] &= (1 << r) - 1;
        if (this.length === 0) this.words[this.length++] = 0;
        return this._strip();
      }
    }, {
      key: "umaskn",
      value: function umaskn(bits) {
        return this.clone().iumaskn(bits);
      }
    }, {
      key: "andln",
      value: function andln(num) {
        return this.words[0] & num;
      }
    }, {
      key: "bit",
      value: function bit(pos) {
        return this.utestn(pos);
      }
    }, {
      key: "bits",
      value: function bits(pos, width) {
        enforce$1(pos >>> 0 === pos, 'pos', 'uint32');
        enforce$1(width >>> 0 === width, 'width', 'uint32');
        enforce$1(width <= 26, 'width', 'width');
        var shift = pos % 26;
        var index = (pos - shift) / 26;
        if (index >= this.length) return 0;
        var bits = this.words[index] >> shift & (1 << width) - 1;

        if (shift + width > 26 && index + 1 < this.length) {
          var more = shift + width - 26;
          var next = this.words[index + 1] & (1 << more) - 1;
          bits |= next << 26 - shift;
        }

        return bits;
      }
      /*
       * Negation
       */

    }, {
      key: "ineg",
      value: function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }
    }, {
      key: "neg",
      value: function neg() {
        return this.clone().ineg();
      }
    }, {
      key: "iabs",
      value: function iabs() {
        this.negative = 0;
        return this;
      }
    }, {
      key: "abs",
      value: function abs() {
        return this.clone().iabs();
      }
      /*
       * Comparison
       */

    }, {
      key: "cmp",
      value: function cmp(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        if (this.negative !== num.negative) return num.negative - this.negative;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      }
    }, {
      key: "cmpn",
      value: function cmpn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        var negative = num < 0 | 0;
        if (this.negative !== negative) return negative - this.negative;
        var res = this.ucmpn(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      }
    }, {
      key: "eq",
      value: function eq(num) {
        return this.cmp(num) === 0;
      }
    }, {
      key: "eqn",
      value: function eqn(num) {
        return this.cmpn(num) === 0;
      }
    }, {
      key: "gt",
      value: function gt(num) {
        return this.cmp(num) > 0;
      }
    }, {
      key: "gtn",
      value: function gtn(num) {
        return this.cmpn(num) > 0;
      }
    }, {
      key: "gte",
      value: function gte(num) {
        return this.cmp(num) >= 0;
      }
    }, {
      key: "gten",
      value: function gten(num) {
        return this.cmpn(num) >= 0;
      }
    }, {
      key: "lt",
      value: function lt(num) {
        return this.cmp(num) < 0;
      }
    }, {
      key: "ltn",
      value: function ltn(num) {
        return this.cmpn(num) < 0;
      }
    }, {
      key: "lte",
      value: function lte(num) {
        return this.cmp(num) <= 0;
      }
    }, {
      key: "lten",
      value: function lten(num) {
        return this.cmpn(num) <= 0;
      }
    }, {
      key: "sign",
      value: function sign() {
        if (this.negative !== 0) return -1;
        if (this.length === 1 && this.words[0] === 0) return 0;
        return 1;
      }
    }, {
      key: "isZero",
      value: function isZero() {
        return this.length === 1 && this.words[0] === 0;
      }
    }, {
      key: "isNeg",
      value: function isNeg() {
        return this.negative !== 0;
      }
    }, {
      key: "isPos",
      value: function isPos() {
        return this.negative === 0;
      }
    }, {
      key: "isOdd",
      value: function isOdd() {
        return (this.words[0] & 1) === 1;
      }
    }, {
      key: "isEven",
      value: function isEven() {
        return (this.words[0] & 1) === 0;
      }
      /*
       * Unsigned Comparison
       */

    }, {
      key: "ucmp",
      value: function ucmp(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        if (this.length < num.length) return -1;
        if (this.length > num.length) return 1;

        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          return (a > b) - (a < b);
        }

        return 0;
      }
    }, {
      key: "ucmpn",
      value: function ucmpn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        if (this.length > 1) return 1;
        var w = this.words[0] | 0;
        if (num < 0) num = -num;
        return (w > num) - (w < num);
      }
      /*
       * Number Theoretic Functions
       */

    }, {
      key: "legendre",
      value: function legendre(num) {
        var red = HAS_BIGINT ? BN.red(num) : BN.mont(num);
        return this.toRed(red).redLegendre();
      }
    }, {
      key: "jacobi",
      value: function jacobi(num) {
        // See: A Binary Algorithm for the Jacobi Symbol
        //   J. Shallit, J. Sorenson
        //   Page 3, Section 3
        enforce$1(BN.isBN(num), 'num', 'bignum');
        if (num.isZero() || num.isEven()) throw new Error('jacobi: `num` must be odd.');

        var a = this._cloneNormal();

        var b = num.clone();
        var j = 1;

        if (b.isNeg()) {
          if (a.isNeg()) j = -1;
          b.ineg();
        }

        if (a.isNeg() || a.ucmp(b) >= 0) a.imod(b);

        while (!a.isZero()) {
          var bits = a._makeOdd();

          if (bits & 1) {
            var _bmod = b.andln(7);

            if (_bmod === 3 || _bmod === 5) j = -j;
          }

          if (a.ucmp(b) < 0) {
            var _ref6 = [b, a];
            a = _ref6[0];
            b = _ref6[1];
            if (a.andln(3) === 3 && b.andln(3) === 3) j = -j;
          }

          a._isub(a, b).iushrn(1);

          var bmod8 = b.andln(7);
          if (bmod8 === 3 || bmod8 === 5) j = -j;
        }

        if (b.cmpn(1) !== 0) return 0;
        return j;
      }
    }, {
      key: "kronecker",
      value: function kronecker(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var table = [0, 1, 0, -1, 0, -1, 0, 1];

        var a = this._cloneNormal();

        var b = num.clone();
        var k = 1;
        if (b.isZero()) return a.ucmpn(1) === 0 ? k : 0;
        if (!a.isOdd() && !b.isOdd()) return 0;

        var bits = b._makeOdd();

        if (bits & 1) k = table[a.andln(7)];

        if (b.isNeg()) {
          if (a.isNeg()) k = -k;
          b.ineg();
        }

        while (!a.isZero()) {
          var _bits = a._makeOdd();

          if (_bits & 1) k *= table[b.andln(7)];
          var w = a.words[0] ^ a.negative * 0x3ffffff;
          if (w & b.words[0] & 2) k = -k;
          b.imod(a);
          var _ref7 = [b, a];
          a = _ref7[0];
          b = _ref7[1];
          b.negative = 0;
        }

        if (b.cmpn(1) !== 0) return 0;
        return k;
      }
    }, {
      key: "igcd",
      value: function igcd(num) {
        return this.gcd(num)._move(this);
      }
    }, {
      key: "gcd",
      value: function gcd(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0; // Remove common factor of two.

        var shift = a._factor2(b);

        if (shift !== 0) {
          a.iushrn(shift);
          b.iushrn(shift);
        }

        for (;;) {
          a._makeOdd();

          b._makeOdd();

          var cmp = a.ucmp(b);

          if (cmp < 0) {
            // a > b
            var _ref8 = [b, a];
            a = _ref8[0];
            b = _ref8[1];
          } else if (cmp === 0 || b.ucmpn(1) === 0) {
            // Break if a == b.
            // Break if b == 1 to avoid repeated subtraction.
            break;
          }

          a._isub(a, b);
        }

        return b.iushln(shift);
      }
    }, {
      key: "ilcm",
      value: function ilcm(num) {
        return this.lcm(num)._move(this);
      }
    }, {
      key: "lcm",
      value: function lcm(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        if (this.isZero() || num.isZero()) return new BN(0);
        return this.quo(this.gcd(num)).mul(num).iabs();
      }
    }, {
      key: "egcd",
      value: function egcd(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');

        if (this.isZero()) {
          return [new BN(0), new BN(num.sign()), num.abs()];
        }

        if (num.isZero()) {
          return [new BN(this.sign()), new BN(0), this.abs()];
        }

        var x = this.clone();
        var y = num.clone();
        x.negative = 0;
        y.negative = 0; // A * x + B * y = x

        var A = new BN(1);
        var B = new BN(0); // C * x + D * y = y

        var C = new BN(0);
        var D = new BN(1); // Remove common factor of two.

        var g = x._factor2(y);

        if (g !== 0) {
          x.iushrn(g);
          y.iushrn(g);
        }

        var yp = y.clone();
        var xp = x.clone();

        while (!x.isZero()) {
          var i = x._makeOdd();

          var j = y._makeOdd();

          while (i--) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }

            A.iushrn(1);
            B.iushrn(1);
          }

          while (j--) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }

            C.iushrn(1);
            D.iushrn(1);
          }

          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }

        if (this.negative !== 0) C.ineg();
        if (num.negative !== 0) D.ineg();
        return [C, D, y.iushln(g)];
      }
    }, {
      key: "iinvert",
      value: function iinvert(num) {
        return this.invert(num)._move(this);
      }
    }, {
      key: "invert",
      value: function invert(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        range$1(num.sign() > 0, 'invert');
        if (num.isOdd()) return this._invertp(num);
        if (num.cmpn(1) === 0) throw new RangeError('Not invertible.');

        var _this$egcd = this.egcd(num),
            _this$egcd2 = _slicedToArray__default['default'](_this$egcd, 3),
            s = _this$egcd2[0],
            g = _this$egcd2[2];

        if (g.cmpn(1) !== 0) throw new RangeError('Not invertible.');
        return s.imod(num);
      }
    }, {
      key: "ifermat",
      value: function ifermat(num) {
        return this.fermat(num)._move(this);
      }
    }, {
      key: "fermat",
      value: function fermat(num) {
        var red = HAS_BIGINT ? BN.red(num) : BN.mont(num);
        return this.toRed(red).redFermat().fromRed();
      }
    }, {
      key: "ipowm",
      value: function ipowm(y, m, mont) {
        return this.powm(y, m, mont)._move(this);
      }
    }, {
      key: "powm",
      value: function powm(y, m, mont) {
        var red = !HAS_BIGINT && mont ? BN.mont(m) : BN.red(m);
        return this.toRed(red).redPow(y).fromRed();
      }
    }, {
      key: "ipowmn",
      value: function ipowmn(y, m, mont) {
        return this.powmn(y, m, mont)._move(this);
      }
    }, {
      key: "powmn",
      value: function powmn(y, m, mont) {
        var red = mont ? BN.mont(m) : BN.red(m);
        return this.toRed(red).redPown(y).fromRed();
      }
    }, {
      key: "isqrtm",
      value: function isqrtm(p) {
        return this.sqrtm(p)._move(this);
      }
    }, {
      key: "sqrtm",
      value: function sqrtm(p) {
        enforce$1(BN.isBN(p), 'p', 'bignum');
        var red;

        if (p.andln(3) === 3 || p.andln(7) === 5) {
          // Probably not worth the setup.
          red = BN.red(p);
        } else {
          red = BN.mont(p);
        }

        return this.toRed(red).redSqrt().fromRed();
      }
    }, {
      key: "isqrtpq",
      value: function isqrtpq(p, q) {
        return this.sqrtpq(p, q)._move(this);
      }
    }, {
      key: "sqrtpq",
      value: function sqrtpq(p, q) {
        var sp = this.sqrtm(p);
        var sq = this.sqrtm(q);

        var _p$egcd = p.egcd(q),
            _p$egcd2 = _slicedToArray__default['default'](_p$egcd, 2),
            mp = _p$egcd2[0],
            mq = _p$egcd2[1];

        var lhs = sq.mul(mp).mul(p);
        var rhs = sp.mul(mq).mul(q);
        var n = p.mul(q);
        return lhs.iadd(rhs).imod(n);
      }
      /*
       * Primality Testing
       */

    }, {
      key: "isPrime",
      value: function isPrime(rng, reps, limit) {
        enforce$1(reps >>> 0 === reps, 'reps', 'uint32');
        if (!this.isPrimeMR(rng, reps + 1, true)) return false;
        if (!this.isPrimeLucas(limit)) return false;
        return true;
      }
    }, {
      key: "isPrimeMR",
      value: function isPrimeMR(rng, reps) {
        var force2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        enforce$1(reps >>> 0 === reps, 'reps', 'uint32');
        enforce$1(reps > 0, 'reps', 'integer');
        enforce$1(typeof force2 === 'boolean', 'force2', 'boolean');
        var n = this;

        if (n.cmpn(7) < 0) {
          return n.cmpn(2) === 0 || n.cmpn(3) === 0 || n.cmpn(5) === 0;
        }

        if (n.isEven()) return false;
        var nm1 = n.subn(1);
        var nm3 = nm1.subn(2);
        var k = nm1.zeroBits();
        var q = nm1.ushrn(k);
        var red = BN.red(n);
        var rnm1 = nm1.toRed(red);
        var rone = new BN(1).toRed(red);

        next: for (var i = 0; i < reps; i++) {
          var x = void 0;

          if (i === reps - 1 && force2) {
            x = new BN(2);
          } else {
            x = BN.random(rng, 0, nm3);
            x.iaddn(2);
          }

          var y = x.toRed(red).redPow(q);
          if (y.cmp(rone) === 0 || y.cmp(rnm1) === 0) continue;

          for (var j = 1; j < k; j++) {
            y = y.redSqr();
            if (y.cmp(rnm1) === 0) continue next;
            if (y.cmp(rone) === 0) return false;
          }

          return false;
        }

        return true;
      }
    }, {
      key: "isPrimeLucas",
      value: function isPrimeLucas() {
        var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        enforce$1(limit >>> 0 === limit, 'limit', 'uint32');
        var n = this; // Ignore 0 and 1.

        if (n.cmpn(1) <= 0) return false; // Two is the only even prime.

        if (n.isEven()) return n.cmpn(2) === 0;
        var p = 3;

        for (;;) {
          if (p > 10000) {
            // Thought to be impossible.
            throw new Error("Cannot find (D/n) = -1 for ".concat(n.toString(10), "."));
          }

          if (limit !== 0 && p > limit) {
            // Optional DoS limit.
            return false;
          }

          var d = new BN(p * p - 4);
          var j = d.jacobi(n);
          if (j === -1) break;
          if (j === 0) return n.cmpn(p + 2) === 0;

          if (p === 40) {
            if (n.isSquare()) return false;
          }

          p += 1;
        }

        var s = n.addn(1);

        var r = s._makeOdd();

        var nm2 = n.subn(2);
        var x = new BN(2);
        var y = new BN(p);

        for (var i = s.bitLength(); i >= 0; i--) {
          if (s.utestn(i)) {
            x = x.mul(y).iadd(n).isubn(p).imod(n);
            y = y.sqr().iadd(nm2).imod(n);
          } else {
            y = y.mul(x).iadd(n).isubn(p).imod(n);
            x = x.sqr().iadd(nm2).imod(n);
          }
        }

        if (x.cmpn(2) === 0 || x.cmp(nm2) === 0) {
          var a = x.muln(p);
          var b = y.ushln(1);

          if (a.cmp(b) < 0) {
            var _ref9 = [b, a];
            a = _ref9[0];
            b = _ref9[1];
          }

          if (a.isub(b).imod(n).isZero()) return true;
        }

        for (var t = 0; t < r - 1; t++) {
          if (x.isZero()) return true;
          if (x.cmpn(2) === 0) return false;
          x = x.sqr().isubn(2).imod(n);
        }

        return false;
      }
      /*
       * Twos Complement
       */

    }, {
      key: "toTwos",
      value: function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
      }
    }, {
      key: "fromTwos",
      value: function fromTwos(width) {
        enforce$1(width >>> 0 === width, 'width', 'uint32');
        range$1(width > 0, 'width');
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
      }
      /*
       * Reduction Context
       */

    }, {
      key: "toRed",
      value: function toRed(ctx) {
        enforce$1(ctx instanceof Red, 'ctx', 'reduction context');
        if (this.red) throw new Error('Already in reduction context.');
        return ctx.convertTo(this);
      }
    }, {
      key: "fromRed",
      value: function fromRed() {
        red(this.red, 'fromRed');
        return this.red.convertFrom(this);
      }
    }, {
      key: "forceRed",
      value: function forceRed(ctx) {
        enforce$1(ctx instanceof Red, 'ctx', 'reduction context');

        if (this.red) {
          if (!ctx.m.eq(this.red.m) || ctx.mont !== this.red.mont) throw new Error('Already in reduction context.');
        } else {
          range$1(this.negative === 0, 'red');
          range$1(this.ucmp(ctx.m) < 0, 'red');
        }

        return this.clone()._forceRed(ctx);
      }
    }, {
      key: "redIAdd",
      value: function redIAdd(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redIAdd');
        return this.red.iadd(this, num);
      }
    }, {
      key: "redAdd",
      value: function redAdd(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redAdd');
        return this.red.add(this, num);
      }
    }, {
      key: "redIAddn",
      value: function redIAddn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redIAddn');
        return this.red.iaddn(this, num);
      }
    }, {
      key: "redAddn",
      value: function redAddn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redAddn');
        return this.red.addn(this, num);
      }
    }, {
      key: "redISub",
      value: function redISub(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redISub');
        return this.red.isub(this, num);
      }
    }, {
      key: "redSub",
      value: function redSub(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redSub');
        return this.red.sub(this, num);
      }
    }, {
      key: "redISubn",
      value: function redISubn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redISubn');
        return this.red.isubn(this, num);
      }
    }, {
      key: "redSubn",
      value: function redSubn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redSubn');
        return this.red.subn(this, num);
      }
    }, {
      key: "redIMul",
      value: function redIMul(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redIMul');
        return this.red.imul(this, num);
      }
    }, {
      key: "redMul",
      value: function redMul(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redMul');
        return this.red.mul(this, num);
      }
    }, {
      key: "redIMuln",
      value: function redIMuln(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redIMuln');
        return this.red.imuln(this, num);
      }
    }, {
      key: "redMuln",
      value: function redMuln(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redMuln');
        return this.red.muln(this, num);
      }
    }, {
      key: "redIDiv",
      value: function redIDiv(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redIDiv');
        return this.red.idiv(this, num);
      }
    }, {
      key: "redDiv",
      value: function redDiv(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redDiv');
        return this.red.div(this, num);
      }
    }, {
      key: "redIDivn",
      value: function redIDivn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redIDivn');
        return this.red.idivn(this, num);
      }
    }, {
      key: "redDivn",
      value: function redDivn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redDivn');
        return this.red.divn(this, num);
      }
    }, {
      key: "redIPow",
      value: function redIPow(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redIPow');
        nonred(!num.red, 'redIPow');
        return this.red.ipow(this, num);
      }
    }, {
      key: "redPow",
      value: function redPow(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redPow');
        nonred(!num.red, 'redPow');
        return this.red.pow(this, num);
      }
    }, {
      key: "redIPown",
      value: function redIPown(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redIPown');
        return this.red.ipown(this, num);
      }
    }, {
      key: "redPown",
      value: function redPown(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redPown');
        return this.red.pown(this, num);
      }
    }, {
      key: "redISqr",
      value: function redISqr() {
        red(this.red, 'redISqr');
        return this.red.isqr(this);
      }
    }, {
      key: "redSqr",
      value: function redSqr() {
        red(this.red, 'redSqr');
        return this.red.sqr(this);
      }
    }, {
      key: "redISqrt",
      value: function redISqrt() {
        red(this.red, 'redISqrt');
        return this.red.isqrt(this);
      }
    }, {
      key: "redSqrt",
      value: function redSqrt() {
        red(this.red, 'redSqrt');
        return this.red.sqrt(this);
      }
    }, {
      key: "redIDivSqrt",
      value: function redIDivSqrt(v) {
        red(this.red, 'redIDivSqrt');
        return this.red.idivsqrt(this, v);
      }
    }, {
      key: "redDivSqrt",
      value: function redDivSqrt(v) {
        red(this.red, 'redDivSqrt');
        return this.red.divsqrt(this, v);
      }
    }, {
      key: "redIsSquare",
      value: function redIsSquare() {
        red(this.red, 'redIsSquare');
        return this.red.isSquare(this);
      }
    }, {
      key: "redIShl",
      value: function redIShl(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redIShl');
        nonred(!num.red, 'redIShl');
        return this.red.ishl(this, num);
      }
    }, {
      key: "redShl",
      value: function redShl(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redShl');
        nonred(!num.red, 'redShl');
        return this.red.shl(this, num);
      }
    }, {
      key: "redIShln",
      value: function redIShln(num) {
        enforce$1(num >>> 0 === num, 'num', 'uint32');
        red(this.red, 'redIShln');
        return this.red.ishln(this, num);
      }
    }, {
      key: "redShln",
      value: function redShln(num) {
        enforce$1(num >>> 0 === num, 'num', 'uint32');
        red(this.red, 'redShln');
        return this.red.shln(this, num);
      }
    }, {
      key: "redINeg",
      value: function redINeg() {
        red(this.red, 'redINeg');
        return this.red.ineg(this);
      }
    }, {
      key: "redNeg",
      value: function redNeg() {
        red(this.red, 'redNeg');
        return this.red.neg(this);
      }
    }, {
      key: "redEq",
      value: function redEq(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        red(this.red, 'redEq');
        return this.red.eq(this, num);
      }
    }, {
      key: "redEqn",
      value: function redEqn(num) {
        enforce$1(isSMI(num), 'num', 'smi');
        red(this.red, 'redEqn');
        return this.red.eqn(this, num);
      }
    }, {
      key: "redIsHigh",
      value: function redIsHigh() {
        red(this.red, 'redIsHigh');
        return this.red.isHigh(this);
      }
    }, {
      key: "redIsLow",
      value: function redIsLow() {
        red(this.red, 'redIsLow');
        return this.red.isLow(this);
      }
    }, {
      key: "redIsOdd",
      value: function redIsOdd() {
        red(this.red, 'redIsOdd');
        return this.red.isOdd(this);
      }
    }, {
      key: "redIsEven",
      value: function redIsEven() {
        red(this.red, 'redIsEven');
        return this.red.isEven(this);
      }
    }, {
      key: "redLegendre",
      value: function redLegendre() {
        red(this.red, 'redLegendre');
        return this.red.legendre(this);
      }
    }, {
      key: "redJacobi",
      value: function redJacobi() {
        red(this.red, 'redJacobi');
        return this.red.jacobi(this);
      }
    }, {
      key: "redKronecker",
      value: function redKronecker() {
        red(this.red, 'redKronecker');
        return this.red.kronecker(this);
      }
    }, {
      key: "redIInvert",
      value: function redIInvert() {
        red(this.red, 'redIInvert');
        return this.red.iinvert(this);
      }
    }, {
      key: "redInvert",
      value: function redInvert() {
        red(this.red, 'redInvert');
        return this.red.invert(this);
      }
    }, {
      key: "redIFermat",
      value: function redIFermat() {
        red(this.red, 'redIFermat');
        return this.red.ifermat(this);
      }
    }, {
      key: "redFermat",
      value: function redFermat() {
        red(this.red, 'redFermat');
        return this.red.fermat(this);
      }
      /*
       * Internal
       */

    }, {
      key: "_move",
      value: function _move(dest) {
        dest.words = this.words;
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
        return dest;
      }
    }, {
      key: "_alloc",
      value: function _alloc(size) {
        while (this.words.length < size) {
          this.words.push(0);
        }

        return this;
      }
    }, {
      key: "_expand",
      value: function _expand(size) {
        this._alloc(size);

        while (this.length < size) {
          this.words[this.length++] = 0;
        }

        return this;
      }
    }, {
      key: "_strip",
      value: function _strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length -= 1;
        }

        return this._normalize();
      }
    }, {
      key: "_normalize",
      value: function _normalize() {
        assert$2(this.length > 0); // -0 = 0

        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }
    }, {
      key: "_check",
      value: function _check() {
        // We never have a zero length number.
        assert$2(this.length > 0); // Cannot exceed array bounds.

        assert$2(this.length <= this.words.length);

        if (this.length === 1) {
          // Must be normalized.
          if (this.words[0] === 0) assert$2(this.negative === 0);
          return this;
        } // Must be stripped.


        assert$2(this.words[this.length - 1] !== 0);
        return this;
      }
    }, {
      key: "_invertp",
      value: function _invertp(p) {
        // Penk's right shift binary EGCD.
        //
        // See: The Art of Computer Programming,
        //      Volume 2, Seminumerical Algorithms
        //   Donald E. Knuth
        //   Exercise 4.5.2.39
        enforce$1(BN.isBN(p), 'p', 'bignum');
        range$1(p.sign() > 0, 'invert');
        assert$2(p.isOdd());
        if (p.cmpn(1) === 0) throw new RangeError('Not invertible.');
        var a = this.clone();
        var b = p.clone();
        var u = new BN(1);
        var v = new BN(0);
        if (a.isNeg() || a.ucmp(b) >= 0) a.imod(b);

        while (!a.isZero()) {
          var i = a._makeOdd();

          var j = b._makeOdd();

          while (i--) {
            if (u.isOdd()) u._iadd(u, p);
            u.iushrn(1);
          }

          while (j--) {
            if (v.isOdd()) v._iadd(v, p);
            v.iushrn(1);
          }

          if (a.ucmp(b) >= 0) {
            a._isub(a, b);

            if (u.ucmp(v) < 0) {
              u._isub(v, u);

              u._isub(p, u);
            } else {
              u._isub(u, v);
            }
          } else {
            b._isub(b, a);

            if (v.ucmp(u) < 0) {
              v._isub(u, v);

              v._isub(p, v);
            } else {
              v._isub(v, u);
            }
          }
        }

        if (b.cmpn(1) !== 0) throw new RangeError('Not invertible.');
        assert$2(v.negative === 0);
        assert$2(v.ucmp(p) < 0);
        return v;
      }
    }, {
      key: "_makeOdd",
      value: function _makeOdd() {
        var shift = this.zeroBits();
        if (shift > 0) this.iushrn(shift);
        return shift;
      }
    }, {
      key: "_factor2",
      value: function _factor2(num) {
        // Find common factor of two.
        // Expects inputs to be non-zero.
        if ((this.words[0] | num.words[0]) & 1) return 0;
        var len = Math.min(this.length, num.length);
        var r = 0;

        for (var i = 0; i < len; i++) {
          var b = _zeroBits(this.words[i] | num.words[i]);

          r += b;
          if (b !== 26) break;
        }

        return r;
      }
    }, {
      key: "_cloneNormal",
      value: function _cloneNormal() {
        return this.red ? this.fromRed() : this.clone();
      }
    }, {
      key: "_forceRed",
      value: function _forceRed(ctx) {
        this.red = ctx;
        return this;
      }
      /*
       * Helpers
       */

    }, {
      key: "clone",
      value: function clone() {
        var copy = new BN();
        copy.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          copy.words[i] = this.words[i];
        }

        copy.length = this.length;
        copy.negative = this.negative;
        copy.red = this.red;
        return copy;
      }
    }, {
      key: "inject",
      value: function inject(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');

        this._alloc(num.length);

        for (var i = 0; i < num.length; i++) {
          this.words[i] = num.words[i];
        }

        this.length = num.length;
        this.negative = num.negative;
        this.red = num.red;
        return this;
      }
    }, {
      key: "set",
      value: function set(num, endian) {
        return this.fromNumber(num, endian);
      }
    }, {
      key: "swap",
      value: function swap(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var x = this;
        var y = num;
        var _ref10 = [y.words, x.words];
        x.words = _ref10[0];
        y.words = _ref10[1];
        var _ref11 = [y.length, x.length];
        x.length = _ref11[0];
        y.length = _ref11[1];
        var _ref12 = [y.negative, x.negative];
        x.negative = _ref12[0];
        y.negative = _ref12[1];
        var _ref13 = [y.red, x.red];
        x.red = _ref13[0];
        y.red = _ref13[1];
        return x;
      }
    }, {
      key: "reverse",
      value: function reverse() {
        var neg = this.negative;
        this.fromBuffer(this.toBuffer('be'), 'le');
        this.negative = neg;
        return this;
      }
    }, {
      key: "byteLength",
      value: function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      }
    }, {
      key: "bitLength",
      value: function bitLength() {
        var w = this.words[this.length - 1];
        var hi = countBits(w);
        return (this.length - 1) * 26 + hi;
      }
    }, {
      key: "zeroBits",
      value: function zeroBits() {
        if (this.isZero()) return 0;
        if (this.isOdd()) return 0;
        var r = 0;

        for (var i = 0; i < this.length; i++) {
          var b = _zeroBits(this.words[i]);

          r += b;
          if (b !== 26) break;
        }

        return r;
      }
    }, {
      key: "isSafe",
      value: function isSafe() {
        if (this.length <= 2) return true;
        if (this.length === 3 && this.words[2] === 0x01) return true;
        return false;
      }
    }, {
      key: "word",
      value: function word(pos) {
        enforce$1(pos >>> 0 === pos, 'pos', 'uint32');
        if (pos >= this.length) return 0;
        return this.words[pos];
      }
    }, {
      key: custom$1,
      value: function value() {
        var prefix = 'BN';
        if (this.red) prefix = 'BN-R';
        return "<".concat(prefix, ": ").concat(this.toString(10), ">");
      }
      /*
       * Constant Time
       */

    }, {
      key: "csign",
      value: function csign() {
        return this.negative * -2 + 1 - this.czero();
      }
    }, {
      key: "czero",
      value: function czero() {
        var zword = this.words[0] - 1 >>> 31;
        return this.length - 2 >>> 31 & zword;
      }
    }, {
      key: "cneg",
      value: function cneg() {
        return this.negative;
      }
    }, {
      key: "cpos",
      value: function cpos() {
        return this.negative ^ 1;
      }
    }, {
      key: "ceq",
      value: function ceq(num) {
        enforce$1(BN.isBN(num), 'num', 'bignum'); // Assumes `num` is the "constant size"
        // parameter. Note that constant size
        // doesn't necessarily mean secret.

        var z = 0;

        for (var i = 0; i < num.length; i++) {
          z |= this.words[i % this.length] ^ num.words[i];
        }

        z |= this.length ^ num.length;
        z |= this.negative ^ num.negative;
        return z - 1 >>> 31;
      }
    }, {
      key: "ceqn",
      value: function ceqn(num) {
        var neg = num >> 31 & 1;
        var word = (num | 0) * (-neg | 1) & 0x3ffffff;
        var z = 0;
        z |= this.words[0] ^ word;
        z |= this.length ^ 1;
        z |= this.negative ^ neg;
        return z - 1 >>> 31;
      }
    }, {
      key: "cswap",
      value: function cswap(num, flag) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var x = this;
        var y = num;
        var cond = (flag >> 31 | -flag >> 31) & 1;
        var mask = -cond & 0x3ffffff;

        x._alloc(y.words.length);

        y._alloc(x.words.length);

        for (var i = 0; i < x.words.length; i++) {
          var word = (x.words[i] ^ y.words[i]) & mask;
          x.words[i] ^= word;
          y.words[i] ^= word;
        }

        var length = (x.length ^ y.length) & mask;
        var negative = (x.negative ^ y.negative) & mask;
        x.length ^= length;
        y.length ^= length;
        x.negative ^= negative;
        y.negative ^= negative;
        return this;
      }
    }, {
      key: "cinject",
      value: function cinject(num, flag) {
        enforce$1(BN.isBN(num), 'num', 'bignum');
        var x = this;
        var y = num;
        var cond = (flag >> 31 | -flag >> 31) & 1;
        var mask0 = cond - 1 & 0x3ffffff;
        var mask1 = ~(cond - 1) & 0x3ffffff;

        x._alloc(y.length);

        for (var i = 0; i < y.length; i++) {
          x.words[i] = x.words[i] & mask0 | y.words[i] & mask1;
        }

        x.length = x.length & mask0 | y.length & mask1;
        x.negative = x.negative & mask0 | y.negative & mask1;
        return this;
      }
    }, {
      key: "cset",
      value: function cset(num, flag) {
        var cond = (flag >> 31 | -flag >> 31) & 1;
        var mask0 = cond - 1 & 0x3ffffff;
        var mask1 = ~(cond - 1) & 0x3ffffff;
        var neg = num >> 31 & 1;
        var word = (num | 0) * (-neg | 1) & 0x3ffffff;
        this.words[0] = this.words[0] & mask0 | word & mask1;
        this.length = this.length & mask0 | 1 & mask1;
        this.negative = this.negative & mask0 | neg & mask1;
        return this;
      }
      /*
       * Conversion
       */

    }, {
      key: "toNumber",
      value: function toNumber() {
        var num = this.words[0];

        if (this.length === 2) {
          num += this.words[1] * 0x4000000;
        } else if (this.length === 3 && this.words[2] === 0x01) {
          // Note: at this stage it is known that the top bit is set.
          num += 0x10000000000000 + this.words[1] * 0x4000000;
        } else if (this.length > 2) {
          throw new RangeError('Number can only safely store up to 53 bits.');
        }

        return this.negative !== 0 ? -num : num;
      }
    }, {
      key: "toDouble",
      value: function toDouble() {
        var num = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          num = num * 0x4000000 + this.words[i];
        }

        return this.negative !== 0 ? -num : num;
      }
    }, {
      key: "valueOf",
      value: function valueOf() {
        return this.toDouble();
      }
    }, {
      key: "toBigInt",
      value: function toBigInt() {
        if (!HAS_BIGINT) throw new Error('BigInt is not supported!');
        var s52 = BigInteger(52);
        var s26 = BigInteger(26);
        var i = this.length - 1;
        var num = BigInteger(0);

        for (; i >= 1; i -= 2) {
          var hi = this.words[i] * 0x4000000;
          var lo = this.words[i - 1];
          num = num << s52 | BigInteger(hi + lo);
        }

        if (i >= 0) num = num << s26 | BigInteger(this.words[0]);
        return this.negative !== 0 ? -num : num;
      }
    }, {
      key: "toBool",
      value: function toBool() {
        return !this.isZero();
      }
    }, {
      key: "toString",
      value: function toString(base, padding) {
        base = getBase(base);
        if (padding == null) padding = 0;
        if (padding === 0) padding = 1;
        enforce$1(base >>> 0 === base, 'base', 'uint32');
        enforce$1(padding >>> 0 === padding, 'padding', 'uint32');
        if (base < 2 || base > 36) throw new RangeError('Base ranges between 2 and 36.');

        this._check();

        if (base === 16) {
          var _out = '';
          var off = 0;
          var carry = 0;

          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;
            if (carry !== 0 || i !== this.length - 1) _out = zeros[6 - word.length] + word + _out;else _out = word + _out;
            off += 2;

            if (off >= 26) {
              off -= 26;
              i -= 1;
            }
          }

          if (carry !== 0) _out = carry.toString(16) + _out;

          while (_out.length % padding !== 0) {
            _out = '0' + _out;
          }

          if (this.negative !== 0) _out = '-' + _out;
          return _out;
        }

        var groupSize = groupSizes[base - 1];
        var groupBase = groupBases[base - 1];
        var c = this.clone();
        var out = '';
        c.negative = 0;

        while (!c.isZero()) {
          var r = c.remrn(groupBase).toString(base);
          c.iquon(groupBase);
          if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;else out = r + out;
        }

        if (this.isZero()) out = '0';

        while (out.length % padding !== 0) {
          out = '0' + out;
        }

        if (this.negative !== 0) out = '-' + out;
        return out;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.toString(16, 2);
      }
    }, {
      key: "toArray",
      value: function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      }
    }, {
      key: "toBuffer",
      value: function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
      }
    }, {
      key: "toArrayLike",
      value: function toArrayLike(ArrayType, endian, length) {
        if (endian == null) endian = 'be';
        if (length == null) length = 0;
        enforce$1(typeof ArrayType === 'function', 'ArrayType', 'function');
        enforce$1(endian === 'be' || endian === 'le', 'endian', 'endianness');
        enforce$1(length >>> 0 === length, 'length', 'uint32');

        this._check();

        var bytes = this.byteLength();
        var size = length || Math.max(1, bytes);
        if (bytes > size) throw new RangeError('Byte array longer than desired length.');
        var res = allocate(ArrayType, size); // See: https://github.com/indutny/bn.js/pull/222

        if (endian === 'be') {
          var pos = res.length - 1;
          var carry = 0;

          for (var i = 0; i < this.length; i++) {
            var shift = (i & 3) << 1;
            var word = this.words[i] << shift | carry;
            res[pos--] = word & 0xff;
            if (pos >= 0) res[pos--] = word >>> 8 & 0xff;
            if (pos >= 0) res[pos--] = word >>> 16 & 0xff;

            if (shift === 6) {
              if (pos >= 0) res[pos--] = word >>> 24 & 0xff;
              carry = 0;
            } else {
              carry = word >>> 24;
            }
          }

          if (pos >= 0) {
            res[pos--] = carry;

            while (pos >= 0) {
              res[pos--] = 0;
            }

            carry = 0;
          }

          assert$2(carry === 0);
        } else {
          var _pos = 0;
          var _carry = 0;

          for (var _i6 = 0; _i6 < this.length; _i6++) {
            var _shift = (_i6 & 3) << 1;

            var _word = this.words[_i6] << _shift | _carry;

            res[_pos++] = _word & 0xff;
            if (_pos < res.length) res[_pos++] = _word >>> 8 & 0xff;
            if (_pos < res.length) res[_pos++] = _word >>> 16 & 0xff;

            if (_shift === 6) {
              if (_pos < res.length) res[_pos++] = _word >>> 24 & 0xff;
              _carry = 0;
            } else {
              _carry = _word >>> 24;
            }
          }

          if (_pos < res.length) {
            res[_pos++] = _carry;

            while (_pos < res.length) {
              res[_pos++] = 0;
            }

            _carry = 0;
          }

          assert$2(_carry === 0);
        }

        return res;
      }
    }, {
      key: "encode",
      value: function encode(endian, length) {
        return this.toBuffer(endian, length);
      }
      /*
       * Instantiation
       */

    }, {
      key: "of",
      value: function of(num, endian) {
        return this.fromNumber(num, endian);
      }
    }, {
      key: "fromNumber",
      value: function fromNumber(num, endian) {
        if (endian == null) endian = 'be';
        enforce$1(isInteger(num), 'num', 'integer');
        enforce$1(endian === 'be' || endian === 'le', 'endian', 'endianness');
        var neg = num < 0 | 0;
        if (neg) num = -num;

        if (num < 0x4000000) {
          this.words[0] = num & 0x3ffffff;
          this.length = 1;
        } else if (num < 0x10000000000000) {
          this.words = [num & 0x3ffffff, num / 0x4000000 & 0x3ffffff];
          this.length = 2;
        } else {
          this.words = [num & 0x3ffffff, num / 0x4000000 & 0x3ffffff, 1];
          this.length = 3;
        }

        this.negative = neg;
        if (endian === 'le') this.reverse();
        return this;
      }
    }, {
      key: "fromDouble",
      value: function fromDouble(num, endian) {
        if (endian == null) endian = 'be';
        enforce$1(typeof num === 'number', 'num', 'double');
        enforce$1(endian === 'be' || endian === 'le', 'endian', 'endianness');
        if (!isFinite(num)) num = 0;
        var neg = num <= -1 | 0;
        if (num < 0) num = -num;
        num = Math.floor(num);
        this.words = [];

        while (num > 0) {
          var lo = num % 0x4000000;
          var hi = (num - lo) / 0x4000000;
          this.words.push(lo);
          num = hi;
        }

        if (this.words.length === 0) this.words.push(0);
        this.length = this.words.length;
        this.negative = neg;
        if (endian === 'le') this.reverse();
        return this;
      }
    }, {
      key: "fromBigInt",
      value: function fromBigInt(num, endian) {
        if (endian == null) endian = 'be';
        enforce$1(typeof num === 'bigint', 'num', 'bigint');
        enforce$1(endian === 'be' || endian === 'le', 'endian', 'endianness');
        if (!HAS_BIGINT) throw new Error('BigInt is not supported!'); // You know the implementation has a
        // problem when strings are twice
        // as fast as bigints.

        var start = num < BigInteger(0) | 0;

        this._fromHex(num.toString(16), start);

        this.negative = start;
        if (endian === 'le') this.reverse();
        return this;
      }
    }, {
      key: "fromBool",
      value: function fromBool(value) {
        enforce$1(typeof value === 'boolean', 'value', 'boolean');
        this.words[0] = value | 0;
        this.length = 1;
        this.negative = 0;
        return this;
      }
    }, {
      key: "fromString",
      value: function fromString(str, base, endian) {
        if (base === 'le' || base === 'be') {
          var _ref14 = [endian, base];
          base = _ref14[0];
          endian = _ref14[1];
        }

        base = getBase(base);
        if (endian == null) endian = 'be';
        enforce$1(typeof str === 'string', 'string', 'string');
        enforce$1(base >>> 0 === base, 'base', 'uint32');
        enforce$1(endian === 'be' || endian === 'le', 'endian', 'endianness');
        if (base < 2 || base > 36) throw new Error('Base ranges between 2 and 36.');
        str = str.replace(/\s+/g, '');
        var start = 0;
        if (str.length > 0 && str.charCodeAt(0) === 0x2d) start = 1;
        if (base === 16) this._fromHex(str, start);else this._fromBase(str, base, start);
        this.negative = start;

        this._normalize();

        if (endian === 'le') this.reverse();
        return this;
      }
    }, {
      key: "_fromHex",
      value: function _fromHex(str, start) {
        this.length = Math.max(2, Math.ceil((str.length - start) / 6));
        this.words = new Array(this.length);

        for (var _i7 = 0; _i7 < this.length; _i7++) {
          this.words[_i7] = 0;
        } // Scan 24-bit chunks and add them to the number.


        var off = 0;
        var i = str.length - 6;
        var j = 0;

        for (; i >= start; i -= 6) {
          var w = parseHex(str, i, i + 6);
          this.words[j] |= w << off & 0x3ffffff; // `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb.

          this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j += 1;
          }
        }

        if (i + 6 !== start) {
          var _w3 = parseHex(str, start, i + 6);

          this.words[j] |= _w3 << off & 0x3ffffff;
          this.words[j + 1] |= _w3 >>> 26 - off & 0x3fffff;
        }

        return this._strip();
      }
    }, {
      key: "_fromBase",
      value: function _fromBase(str, base, start) {
        // Initialize as zero.
        this.words[0] = 0;
        this.length = 1;
        this.negative = 0; // Find length of limb in base.

        var limbLen = 0;
        var limbPow = 1;

        for (; limbPow <= 0x3ffffff; limbPow *= base) {
          limbLen += 1;
        }

        limbLen -= 1;
        limbPow = limbPow / base | 0;
        var total = str.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var i = start;

        for (; i < end; i += limbLen) {
          var word = parseBase(str, i, i + limbLen, base);
          this.imuln(limbPow);

          this._iaddn(word);
        }

        if (mod !== 0) {
          var pow = Math.pow(base, mod);

          var _word2 = parseBase(str, i, str.length, base);

          this.imuln(pow);

          this._iaddn(_word2);
        }

        return this;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        if (BN.isBN(json)) {
          if (json.red) return json.fromRed();
          return json.clone();
        }

        if (Array.isArray(json)) {
          var _iterator = _createForOfIteratorHelper$1(json),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var chunk = _step.value;
              enforce$1(typeof chunk === 'string', 'chunk', 'string');
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          json = json.join('');
        }

        return this.fromString(json, 16);
      }
    }, {
      key: "fromBN",
      value: function fromBN(num) {
        return this.inject(num);
      }
    }, {
      key: "fromArray",
      value: function fromArray(data, endian) {
        enforce$1(Array.isArray(data), 'data', 'array');
        return this.fromArrayLike(data, endian);
      }
    }, {
      key: "fromBuffer",
      value: function fromBuffer(data, endian) {
        enforce$1(Buffer.isBuffer(data), 'data', 'buffer');
        return this.fromArrayLike(data, endian);
      }
    }, {
      key: "fromArrayLike",
      value: function fromArrayLike(data, endian) {
        if (endian == null) endian = 'be';
        enforce$1(data && data.length >>> 0 === data.length, 'data', 'array-like');
        enforce$1(endian === 'be' || endian === 'le', 'endian', 'endianness');

        if (data.length === 0) {
          this.words[0] = 0;
          this.length = 1;
          this.negative = 0;
          return this;
        }

        this.length = Math.max(2, Math.ceil(data.length / 3));
        this.words = new Array(this.length);
        this.negative = 0;

        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }

        var left = data.length % 3;
        var off = 0;
        var j = 0;
        var w = 0;

        if (endian === 'be') {
          for (var _i8 = data.length - 1; _i8 >= 2; _i8 -= 3) {
            var _w4 = data[_i8] | data[_i8 - 1] << 8 | data[_i8 - 2] << 16;

            this.words[j] |= _w4 << off & 0x3ffffff;
            this.words[j + 1] = _w4 >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j += 1;
            }
          }

          switch (left) {
            case 2:
              w = data[1] | data[0] << 8;
              break;

            case 1:
              w = data[0];
              break;
          }
        } else {
          var len = data.length - left;

          for (var _i9 = 0; _i9 < len; _i9 += 3) {
            var _w5 = data[_i9] | data[_i9 + 1] << 8 | data[_i9 + 2] << 16;

            this.words[j] |= _w5 << off & 0x3ffffff;
            this.words[j + 1] = _w5 >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j += 1;
            }
          }

          switch (left) {
            case 2:
              w = data[len] | data[len + 1] << 8;
              break;

            case 1:
              w = data[len];
              break;
          }
        }

        if (left > 0) {
          this.words[j] |= w << off & 0x3ffffff;
          this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        }

        return this._strip();
      }
    }, {
      key: "decode",
      value: function decode(data, endian) {
        return this.fromBuffer(data, endian);
      }
    }, {
      key: "from",
      value: function from(num, base, endian) {
        if (num == null) return this;

        if (base === 'le' || base === 'be') {
          var _ref15 = [endian, base];
          base = _ref15[0];
          endian = _ref15[1];
        }

        if (typeof num === 'number') return this.fromNumber(num, endian);
        if (typeof num === 'bigint') return this.fromBigInt(num, endian);
        if (typeof num === 'string') return this.fromString(num, base, endian);

        if (_typeof__default['default'](num) === 'object') {
          if (BN.isBN(num)) return this.fromBN(num, endian);
          if (num.length >>> 0 === num.length) return this.fromArrayLike(num, endian);
        }

        if (typeof num === 'boolean') return this.fromBool(num);
        throw new TypeError('Non-numeric object passed to BN.');
      }
      /*
       * Static Methods
       */

    }], [{
      key: "min",
      value: function min() {
        var min = null;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        for (var _i10 = 0, _args = args; _i10 < _args.length; _i10++) {
          var num = _args[_i10];
          enforce$1(BN.isBN(num), 'num', 'bignum');
          if (!min || num.cmp(min) < 0) min = num;
        }

        return min || new BN(0);
      }
    }, {
      key: "max",
      value: function max() {
        var max = null;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        for (var _i11 = 0, _args2 = args; _i11 < _args2.length; _i11++) {
          var num = _args2[_i11];
          enforce$1(BN.isBN(num), 'num', 'bignum');
          if (!max || num.cmp(max) > 0) max = num;
        }

        return max || new BN(0);
      }
    }, {
      key: "cmp",
      value: function cmp(a, b) {
        enforce$1(BN.isBN(a), 'a', 'bignum');
        return a.cmp(b);
      }
    }, {
      key: "ucmp",
      value: function ucmp(a, b) {
        enforce$1(BN.isBN(a), 'a', 'bignum');
        return a.ucmp(b);
      }
    }, {
      key: "red",
      value: function red(num) {
        return new Red(num);
      }
    }, {
      key: "barrett",
      value: function barrett(num) {
        return new Barrett(num);
      }
    }, {
      key: "mont",
      value: function mont(num) {
        return new Mont(num);
      }
    }, {
      key: "_prime",
      value: function _prime(name) {
        if (primes[name]) return primes[name];
        var prime;
        if (name === 'p192') prime = new P192();else if (name === 'p224') prime = new P224();else if (name === 'p521') prime = new P521();else if (name === 'k256') prime = new K256();else if (name === 'p251') prime = new P251();else if (name === 'p25519') prime = new P25519();else if (name === 'p448') prime = new P448();else throw new Error("Unknown prime: \"".concat(name, "\"."));
        primes[name] = prime;
        return prime;
      }
    }, {
      key: "prime",
      value: function prime(name) {
        return BN._prime(name).p.clone();
      }
    }, {
      key: "pow",
      value: function pow(num, exp) {
        if (num === 2) return BN.shift(1, exp);
        return new BN().fromNumber(num).pown(exp);
      }
    }, {
      key: "shift",
      value: function shift(num, bits) {
        if (num === 1) return new BN(0).usetn(bits, 1);
        return new BN().fromNumber(num).ishln(bits);
      }
    }, {
      key: "mask",
      value: function mask(bits) {
        return BN.shift(1, bits).isubn(1);
      }
    }, {
      key: "randomBits",
      value: function randomBits(rng, bits) {
        enforce$1(rng != null, 'rng', 'rng');
        enforce$1(bits >>> 0 === bits, 'bits', 'uint32');

        if (_typeof__default['default'](rng) === 'object') {
          enforce$1(typeof rng.randomBytes === 'function', 'rng', 'rng');
          var size = bits + 7 >>> 3;
          var total = size * 8;
          var bytes = rng.randomBytes(size);
          enforce$1(Buffer.isBuffer(bytes), 'bytes', 'buffer');
          if (bytes.length !== size) throw new RangeError('Invalid number of bytes returned from RNG.');

          var _num = BN.fromBuffer(bytes);

          if (total > bits) _num.iushrn(total - bits);
          return _num;
        }

        enforce$1(typeof rng === 'function', 'rng', 'rng');
        var num = rng(bits);
        enforce$1(BN.isBN(num), 'num', 'bignum');
        range$1(num.negative === 0, 'RNG');
        nonred(!num.red, 'RNG');
        if (num.bitLength() > bits) throw new RangeError('Invalid number of bits returned from RNG.');
        return num;
      }
    }, {
      key: "random",
      value: function random(rng, min, max) {
        min = BN.cast(min, 16);
        max = BN.cast(max, 16);
        if (min.cmp(max) > 0) throw new RangeError('Minimum cannot be greater than maximum.');
        var space = max.sub(min).iabs();
        var bits = space.bitLength();
        if (bits === 0) return min.clone();

        for (;;) {
          var num = BN.randomBits(rng, bits); // Maximum is _exclusive_!

          if (num.cmp(space) >= 0) continue; // Minimum is _inclusive_!

          num.iadd(min);
          return num;
        }
      }
    }, {
      key: "of",
      value: function of(num, endian) {
        return new BN().of(num, endian);
      }
    }, {
      key: "fromNumber",
      value: function fromNumber(num, endian) {
        return new BN().fromNumber(num, endian);
      }
    }, {
      key: "fromDouble",
      value: function fromDouble(num, endian) {
        return new BN().fromDouble(num, endian);
      }
    }, {
      key: "fromBigInt",
      value: function fromBigInt(num, endian) {
        return new BN().fromBigInt(num, endian);
      }
    }, {
      key: "fromBool",
      value: function fromBool(value) {
        return new BN().fromBool(value);
      }
    }, {
      key: "fromString",
      value: function fromString(str, base, endian) {
        return new BN().fromString(str, base, endian);
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        return new BN().fromJSON(json);
      }
    }, {
      key: "fromBN",
      value: function fromBN(num) {
        return new BN().fromBN(num);
      }
    }, {
      key: "fromArray",
      value: function fromArray(data, endian) {
        return new BN().fromArray(data, endian);
      }
    }, {
      key: "fromBuffer",
      value: function fromBuffer(data, endian) {
        return new BN().fromBuffer(data, endian);
      }
    }, {
      key: "fromArrayLike",
      value: function fromArrayLike(data, endian) {
        return new BN().fromArrayLike(data, endian);
      }
    }, {
      key: "decode",
      value: function decode(data, endian) {
        return new BN().decode(data, endian);
      }
    }, {
      key: "from",
      value: function from(num, base, endian) {
        return new BN().from(num, base, endian);
      }
    }, {
      key: "cast",
      value: function cast(num, base, endian) {
        if (BN.isBN(num)) return num;
        return new BN(num, base, endian);
      }
    }, {
      key: "isBN",
      value: function isBN(obj) {
        return obj instanceof BN;
      }
    }]);

    return BN;
  }();
  /*
   * Static
   */


  BN.BN = BN;
  BN.wordSize = 26;
  BN.native = 0;
  /**
   * Prime
   */

  var Prime = /*#__PURE__*/function () {
    function Prime(name, p) {
      _classCallCheck__default['default'](this, Prime);

      // P = 2^N - K
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = BN.shift(1, this.n).isub(this.p);
      this.lo = this.p.clone();
      this.one = this.p.clone();
    }

    _createClass__default['default'](Prime, [{
      key: "ireduce",
      value: function ireduce(num) {
        // Assumes that `num` is less than `P^2`:
        // num = HI * (2^N - K) + HI * K + LO = HI * K + LO (mod P)
        var neg = num.negative !== 0; // Track bits.

        var bits = num.bitLength(); // Must be less than P^2.

        assert$2(bits <= this.n * 2); // Ensure positive.

        num.negative = 0; // Reduce.

        while (bits > this.n) {
          // lo = num & ((1 << n) - 1)
          // num = num >> n
          this.split(num, this.lo); // num = num * K

          this.imulK(num); // num = num + lo

          num._iadd(num, this.lo); // bits = bitlen(num)


          bits = num.bitLength();
        } // Final reduction.


        var cmp = bits < this.n ? -1 : num.ucmp(this.p);

        if (cmp === 0) {
          num.words[0] = 0;
          num.length = 1;
        } else if (cmp > 0) {
          num._isub(num, this.p);
        } else ; // Adjust sign.


        if (neg && !num.isZero()) num._isub(this.p, num);
        return num;
      }
    }, {
      key: "split",
      value: function split(input, out) {
        input._split(this.n, out);
      }
    }, {
      key: "imulK",
      value: function imulK(num) {
        return num.imul(this.k);
      }
    }]);

    return Prime;
  }();
  /**
   * P192
   */


  var P192 = /*#__PURE__*/function (_Prime) {
    _inherits__default['default'](P192, _Prime);

    var _super = _createSuper$b(P192);

    function P192() {
      _classCallCheck__default['default'](this, P192);

      // 2^192 - 2^64 - 1 (= 3 mod 4)
      return _super.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe' + 'ffffffff ffffffff');
    }

    _createClass__default['default'](P192, [{
      key: "imulK",
      value: function imulK(num) {
        // K = 0x10000000000000001
        // K = 2^64 + 1
        var one = this.one.inject(num);
        return num.iushln(64)._iadd(num, one);
      }
    }]);

    return P192;
  }(Prime);
  /**
   * P224
   */


  var P224 = /*#__PURE__*/function (_Prime2) {
    _inherits__default['default'](P224, _Prime2);

    var _super2 = _createSuper$b(P224);

    function P224() {
      _classCallCheck__default['default'](this, P224);

      // 2^224 - 2^96 + 1 (no congruence)
      return _super2.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff' + '00000000 00000000 00000001');
    }

    _createClass__default['default'](P224, [{
      key: "imulK",
      value: function imulK(num) {
        // K = 0xffffffffffffffffffffffff
        // K = 2^96 - 1
        var one = this.one.inject(num);
        return num.iushln(96)._isub(num, one);
      }
    }]);

    return P224;
  }(Prime);
  /**
   * P521
   */


  var P521 = /*#__PURE__*/function (_Prime3) {
    _inherits__default['default'](P521, _Prime3);

    var _super3 = _createSuper$b(P521);

    function P521() {
      _classCallCheck__default['default'](this, P521);

      // 2^521 - 1 (= 3 mod 4)
      return _super3.call(this, 'p521', '000001ff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff');
    }

    _createClass__default['default'](P521, [{
      key: "imulK",
      value: function imulK(num) {
        // K = 0x01
        return num;
      }
    }]);

    return P521;
  }(Prime);
  /**
   * K256
   */


  var K256 = /*#__PURE__*/function (_Prime4) {
    _inherits__default['default'](K256, _Prime4);

    var _super4 = _createSuper$b(K256);

    function K256() {
      _classCallCheck__default['default'](this, K256);

      // 2^256 - 2^32 - 977 (= 3 mod 4)
      return _super4.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe fffffc2f');
    }

    _createClass__default['default'](K256, [{
      key: "split",
      value: function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var len = Math.min(input.length, 9);

        output._alloc(len + 1);

        for (var _i12 = 0; _i12 < len; _i12++) {
          output.words[_i12] = input.words[_i12];
        }

        output.length = len;

        if (input.length <= 9) {
          output._strip();

          input.words[0] = 0;
          input.length = 1;
          return;
        } // Shift by 9 limbs.


        var prev = input.words[9];
        var i = 10;
        output.words[output.length++] = prev & mask;

        output._strip();

        for (; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }

        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;else input.length -= 9;

        input._strip(); // Unsure if we need this.

      }
    }, {
      key: "imulK",
      value: function imulK(num) {
        // K = 0x1000003d1 = [0x40, 0x3d1]
        // K = 2^32 + 977
        num._expand(num.length + 2); // Bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390


        var lo = 0;

        for (var i = 0; i < num.length; i++) {
          var w = num.words[i];
          lo += w * 0x3d1;
          num.words[i] = lo & 0x3ffffff;
          lo = w * 0x40 + Math.floor(lo / 0x4000000);
        } // Fast length reduction.


        if (num.words[num.length - 1] === 0) {
          num.length -= 1;
          if (num.words[num.length - 1] === 0) num.length -= 1;
        } // Note: we shouldn't need to strip here.


        return num;
      }
    }]);

    return K256;
  }(Prime);
  /**
   * P251
   */


  var P251 = /*#__PURE__*/function (_Prime5) {
    _inherits__default['default'](P251, _Prime5);

    var _super5 = _createSuper$b(P251);

    function P251() {
      _classCallCheck__default['default'](this, P251);

      // 2^251 - 9
      return _super5.call(this, 'p251', '07ffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff fffffff7');
    }

    _createClass__default['default'](P251, [{
      key: "imulK",
      value: function imulK(num) {
        // K = 0x09
        if (num.isZero()) return num;
        var carry = 0;

        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] * 0x09 + carry;
          carry = w >>> 26;
          num.words[i] = w & 0x3ffffff;
        }

        if (carry !== 0) {
          num._alloc(num.length + 1);

          num.words[num.length++] = carry;
        } // Note: we shouldn't need to strip here.


        return num;
      }
    }]);

    return P251;
  }(Prime);
  /**
   * P25519
   */


  var P25519 = /*#__PURE__*/function (_Prime6) {
    _inherits__default['default'](P25519, _Prime6);

    var _super6 = _createSuper$b(P25519);

    function P25519() {
      _classCallCheck__default['default'](this, P25519);

      // 2^255 - 19 (= 5 mod 8)
      return _super6.call(this, 'p25519', '7fffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffed');
    }

    _createClass__default['default'](P25519, [{
      key: "imulK",
      value: function imulK(num) {
        // K = 0x13
        var carry = 0;

        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] * 0x13 + carry;
          carry = w >>> 26;
          num.words[i] = w & 0x3ffffff;
        }

        if (carry !== 0) {
          num._alloc(num.length + 1);

          num.words[num.length++] = carry;
        } // Note: we shouldn't need to strip here.


        return num;
      }
    }]);

    return P25519;
  }(Prime);
  /**
   * P448
   */


  var P448 = /*#__PURE__*/function (_Prime7) {
    _inherits__default['default'](P448, _Prime7);

    var _super7 = _createSuper$b(P448);

    function P448() {
      _classCallCheck__default['default'](this, P448);

      // 2^448 - 2^224 - 1 (= 3 mod 4)
      return _super7.call(this, 'p448', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff');
    }

    _createClass__default['default'](P448, [{
      key: "imulK",
      value: function imulK(num) {
        // K = 0x100000000000000000000000000000000000000000000000000000001
        // K = 2^224 + 1
        var one = this.one.inject(num);
        return num.iushln(224)._iadd(num, one);
      }
    }]);

    return P448;
  }(Prime);
  /**
   * Reduction Engine
   */


  var Red = /*#__PURE__*/function () {
    function Red(m) {
      _classCallCheck__default['default'](this, Red);

      var prime = null;

      if (typeof m === 'string') {
        prime = BN._prime(m);
        m = prime.p;
      }

      enforce$1(BN.isBN(m), 'm', 'bignum');
      nonred(!m.red, 'reduction');
      range$1(m.sign() > 0, 'reduction');
      this.m = m;
      this.prime = prime;
      this.mb = null;
      this.sm1 = null;
    }

    _createClass__default['default'](Red, [{
      key: "_verify1",
      value: function _verify1(a) {
        range$1(a.negative === 0, 'red');
        red(a.red != null, 'red');
      }
    }, {
      key: "_verify2",
      value: function _verify2(a, b) {
        range$1((a.negative | b.negative) === 0, 'red');
        red(a.red != null && a.red === b.red, 'red');
      }
    }, {
      key: "precompute",
      value: function precompute() {
        // Precompute `sqrt(-1)` for primes congruent to 5 mod 8.
        if (this.sm1 === null && this.m.andln(7) === 5) {
          var x = new BN(2).toRed(this);
          var e = this.m.subn(1).iushrn(2); // sqrt(-1) = 2^((p - 1) / 4) mod p

          this.sm1 = this.pow(x, e);
        }

        return this;
      }
    }, {
      key: "convertTo",
      value: function convertTo(num) {
        var res = num.mod(this.m);
        res.red = this;
        return res;
      }
    }, {
      key: "convertFrom",
      value: function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }
    }, {
      key: "intTo",
      value: function intTo(a) {
        return a;
      }
    }, {
      key: "intFrom",
      value: function intFrom(a) {
        return a;
      }
    }, {
      key: "imod",
      value: function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.imod(this.m)._forceRed(this);
      }
    }, {
      key: "iadd",
      value: function iadd(a, b) {
        this._verify2(a, b);

        a._iadd(a, b);

        if (a.ucmp(this.m) >= 0) a._isub(a, this.m);
        return a;
      }
    }, {
      key: "add",
      value: function add(a, b) {
        if (a.length < b.length) return this.iadd(b.clone(), a);
        return this.iadd(a.clone(), b);
      }
    }, {
      key: "iaddn",
      value: function iaddn(a, num) {
        this._verify1(a);

        if (num < 0) return this.isubn(a, -num);
        if (this.m.length === 1) num %= this.m.words[0];

        a._iaddn(num);

        if (a.ucmp(this.m) >= 0) a._isub(a, this.m);
        return a;
      }
    }, {
      key: "addn",
      value: function addn(a, num) {
        return this.iaddn(a.clone(), num);
      }
    }, {
      key: "isub",
      value: function isub(a, b) {
        this._verify2(a, b); //  0: a - a mod m == 0
        // -1: a - b mod m == m - (b - a)
        // +1: a - b mod m == a - b


        var cmp = a.ucmp(b);

        if (cmp === 0) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }

        if (cmp < 0) {
          a._isub(b, a);

          a._isub(this.m, a);
        } else {
          a._isub(a, b);
        }

        return a;
      }
    }, {
      key: "sub",
      value: function sub(a, b) {
        return this.isub(a.clone(), b);
      }
    }, {
      key: "isubn",
      value: function isubn(a, num) {
        this._verify1(a);

        if (num < 0) return this.iaddn(a, -num);
        if (this.m.length === 1) num %= this.m.words[0]; //  <: a - b mod m == m - (b - a)
        // >=: a - b mod m == a - b

        if (a.length === 1 && a.words[0] < num) {
          a.words[0] = num - a.words[0];

          a._isub(this.m, a);
        } else {
          a._isubn(num);
        }

        return a;
      }
    }, {
      key: "subn",
      value: function subn(a, num) {
        return this.isubn(a.clone(), num);
      }
    }, {
      key: "imul",
      value: function imul(a, b) {
        this._verify2(a, b);

        return this.imod(a.imul(b));
      }
    }, {
      key: "mul",
      value: function mul(a, b) {
        this._verify2(a, b);

        return this.imod(a.mul(b));
      }
    }, {
      key: "imuln",
      value: function imuln(a, num) {
        this._verify1(a);

        if (a.isZero()) return a;

        if (num === 0) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }

        var neg = num < 0;
        if (neg) num = -num;
        if (this.m.length === 1) num %= this.m.words[0];
        a.imuln(num);

        if (num <= 16) {
          // Quick reduction.
          while (a.ucmp(this.m) >= 0) {
            a._isub(a, this.m);
          }
        } else {
          this.imod(a);
        }

        if (neg) this.ineg(a);
        return a;
      }
    }, {
      key: "muln",
      value: function muln(a, num) {
        return this.imuln(a.clone(), num);
      }
    }, {
      key: "idiv",
      value: function idiv(a, b) {
        return this.div(a, b)._move(a);
      }
    }, {
      key: "div",
      value: function div(a, b) {
        return this.mul(a, this.invert(b));
      }
    }, {
      key: "idivn",
      value: function idivn(a, num) {
        return this.divn(a, num)._move(a);
      }
    }, {
      key: "divn",
      value: function divn(a, num) {
        return this.div(a, this.convertTo(new BN(num)));
      }
    }, {
      key: "ipow",
      value: function ipow(a, num) {
        return this.pow(a, num)._move(a);
      }
    }, {
      key: "pow",
      value: function pow(a, num) {
        this._verify1(a);

        if (num.isNeg()) a = this.invert(a); // Small exponent.

        if (num.length === 1) return this.pown(a, num.words[0]); // Call out to BigInt.

        if (HAS_BIGINT && !this.prime) return this.powInt(a, num); // Otherwise, a BN implementation.

        return this.powNum(a, num);
      }
    }, {
      key: "powNum",
      value: function powNum(a, num) {
        // Sliding window.
        var wnd = new Array(WND_SIZE);
        wnd[0] = this.sqrn(a, WND_WIDTH - 1);

        for (var _i13 = 1; _i13 < WND_SIZE; _i13++) {
          wnd[_i13] = this.mul(wnd[_i13 - 1], a);
        }

        var i = num.bitLength();
        var r = new BN(1).toRed(this);

        while (i >= WND_WIDTH) {
          var pos = i - WND_WIDTH;
          var bits = num.bits(pos, WND_WIDTH);

          if (bits < WND_SIZE) {
            r = this.sqr(r);
            i -= 1;
            continue;
          }

          r = this.sqrn(r, WND_WIDTH);
          r = this.mul(r, wnd[bits & ~WND_SIZE]);
          i = pos;
        }

        if (i > 0) {
          var _bits2 = num.bits(0, i);

          while (i--) {
            r = this.sqr(r);
            if (_bits2 >> i & 1) r = this.mul(r, a);
          }
        }

        return r;
      }
    }, {
      key: "powInt",
      value: function powInt(a, num) {
        if (this.mb === null) this.mb = this.m.toBigInt();
        var x = this.intFrom(a.toBigInt());

        var y = _powInt(x, num, this.mb);

        var z = this.intTo(y);
        return BN.fromBigInt(z)._forceRed(this);
      }
    }, {
      key: "sqrn",
      value: function sqrn(a, n) {
        for (var i = 0; i < n; i++) {
          a = this.sqr(a);
        }

        return a;
      }
    }, {
      key: "ipown",
      value: function ipown(a, num) {
        return this.pown(a, num)._move(a);
      }
    }, {
      key: "pown",
      value: function pown(a, num) {
        this._verify1(a);

        if (num < 0) {
          a = this.invert(a);
          num = -num;
        }

        if (num === 0) return new BN(1).toRed(this);
        if (num === 1) return a.clone();
        var bits = countBits(num);
        var r = a;

        for (var i = bits - 2; i >= 0; i--) {
          r = this.sqr(r);
          if (num >> i & 1) r = this.mul(r, a);
        }

        return r;
      }
    }, {
      key: "isqr",
      value: function isqr(a) {
        return this.imul(a, a);
      }
    }, {
      key: "sqr",
      value: function sqr(a) {
        return this.mul(a, a);
      }
    }, {
      key: "isqrt",
      value: function isqrt(x) {
        return this.sqrt(x)._move(x);
      }
    }, {
      key: "sqrt",
      value: function sqrt(x) {
        this._verify1(x); // Fast case (p = 3 mod 4).


        if (this.m.andln(3) === 3) return this.sqrt3mod4(x); // Fast case (p = 5 mod 8).

        if (this.m.andln(7) === 5) {
          if (this.sm1 != null) return this.sqrt5mod8sm1(x);
          return this.sqrt5mod8(x);
        } // Slow case (Tonelli-Shanks).


        return this.sqrt0(x);
      }
    }, {
      key: "sqrt3mod4",
      value: function sqrt3mod4(x) {
        var e = this.m.addn(1).iushrn(2); // (p + 1) / 4

        var b = this.pow(x, e);
        if (!this.sqr(b).eq(x)) throw new Error('X is not a square mod P.');
        return b;
      }
    }, {
      key: "sqrt5mod8",
      value: function sqrt5mod8(x) {
        // Atkin's Algorithm.
        var one = new BN(1).toRed(this);
        var e = this.m.ushrn(3); // (p - 5) / 8

        var x2 = this.add(x, x);
        var alpha = this.pow(x2, e);
        var beta = this.mul(x2, this.sqr(alpha));
        var b = this.mul(this.mul(alpha, x), this.isub(beta, one));
        if (!this.sqr(b).eq(x)) throw new Error('X is not a square mod P.');
        return b;
      }
    }, {
      key: "sqrt5mod8sm1",
      value: function sqrt5mod8sm1(x) {
        var e = this.m.addn(3).iushrn(3); // (p + 3) / 8

        var b = this.pow(x, e);
        if (this.sqr(b).eq(x)) return b;
        var c = this.mul(b, this.sm1);
        if (this.sqr(c).eq(x)) return c;
        throw new Error('X is not a square mod P.');
      }
    }, {
      key: "sqrt0",
      value: function sqrt0(x) {
        if (this.m.cmpn(1) === 0 || !this.m.isOdd()) throw new Error('Invalid prime.');

        switch (this.jacobi(x)) {
          case -1:
            throw new Error('X is not a square mod P.');

          case 0:
            return new BN(0)._forceRed(this);
        }

        var one = new BN(1).toRed(this);
        var s = this.m.subn(1);

        var e = s._makeOdd();

        var n = new BN(2).toRed(this);

        while (this.jacobi(n) !== -1) {
          this.iadd(n, one);
        }

        var b = this.pow(x, s);
        var g = this.pow(n, s);
        var y = this.pow(x, s.iaddn(1).iushrn(1));
        var k = e;

        for (;;) {
          var t = b;
          var m = 0;

          while (t.cmp(one) !== 0 && m < k) {
            t = this.sqr(t);
            m += 1;
          }

          if (m === 0) break;
          assert$2(m < k);
          t = this.sqrn(g, k - m - 1);
          g = this.sqr(t);
          y = this.mul(y, t);
          b = this.mul(b, g);
          k = m;
        }

        return y;
      }
    }, {
      key: "idivsqrt",
      value: function idivsqrt(u, v) {
        return this.divsqrt(u, v)._move(u);
      }
    }, {
      key: "divsqrt",
      value: function divsqrt(u, v) {
        this._verify2(u, v); // v = 0


        if (v.isZero()) throw new RangeError('Not invertible.'); // p = 3 mod 4

        if (this.m.andln(3) === 3) return this.divsqrt3mod4(u, v); // p = 5 mod 8

        if (this.sm1 != null && this.m.andln(7) === 5) return this.divsqrt5mod8(u, v);
        return this.sqrt(this.div(u, v));
      }
    }, {
      key: "divsqrt3mod4",
      value: function divsqrt3mod4(u, v) {
        // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p
        var e = this.m.subn(3).iushrn(2);
        var u2 = this.sqr(u);
        var u3 = this.mul(u2, u);
        var u5 = this.mul(u3, u2);
        var v3 = this.mul(this.sqr(v), v);
        var p = this.pow(this.mul(u5, v3), e);
        var x = this.mul(this.mul(u3, v), p);
        var c = this.mul(v, this.sqr(x));
        if (c.cmp(u) === 0) return x;
        throw new Error('X is not a square mod P.');
      }
    }, {
      key: "divsqrt5mod8",
      value: function divsqrt5mod8(u, v) {
        // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p
        var e = this.m.subn(5).iushrn(3);
        var v3 = this.mul(this.sqr(v), v);
        var v7 = this.mul(this.sqr(v3), v);
        var p = this.pow(this.mul(u, v7), e);
        var x = this.mul(this.mul(u, v3), p);
        var c = this.mul(v, this.sqr(x));
        if (c.cmp(u) === 0) return x;
        if (this.ineg(c).cmp(u) === 0) return this.mul(x, this.sm1);
        throw new Error('X is not a square mod P.');
      }
    }, {
      key: "isSquare",
      value: function isSquare(a) {
        var symbol;
        if (this.prime) symbol = this.legendre(a);else if (this.m.isOdd()) symbol = this.jacobi(a);else symbol = this.kronecker(a);
        return Boolean(~symbol >>> 31);
      }
    }, {
      key: "ishl",
      value: function ishl(a, num) {
        this._verify1(a);

        return this.imod(a.iushl(num));
      }
    }, {
      key: "shl",
      value: function shl(a, num) {
        return this.ishl(a.clone(), num);
      }
    }, {
      key: "ishln",
      value: function ishln(a, num) {
        this._verify1(a);

        a.iushln(num);

        if (num <= 4) {
          // Quick reduction.
          while (a.ucmp(this.m) >= 0) {
            a._isub(a, this.m);
          }
        } else {
          this.imod(a);
        }

        return a;
      }
    }, {
      key: "shln",
      value: function shln(a, num) {
        return this.ishln(a.clone(), num);
      }
    }, {
      key: "ineg",
      value: function ineg(a) {
        this._verify1(a);

        if (!a.isZero()) a._isub(this.m, a);
        return a;
      }
    }, {
      key: "neg",
      value: function neg(a) {
        return this.ineg(a.clone());
      }
    }, {
      key: "eq",
      value: function eq(a, b) {
        this._verify2(a, b);

        return a.ucmp(b) === 0;
      }
    }, {
      key: "eqn",
      value: function eqn(a, num) {
        this._verify1(a);

        if (this.m.length === 1) {
          num %= this.m.words[0];
          if (num < 0) num += this.m.words[0];
          return a.ucmpn(num) === 0;
        }

        if (num < 0) {
          this.m._isubn(-num);

          var cmp = a.ucmp(this.m);

          this.m._iaddn(-num);

          return cmp === 0;
        }

        return a.ucmpn(num) === 0;
      }
    }, {
      key: "isHigh",
      value: function isHigh(a) {
        return !this.isLow(a);
      }
    }, {
      key: "isLow",
      value: function isLow(a) {
        this._verify1(a);

        return a.ucmp(this.m.ushrn(1)) <= 0;
      }
    }, {
      key: "isOdd",
      value: function isOdd(a) {
        this._verify1(a);

        return a.isOdd();
      }
    }, {
      key: "isEven",
      value: function isEven(a) {
        this._verify1(a);

        return a.isEven();
      }
    }, {
      key: "legendre",
      value: function legendre(num) {
        this._verify1(num);

        if (this.m.isEven()) throw new Error('legendre: `num` must be odd.'); // Euler's criterion.

        var e = this.m.subn(1).iushrn(1); // (p - 1) / 2

        var symbol = this.pow(num, e);
        var one = new BN(1).toRed(this);
        var a = symbol.czero();
        var b = symbol.ceq(one);
        var c = symbol.ceq(this.ineg(one)); // Must be one of these.

        if ((a | b | c) === 0) throw new Error('Invalid prime.'); // Cannot be multiple.

        assert$2(a + b + c === 1); // 0, 1, or -1.

        return b - c;
      }
    }, {
      key: "jacobi",
      value: function jacobi(a) {
        this._verify1(a);

        return a.jacobi(this.m);
      }
    }, {
      key: "kronecker",
      value: function kronecker(a) {
        this._verify1(a);

        return a.kronecker(this.m);
      }
    }, {
      key: "iinvert",
      value: function iinvert(a) {
        return this.invert(a)._move(a);
      }
    }, {
      key: "invert",
      value: function invert(a) {
        this._verify1(a);

        return a.invert(this.m)._forceRed(this);
      }
    }, {
      key: "ifermat",
      value: function ifermat(a) {
        return this.fermat(a)._move(a);
      }
    }, {
      key: "fermat",
      value: function fermat(a) {
        this._verify1(a);

        if (a.isZero() || this.m.cmpn(1) === 0) throw new RangeError('Not invertible.'); // Invert using fermat's little theorem.

        return this.pow(a, this.m.subn(2));
      }
    }, {
      key: custom$1,
      value: function value() {
        if (this.prime) return "<Red: ".concat(this.prime.name, ">");
        return "<Red: ".concat(this.m.toString(10), ">");
      }
    }, {
      key: "mont",
      get: function get() {
        return false;
      }
    }]);

    return Red;
  }();
  /**
   * Barrett Engine
   */


  var Barrett = /*#__PURE__*/function (_Red) {
    _inherits__default['default'](Barrett, _Red);

    var _super8 = _createSuper$b(Barrett);

    function Barrett(m) {
      var _this;

      _classCallCheck__default['default'](this, Barrett);

      _this = _super8.call(this, m);
      _this.prime = null;
      _this.n = _this.m.bitLength();
      if (_this.n % 26 !== 0) _this.n += 26 - _this.n % 26;
      _this.k = _this.n * 2;
      _this.w = _this.k / 26;
      _this.b = BN.shift(1, _this.k).div(_this.m);
      return _this;
    }

    _createClass__default['default'](Barrett, [{
      key: "convertTo",
      value: function convertTo(num) {
        if (num.length > this.w) return _get__default['default'](_getPrototypeOf__default['default'](Barrett.prototype), "convertTo", this).call(this, num);
        return this.imod(num.clone());
      }
    }, {
      key: "_shift",
      value: function _shift(q) {
        var i = 0;
        var j = this.w;

        while (j < q.length) {
          q.words[i++] = q.words[j++];
        }

        if (i === 0) q.words[i++] = 0;
        q.length = i;
      }
    }, {
      key: "imod",
      value: function imod(a) {
        var neg = a.negative;
        assert$2(a.length <= this.w);
        a.negative = 0;
        var q = a.mul(this.b); // Shift right by `k` bits.

        this._shift(q);

        a._isub(a, q.mul(this.m));

        if (a.ucmp(this.m) >= 0) a._isub(a, this.m);
        if (neg && !a.isZero()) a._isub(this.m, a);
        a.red = this;
        return a;
      }
    }]);

    return Barrett;
  }(Red);
  /**
   * Montgomery Engine
   */


  var Mont = /*#__PURE__*/function (_Red2) {
    _inherits__default['default'](Mont, _Red2);

    var _super9 = _createSuper$b(Mont);

    function Mont(m) {
      var _this2;

      _classCallCheck__default['default'](this, Mont);

      _this2 = _super9.call(this, m); // Note that:
      //
      //   mi = (-m^-1 mod (2^(n * 2))) mod r
      //
      // and:
      //
      //   mi = (((2^n)^-1 mod m) * r^-1 - 1) / m
      //
      // are equivalent.

      _this2.prime = null;
      _this2.n = _this2.m.length * 26;
      _this2.r = BN.shift(1, _this2.n);
      _this2.r2 = BN.shift(1, _this2.n * 2).imod(_this2.m);
      _this2.ri = _this2.r.invert(_this2.m);
      _this2.mi = _this2.r.mul(_this2.ri).isubn(1).div(_this2.m);
      _this2.rib = null;
      return _this2;
    }

    _createClass__default['default'](Mont, [{
      key: "convertTo",
      value: function convertTo(num) {
        if (num.isNeg() || num.ucmp(this.m) >= 0) return this.imod(num.ushln(this.n)); // Equivalent to: (num * 2^n) mod m

        return this.mul(num, this.r2);
      }
    }, {
      key: "convertFrom",
      value: function convertFrom(num) {
        // Equivalent to: num * r^-1 mod m
        var r = this.mul(num, new BN(1));
        r.red = null;
        return r;
      }
    }, {
      key: "intTo",
      value: function intTo(a) {
        return (a << BigInteger(this.n)) % this.mb;
      }
    }, {
      key: "intFrom",
      value: function intFrom(a) {
        if (this.rib === null) this.rib = this.ri.toBigInt();
        return a * this.rib % this.mb;
      }
    }, {
      key: "iaddn",
      value: function iaddn(a, num) {
        return this.iadd(a, this.convertTo(new BN(num)));
      }
    }, {
      key: "isubn",
      value: function isubn(a, num) {
        return this.isub(a, this.convertTo(new BN(num)));
      }
    }, {
      key: "imul",
      value: function imul(a, b) {
        return this.mul(a, b)._move(a);
      }
    }, {
      key: "mul",
      value: function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.umaskn(this.n).mul(this.mi).iumaskn(this.n);
        var u = t.iadd(c.mul(this.m)).iushrn(this.n);
        if (u.ucmp(this.m) >= 0) u._isub(u, this.m);
        return u._forceRed(this);
      }
    }, {
      key: "imuln",
      value: function imuln(a, num) {
        this._verify1(a);

        if (a.isZero()) return a;

        if (num === 0) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }

        var neg = num < 0;
        if (neg) num = -num;
        if (this.m.length === 1) num %= this.m.words[0];
        var bits = countBits(num); // Potentially compute with additions.
        // This avoids an expensive division.

        if (bits > 5) {
          // Slow case (num > 31).
          this.imul(a, this.convertTo(new BN(num)));
        } else if ((num & num - 1) === 0) {
          // Optimize for powers of two.
          for (var i = 0; i < bits - 1; i++) {
            this.iadd(a, a);
          }
        } else {
          // Multiply left to right.
          var c = a.clone();

          for (var _i14 = bits - 2; _i14 >= 0; _i14--) {
            this.iadd(a, a);
            if (num >> _i14 & 1) this.iadd(a, c);
          }
        }

        if (neg) this.ineg(a);
        return a;
      }
    }, {
      key: "eqn",
      value: function eqn(a, num) {
        this._verify1(a);

        if (num === 0) return a.isZero();
        return a.ucmp(this.convertTo(new BN(num))) === 0;
      }
    }, {
      key: "isLow",
      value: function isLow(a) {
        this._verify1(a);

        return this.convertFrom(a).ucmp(this.m.ushrn(1)) <= 0;
      }
    }, {
      key: "isOdd",
      value: function isOdd(a) {
        this._verify1(a);

        return this.convertFrom(a).isOdd();
      }
    }, {
      key: "isEven",
      value: function isEven(a) {
        this._verify1(a);

        return this.convertFrom(a).isEven();
      }
    }, {
      key: "invert",
      value: function invert(a) {
        this._verify1(a); // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R


        return this.imod(a.invert(this.m).mul(this.r2));
      }
    }, {
      key: "mont",
      get: function get() {
        return true;
      }
    }]);

    return Mont;
  }(Red);
  /*
   * Helpers
   */


  function makeError(Error, msg, start) {
    var err = new Error(msg);
    if (Error.captureStackTrace) Error.captureStackTrace(err, start);
    return err;
  }

  function assert$2(value, message) {
    if (!value) {
      var msg = message || 'Assertion failed.';
      throw makeError(Error, msg, assert$2);
    }
  }

  function enforce$1(value, name, type) {
    if (!value) {
      var msg = "\"".concat(name, "\" must be a(n) ").concat(type, ".");
      throw makeError(TypeError, msg, enforce$1);
    }
  }

  function range$1(value, name) {
    if (!value) {
      var msg = "\"".concat(name, "\" only works with positive numbers.");
      throw makeError(RangeError, msg, range$1);
    }
  }

  function red(value, name) {
    if (!value) {
      var msg = "\"".concat(name, "\" only works with red numbers.");
      throw makeError(TypeError, msg, red);
    }
  }

  function nonred(value, name) {
    if (!value) {
      var msg = "\"".concat(name, "\" only works with normal numbers.");
      throw makeError(TypeError, msg, nonred);
    }
  }

  function nonzero(value) {
    if (!value) {
      var msg = 'Cannot divide by zero.';
      throw makeError(RangeError, msg, nonzero);
    }
  }

  function isInteger(num) {
    return Number.isSafeInteger(num);
  }

  function isSMI(num) {
    return isInteger(num) && num >= -0x3ffffff && num <= 0x3ffffff;
  }

  function allocate(ArrayType, size) {
    if (ArrayType.allocUnsafeSlow) return ArrayType.allocUnsafeSlow(size);
    return new ArrayType(size);
  }

  function getBase(base) {
    if (base == null) return 10;
    if (typeof base === 'number') return base;

    switch (base) {
      case 'bin':
        return 2;

      case 'oct':
        return 8;

      case 'dec':
        return 10;

      case 'hex':
        return 16;
    }

    return 0;
  }
  /*
   * Internal
   */


  function countBits(w) {
    if (Math.clz32) return 32 - Math.clz32(w);
    var t = w;
    var r = 0;

    if (t >= 0x1000) {
      r += 13;
      t >>>= 13;
    }

    if (t >= 0x40) {
      r += 7;
      t >>>= 7;
    }

    if (t >= 0x8) {
      r += 4;
      t >>>= 4;
    }

    if (t >= 0x02) {
      r += 2;
      t >>>= 2;
    }

    return r + t;
  }

  function _zeroBits(w) {
    // Shortcut.
    if (w === 0) return 26;
    var t = w;
    var r = 0;

    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }

    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }

    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }

    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }

    if ((t & 0x1) === 0) r += 1;
    return r;
  }

  function parseHex(str, start, end) {
    var len = Math.min(str.length, end);
    var r = 0;
    var z = 0;

    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;
      r <<= 4;
      var b = void 0;

      if (c >= 49 && c <= 54) {
        // 'a' - 'f'
        b = c - 49 + 0xa;
      } else if (c >= 17 && c <= 22) {
        // 'A' - 'F'
        b = c - 17 + 0xa;
      } else {
        // '0' - '9'
        b = c;
      }

      r |= b;
      z |= b;
    }

    if (z & ~15) throw new Error('Invalid string.');
    return r;
  }

  function parseBase(str, start, end, mul) {
    var len = Math.min(str.length, end);
    var r = 0;

    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;
      r *= mul;
      var b = void 0;

      if (c >= 49) {
        // 'a'
        b = c - 49 + 0xa;
      } else if (c >= 17) {
        // 'A'
        b = c - 17 + 0xa;
      } else {
        // '0' - '9'
        b = c;
      }

      if (c < 0 || c > 207 || b >= mul) throw new Error('Invalid string.');
      r += b;
    }

    return r;
  }
  /*
   * Exponentiation (bigint)
   */


  function _powInt(x, e, m) {
    // Sliding window.
    var wnd = new Array(WND_SIZE);
    wnd[0] = sqrn(x, WND_WIDTH - 1, m);

    for (var _i15 = 1; _i15 < WND_SIZE; _i15++) {
      wnd[_i15] = wnd[_i15 - 1] * x % m;
    }

    var i = e.bitLength();
    var r = BigInteger(1);

    while (i >= WND_WIDTH) {
      var pos = i - WND_WIDTH;
      var bits = e.bits(pos, WND_WIDTH);

      if (bits < WND_SIZE) {
        r = r * r % m;
        i -= 1;
        continue;
      }

      r = sqrn(r, WND_WIDTH, m);
      r = r * wnd[bits & ~WND_SIZE] % m;
      i = pos;
    }

    if (i > 0) {
      var _bits3 = e.bits(0, i);

      while (i--) {
        r = r * r % m;
        if (_bits3 >> i & 1) r = r * x % m;
      }
    }

    return r;
  }

  function sqrn(x, n, m) {
    for (var i = 0; i < n; i++) {
      x = x * x % m;
    }

    return x;
  }
  /*
   * Multiplication
   */


  function smallMulTo(self, num, out) {
    var len = self.length + num.length;
    out.negative = self.negative ^ num.negative;

    out._alloc(len);

    out.length = len; // Peel one iteration (compiler can't
    // do it, because of code complexity).

    var a = self.words[0];
    var b = num.words[0];
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    var k = 1;
    out.words[0] = lo;

    for (; k < out.length - 1; k++) {
      // Sum all words with the same
      // `i + j = k` and accumulate
      // `ncarry`, note that ncarry
      // could be >= 0x3ffffff.
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var min = Math.max(0, k - self.length + 1);
      var max = Math.min(k, num.length - 1);

      for (var j = min; j <= max; j++) {
        var i = k - j;
        var _a = self.words[i];
        var _b = num.words[j];

        var _r3 = _a * _b + rword;

        ncarry += _r3 / 0x4000000 | 0;
        rword = _r3 & 0x3ffffff;
      }

      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }

    if (carry !== 0) out.words[k] = carry | 0;else out.length -= 1;
    return out._strip();
  }

  function bigMulTo(self, num, out) {
    var len = self.length + num.length;
    out.negative = self.negative ^ num.negative;

    out._alloc(len);

    out.length = len;
    var carry = 0;
    var hncarry = 0;
    var k = 0;

    for (; k < out.length - 1; k++) {
      // Sum all words with the same
      // `i + j = k` and accumulate
      // `ncarry`, note that ncarry
      // could be >= 0x3ffffff.
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var min = Math.max(0, k - self.length + 1);
      var max = Math.min(k, num.length - 1);

      for (var j = min; j <= max; j++) {
        var i = k - j;
        var a = self.words[i];
        var b = num.words[j];
        var r = a * b;
        var lo = r & 0x3ffffff;
        ncarry = ncarry + (r / 0x4000000 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 0x3ffffff;
        ncarry = ncarry + (lo >>> 26) | 0;
        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }

      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }

    if (carry !== 0) out.words[k] = carry;else out.length -= 1;
    return out._strip();
  }

  function jumboMulTo(x, y, out) {
    // v8 has a 2147483519 bit max (~256mb).
    if (!HAS_BIGINT || x.length + y.length > 82595519) return bigMulTo(x, y, out);
    var zero = BigInteger(0);
    var mask = BigInteger(0x3ffffff);
    var shift = BigInteger(26);
    var z = x.toBigInt() * y.toBigInt();
    var neg = z < zero | 0;
    if (neg) z = -z;
    var i = 0;

    while (z > zero) {
      out.words[i++] = Number(z & mask);
      z >>= shift;
    }

    if (i === 0) out.words[i++] = 0;
    out.length = i;
    out.negative = neg;
    return out;
  }

  function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    var c = 0;
    var lo, mid, hi;
    out.negative = self.negative ^ num.negative;

    out._alloc(20);

    out.length = 19;
    /* k = 0 */

    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */

    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */

    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */

    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */

    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */

    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */

    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */

    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */

    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */

    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */

    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */

    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */

    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */

    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */

    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */

    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */

    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */

    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */

    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;

    if (c !== 0) {
      o[19] = c;
      out.length += 1;
    } // Note: we shouldn't need to strip here.


    return out;
  } // Polyfill comb.


  if (!Math.imul) comb10MulTo = smallMulTo;
  /*
   * Expose
   */

  BN.Red = Red;
  var bn = BN;

  var bnBrowser = bn;

  var lookup$1 = [];
  var revLookup$1 = [];
  var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited$1 = false;

  function init$1() {
    inited$1 = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    for (var i = 0, len = code.length; i < len; ++i) {
      lookup$1[i] = code[i];
      revLookup$1[code.charCodeAt(i)] = i;
    }

    revLookup$1['-'.charCodeAt(0)] = 62;
    revLookup$1['_'.charCodeAt(0)] = 63;
  }

  function toByteArray$1(b64) {
    if (!inited$1) {
      init$1();
    }

    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice


    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

    arr = new Arr$1(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup$1[b64.charCodeAt(i)] << 18 | revLookup$1[b64.charCodeAt(i + 1)] << 12 | revLookup$1[b64.charCodeAt(i + 2)] << 6 | revLookup$1[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 0xFF;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = revLookup$1[b64.charCodeAt(i)] << 2 | revLookup$1[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = revLookup$1[b64.charCodeAt(i)] << 10 | revLookup$1[b64.charCodeAt(i + 1)] << 4 | revLookup$1[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64$1(num) {
    return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F];
  }

  function encodeChunk$1(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64$1(tmp));
    }

    return output.join('');
  }

  function fromByteArray$1(uint8) {
    if (!inited$1) {
      init$1();
    }

    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3
    // go through the array every three bytes, we'll deal with trailing stuff later

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk$1(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    } // pad the end with zeros, but make sure to not forget the extra bytes


    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup$1[tmp >> 2];
      output += lookup$1[tmp << 4 & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup$1[tmp >> 10];
      output += lookup$1[tmp >> 4 & 0x3F];
      output += lookup$1[tmp << 2 & 0x3F];
      output += '=';
    }

    parts.push(output);
    return parts.join('');
  }

  function read$1(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }

  function write$1(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$2 = {}.toString;

  var isArray$2 = Array.isArray || function (arr) {
    return toString$2.call(arr) == '[object Array]';
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */


  var INSPECT_MAX_BYTES$1 = 50;
  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */

  Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;
  /*
   * Export kMaxLength after typed array support is determined.
   */

  var _kMaxLength = kMaxLength$1();

  function kMaxLength$1() {
    return Buffer$1.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  function createBuffer$1(that, length) {
    if (kMaxLength$1() < length) {
      throw new RangeError('Invalid typed array length');
    }

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer$1(length);
      }

      that.length = length;
    }

    return that;
  }
  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */


  function Buffer$1(arg, encodingOrOffset, length) {
    if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
      return new Buffer$1(arg, encodingOrOffset, length);
    } // Common case.


    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error('If encoding is specified then the first argument must be a string');
      }

      return allocUnsafe$1(this, arg);
    }

    return from$1(this, arg, encodingOrOffset, length);
  }

  Buffer$1.poolSize = 8192; // not used by this implementation
  // TODO: Legacy, not needed anymore. Remove in next major version.

  Buffer$1._augment = function (arr) {
    arr.__proto__ = Buffer$1.prototype;
    return arr;
  };

  function from$1(that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number');
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer$1(that, value, encodingOrOffset, length);
    }

    if (typeof value === 'string') {
      return fromString$1(that, value, encodingOrOffset);
    }

    return fromObject$1(that, value);
  }
  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/


  Buffer$1.from = function (value, encodingOrOffset, length) {
    return from$1(null, value, encodingOrOffset, length);
  };

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    Buffer$1.prototype.__proto__ = Uint8Array.prototype;
    Buffer$1.__proto__ = Uint8Array;
  }

  function assertSize$1(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }

  function alloc$1(that, size, fill, encoding) {
    assertSize$1(size);

    if (size <= 0) {
      return createBuffer$1(that, size);
    }

    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string' ? createBuffer$1(that, size).fill(fill, encoding) : createBuffer$1(that, size).fill(fill);
    }

    return createBuffer$1(that, size);
  }
  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/


  Buffer$1.alloc = function (size, fill, encoding) {
    return alloc$1(null, size, fill, encoding);
  };

  function allocUnsafe$1(that, size) {
    assertSize$1(size);
    that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);

    if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }

    return that;
  }
  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */


  Buffer$1.allocUnsafe = function (size) {
    return allocUnsafe$1(null, size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */


  Buffer$1.allocUnsafeSlow = function (size) {
    return allocUnsafe$1(null, size);
  };

  function fromString$1(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }

    var length = byteLength$1(string, encoding) | 0;
    that = createBuffer$1(that, length);
    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that;
  }

  function fromArrayLike$1(that, array) {
    var length = array.length < 0 ? 0 : checked$1(array.length) | 0;
    that = createBuffer$1(that, length);

    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }

    return that;
  }

  function fromArrayBuffer$1(that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds');
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike$1(that, array);
    }

    return that;
  }

  function fromObject$1(that, obj) {
    if (internalIsBuffer$1(obj)) {
      var len = checked$1(obj.length) | 0;
      that = createBuffer$1(that, len);

      if (that.length === 0) {
        return that;
      }

      obj.copy(that, 0, 0, len);
      return that;
    }

    if (obj) {
      if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan$1(obj.length)) {
          return createBuffer$1(that, 0);
        }

        return fromArrayLike$1(that, obj);
      }

      if (obj.type === 'Buffer' && isArray$2(obj.data)) {
        return fromArrayLike$1(that, obj.data);
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
  }

  function checked$1(length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength$1()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength$1().toString(16) + ' bytes');
    }

    return length | 0;
  }

  function SlowBuffer(length) {
    if (+length != length) {
      // eslint-disable-line eqeqeq
      length = 0;
    }

    return Buffer$1.alloc(+length);
  }

  Buffer$1.isBuffer = isBuffer$2;

  function internalIsBuffer$1(b) {
    return !!(b != null && b._isBuffer);
  }

  Buffer$1.compare = function compare(a, b) {
    if (!internalIsBuffer$1(a) || !internalIsBuffer$1(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer$1.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  Buffer$1.concat = function concat(list, length) {
    if (!isArray$2(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer$1.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer$1.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (!internalIsBuffer$1(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      buf.copy(buffer, pos);
      pos += buf.length;
    }

    return buffer;
  };

  function byteLength$1(string, encoding) {
    if (internalIsBuffer$1(string)) {
      return string.length;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0; // Use a for loop to avoid recursion

    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;

        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes$1(string).length;

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;

        case 'hex':
          return len >>> 1;

        case 'base64':
          return base64ToBytes$1(string).length;

        default:
          if (loweredCase) return utf8ToBytes$1(string).length; // assume utf8

          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer$1.byteLength = byteLength$1;

  function slowToString$1(encoding, start, end) {
    var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

    if (start === undefined || start < 0) {
      start = 0;
    } // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.


    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice$1(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice$1(this, start, end);

        case 'ascii':
          return asciiSlice$1(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice$1(this, start, end);

        case 'base64':
          return base64Slice$1(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice$1(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.


  Buffer$1.prototype._isBuffer = true;

  function swap$1(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer$1.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      swap$1(this, i, i + 1);
    }

    return this;
  };

  Buffer$1.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      swap$1(this, i, i + 3);
      swap$1(this, i + 1, i + 2);
    }

    return this;
  };

  Buffer$1.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      swap$1(this, i, i + 7);
      swap$1(this, i + 1, i + 6);
      swap$1(this, i + 2, i + 5);
      swap$1(this, i + 3, i + 4);
    }

    return this;
  };

  Buffer$1.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice$1(this, 0, length);
    return slowToString$1.apply(this, arguments);
  };

  Buffer$1.prototype.equals = function equals(b) {
    if (!internalIsBuffer$1(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer$1.compare(this, b) === 0;
  };

  Buffer$1.prototype.inspect = function inspect() {
    var str = '';
    var max = INSPECT_MAX_BYTES$1;

    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }

    return '<Buffer ' + str + '>';
  };

  Buffer$1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer$1(target)) {
      throw new TypeError('Argument must be a Buffer');
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf


  function bidirectionalIndexOf$1(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1; // Normalize byteOffset

    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }

    byteOffset = +byteOffset; // Coerce to Number.

    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    } // Normalize byteOffset: negative offsets start from the end of the buffer


    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    } // Normalize val


    if (typeof val === 'string') {
      val = Buffer$1.from(val, encoding);
    } // Finally, search either indexOf (if dir is true) or lastIndexOf


    if (internalIsBuffer$1(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }

      return arrayIndexOf$1(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]

      if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }

      return arrayIndexOf$1(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf$1(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();

      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }

        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;

    if (dir) {
      var foundIndex = -1;

      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

      for (i = byteOffset; i >= 0; i--) {
        var found = true;

        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }

        if (found) return i;
      }
    }

    return -1;
  }

  Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer$1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf$1(this, val, byteOffset, encoding, true);
  };

  Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf$1(this, val, byteOffset, encoding, false);
  };

  function hexWrite$1(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;

    if (!length) {
      length = remaining;
    } else {
      length = Number(length);

      if (length > remaining) {
        length = remaining;
      }
    } // must be an even number of digits


    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }

    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }

    return i;
  }

  function utf8Write$1(buf, string, offset, length) {
    return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite$1(buf, string, offset, length) {
    return blitBuffer$1(asciiToBytes$1(string), buf, offset, length);
  }

  function latin1Write$1(buf, string, offset, length) {
    return asciiWrite$1(buf, string, offset, length);
  }

  function base64Write$1(buf, string, offset, length) {
    return blitBuffer$1(base64ToBytes$1(string), buf, offset, length);
  }

  function ucs2Write$1(buf, string, offset, length) {
    return blitBuffer$1(utf16leToBytes$1(string, buf.length - offset), buf, offset, length);
  }

  Buffer$1.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0; // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0; // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;

      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      } // legacy write(string, encoding, offset, length) - remove in v0.13

    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite$1(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write$1(this, string, offset, length);

        case 'ascii':
          return asciiWrite$1(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write$1(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write$1(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write$1(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer$1.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice$1(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray$1(buf);
    } else {
      return fromByteArray$1(buf.slice(start, end));
    }
  }

  function utf8Slice$1(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;

    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }

            break;

          case 2:
            secondByte = buf[i + 1];

            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }

        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray$1(res);
  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety


  var MAX_ARGUMENTS_LENGTH$1 = 0x1000;

  function decodeCodePointsArray$1(codePoints) {
    var len = codePoints.length;

    if (len <= MAX_ARGUMENTS_LENGTH$1) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    } // Decode in chunks to avoid "call stack size exceeded".


    var res = '';
    var i = 0;

    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH$1));
    }

    return res;
  }

  function asciiSlice$1(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }

    return ret;
  }

  function latin1Slice$1(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }

    return ret;
  }

  function hexSlice$1(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';

    for (var i = start; i < end; ++i) {
      out += toHex$1(buf[i]);
    }

    return out;
  }

  function utf16leSlice$1(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';

    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }

    return res;
  }

  Buffer$1.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf;

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$1.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$1(sliceLen, undefined);

      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf;
  };
  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */


  function checkOffset$1(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer$1.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset$1(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer$1.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      checkOffset$1(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer$1.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 1, this.length);
    return this[offset];
  };

  Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer$1.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset$1(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer$1.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset$1(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer$1.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer$1.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer$1.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer$1.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer$1.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer$1.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return read$1(this, offset, true, 23, 4);
  };

  Buffer$1.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 4, this.length);
    return read$1(this, offset, false, 23, 4);
  };

  Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 8, this.length);
    return read$1(this, offset, true, 52, 8);
  };

  Buffer$1.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset$1(offset, 8, this.length);
    return read$1(this, offset, false, 52, 8);
  };

  function checkInt$1(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer$1(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer$1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt$1(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer$1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt$1(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer$1.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 1, 0xff, 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16$1(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16$1(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16$1(this, value, offset, false);
    }

    return offset + 2;
  };

  function objectWriteUInt32$1(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32$1(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32$1(this, value, offset, false);
    }

    return offset + 4;
  };

  Buffer$1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer$1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer$1.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer$1.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16$1(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer$1.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16$1(this, value, offset, false);
    }

    return offset + 2;
  };

  Buffer$1.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32$1(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer$1.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32$1(this, value, offset, false);
    }

    return offset + 4;
  };

  function checkIEEE754$1(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat$1(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754$1(buf, value, offset, 4);
    }

    write$1(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer$1.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat$1(this, value, offset, true, noAssert);
  };

  Buffer$1.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat$1(this, value, offset, false, noAssert);
  };

  function writeDouble$1(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754$1(buf, value, offset, 8);
    }

    write$1(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble$1(this, value, offset, true, noAssert);
  };

  Buffer$1.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble$1(this, value, offset, false, noAssert);
  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


  Buffer$1.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }

    return len;
  }; // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])


  Buffer$1.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (code < 256) {
          val = code;
        }
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } // Invalid ranges are not set to a default, so can range check early.


    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer$1(val) ? val : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
      var len = bytes.length;

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  }; // HELPER FUNCTIONS
  // ================


  var INVALID_BASE64_RE$1 = /[^+\/0-9A-Za-z-_]/g;

  function base64clean$1(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim$1(str).replace(INVALID_BASE64_RE$1, ''); // Node converts strings with length < 2 to ''

    if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

    while (str.length % 4 !== 0) {
      str = str + '=';
    }

    return str;
  }

  function stringtrim$1(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex$1(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes$1(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i); // is surrogate component

      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } // valid lead


          leadSurrogate = codePoint;
          continue;
        } // 2 leads in a row


        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        } // valid surrogate pair


        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null; // encode utf8

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes$1(str) {
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }

    return byteArray;
  }

  function utf16leToBytes$1(str, units) {
    var c, hi, lo;
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes$1(str) {
    return toByteArray$1(base64clean$1(str));
  }

  function blitBuffer$1(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  }

  function isnan$1(val) {
    return val !== val; // eslint-disable-line no-self-compare
  } // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually


  function isBuffer$2(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer$1(obj) || isSlowBuffer$1(obj));
  }

  function isFastBuffer$1(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
  } // For Node v0.10 support. Remove this eventually.


  function isSlowBuffer$1(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer$1(obj.slice(0, 0));
  }

  var bufferEs6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Buffer: Buffer$1,
    INSPECT_MAX_BYTES: INSPECT_MAX_BYTES$1,
    SlowBuffer: SlowBuffer,
    isBuffer: isBuffer$2,
    kMaxLength: _kMaxLength
  });

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js
  function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
  }

  function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
  }

  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;

  if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
  }

  if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      //normal enviroments in sane situations
      return setTimeout(fun, 0);
    } // if setTimeout wasn't available but was latter defined


    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }

  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      //normal enviroments in sane situations
      return clearTimeout(marker);
    } // if clearTimeout wasn't available but was latter defined


    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
        return cachedClearTimeout.call(null, marker);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
        return cachedClearTimeout.call(this, marker);
      }
    }
  }

  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }

    draining = false;

    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }

    if (queue.length) {
      drainQueue();
    }
  }

  function drainQueue() {
    if (draining) {
      return;
    }

    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;

    while (len) {
      currentQueue = queue;
      queue = [];

      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }

      queueIndex = -1;
      len = queue.length;
    }

    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }

  function nextTick(fun) {
    var args = new Array(arguments.length - 1);

    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }

    queue.push(new Item(fun, args));

    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  } // v8 likes predictible objects

  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }

  Item.prototype.run = function () {
    this.fun.apply(null, this.array);
  };

  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues

  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;
  function binding(name) {
    throw new Error('process.binding is not supported');
  }
  function cwd() {
    return '/';
  }
  function chdir(dir) {
    throw new Error('process.chdir is not supported');
  }
  function umask() {
    return 0;
  } // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js

  var performance = global$1.performance || {};

  var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
    return new Date().getTime();
  }; // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime


  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);

    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];

      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }

    return [seconds, nanoseconds];
  }
  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }
  var process = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var hasToStringTag = typeof Symbol === 'function' && _typeof__default['default'](Symbol.toStringTag) === 'symbol';
  var toStr = Object.prototype.toString;

  var isStandardArguments = function isArguments(value) {
    if (hasToStringTag && value && _typeof__default['default'](value) === 'object' && Symbol.toStringTag in value) {
      return false;
    }

    return toStr.call(value) === '[object Arguments]';
  };

  var isLegacyArguments = function isArguments(value) {
    if (isStandardArguments(value)) {
      return true;
    }

    return value !== null && _typeof__default['default'](value) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value) !== '[object Array]' && toStr.call(value.callee) === '[object Function]';
  };

  var supportsStandardArguments = function () {
    return isStandardArguments(arguments);
  }();

  isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

  var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

  var toStr$1 = Object.prototype.toString;
  var fnToStr = Function.prototype.toString;
  var isFnRegex = /^\s*(?:function)?\*/;
  var hasToStringTag$1 = typeof Symbol === 'function' && _typeof__default['default'](Symbol.toStringTag) === 'symbol';
  var getProto = Object.getPrototypeOf;

  var getGeneratorFunc = function getGeneratorFunc() {
    // eslint-disable-line consistent-return
    if (!hasToStringTag$1) {
      return false;
    }

    try {
      return Function('return function*() {}')();
    } catch (e) {}
  };

  var generatorFunc = getGeneratorFunc();
  var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};

  var isGeneratorFunction = function isGeneratorFunction(fn) {
    if (typeof fn !== 'function') {
      return false;
    }

    if (isFnRegex.test(fnToStr.call(fn))) {
      return true;
    }

    if (!hasToStringTag$1) {
      var str = toStr$1.call(fn);
      return str === '[object GeneratorFunction]';
    }

    return getProto(fn) === GeneratorFunction;
  };

  var hasOwn = Object.prototype.hasOwnProperty;
  var toString$3 = Object.prototype.toString;

  var foreach = function forEach(obj, fn, ctx) {
    if (toString$3.call(fn) !== '[object Function]') {
      throw new TypeError('iterator must be a function');
    }

    var l = obj.length;

    if (l === +l) {
      for (var i = 0; i < l; i++) {
        fn.call(ctx, obj[i], i, obj);
      }
    } else {
      for (var k in obj) {
        if (hasOwn.call(obj, k)) {
          fn.call(ctx, obj[k], k, obj);
        }
      }
    }
  };

  /**
   * Array#filter.
   *
   * @param {Array} arr
   * @param {Function} fn
   * @param {Object=} self
   * @return {Array}
   * @throw TypeError
   */
  var arrayFilter = function arrayFilter(arr, fn, self) {
    if (arr.filter) return arr.filter(fn, self);
    if (void 0 === arr || null === arr) throw new TypeError();
    if ('function' != typeof fn) throw new TypeError();
    var ret = [];

    for (var i = 0; i < arr.length; i++) {
      if (!hasOwn$1.call(arr, i)) continue;
      var val = arr[i];
      if (fn.call(self, val, i, arr)) ret.push(val);
    }

    return ret;
  };

  var hasOwn$1 = Object.prototype.hasOwnProperty;

  var availableTypedArrays = function availableTypedArrays() {
    return arrayFilter(['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'], function (typedArray) {
      return typeof commonjsGlobal[typedArray] === 'function';
    });
  };

  var shams = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
      return false;
    }

    if (_typeof__default['default'](Symbol.iterator) === 'symbol') {
      return true;
    }

    var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);

    if (typeof sym === 'string') {
      return false;
    }

    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
      return false;
    }

    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
      return false;
    } // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


    var symVal = 42;
    obj[sym] = symVal;

    for (sym in obj) {
      return false;
    } // eslint-disable-line no-restricted-syntax


    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
      return false;
    }

    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }

    var syms = Object.getOwnPropertySymbols(obj);

    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }

    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }

    if (typeof Object.getOwnPropertyDescriptor === 'function') {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }

    return true;
  };

  var origSymbol = commonjsGlobal.Symbol;

  var hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
      return false;
    }

    if (typeof Symbol !== 'function') {
      return false;
    }

    if (_typeof__default['default'](origSymbol('foo')) !== 'symbol') {
      return false;
    }

    if (_typeof__default['default'](Symbol('bar')) !== 'symbol') {
      return false;
    }

    return shams();
  };

  /* eslint no-invalid-this: 1 */

  var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
  var slice = Array.prototype.slice;
  var toStr$2 = Object.prototype.toString;
  var funcType = '[object Function]';

  var implementation = function bind(that) {
    var target = this;

    if (typeof target !== 'function' || toStr$2.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }

    var args = slice.call(arguments, 1);
    var bound;

    var binder = function binder() {
      if (this instanceof bound) {
        var result = target.apply(this, args.concat(slice.call(arguments)));

        if (Object(result) === result) {
          return result;
        }

        return this;
      } else {
        return target.apply(that, args.concat(slice.call(arguments)));
      }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];

    for (var i = 0; i < boundLength; i++) {
      boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
      var Empty = function Empty() {};

      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }

    return bound;
  };

  var functionBind = Function.prototype.bind || implementation;

  /* globals
  	Atomics,
  	SharedArrayBuffer,
  */


  var undefined$1;
  var $TypeError = TypeError;
  var $gOPD = Object.getOwnPropertyDescriptor;

  if ($gOPD) {
    try {
      $gOPD({}, '');
    } catch (e) {
      $gOPD = null; // this is IE 8, which has a broken gOPD
    }
  }

  var throwTypeError = function throwTypeError() {
    throw new $TypeError();
  };

  var ThrowTypeError = $gOPD ? function () {
    try {
      // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
      arguments.callee; // IE 8 does not throw here

      return throwTypeError;
    } catch (calleeThrows) {
      try {
        // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
        return $gOPD(arguments, 'callee').get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols$1 = hasSymbols();

  var getProto$1 = Object.getPrototypeOf || function (x) {
    return x.__proto__;
  }; // eslint-disable-line no-proto

  var generatorFunction =  undefined$1;

  var asyncFunction =  undefined$1;

  var asyncGenFunction =  undefined$1;
  var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto$1(Uint8Array);
  var INTRINSICS = {
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
    '%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,
    '%ArrayIteratorPrototype%': hasSymbols$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
    '%ArrayPrototype%': Array.prototype,
    '%ArrayProto_entries%': Array.prototype.entries,
    '%ArrayProto_forEach%': Array.prototype.forEach,
    '%ArrayProto_keys%': Array.prototype.keys,
    '%ArrayProto_values%': Array.prototype.values,
    '%AsyncFromSyncIteratorPrototype%': undefined$1,
    '%AsyncFunction%': asyncFunction,
    '%AsyncFunctionPrototype%':  undefined$1,
    '%AsyncGenerator%':  undefined$1,
    '%AsyncGeneratorFunction%': asyncGenFunction,
    '%AsyncGeneratorPrototype%':  undefined$1,
    '%AsyncIteratorPrototype%':  undefined$1,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
    '%Boolean%': Boolean,
    '%BooleanPrototype%': Boolean.prototype,
    '%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
    '%DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,
    '%Date%': Date,
    '%DatePrototype%': Date.prototype,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': Error,
    '%ErrorPrototype%': Error.prototype,
    '%eval%': eval,
    // eslint-disable-line no-eval
    '%EvalError%': EvalError,
    '%EvalErrorPrototype%': EvalError.prototype,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
    '%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
    '%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,
    '%Function%': Function,
    '%FunctionPrototype%': Function.prototype,
    '%Generator%':  undefined$1,
    '%GeneratorFunction%': generatorFunction,
    '%GeneratorPrototype%':  undefined$1,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
    '%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
    '%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
    '%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
    '%JSON%': (typeof JSON === "undefined" ? "undefined" : _typeof__default['default'](JSON)) === 'object' ? JSON : undefined$1,
    '%JSONParse%': (typeof JSON === "undefined" ? "undefined" : _typeof__default['default'](JSON)) === 'object' ? JSON.parse : undefined$1,
    '%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
    '%MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,
    '%Math%': Math,
    '%Number%': Number,
    '%NumberPrototype%': Number.prototype,
    '%Object%': Object,
    '%ObjectPrototype%': Object.prototype,
    '%ObjProto_toString%': Object.prototype.toString,
    '%ObjProto_valueOf%': Object.prototype.valueOf,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
    '%PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,
    '%PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,
    '%Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,
    '%Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,
    '%Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
    '%RangeError%': RangeError,
    '%RangeErrorPrototype%': RangeError.prototype,
    '%ReferenceError%': ReferenceError,
    '%ReferenceErrorPrototype%': ReferenceError.prototype,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
    '%RegExp%': RegExp,
    '%RegExpPrototype%': RegExp.prototype,
    '%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
    '%SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
    '%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols$1 ? getProto$1(''[Symbol.iterator]()) : undefined$1,
    '%StringPrototype%': String.prototype,
    '%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
    '%SymbolPrototype%': hasSymbols$1 ? Symbol.prototype : undefined$1,
    '%SyntaxError%': SyntaxError,
    '%SyntaxErrorPrototype%': SyntaxError.prototype,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,
    '%TypeError%': $TypeError,
    '%TypeErrorPrototype%': $TypeError.prototype,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
    '%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
    '%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
    '%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
    '%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,
    '%URIError%': URIError,
    '%URIErrorPrototype%': URIError.prototype,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
    '%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
    '%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype
  };
  var $replace = functionBind.call(Function.call, String.prototype.replace);
  /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  /** Used to match backslashes in property paths. */

  var stringToPath = function stringToPath(string) {
    var result = [];
    $replace(string, rePropName, function (match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
  };
  /* end adaptation */


  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    if (!(name in INTRINSICS)) {
      throw new SyntaxError('intrinsic ' + name + ' does not exist!');
    } // istanbul ignore if // hopefully this is impossible to test :-)


    if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return INTRINSICS[name];
  };

  var GetIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
      throw new TypeError('intrinsic name must be a non-empty string');
    }

    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
      throw new TypeError('"allowMissing" argument must be a boolean');
    }

    var parts = stringToPath(name);
    var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);

    for (var i = 1; i < parts.length; i += 1) {
      if (value != null) {
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, parts[i]);

          if (!allowMissing && !(parts[i] in value)) {
            throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
          } // By convention, when a data property is converted to an accessor
          // property to emulate a data property that does not suffer from
          // the override mistake, that accessor's getter is marked with
          // an `originalValue` property. Here, when we detect this, we
          // uphold the illusion by pretending to see that original data
          // property, i.e., returning the value rather than the getter
          // itself.


          value = desc && 'get' in desc && !('originalValue' in desc.get) ? desc.get : value[parts[i]];
        } else {
          value = value[parts[i]];
        }
      }
    }

    return value;
  };

  var callBind = createCommonjsModule(function (module) {

    var $apply = GetIntrinsic('%Function.prototype.apply%');
    var $call = GetIntrinsic('%Function.prototype.call%');
    var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || functionBind.call($call, $apply);
    var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

    if ($defineProperty) {
      try {
        $defineProperty({}, 'a', {
          value: 1
        });
      } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = null;
      }
    }

    module.exports = function callBind() {
      return $reflectApply(functionBind, $call, arguments);
    };

    var applyBind = function applyBind() {
      return $reflectApply(functionBind, $apply, arguments);
    };

    if ($defineProperty) {
      $defineProperty(module.exports, 'apply', {
        value: applyBind
      });
    } else {
      module.exports.apply = applyBind;
    }
  });

  var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

  var callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);

    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
      return callBind(intrinsic);
    }

    return intrinsic;
  };

  var $gOPD$1 = GetIntrinsic('%Object.getOwnPropertyDescriptor%');

  if ($gOPD$1) {
    try {
      $gOPD$1([], 'length');
    } catch (e) {
      // IE 8 has a broken gOPD
      $gOPD$1 = null;
    }
  }

  var getOwnPropertyDescriptor = $gOPD$1;

  var $toString = callBound('Object.prototype.toString');
  var hasSymbols$2 = hasSymbols();
  var hasToStringTag$2 = hasSymbols$2 && _typeof__default['default'](Symbol.toStringTag) === 'symbol';
  var typedArrays = availableTypedArrays();

  var $indexOf$1 = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }

    return -1;
  };

  var $slice = callBound('String.prototype.slice');
  var toStrTags = {};
  var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

  if (hasToStringTag$2 && getOwnPropertyDescriptor && getPrototypeOf) {
    foreach(typedArrays, function (typedArray) {
      var arr = new commonjsGlobal[typedArray]();

      if (!(Symbol.toStringTag in arr)) {
        throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
      }

      var proto = getPrototypeOf(arr);
      var descriptor = getOwnPropertyDescriptor(proto, Symbol.toStringTag);

      if (!descriptor) {
        var superProto = getPrototypeOf(proto);
        descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
      }

      toStrTags[typedArray] = descriptor.get;
    });
  }

  var tryTypedArrays = function tryAllTypedArrays(value) {
    var anyTrue = false;
    foreach(toStrTags, function (getter, typedArray) {
      if (!anyTrue) {
        try {
          anyTrue = getter.call(value) === typedArray;
        } catch (e) {
          /**/
        }
      }
    });
    return anyTrue;
  };

  var isTypedArray = function isTypedArray(value) {
    if (!value || _typeof__default['default'](value) !== 'object') {
      return false;
    }

    if (!hasToStringTag$2) {
      var tag = $slice($toString(value), 8, -1);
      return $indexOf$1(typedArrays, tag) > -1;
    }

    if (!getOwnPropertyDescriptor) {
      return false;
    }

    return tryTypedArrays(value);
  };

  var $toString$1 = callBound('Object.prototype.toString');
  var hasSymbols$3 = hasSymbols();
  var hasToStringTag$3 = hasSymbols$3 && _typeof__default['default'](Symbol.toStringTag) === 'symbol';
  var typedArrays$1 = availableTypedArrays();
  var $slice$1 = callBound('String.prototype.slice');
  var toStrTags$1 = {};
  var getPrototypeOf$1 = Object.getPrototypeOf; // require('getprototypeof');

  if (hasToStringTag$3 && getOwnPropertyDescriptor && getPrototypeOf$1) {
    foreach(typedArrays$1, function (typedArray) {
      if (typeof commonjsGlobal[typedArray] === 'function') {
        var arr = new commonjsGlobal[typedArray]();

        if (!(Symbol.toStringTag in arr)) {
          throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
        }

        var proto = getPrototypeOf$1(arr);
        var descriptor = getOwnPropertyDescriptor(proto, Symbol.toStringTag);

        if (!descriptor) {
          var superProto = getPrototypeOf$1(proto);
          descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
        }

        toStrTags$1[typedArray] = descriptor.get;
      }
    });
  }

  var tryTypedArrays$1 = function tryAllTypedArrays(value) {
    var foundName = false;
    foreach(toStrTags$1, function (getter, typedArray) {
      if (!foundName) {
        try {
          var name = getter.call(value);

          if (name === typedArray) {
            foundName = name;
          }
        } catch (e) {}
      }
    });
    return foundName;
  };

  var whichTypedArray = function whichTypedArray(value) {
    if (!isTypedArray(value)) {
      return false;
    }

    if (!hasToStringTag$3) {
      return $slice$1($toString$1(value), 8, -1);
    }

    return tryTypedArrays$1(value);
  };

  var types = createCommonjsModule(function (module, exports) {

    function uncurryThis(f) {
      return f.call.bind(f);
    }

    var BigIntSupported = typeof BigInteger !== 'undefined';
    var SymbolSupported = typeof Symbol !== 'undefined';
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);

    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInteger.prototype.valueOf);
    }

    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }

    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (_typeof__default['default'](value) !== 'object') {
        return false;
      }

      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }

    exports.isArgumentsObject = isArguments;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray; // Taken from here and modified for better browser support
    // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js

    function isPromise(input) {
      return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && _typeof__default['default'](input) === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
    }

    exports.isPromise = isPromise;

    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }

      return isTypedArray(value) || isDataView(value);
    }

    exports.isArrayBufferView = isArrayBufferView;

    function isUint8Array(value) {
      return whichTypedArray(value) === 'Uint8Array';
    }

    exports.isUint8Array = isUint8Array;

    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === 'Uint8ClampedArray';
    }

    exports.isUint8ClampedArray = isUint8ClampedArray;

    function isUint16Array(value) {
      return whichTypedArray(value) === 'Uint16Array';
    }

    exports.isUint16Array = isUint16Array;

    function isUint32Array(value) {
      return whichTypedArray(value) === 'Uint32Array';
    }

    exports.isUint32Array = isUint32Array;

    function isInt8Array(value) {
      return whichTypedArray(value) === 'Int8Array';
    }

    exports.isInt8Array = isInt8Array;

    function isInt16Array(value) {
      return whichTypedArray(value) === 'Int16Array';
    }

    exports.isInt16Array = isInt16Array;

    function isInt32Array(value) {
      return whichTypedArray(value) === 'Int32Array';
    }

    exports.isInt32Array = isInt32Array;

    function isFloat32Array(value) {
      return whichTypedArray(value) === 'Float32Array';
    }

    exports.isFloat32Array = isFloat32Array;

    function isFloat64Array(value) {
      return whichTypedArray(value) === 'Float64Array';
    }

    exports.isFloat64Array = isFloat64Array;

    function isBigInt64Array(value) {
      return whichTypedArray(value) === 'BigInt64Array';
    }

    exports.isBigInt64Array = isBigInt64Array;

    function isBigUint64Array(value) {
      return whichTypedArray(value) === 'BigUint64Array';
    }

    exports.isBigUint64Array = isBigUint64Array;

    function isMapToString(value) {
      return ObjectToString(value) === '[object Map]';
    }

    isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());

    function isMap(value) {
      if (typeof Map === 'undefined') {
        return false;
      }

      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }

    exports.isMap = isMap;

    function isSetToString(value) {
      return ObjectToString(value) === '[object Set]';
    }

    isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());

    function isSet(value) {
      if (typeof Set === 'undefined') {
        return false;
      }

      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }

    exports.isSet = isSet;

    function isWeakMapToString(value) {
      return ObjectToString(value) === '[object WeakMap]';
    }

    isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());

    function isWeakMap(value) {
      if (typeof WeakMap === 'undefined') {
        return false;
      }

      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }

    exports.isWeakMap = isWeakMap;

    function isWeakSetToString(value) {
      return ObjectToString(value) === '[object WeakSet]';
    }

    isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());

    function isWeakSet(value) {
      return isWeakSetToString(value);
    }

    exports.isWeakSet = isWeakSet;

    function isArrayBufferToString(value) {
      return ObjectToString(value) === '[object ArrayBuffer]';
    }

    isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());

    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === 'undefined') {
        return false;
      }

      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }

    exports.isArrayBuffer = isArrayBuffer;

    function isDataViewToString(value) {
      return ObjectToString(value) === '[object DataView]';
    }

    isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));

    function isDataView(value) {
      if (typeof DataView === 'undefined') {
        return false;
      }

      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }

    exports.isDataView = isDataView;

    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === '[object SharedArrayBuffer]';
    }

    isSharedArrayBufferToString.working = typeof SharedArrayBuffer !== 'undefined' && isSharedArrayBufferToString(new SharedArrayBuffer());

    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBuffer === 'undefined') {
        return false;
      }

      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBuffer;
    }

    exports.isSharedArrayBuffer = isSharedArrayBuffer;

    function isAsyncFunction(value) {
      return ObjectToString(value) === '[object AsyncFunction]';
    }

    exports.isAsyncFunction = isAsyncFunction;

    function isMapIterator(value) {
      return ObjectToString(value) === '[object Map Iterator]';
    }

    exports.isMapIterator = isMapIterator;

    function isSetIterator(value) {
      return ObjectToString(value) === '[object Set Iterator]';
    }

    exports.isSetIterator = isSetIterator;

    function isGeneratorObject(value) {
      return ObjectToString(value) === '[object Generator]';
    }

    exports.isGeneratorObject = isGeneratorObject;

    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === '[object WebAssembly.Module]';
    }

    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }

    exports.isNumberObject = isNumberObject;

    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }

    exports.isStringObject = isStringObject;

    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }

    exports.isBooleanObject = isBooleanObject;

    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }

    exports.isBigIntObject = isBigIntObject;

    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }

    exports.isSymbolObject = isSymbolObject;

    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }

    exports.isBoxedPrimitive = isBoxedPrimitive;

    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }

    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function value() {
          throw new Error(method + ' is not supported in userland');
        }
      });
    });
  });

  var isBufferBrowser = function isBuffer(arg) {
    return arg && _typeof__default['default'](arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };

  var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;

          var TempCtor = function TempCtor() {};

          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  });

  var util = createCommonjsModule(function (module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};

      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }

      return descriptors;
    };

    var formatRegExp = /%[sdj%]/g;

    exports.format = function (f) {
      if (!isString(f)) {
        var objects = [];

        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }

        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') return '%';
        if (i >= len) return x;

        switch (x) {
          case '%s':
            return String(args[i++]);

          case '%d':
            return Number(args[i++]);

          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }

          default:
            return x;
        }
      });

      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }

      return str;
    }; // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.


    exports.deprecate = function (fn, msg) {
      if (typeof process !== 'undefined' && process.noDeprecation === true) {
        return fn;
      } // Allow for deprecating things in the process of starting up.


      if (typeof process === 'undefined') {
        return function () {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }

      var warned = false;

      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }

          warned = true;
        }

        return fn.apply(this, arguments);
      }

      return deprecated;
    };

    var debugs = {};
    var debugEnvRegex = /^$/;

    if (process.env.NODE_DEBUG) {
      var debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
      debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
    }

    exports.debuglog = function (set) {
      set = set.toUpperCase();

      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;

          debugs[set] = function () {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function () {};
        }
      }

      return debugs[set];
    };
    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */

    /* legacy: obj, showHidden, depth, colors*/


    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      }; // legacy...

      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];

      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
      } // set default options


      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }

    exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    }; // Don't use 'blue' not visible on cmd.exe

    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };

    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }

    function stylizeNoColor(str, styleType) {
      return str;
    }

    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }

    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);

        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }

        return ret;
      } // Primitive types cannot have properties


      var primitive = formatPrimitive(ctx, value);

      if (primitive) {
        return primitive;
      } // Look up the keys of the object.


      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      } // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      } // Some type of object without properties can be shortcutted.


      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }

        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }

        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }

        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '',
          array = false,
          braces = ['{', '}']; // Make Array say that they are Array

      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      } // Make functions say that they are functions


      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      } // Make RegExps say that they are RegExps


      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      } // Make dates with properties first say the date


      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      } // Make error with message first say the error


      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);
      var output;

      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }

      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

      if (isNull(value)) return ctx.stylize('null', 'null');
    }

    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];

      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };

      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }

      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }

      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }

          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }

      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }

        name = JSON.stringify('' + key);

        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }

    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function (prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    } // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.


    exports.types = types;

    function isArray(ar) {
      return Array.isArray(ar);
    }

    exports.isArray = isArray;

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    exports.isBoolean = isBoolean;

    function isNull(arg) {
      return arg === null;
    }

    exports.isNull = isNull;

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    exports.isNullOrUndefined = isNullOrUndefined;

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    exports.isNumber = isNumber;

    function isString(arg) {
      return typeof arg === 'string';
    }

    exports.isString = isString;

    function isSymbol(arg) {
      return _typeof__default['default'](arg) === 'symbol';
    }

    exports.isSymbol = isSymbol;

    function isUndefined(arg) {
      return arg === void 0;
    }

    exports.isUndefined = isUndefined;

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }

    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;

    function isObject(arg) {
      return _typeof__default['default'](arg) === 'object' && arg !== null;
    }

    exports.isObject = isObject;

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }

    exports.isDate = isDate;
    exports.types.isDate = isDate;

    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    exports.isError = isError;
    exports.types.isNativeError = isError;

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    exports.isFunction = isFunction;

    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof__default['default'](arg) === 'symbol' || // ES6 symbol
      typeof arg === 'undefined';
    }

    exports.isPrimitive = isPrimitive;
    exports.isBuffer = isBufferBrowser;

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }

    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    } // log is just a thin wrapper to console.log that prepends a timestamp


    exports.log = function () {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    /**
     * Inherit the prototype methods from one constructor into another.
     *
     * The Function.prototype.inherits from lang.js rewritten as a standalone
     * function (not on Function.prototype). NOTE: If this file is to be loaded
     * during bootstrapping this function needs to be rewritten using some native
     * functions as prototype setup using normal JavaScript does not work as
     * expected during bootstrapping (see mirror.js in r114903).
     *
     * @param {function} ctor Constructor function which needs to inherit the
     *     prototype.
     * @param {function} superCtor Constructor function to inherit prototype from.
     */


    exports.inherits = inherits_browser;

    exports._extend = function (origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;

      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }

      return origin;
    };

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

    exports.promisify = function promisify(original) {
      if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];

        if (typeof fn !== 'function') {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }

        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }

      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function (resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];

        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        args.push(function (err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });

        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }

        return promise;
      }

      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };

    exports.promisify.custom = kCustomPromisifiedSymbol;

    function callbackifyOnRejected(reason, cb) {
      // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
      // Because `null` is a special error value in callbacks which means "no error
      // occurred", we error-wrap so the callback consumer can distinguish between
      // "the promise rejected with null" or "the promise fulfilled with undefined".
      if (!reason) {
        var newReason = new Error('Promise was rejected with a falsy value');
        newReason.reason = reason;
        reason = newReason;
      }

      return cb(reason);
    }

    function callbackify(original) {
      if (typeof original !== 'function') {
        throw new TypeError('The "original" argument must be of type Function');
      } // We DO NOT return the promise as it gives the user a false sense that
      // the promise is actually somehow related to the callback's execution
      // and that the callback throwing will reject the promise.


      function callbackified() {
        var args = [];

        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        var maybeCb = args.pop();

        if (typeof maybeCb !== 'function') {
          throw new TypeError('The last argument must be of type Function');
        }

        var self = this;

        var cb = function cb() {
          return maybeCb.apply(self, arguments);
        }; // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)


        original.apply(this, args).then(function (ret) {
          process.nextTick(cb.bind(null, null, ret));
        }, function (rej) {
          process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }

      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }

    exports.callbackify = callbackify;
  });

  function compare$1(a, b) {
    if (a === b) {
      return 0;
    }

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) {
      return -1;
    }

    if (y < x) {
      return 1;
    }

    return 0;
  }

  var hasOwn$2 = Object.prototype.hasOwnProperty;

  var objectKeys = Object.keys || function (obj) {
    var keys = [];

    for (var key in obj) {
      if (hasOwn$2.call(obj, key)) keys.push(key);
    }

    return keys;
  }; // based on node assert, original notice:
  var pSlice = Array.prototype.slice;

  var _functionsHaveNames;

  function functionsHaveNames() {
    if (typeof _functionsHaveNames !== 'undefined') {
      return _functionsHaveNames;
    }

    return _functionsHaveNames = function () {
      return function foo() {}.name === 'foo';
    }();
  }

  function pToString(obj) {
    return Object.prototype.toString.call(obj);
  }

  function isView$1(arrbuf) {
    if (isBuffer$2(arrbuf)) {
      return false;
    }

    if (typeof global$1.ArrayBuffer !== 'function') {
      return false;
    }

    if (typeof ArrayBuffer.isView === 'function') {
      return ArrayBuffer.isView(arrbuf);
    }

    if (!arrbuf) {
      return false;
    }

    if (arrbuf instanceof DataView) {
      return true;
    }

    if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
      return true;
    }

    return false;
  } // 1. The assert module provides functions that throw
  // AssertionError's when particular conditions are not met. The
  // assert module must conform to the following interface.


  function assert$3(value, message) {
    if (!value) fail$1(value, true, message, '==', ok);
  }
  // new assert.AssertionError({ message: message,
  //                             actual: actual,
  //                             expected: expected })

  var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

  function getName(func) {
    if (!util.isFunction(func)) {
      return;
    }

    if (functionsHaveNames()) {
      return func.name;
    }

    var str = func.toString();
    var match = str.match(regex);
    return match && match[1];
  }

  assert$3.AssertionError = AssertionError$1;
  function AssertionError$1(options) {
    this.name = 'AssertionError';
    this.actual = options.actual;
    this.expected = options.expected;
    this.operator = options.operator;

    if (options.message) {
      this.message = options.message;
      this.generatedMessage = false;
    } else {
      this.message = getMessage(this);
      this.generatedMessage = true;
    }

    var stackStartFunction = options.stackStartFunction || fail$1;

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, stackStartFunction);
    } else {
      // non v8 browsers so we can have a stacktrace
      var err = new Error();

      if (err.stack) {
        var out = err.stack; // try to strip useless frames

        var fn_name = getName(stackStartFunction);
        var idx = out.indexOf('\n' + fn_name);

        if (idx >= 0) {
          // once we have located the function frame
          // we need to strip out everything before it (and its line)
          var next_line = out.indexOf('\n', idx + 1);
          out = out.substring(next_line + 1);
        }

        this.stack = out;
      }
    }
  } // assert.AssertionError instanceof Error

  util.inherits(AssertionError$1, Error);

  function truncate(s, n) {
    if (typeof s === 'string') {
      return s.length < n ? s : s.slice(0, n);
    } else {
      return s;
    }
  }

  function inspect(something) {
    if (functionsHaveNames() || !util.isFunction(something)) {
      return util.inspect(something);
    }

    var rawname = getName(something);
    var name = rawname ? ': ' + rawname : '';
    return '[Function' + name + ']';
  }

  function getMessage(self) {
    return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
  } // At present only the three keys mentioned above are used and
  // understood by the spec. Implementations or sub modules can pass
  // other keys to the AssertionError's constructor - they will be
  // ignored.
  // 3. All of the following functions must throw an AssertionError
  // when a corresponding condition is not met, with a message that
  // may be undefined if not provided.  All assertion methods provide
  // both the actual and expected values to the assertion error for
  // display purposes.


  function fail$1(actual, expected, message, operator, stackStartFunction) {
    throw new AssertionError$1({
      message: message,
      actual: actual,
      expected: expected,
      operator: operator,
      stackStartFunction: stackStartFunction
    });
  } // EXTENSION! allows for well behaved errors defined elsewhere.

  assert$3.fail = fail$1; // 4. Pure assertion tests whether a value is truthy, as determined
  // by !!guard.
  // assert.ok(guard, message_opt);
  // This statement is equivalent to assert.equal(true, !!guard,
  // message_opt);. To test strictly for the value true, use
  // assert.strictEqual(true, guard, message_opt);.

  function ok(value, message) {
    if (!value) fail$1(value, true, message, '==', ok);
  }
  assert$3.ok = ok;
  // ==.
  // assert.equal(actual, expected, message_opt);

  assert$3.equal = equal$1;
  function equal$1(actual, expected, message) {
    if (actual != expected) fail$1(actual, expected, message, '==', equal$1);
  } // 6. The non-equality assertion tests for whether two objects are not equal
  // with != assert.notEqual(actual, expected, message_opt);

  assert$3.notEqual = notEqual$1;
  function notEqual$1(actual, expected, message) {
    if (actual == expected) {
      fail$1(actual, expected, message, '!=', notEqual$1);
    }
  } // 7. The equivalence assertion tests a deep equality relation.
  // assert.deepEqual(actual, expected, message_opt);

  assert$3.deepEqual = deepEqual$1;
  function deepEqual$1(actual, expected, message) {
    if (!_deepEqual(actual, expected, false)) {
      fail$1(actual, expected, message, 'deepEqual', deepEqual$1);
    }
  }
  assert$3.deepStrictEqual = deepStrictEqual;
  function deepStrictEqual(actual, expected, message) {
    if (!_deepEqual(actual, expected, true)) {
      fail$1(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
    }
  }

  function _deepEqual(actual, expected, strict, memos) {
    // 7.1. All identical values are equivalent, as determined by ===.
    if (actual === expected) {
      return true;
    } else if (isBuffer$2(actual) && isBuffer$2(expected)) {
      return compare$1(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
      // equivalent if it is also a Date object that refers to the same time.
    } else if (util.isDate(actual) && util.isDate(expected)) {
      return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
      // equivalent if it is also a RegExp object with the same source and
      // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
    } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
      return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
    } else if ((actual === null || _typeof__default['default'](actual) !== 'object') && (expected === null || _typeof__default['default'](expected) !== 'object')) {
      return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
      // ArrayBuffers in a Buffer each to increase performance
      // This optimization requires the arrays to have the same type as checked by
      // Object.prototype.toString (aka pToString). Never perform binary
      // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
      // bit patterns are not identical.
    } else if (isView$1(actual) && isView$1(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
      return compare$1(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
    } else if (isBuffer$2(actual) !== isBuffer$2(expected)) {
      return false;
    } else {
      memos = memos || {
        actual: [],
        expected: []
      };
      var actualIndex = memos.actual.indexOf(actual);

      if (actualIndex !== -1) {
        if (actualIndex === memos.expected.indexOf(expected)) {
          return true;
        }
      }

      memos.actual.push(actual);
      memos.expected.push(expected);
      return objEquiv(actual, expected, strict, memos);
    }
  }

  function isArguments$1(object) {
    return Object.prototype.toString.call(object) == '[object Arguments]';
  }

  function objEquiv(a, b, strict, actualVisitedObjects) {
    if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

    if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
    if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
    var aIsArgs = isArguments$1(a);
    var bIsArgs = isArguments$1(b);
    if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

    if (aIsArgs) {
      a = pSlice.call(a);
      b = pSlice.call(b);
      return _deepEqual(a, b, strict);
    }

    var ka = objectKeys(a);
    var kb = objectKeys(b);
    var key, i; // having the same number of owned properties (keys incorporates
    // hasOwnProperty)

    if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

    ka.sort();
    kb.sort(); //~~~cheap key test

    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] !== kb[i]) return false;
    } //equivalent values for every corresponding key, and
    //~~~possibly expensive deep test


    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
    }

    return true;
  } // 8. The non-equivalence assertion tests for any deep inequality.
  // assert.notDeepEqual(actual, expected, message_opt);


  assert$3.notDeepEqual = notDeepEqual$1;
  function notDeepEqual$1(actual, expected, message) {
    if (_deepEqual(actual, expected, false)) {
      fail$1(actual, expected, message, 'notDeepEqual', notDeepEqual$1);
    }
  }
  assert$3.notDeepStrictEqual = notDeepStrictEqual;
  function notDeepStrictEqual(actual, expected, message) {
    if (_deepEqual(actual, expected, true)) {
      fail$1(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
    }
  } // 9. The strict equality assertion tests strict equality, as determined by ===.
  // assert.strictEqual(actual, expected, message_opt);

  assert$3.strictEqual = strictEqual;
  function strictEqual(actual, expected, message) {
    if (actual !== expected) {
      fail$1(actual, expected, message, '===', strictEqual);
    }
  } // 10. The strict non-equality assertion tests for strict inequality, as
  // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

  assert$3.notStrictEqual = notStrictEqual;
  function notStrictEqual(actual, expected, message) {
    if (actual === expected) {
      fail$1(actual, expected, message, '!==', notStrictEqual);
    }
  }

  function expectedException(actual, expected) {
    if (!actual || !expected) {
      return false;
    }

    if (Object.prototype.toString.call(expected) == '[object RegExp]') {
      return expected.test(actual);
    }

    try {
      if (actual instanceof expected) {
        return true;
      }
    } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
    }

    if (Error.isPrototypeOf(expected)) {
      return false;
    }

    return expected.call({}, actual) === true;
  }

  function _tryBlock(block) {
    var error;

    try {
      block();
    } catch (e) {
      error = e;
    }

    return error;
  }

  function _throws(shouldThrow, block, expected, message) {
    var actual;

    if (typeof block !== 'function') {
      throw new TypeError('"block" argument must be a function');
    }

    if (typeof expected === 'string') {
      message = expected;
      expected = null;
    }

    actual = _tryBlock(block);
    message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

    if (shouldThrow && !actual) {
      fail$1(actual, expected, 'Missing expected exception' + message);
    }

    var userProvidedMessage = typeof message === 'string';
    var isUnwantedException = !shouldThrow && util.isError(actual);
    var isUnexpectedException = !shouldThrow && actual && !expected;

    if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
      fail$1(actual, expected, 'Got unwanted exception' + message);
    }

    if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
      throw actual;
    }
  } // 11. Expected to throw an error:
  // assert.throws(block, Error_opt, message_opt);


  assert$3.throws = throws$1;
  function throws$1(block,
  /*optional*/
  error,
  /*optional*/
  message) {
    _throws(true, block, error, message);
  } // EXTENSION! This is annoying to write outside this module.

  assert$3.doesNotThrow = doesNotThrow$1;
  function doesNotThrow$1(block,
  /*optional*/
  error,
  /*optional*/
  message) {
    _throws(false, block, error, message);
  }
  assert$3.ifError = ifError$1;
  function ifError$1(err) {
    if (err) throw err;
  }

  /*
   * Constants
   */


  var BIG_ENDIAN$1 = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
  /**
   * Salsa20
   */

  var Salsa20 = /*#__PURE__*/function () {
    /**
     * Create a Salsa20 context.
     * @constructor
     */
    function Salsa20() {
      _classCallCheck__default['default'](this, Salsa20);

      this.state = new Uint32Array(16);
      this.stream = new Uint32Array(16);
      this.bytes = new Uint8Array(this.stream.buffer);
      this.pos = -1;
      if (BIG_ENDIAN$1) this.bytes = Buffer.alloc(64);
    }
    /**
     * Initialize salsa20 with a key, nonce, and counter.
     * @param {Buffer} key
     * @param {Buffer} nonce
     * @param {Number} counter
     */


    _createClass__default['default'](Salsa20, [{
      key: "init",
      value: function init(key, nonce, counter) {
        if (counter == null) counter = 0;
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(Buffer.isBuffer(nonce));
        assert_1$1(Number.isSafeInteger(counter));
        if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');

        if (nonce.length >= 24) {
          key = Salsa20.derive(key, nonce.slice(0, 16));
          nonce = nonce.slice(16);
        }

        this.state[0] = 0x61707865;
        this.state[1] = readU32$7(key, 0);
        this.state[2] = readU32$7(key, 4);
        this.state[3] = readU32$7(key, 8);
        this.state[4] = readU32$7(key, 12);
        this.state[5] = key.length < 32 ? 0x3120646e : 0x3320646e;

        if (nonce.length === 8) {
          this.state[6] = readU32$7(nonce, 0);
          this.state[7] = readU32$7(nonce, 4);
          this.state[8] = counter >>> 0;
          this.state[9] = counter / 0x100000000 >>> 0;
        } else if (nonce.length === 12) {
          this.state[6] = readU32$7(nonce, 0);
          this.state[7] = readU32$7(nonce, 4);
          this.state[8] = readU32$7(nonce, 8);
          this.state[9] = counter >>> 0;
        } else if (nonce.length === 16) {
          this.state[6] = readU32$7(nonce, 0);
          this.state[7] = readU32$7(nonce, 4);
          this.state[8] = readU32$7(nonce, 8);
          this.state[9] = readU32$7(nonce, 12);
        } else {
          throw new RangeError('Invalid nonce size.');
        }

        this.state[10] = key.length < 32 ? 0x79622d36 : 0x79622d32;
        this.state[11] = readU32$7(key, 16 % key.length);
        this.state[12] = readU32$7(key, 20 % key.length);
        this.state[13] = readU32$7(key, 24 % key.length);
        this.state[14] = readU32$7(key, 28 % key.length);
        this.state[15] = 0x6b206574;
        this.pos = 0;
        return this;
      }
      /**
       * Encrypt/decrypt data.
       * @param {Buffer} data - Will be mutated.
       * @returns {Buffer}
       */

    }, {
      key: "encrypt",
      value: function encrypt(data) {
        assert_1$1(Buffer.isBuffer(data));
        if (this.pos === -1) throw new Error('Context is not initialized.');

        for (var i = 0; i < data.length; i++) {
          if ((this.pos & 63) === 0) {
            this._block();

            this.pos = 0;
          }

          data[i] ^= this.bytes[this.pos++];
        }

        return data;
      }
      /**
       * Stir the stream.
       */

    }, {
      key: "_block",
      value: function _block() {
        for (var i = 0; i < 16; i++) {
          this.stream[i] = this.state[i];
        }

        for (var _i = 0; _i < 10; _i++) {
          qround$1(this.stream, 0, 4, 8, 12);
          qround$1(this.stream, 5, 9, 13, 1);
          qround$1(this.stream, 10, 14, 2, 6);
          qround$1(this.stream, 15, 3, 7, 11);
          qround$1(this.stream, 0, 1, 2, 3);
          qround$1(this.stream, 5, 6, 7, 4);
          qround$1(this.stream, 10, 11, 8, 9);
          qround$1(this.stream, 15, 12, 13, 14);
        }

        for (var _i2 = 0; _i2 < 16; _i2++) {
          this.stream[_i2] += this.state[_i2];
        }

        if (BIG_ENDIAN$1) {
          for (var _i3 = 0; _i3 < 16; _i3++) {
            writeU32$6(this.bytes, this.stream[_i3], _i3 * 4);
          }
        }

        this.state[8] += 1;
        if (this.state[8] === 0) this.state[9] += 1;
      }
      /**
       * Destroy context.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 16; i++) {
          this.state[i] = 0;
          this.stream[i] = 0;
        }

        if (BIG_ENDIAN$1) {
          for (var _i4 = 0; _i4 < 64; _i4++) {
            this.bytes[_i4] = 0;
          }
        }

        this.pos = -1;
        return this;
      }
      /**
       * Derive key with XSalsa20.
       * @param {Buffer} key
       * @param {Buffer} nonce
       * @returns {Buffer}
       */

    }], [{
      key: "derive",
      value: function derive(key, nonce) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(Buffer.isBuffer(nonce));
        if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');
        if (nonce.length !== 16) throw new RangeError('Invalid nonce size.');
        var state = new Uint32Array(16);
        state[0] = 0x61707865;
        state[1] = readU32$7(key, 0);
        state[2] = readU32$7(key, 4);
        state[3] = readU32$7(key, 8);
        state[4] = readU32$7(key, 12);
        state[5] = key.length < 32 ? 0x3120646e : 0x3320646e;
        state[6] = readU32$7(nonce, 0);
        state[7] = readU32$7(nonce, 4);
        state[8] = readU32$7(nonce, 8);
        state[9] = readU32$7(nonce, 12);
        state[10] = key.length < 32 ? 0x79622d36 : 0x79622d32;
        state[11] = readU32$7(key, 16 % key.length);
        state[12] = readU32$7(key, 20 % key.length);
        state[13] = readU32$7(key, 24 % key.length);
        state[14] = readU32$7(key, 28 % key.length);
        state[15] = 0x6b206574;

        for (var j = 0; j < 10; j++) {
          qround$1(state, 0, 4, 8, 12);
          qround$1(state, 5, 9, 13, 1);
          qround$1(state, 10, 14, 2, 6);
          qround$1(state, 15, 3, 7, 11);
          qround$1(state, 0, 1, 2, 3);
          qround$1(state, 5, 6, 7, 4);
          qround$1(state, 10, 11, 8, 9);
          qround$1(state, 15, 12, 13, 14);
        }

        var out = Buffer.alloc(32);
        writeU32$6(out, state[0], 0);
        writeU32$6(out, state[5], 4);
        writeU32$6(out, state[10], 8);
        writeU32$6(out, state[15], 12);
        writeU32$6(out, state[6], 16);
        writeU32$6(out, state[7], 20);
        writeU32$6(out, state[8], 24);
        writeU32$6(out, state[9], 28);
        return out;
      }
    }]);

    return Salsa20;
  }();
  /*
   * Static
   */


  Salsa20.native = 0;
  /*
   * Helpers
   */

  function qround$1(x, a, b, c, d) {
    x[b] ^= rotl32$1(x[a] + x[d], 7);
    x[c] ^= rotl32$1(x[b] + x[a], 9);
    x[d] ^= rotl32$1(x[c] + x[b], 13);
    x[a] ^= rotl32$1(x[d] + x[c], 18);
  }

  function rotl32$1(w, b) {
    return w << b | w >>> 32 - b;
  }

  function readU32$7(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }

  function writeU32$6(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var salsa20 = Salsa20;

  var salsa20Browser = salsa20;

  var poly1305Browser = poly1305;

  /*
   * Constants
   */


  var ZERO16 = Buffer.alloc(16, 0x00);
  /*
   * Secret Box
   */

  function seal(msg, key, nonce) {
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(key));
    assert_1$1(Buffer.isBuffer(nonce));
    assert_1$1(key.length === 32);
    assert_1$1(nonce.length === 24);
    var polyKey = Buffer.alloc(32, 0x00);
    var box = Buffer.alloc(16 + msg.length);
    var ciphertext = box.slice(16);
    var salsa = new salsa20Browser();
    var poly = new poly1305Browser();
    msg.copy(box, 16);
    salsa.init(key, nonce);
    salsa.encrypt(polyKey);
    salsa.encrypt(ciphertext);
    poly.init(polyKey);
    poly.update(ciphertext);
    poly.final().copy(box, 0);
    return box;
  }

  function open(sealed, key, nonce) {
    assert_1$1(Buffer.isBuffer(sealed));
    assert_1$1(Buffer.isBuffer(key));
    assert_1$1(Buffer.isBuffer(nonce));
    assert_1$1(key.length === 32);
    assert_1$1(nonce.length === 24);
    if (sealed.length < 16) throw new Error('Invalid secret box size.');
    var polyKey = Buffer.alloc(32, 0x00);
    var input = Buffer.from(sealed);
    var tag = input.slice(0, 16);
    var msg = input.slice(16);
    var salsa = new salsa20Browser();
    var poly = new poly1305Browser();
    salsa.init(key, nonce);
    salsa.encrypt(polyKey);
    poly.init(polyKey);
    poly.update(msg);
    if (!poly.verify(tag)) throw new Error('Invalid secret box tag.');
    salsa.encrypt(msg);
    return msg;
  }

  function derive$1(secret, kdf) {
    var key = deriveSecret(secret, kdf);
    return salsa20Browser.derive(key, ZERO16);
  }
  /*
   * Helpers
   */


  function deriveSecret(secret, kdf) {
    assert_1$1(Buffer.isBuffer(secret));

    if (kdf == null) {
      if (secret.length !== 32) throw new RangeError('Invalid secret size for secret box.');
      return secret;
    }

    var key;
    if (typeof kdf.digest === 'function') key = kdf.digest(secret);else if (typeof kdf === 'function') key = kdf(secret);else throw new Error('Invalid key derivation function.');
    assert_1$1(Buffer.isBuffer(key));
    if (key.length < 32) throw new RangeError('Key is too small for secret box.');
    return key.slice(0, 32);
  }
  /*
   * Expose
   */


  var native_1$2 = 0;
  var seal_1 = seal;
  var open_1 = open;
  var derive_1$1 = derive$1;
  var secretbox = {
    native: native_1$2,
    seal: seal_1,
    open: open_1,
    derive: derive_1$1
  };

  var secretboxBrowser = secretbox;

  /*
   * Constants
   */


  var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  var HAS_CRYPTO = crypto && typeof crypto.getRandomValues === 'function';
  var randomValues = HAS_CRYPTO ? crypto.getRandomValues.bind(crypto) : null;
  var pool = new Uint32Array(16);
  var MAX_BYTES = 65536;
  var poolPos = 0;
  /**
   * Generate pseudo-random bytes.
   * @param {Number} size
   * @returns {Buffer}
   */

  function randomBytes(size) {
    assert_1$1(size >>> 0 === size);
    var data = Buffer.alloc(size);
    randomFillSync(data, 0, size);
    return data;
  }
  /**
   * Generate pseudo-random bytes.
   * @param {Buffer} data
   * @param {Number} [off=0]
   * @param {Number} [size=data.length-off]
   * @returns {Buffer}
   */


  function randomFill(data, off, size) {
    assert_1$1(Buffer.isBuffer(data));
    if (off == null) off = 0;
    assert_1$1(off >>> 0 === off);
    if (size == null) size = data.length - off;
    assert_1$1(size >>> 0 === size);
    assert_1$1(off + size <= data.length);
    randomFillSync(data, off, size);
    return data;
  }
  /**
   * Generate a random uint32.
   * @returns {Number}
   */


  function randomInt() {
    if ((poolPos & 15) === 0) {
      getRandomValues(pool);
      poolPos = 0;
    }

    return pool[poolPos++];
  }
  /**
   * Generate a random uint32 within a range.
   * @param {Number} min - Inclusive.
   * @param {Number} max - Exclusive.
   * @returns {Number}
   */


  function randomRange(min, max) {
    assert_1$1(min >>> 0 === min);
    assert_1$1(max >>> 0 === max);
    assert_1$1(max >= min);
    var space = max - min;
    if (space === 0) return min;
    var top = -space >>> 0;
    var x, r;

    do {
      x = randomInt();
      r = x % space;
    } while (x - r > top);

    return r + min;
  }
  /*
   * Helpers
   */


  function getRandomValues(array) {
    if (!HAS_CRYPTO) throw new Error('Entropy source not available.');
    return randomValues(array);
  }

  function randomFillSync(data, off, size) {
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(data.buffer instanceof ArrayBuffer);
    assert_1$1(data.byteOffset >>> 0 === data.byteOffset);
    assert_1$1(data.byteLength >>> 0 === data.byteLength);
    assert_1$1(off >>> 0 === off);
    assert_1$1(size >>> 0 === size);
    assert_1$1(off + size <= data.byteLength);
    if (size > Math.pow(2, 31) - 1) throw new RangeError('The value "size" is out of range.');
    var offset = data.byteOffset + off;
    var array = new Uint8Array(data.buffer, offset, size);

    if (array.length > MAX_BYTES) {
      for (var i = 0; i < array.length; i += MAX_BYTES) {
        var j = i + MAX_BYTES;
        if (j > array.length) j = array.length;
        getRandomValues(array.subarray(i, j));
      }
    } else {
      if (array.length > 0) getRandomValues(array);
    }
  }
  /*
   * Expose
   */


  var native_1$3 = 0;
  var randomBytes_1 = randomBytes;
  var randomFill_1 = randomFill;
  var randomInt_1 = randomInt;
  var randomRange_1 = randomRange;
  var random = {
    native: native_1$3,
    randomBytes: randomBytes_1,
    randomFill: randomFill_1,
    randomInt: randomInt_1,
    randomRange: randomRange_1
  };

  var randomBrowser = random;

  function _createForOfIteratorHelper$2(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e3) { throw _e3; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e4) { didErr = true; err = _e4; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

  function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var custom$2 = customBrowser.custom;
  /*
   * Constants
   */

  var types$1 = {
    AFFINE: 0,
    JACOBIAN: 1,
    PROJECTIVE: 2,
    EXTENDED: 3
  };
  var jsfIndex = [-3, // -1 -1
  -1, // -1 0
  -5, // -1 1
  -7, // 0 -1
  0, // 0 0
  7, // 0 1
  5, // 1 -1
  1, // 1 0
  3 // 1 1
  ];
  var uid = 0;
  /**
   * Curve
   */

  var Curve = /*#__PURE__*/function () {
    function Curve(Point, type, conf) {
      _classCallCheck__default['default'](this, Curve);

      this.Point = null;
      this.id = null;
      this.uid = uid++;
      this.ossl = null;
      this.type = 'base';
      this.endian = 'be';
      this.hash = null;
      this.prefix = null;
      this.context = false;
      this.prime = null;
      this.p = null;
      this.red = null;
      this.fieldSize = 0;
      this.fieldBits = 0;
      this.adjustedSize = 0;
      this.signBit = 0;
      this.mask = 0;
      this.n = null;
      this.h = null;
      this.q = null;
      this.z = null;
      this.g = null;
      this.nh = null;
      this.scalarSize = 0;
      this.scalarBits = 0;
      this.zero = null;
      this.one = null;
      this.two = null;
      this.three = null;
      this.four = null;
      this.i2 = null;
      this.i3 = null;
      this.i4 = null;
      this.i6 = null;
      this.torsion = null;
      this.endo = null;
      this.hi = null;

      this._init(Point, type, conf);
    }

    _createClass__default['default'](Curve, [{
      key: "_init",
      value: function _init(Point, type, conf) {
        assert$4(typeof Point === 'function');
        assert$4(typeof type === 'string');
        assert$4(conf && _typeof__default['default'](conf) === 'object');
        assert$4(conf.red == null || conf.red instanceof bnBrowser.Red);
        assert$4(conf.p != null, 'Must pass a prime.');
        assert$4(conf.id == null || typeof conf.id === 'string');
        assert$4(conf.ossl == null || typeof conf.ossl === 'string');
        assert$4(conf.endian == null || typeof conf.endian === 'string');
        assert$4(conf.hash == null || typeof conf.hash === 'string');
        assert$4(conf.prefix == null || typeof conf.prefix === 'string');
        assert$4(conf.context == null || typeof conf.context === 'boolean');
        assert$4(conf.prime == null || typeof conf.prime === 'string');
        assert$4(conf.torsion == null || Array.isArray(conf.torsion)); // Point class.

        this.Point = Point; // Meta.

        this.id = conf.id || null;
        this.ossl = conf.ossl || null;
        this.type = type;
        this.endian = conf.endian || (type === 'short' ? 'be' : 'le');
        this.hash = conf.hash || null;
        this.prefix = conf.prefix ? Buffer.from(conf.prefix, 'binary') : null;
        this.context = conf.context || false;
        this.prime = conf.prime || null; // Prime.

        this.p = bnBrowser.fromJSON(conf.p); // Reduction.

        if (conf.red) {
          this.red = conf.red;
        } else {
          // Use Montgomery when there is no fast reduction for the prime.
          this.red = conf.prime ? bnBrowser.red(conf.prime) : bnBrowser.mont(this.p);
          this.red.precompute();
        } // Precalculate encoding length.


        this.fieldSize = this.p.byteLength();
        this.fieldBits = this.p.bitLength();
        this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0);
        this.signBit = this.adjustedSize * 8 - 1;
        this.mask = 0xff;
        if ((this.fieldBits & 7) !== 0) this.mask = (1 << (this.fieldBits & 7)) - 1; // Curve configuration, optional.

        this.n = bnBrowser.fromJSON(conf.n || '0');
        this.h = bnBrowser.fromJSON(conf.h || '1');
        this.q = this.n.mul(this.h);
        this.z = bnBrowser.fromJSON(conf.z || '0').toRed(this.red);
        this.g = null;
        this.nh = this.n.ushrn(1);
        this.scalarSize = this.n.byteLength();
        this.scalarBits = this.n.bitLength(); // Useful for many curves.

        this.zero = new bnBrowser(0).toRed(this.red);
        this.one = new bnBrowser(1).toRed(this.red);
        this.two = new bnBrowser(2).toRed(this.red);
        this.three = new bnBrowser(3).toRed(this.red);
        this.four = new bnBrowser(4).toRed(this.red); // Inverses.

        this.i2 = this.two.redInvert();
        this.i3 = this.three.redInvert();
        this.i4 = this.i2.redSqr();
        this.i6 = this.i2.redMul(this.i3); // Torsion.

        this.torsion = new Array(this.h.word(0));

        for (var i = 0; i < this.torsion.length; i++) {
          this.torsion[i] = this.point();
        } // Endomorphism.


        this.endo = null; // Cache.

        this.hi = null; // Memoize.

        this._scale = memoize$1(this._scale, this);
        this.isIsomorphic = memoize$1(this.isIsomorphic, this);
        this.isIsogenous = memoize$1(this.isIsogenous, this); // Sanity checks.

        assert$4(this.p.sign() > 0 && this.p.isOdd());
        assert$4(this.n.sign() >= 0);
        assert$4(this.h.sign() > 0 && this.h.cmpn(255) <= 0);
        assert$4(this.endian === 'be' || this.endian === 'le');
        return this;
      }
    }, {
      key: "_finalize",
      value: function _finalize(conf) {
        assert$4(conf && _typeof__default['default'](conf) === 'object'); // Create base point.

        this.g = conf.g ? this.pointFromJSON(conf.g) : this.point(); // Parse small order points.

        if (conf.torsion) {
          assert$4(conf.torsion.length === this.torsion.length);

          for (var i = 0; i < this.torsion.length; i++) {
            this.torsion[i] = this.pointFromJSON(conf.torsion[i]);
          }
        }

        return this;
      }
    }, {
      key: "_findTorsion",
      value: function _findTorsion() {
        // Find all torsion points by grinding.
        assert$4(!this.n.isZero());
        var h = this.h.word(0);
        var x = this.one.redNeg();
        var out = [this.point()];
        var set = new Set();
        var len = h;

        while (out.length < len) {
          var p = void 0;
          x.redIAdd(this.one);

          try {
            p = this.pointFromX(x.clone());
          } catch (e) {
            continue;
          }

          try {
            p = p.mul(this.n);
          } catch (e) {
            len = 2;
            continue;
          }

          if (p.isInfinity()) continue;
          p.normalize();

          for (var _i = 0, _arr = [p, p.neg()]; _i < _arr.length; _i++) {
            var point = _arr[_i];
            var key = point.key();

            if (!set.has(key)) {
              out.push(point);
              set.add(key);
            }
          }
        }

        out.sort(function (a, b) {
          return a.cmp(b);
        });

        while (out.length < h) {
          out.push(this.point());
        }

        return out;
      }
    }, {
      key: "_simpleMul",
      value: function _simpleMul(p, k) {
        // Left-to-right point multiplication.
        //
        // [GECC] Algorithm 3.27, Page 97, Section 3.3.
        //        Algorithm 3.26, Page 96, Section 3.3.
        assert$4(p instanceof Point);
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red); // We prefer left-to-right since it
        // allows us to repeatedly add an
        // affine point to the accumulator.

        var bits = k.bitLength(); // Flip sign if necessary.

        if (k.isNeg()) p = p.neg(); // Multiply.

        var acc = this.jpoint();

        for (var i = bits - 1; i >= 0; i--) {
          var bit = k.bit(i);
          acc = acc.dbl();
          if (bit === 1) acc = acc.add(p);
        }

        return acc;
      }
    }, {
      key: "_simpleMulAdd",
      value: function _simpleMulAdd(points, coeffs) {
        // Multiple point multiplication, also known
        // as "Shamir's trick".
        //
        // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.
        assert$4(Array.isArray(points));
        assert$4(Array.isArray(coeffs));
        assert$4(points.length === coeffs.length);
        var len = points.length;
        var npoints = new Array(len);
        var ncoeffs = coeffs; // Check arrays and calculate size.

        var max = 0;

        for (var i = 0; i < len; i++) {
          var point = points[i];
          var coeff = coeffs[i];
          assert$4(point instanceof Point);
          assert$4(coeff instanceof bnBrowser);
          assert$4(!coeff.red);
          if (i > 0 && point.type !== points[i - 1].type) throw new Error('Cannot mix points.'); // Flip signs if necessary.

          npoints[i] = coeff.isNeg() ? point.neg() : point; // Compute max scalar size.

          max = Math.max(max, coeff.bitLength());
        } // Multiply and add.


        var acc = this.jpoint();

        for (var _i2 = max - 1; _i2 >= 0; _i2--) {
          acc = acc.dbl();

          for (var j = 0; j < len; j++) {
            var _point = npoints[j];
            var _coeff = ncoeffs[j];

            var bit = _coeff.bit(_i2);

            if (bit === 1) acc = acc.add(_point);
          }
        }

        return acc;
      }
    }, {
      key: "_constMul",
      value: function _constMul(p, k, rng) {
        assert$4(p instanceof Point); // Must have order.

        if (this.n.isZero()) return this._simpleMul(p, k); // Use Co-Z arithmetic for Weierstrass (h=1).

        if (this.type === 'short' && this.h.cmpn(1) === 0) return this._coZLadderMul(p, k); // Otherwise, a regular ladder.

        return this._ladderMul(p, k);
      }
    }, {
      key: "_ladderMul",
      value: function _ladderMul(p, k) {
        // Generalized Montgomery Ladder.
        //
        // [MONT1] Page 24, Section 4.6.2.
        assert$4(p instanceof Point);
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red); // Curve must expose some form of unified
        // addition (this is easier said than done
        // for Weierstrass curves). This ensures
        // both branches of the ladder consume
        // the same power and number of cycles.
        //
        // We implement the ladder as a branchless
        // function with a constant time swap.
        //
        // Current cost:
        //
        //   N * (14M + 14S + 11A + 2*a + 1*8 + 3*4 + 2*3 + 4*2)
        //
        //   N=256 => 3584M + 3584S + 2816A + 512*a
        //          + 256*8 + 768*4 + 512*3 + 1024*2

        var _getLadderBits = getLadderBits(k, this.q),
            _getLadderBits2 = _slicedToArray__default['default'](_getLadderBits, 3),
            sign = _getLadderBits2[0],
            bits = _getLadderBits2[1],
            exp = _getLadderBits2[2]; // Clone points (for safe swapping).


        var a = p.toJ().clone();
        var b = this.jpoint().clone();
        var swap = 0; // Climb the ladder.

        for (var i = bits - 1; i >= 0; i--) {
          var bit = exp[i >> 3] >> (i & 7) & 1; // Maybe swap.

          a.swap(b, swap ^ bit); // Unified addition.

          a = a.uadd(b);
          b = b.udbl();
          swap = bit;
        } // Finalize loop.


        a.swap(b, swap); // Flip sign retroactively.

        b.swap(b.neg(), sign);
        return b;
      }
    }, {
      key: "_coZLadderMul",
      value: function _coZLadderMul(p, k) {
        // Co-Z Montgomery Ladder.
        //
        // [COZ] Algorithm 9, Page 6, Section 4.
        assert$4(p instanceof Point);
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red); // Multiply with Co-Z arithmetic. This method is
        // 2x faster than our regular unified addition
        // ladder. However, there are some problems with
        // leakage of the scalar length.
        //
        // There are three issues with this algorithm:
        //
        //   1. The amount of steps in the ladder is not
        //      constant, since we must assume k[n-1]=1
        //      (it follows that k[n]=0). A side effect
        //      of this is that we cannot handle a point
        //      at infinity (k[n-1]=0).
        //
        //   2. On the off chance we pass in a "low"
        //      scalar (lacking several hi bits), there
        //      will be a noticeable difference in cycles.
        //
        //   3. The algorithm cannot handle k = -1 mod n.
        //      It will overflow to infinity.
        //
        // To avoid two of these issues, we _negate_ the
        // scalar in the event that bits(k) < bits(-k). If
        // we do end up negating a scalar, we negate the
        // resulting point in constant time at the end.
        //
        // Doing this not only solves the point at infinity
        // issue (i.e. N-0=N=0), but it also ensures a scalar
        // is within at least 1 bit of the order (usually).
        //
        // The final edge case can be solved with a
        // comparison and subsequent constant-time swap at
        // the end.
        //
        // Note that our scalar recoding here disallows
        // the possibility of curves with a cofactor > 1.
        //
        // A possibility for a perf improvement involves
        // using the ZACAU method. This is faster assuming
        // a cost of 1S < 1M, but our squaring impl. is
        // identical to our multiplication impl., so we
        // wouldn't get any real benefit.
        //
        // Current cost:
        //
        //   1M + 5S + 8A + 4*2 + 1*8
        //   N * (11M + 3S + 21A + 1*2)
        //
        //   N=256 => 2817M + 773S + 5384A + 256*2 + 4*2 + 1*8

        var c = p.toJ().clone();

        var _getCOZBits = getCOZBits(k, this.n),
            _getCOZBits2 = _slicedToArray__default['default'](_getCOZBits, 4),
            sign = _getCOZBits2[0],
            bits = _getCOZBits2[1],
            exp = _getCOZBits2[2],
            m1 = _getCOZBits2[3]; // Initial double (we assume k[n-1] == 1).


        var _c$zdblu = c.zdblu(),
            _c$zdblu2 = _slicedToArray__default['default'](_c$zdblu, 2),
            a = _c$zdblu2[0],
            b = _c$zdblu2[1];

        var swap = 0; // Climb the ladder.

        for (var i = bits - 2; i >= 0; i--) {
          var bit = exp[i >> 3] >> (i & 7) & 1; // Maybe swap.

          a.swap(b, swap ^ bit); // Co-Z addition.

          var _b$zaddc = b.zaddc(a);

          var _b$zaddc2 = _slicedToArray__default['default'](_b$zaddc, 2);

          a = _b$zaddc2[0];
          b = _b$zaddc2[1];

          var _a$zaddu = a.zaddu(b);

          var _a$zaddu2 = _slicedToArray__default['default'](_a$zaddu, 2);

          b = _a$zaddu2[0];
          a = _a$zaddu2[1];
          swap = bit;
        } // Finalize loop.


        a.swap(b, swap); // Final edge case.

        b.swap(c.neg(), m1); // Adjust sign.

        b.swap(b.neg(), sign);
        return b;
      }
    }, {
      key: "_fixedMul",
      value: function _fixedMul(p, k) {
        // Fixed-base method for point multiplication.
        //
        // [ECPM] "Windowed method".
        // [GECC] Page 95, Section 3.3.
        //
        // Windows are appropriately shifted to avoid any
        // doublings. This reduces a 256 bit multiplication
        // down to 64 additions with a window size of 4.
        assert$4(p instanceof Point);
        assert$4(k instanceof bnBrowser);
        assert$4(p.pre && p.pre.windows); // Get precomputed windows.

        var _p$_getWindows = p._getWindows(0, 0),
            width = _p$_getWindows.width,
            bits = _p$_getWindows.bits,
            points = _p$_getWindows.points; // Recompute window size.


        var size = 1 << width; // Recompute steps.

        var steps = (bits + width - 1) / width >>> 0; // Multiply.

        var acc = this.jpoint();

        for (var i = 0; i < steps; i++) {
          var _bits = k.bits(i * width, width);

          acc = acc.add(points[i * size + _bits]);
        } // Adjust sign.


        if (k.isNeg()) acc = acc.neg();
        return acc;
      }
    }, {
      key: "_fixedNafMul",
      value: function _fixedNafMul(p, k) {
        // Fixed-base NAF windowing method for point multiplication.
        //
        // [GECC] Algorithm 3.42, Page 105, Section 3.3.
        assert$4(p instanceof Point);
        assert$4(k instanceof bnBrowser);
        assert$4(p.pre && p.pre.doubles); // Get precomputed doubles.

        var _p$_getDoubles = p._getDoubles(0, 0),
            step = _p$_getDoubles.step,
            points = _p$_getDoubles.points; // Get fixed NAF (in a more windowed form).


        var naf = getFixedNAF(k, 2, k.bitLength() + 1, step); // Compute steps.

        var I = ((1 << step + 1) - (step % 2 === 0 ? 2 : 1)) / 3; // Multiply.

        var a = this.jpoint();
        var b = this.jpoint();

        for (var i = I; i > 0; i--) {
          for (var j = 0; j < naf.length; j++) {
            var nafW = naf[j];
            if (nafW === i) b = b.add(points[j]);else if (nafW === -i) b = b.sub(points[j]);
          }

          a = a.add(b);
        }

        return a;
      }
    }, {
      key: "_windowMul",
      value: function _windowMul(width, p, k) {
        // Windowed method for point multiplication.
        //
        // [ECPM] "Windowed method".
        // [GECC] Page 95, Section 3.3.
        assert$4(width >>> 0 === width);
        assert$4(p instanceof Point);
        assert$4(k instanceof bnBrowser);
        var size = 1 << width;
        var bits = Math.max(k.bitLength(), this.n.bitLength());
        var steps = (bits + width - 1) / width >>> 0;
        var wnd = new Array(size);
        var point = p.toJ(); // Precompute.

        wnd[0] = this.jpoint();
        wnd[1] = point;

        for (var i = 2; i < size; i += 2) {
          wnd[i + 0] = wnd[i >> 1].dbl();
          wnd[i + 1] = wnd[i].add(point);
        } // Multiply.


        var acc = this.jpoint();

        for (var _i3 = steps - 1; _i3 >= 0; _i3--) {
          var _bits2 = k.bits(_i3 * width, width);

          if (_i3 === steps - 1) {
            acc = wnd[_bits2];
          } else {
            acc = acc.dblp(width);
            acc = acc.add(wnd[_bits2]);
          }
        } // Adjust sign.


        if (k.isNeg()) acc = acc.neg();
        return acc;
      }
    }, {
      key: "_slideMul",
      value: function _slideMul(width, p, k) {
        // Sliding window method for point multiplication.
        //
        // [ECPM] "Sliding-window method".
        // [GECC] Algorithm 3.38, Page 101, Section 3.3.
        assert$4(width >>> 0 === width);
        assert$4(p instanceof Point);
        assert$4(k instanceof bnBrowser);
        var size = 1 << width - 1;
        var wnd = new Array(size);
        var point = p.toJ(); // Precompute.

        wnd[0] = point.dblp(width - 1);

        for (var _i4 = 1; _i4 < size; _i4++) {
          wnd[_i4] = wnd[_i4 - 1].add(point);
        } // Multiply.


        var i = k.bitLength();
        var r = this.jpoint();

        while (i >= width) {
          var pos = i - width;
          var bits = k.bits(pos, width);

          if (bits < size) {
            r = r.dbl();
            i -= 1;
            continue;
          }

          r = r.dblp(width);
          r = r.add(wnd[bits & ~size]);
          i = pos;
        } // Finish.


        if (i > 0) {
          var _bits3 = k.bits(0, i);

          while (i--) {
            r = r.dbl();
            if (_bits3 >> i & 1) r = r.add(p);
          }
        } // Adjust sign.


        if (k.isNeg()) r = r.neg();
        return r;
      }
    }, {
      key: "_wnafMul",
      value: function _wnafMul(w, p, k) {
        // Window NAF method for point multiplication.
        //
        // [GECC] Algorithm 3.36, Page 100, Section 3.3.
        assert$4(p instanceof Point);
        assert$4(k instanceof bnBrowser); // Precompute window.

        var _p$_safeNAF = p._safeNAF(w),
            width = _p$_safeNAF.width,
            points = _p$_safeNAF.points; // Get NAF form.


        var naf = getNAF(k, width, k.bitLength() + 1); // Add `this`*(N+1) for every w-NAF index.

        var acc = this.jpoint();

        for (var i = naf.length - 1; i >= 0; i--) {
          var z = naf[i];
          if (i !== naf.length - 1) acc = acc.dbl();
          if (z > 0) acc = acc.add(points[z - 1 >> 1]);else if (z < 0) acc = acc.sub(points[-z - 1 >> 1]);
        }

        return acc;
      }
    }, {
      key: "_wnafMulAdd",
      value: function _wnafMulAdd(w, points, coeffs) {
        // Multiple point multiplication, also known
        // as "Shamir's trick" (with interleaved NAFs).
        //
        // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.
        //        Algorithm 3.51, Page 112, Section 3.3.
        //
        // This is particularly useful for signature
        // verifications and mutiplications after an
        // endomorphism split.
        assert$4(w >>> 0 === w);
        assert$4(Array.isArray(points));
        assert$4(Array.isArray(coeffs));
        assert$4(points.length === coeffs.length);
        var length = points.length;
        var wnd = new Array(length);
        var naf = new Array(length); // Check arrays and calculate size.

        var max = 0;

        for (var i = 0; i < length; i++) {
          var point = points[i];
          var coeff = coeffs[i];
          assert$4(point instanceof Point);
          assert$4(coeff instanceof bnBrowser);
          if (i > 0 && point.type !== points[i - 1].type) throw new Error('Cannot mix points.'); // Avoid sparse arrays.

          wnd[i] = null;
          naf[i] = null; // Compute max scalar size.

          max = Math.max(max, coeff.bitLength() + 1);
        } // Compute NAFs.


        var ppoint = null;
        var pcoeff = null;
        var len = 0;

        for (var _i5 = 0; _i5 < length; _i5++) {
          var _point2 = points[_i5];
          var _coeff2 = coeffs[_i5];

          var pre = _point2._getNAF(0); // Use precomputation if available.


          if (pre) {
            wnd[len] = pre.points;
            naf[len] = getNAF(_coeff2, pre.width, max);
            len += 1;
            continue;
          } // Save last non-precomputed point.


          if (!ppoint) {
            ppoint = _point2;
            pcoeff = _coeff2;
            continue;
          } // Compute JSF in NAF form.


          wnd[len] = ppoint._getJNAF(_point2);
          naf[len] = getJNAF(pcoeff, _coeff2, max);
          ppoint = null;
          pcoeff = null;
          len += 1;
        } // Regular NAF for odd points.


        if (ppoint) {
          var nafw = ppoint._safeNAF(w);

          wnd[len] = nafw.points;
          naf[len] = getNAF(pcoeff, nafw.width, max);
          len += 1;
        } // Multiply and add.


        var acc = this.jpoint();

        for (var _i6 = max - 1; _i6 >= 0; _i6--) {
          if (_i6 !== max - 1) acc = acc.dbl();

          for (var j = 0; j < len; j++) {
            var z = naf[j][_i6];
            if (z > 0) acc = acc.add(wnd[j][z - 1 >> 1]);else if (z < 0) acc = acc.sub(wnd[j][-z - 1 >> 1]);
          }
        }

        return acc;
      }
    }, {
      key: "_endoWnafMulAdd",
      value: function _endoWnafMulAdd(points, coeffs) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_scale",
      value: function _scale(curve, invert) {
        assert$4(curve instanceof Curve);
        assert$4(curve.p.eq(this.p));

        switch (curve.type) {
          case 'short':
            return this._scaleShort(curve, invert);

          case 'mont':
            return this._scaleMont(curve, invert);

          case 'edwards':
            return this._scaleEdwards(curve, invert);

          default:
            throw new Error('Not implemented.');
        }
      }
    }, {
      key: "_scaleShort",
      value: function _scaleShort(curve, invert) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_scaleMont",
      value: function _scaleMont(curve, invert) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_scaleEdwards",
      value: function _scaleEdwards(curve, invert) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isElliptic",
      value: function isElliptic() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "jinv",
      value: function jinv() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isComplete",
      value: function isComplete() {
        return false;
      }
    }, {
      key: "precompute",
      value: function precompute(rng) {
        assert$4(!this.g.isInfinity(), 'Must have base point.');
        assert$4(!this.n.isZero(), 'Must have order.');
        this.g.precompute(this.n.bitLength(), rng);
        return this;
      }
    }, {
      key: "scalar",
      value: function scalar(num, base, endian) {
        var k = new bnBrowser(num, base, endian);
        assert$4(!k.red);
        if (this.n.isZero()) return k;
        return k.imod(this.n);
      }
    }, {
      key: "field",
      value: function field(num, base, endian) {
        var x = bnBrowser.cast(num, base, endian);
        if (x.red) return x.forceRed(this.red);
        return x.toRed(this.red);
      }
    }, {
      key: "point",
      value: function point(x, y) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "jpoint",
      value: function jpoint(x, y, z) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "xpoint",
      value: function xpoint(x, z) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "cpoint",
      value: function cpoint(xx, xz, yy, yz) {
        assert$4(xx instanceof bnBrowser);
        assert$4(xz instanceof bnBrowser);
        assert$4(yy instanceof bnBrowser);
        assert$4(yz instanceof bnBrowser);
        if (xz.isZero() || yz.isZero()) return this.point();
        var z = xz.redMul(yz).redInvert();
        var x = xx.redMul(yz).redMul(z);
        var y = yy.redMul(xz).redMul(z);
        return this.point(x, y);
      }
    }, {
      key: "solveX2",
      value: function solveX2(y) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "solveX",
      value: function solveX(y) {
        return this.solveX2(y).redSqrt();
      }
    }, {
      key: "solveY2",
      value: function solveY2(x) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "solveY",
      value: function solveY(x) {
        return this.solveY2(x).redSqrt();
      }
    }, {
      key: "validate",
      value: function validate(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromX",
      value: function pointFromX(x, sign) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromY",
      value: function pointFromY(y, sign) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isIsomorphic",
      value: function isIsomorphic(curve) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isIsogenous",
      value: function isIsogenous(curve) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromShort",
      value: function pointFromShort(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromMont",
      value: function pointFromMont(point, sign) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromEdwards",
      value: function pointFromEdwards(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromUniform",
      value: function pointFromUniform(u) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointToUniform",
      value: function pointToUniform(p) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromHash",
      value: function pointFromHash(bytes) {
        var pake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        // [H2EC] "Roadmap".
        assert$4(Buffer.isBuffer(bytes));
        assert$4(typeof pake === 'boolean');
        if (bytes.length !== this.fieldSize * 2) throw new Error('Invalid hash size.'); // Random oracle encoding.
        // Ensure a proper distribution.

        var s1 = bytes.slice(0, this.fieldSize);
        var s2 = bytes.slice(this.fieldSize);
        var u1 = this.decodeUniform(s1);
        var u2 = this.decodeUniform(s2);
        var p1 = this.pointFromUniform(u1);
        var p2 = this.pointFromUniform(u2);
        var p3 = p1.uadd(p2);
        return pake ? p3.mulH() : p3;
      }
    }, {
      key: "pointToHash",
      value: function pointToHash(p, subgroup, rng) {
        // [SQUARED] Algorithm 1, Page 8, Section 3.3.
        assert$4(p instanceof this.Point);
        assert$4(subgroup >>> 0 === subgroup); // Add a random torsion component.

        var i = subgroup % this.torsion.length;
        var p0 = p.add(this.torsion[i]); // Average Cost (R = sqrt):
        //
        //   SSWU (~4 iterations) => 8I + 16R
        //   SVDW (~4 iterations) => 12I + 28R
        //   Elligator 1 (~2 iterations) => 6I + 10R
        //   Elligator 2 (~2 iterations) => 4I + 6R
        //   Ristretto (~1 iteration) => 1I + 2R + h*1R

        for (;;) {
          var u1 = this.randomField(rng);
          var p1 = this.pointFromUniform(u1); // Avoid 2-torsion points:
          //   Short Weierstrass: ((A / 3) / B, 0)
          //   Montgomery: (0, 0)
          //   Twisted Edwards: (0, -1)

          if (p1.neg().eq(p1)) continue;
          var p2 = p0.usub(p1);
          var hint = randomInt$1(rng);
          var u2 = void 0;

          try {
            u2 = this.pointToUniform(p2, hint & 15);
          } catch (e) {
            if (e.message === 'Invalid point.') continue;
            throw e;
          }

          var s1 = this.encodeUniform(u1, hint >>> 8);
          var s2 = this.encodeUniform(u2, hint >>> 16);
          return Buffer.concat([s1, s2]);
        }
      }
    }, {
      key: "randomScalar",
      value: function randomScalar(rng) {
        var max = this.n.isZero() ? this.p : this.n;
        return bnBrowser.random(rng, 1, max);
      }
    }, {
      key: "randomField",
      value: function randomField(rng) {
        return bnBrowser.random(rng, 1, this.p).toRed(this.red);
      }
    }, {
      key: "randomPoint",
      value: function randomPoint(rng) {
        var p;

        for (;;) {
          var x = this.randomField(rng);
          var sign = (randomInt$1(rng) & 1) !== 0;

          try {
            p = this.pointFromX(x, sign);
          } catch (e) {
            continue;
          }

          assert$4(p.validate());
          return p.mulH();
        }
      }
    }, {
      key: "mulAll",
      value: function mulAll(points, coeffs) {
        return this.jmulAll(points, coeffs);
      }
    }, {
      key: "mulAllSimple",
      value: function mulAllSimple(points, coeffs) {
        return this.jmulAllSimple(points, coeffs);
      }
    }, {
      key: "jmulAll",
      value: function jmulAll(points, coeffs) {
        assert$4(Array.isArray(points));
        assert$4(points.length === 0 || points[0] instanceof Point); // Multiply with endomorphism if we're using affine points.

        if (this.endo && points.length > 0 && points[0].type === types$1.AFFINE) return this._endoWnafMulAdd(points, coeffs); // Otherwise, a regular Shamir's trick.

        return this._wnafMulAdd(5, points, coeffs);
      }
    }, {
      key: "jmulAllSimple",
      value: function jmulAllSimple(points, coeffs) {
        return this._simpleMulAdd(points, coeffs);
      }
    }, {
      key: "mulH",
      value: function mulH(k) {
        assert$4(k instanceof bnBrowser);
        return this.imulH(k.clone());
      }
    }, {
      key: "imulH",
      value: function imulH(k) {
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red);
        var word = this.h.word(0); // Optimize for powers of two.

        if ((word & word - 1) === 0) {
          var bits = this.h.bitLength();
          return k.iushln(bits - 1).imod(this.n);
        }

        return k.imuln(word).imod(this.n);
      }
    }, {
      key: "clamp",
      value: function clamp(scalar) {
        // [RFC7748] Page 8, Section 5.
        // [RFC8032] Section 5.1.5 & 5.2.5.
        assert$4(Buffer.isBuffer(scalar));
        assert$4(scalar.length === this.scalarSize);
        assert$4(this.scalarSize <= this.fieldSize);
        var top = this.fieldBits & 7 || 8;
        var lsb = 0;
        var msb = this.scalarSize - 1; // Swap endianness.

        if (this.endian === 'be') {
          var _ref = [msb, lsb];
          lsb = _ref[0];
          msb = _ref[1];
        } // Adjust for low order.


        if (this.scalarSize < this.fieldSize) top = 8; // Ensure a multiple of the cofactor.

        scalar[lsb] &= -this.h.word(0) & 0xff; // Clamp to the prime.

        scalar[msb] &= (1 << top) - 1; // Set the high bit.

        scalar[msb] |= 1 << top - 1;
        return scalar;
      }
    }, {
      key: "splitHash",
      value: function splitHash(bytes) {
        // [RFC8032] Section 5.1.6 & 5.2.6.
        assert$4(Buffer.isBuffer(bytes));
        assert$4(bytes.length === this.adjustedSize * 2);
        assert$4(this.scalarSize <= this.adjustedSize);
        var off = 0;
        if (this.endian === 'be') off = this.adjustedSize - this.scalarSize;
        var scalar = bytes.slice(off, off + this.scalarSize);
        var prefix = bytes.slice(this.adjustedSize);
        this.clamp(scalar);
        return [scalar, prefix];
      }
    }, {
      key: "encodeField",
      value: function encodeField(x) {
        // [SEC1] Page 12, Section 2.3.5.
        assert$4(x instanceof bnBrowser);
        assert$4(!x.red);
        return x.encode(this.endian, this.fieldSize);
      }
    }, {
      key: "decodeField",
      value: function decodeField(bytes) {
        // [SEC1] Page 13, Section 2.3.6.
        assert$4(Buffer.isBuffer(bytes));
        if (bytes.length !== this.fieldSize) throw new Error('Invalid field element size.');
        return bnBrowser.decode(bytes, this.endian);
      }
    }, {
      key: "encodeAdjusted",
      value: function encodeAdjusted(x) {
        assert$4(x instanceof bnBrowser);
        assert$4(!x.red);
        return x.encode(this.endian, this.adjustedSize);
      }
    }, {
      key: "decodeAdjusted",
      value: function decodeAdjusted(bytes) {
        assert$4(Buffer.isBuffer(bytes));
        if (bytes.length !== this.adjustedSize) throw new Error('Invalid field element size.');
        return bnBrowser.decode(bytes, this.endian);
      }
    }, {
      key: "encodeScalar",
      value: function encodeScalar(k) {
        // [SEC1] Page 13, Section 2.3.7.
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red);
        return k.encode(this.endian, this.scalarSize);
      }
    }, {
      key: "decodeScalar",
      value: function decodeScalar(bytes) {
        // [SEC1] Page 14, Section 2.3.8.
        assert$4(Buffer.isBuffer(bytes));
        if (bytes.length !== this.scalarSize) throw new Error('Invalid scalar size.');
        return bnBrowser.decode(bytes, this.endian);
      }
    }, {
      key: "encodeClamped",
      value: function encodeClamped(k) {
        // [RFC7748] Page 8, Section 5.
        // [RFC8032] Section 5.1.5 & 5.2.5.
        return this.clamp(this.encodeScalar(k));
      }
    }, {
      key: "decodeClamped",
      value: function decodeClamped(bytes) {
        // [RFC7748] Page 8, Section 5.
        // [RFC8032] Section 5.1.5 & 5.2.5.
        assert$4(Buffer.isBuffer(bytes));
        if (bytes.length !== this.scalarSize) throw new Error('Invalid scalar size.');
        var clamped = this.clamp(Buffer.from(bytes));
        return bnBrowser.decode(clamped, this.endian);
      }
    }, {
      key: "encodeUniform",
      value: function encodeUniform(x, bits) {
        assert$4(x instanceof bnBrowser);
        assert$4(bits >>> 0 === bits);
        var msb = this.endian === 'le' ? this.fieldSize - 1 : 0;
        var bytes = x.fromRed().encode(this.endian, this.fieldSize);
        bytes[msb] |= bits & ~this.mask & 0xff;
        return bytes;
      }
    }, {
      key: "decodeUniform",
      value: function decodeUniform(bytes) {
        assert$4(Buffer.isBuffer(bytes));
        if (bytes.length !== this.fieldSize) throw new Error('Invalid field size.');
        var x = bnBrowser.decode(bytes, this.endian);
        x.iumaskn(this.fieldBits);
        return x.toRed(this.red);
      }
    }, {
      key: "encodePoint",
      value: function encodePoint(point, compact) {
        assert$4(point instanceof Point);
        return point.encode(compact);
      }
    }, {
      key: "decodePoint",
      value: function decodePoint(bytes) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "encodeX",
      value: function encodeX(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "decodeX",
      value: function decodeX(bytes) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "decodeEven",
      value: function decodeEven(bytes) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "decodeSquare",
      value: function decodeSquare(bytes) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "toShort",
      value: function toShort() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "toMont",
      value: function toMont(b0) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "toEdwards",
      value: function toEdwards(a0) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointToJSON",
      value: function pointToJSON(point, pre) {
        assert$4(point instanceof Point);
        return point.toJSON(pre);
      }
    }, {
      key: "pointFromJSON",
      value: function pointFromJSON(json) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        var prefix, context;
        var n, z, endo;

        if (this.type === 'edwards') {
          prefix = this.prefix ? this.prefix.toString() : null;
          context = this.context;
        }

        if (!this.n.isZero()) n = this.n.toJSON();

        if (!this.z.isZero()) {
          z = this.z.fromRed();
          if (this.z.redIsHigh()) z.isub(this.p);
          z = z.toString(16);
        }

        if (this.endo) endo = this.endo.toJSON();
        return {
          id: this.id,
          ossl: this.ossl,
          type: this.type,
          endian: this.endian,
          hash: this.hash,
          prefix: prefix,
          context: context,
          prime: this.prime,
          p: this.p.toJSON(),
          a: undefined,
          b: undefined,
          d: undefined,
          n: n,
          h: this.h.toString(16),
          s: undefined,
          z: z,
          c: undefined,
          g: this.g.toJSON(pre),
          endo: endo
        };
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(json) {
        return new this(json);
      }
    }]);

    return Curve;
  }();
  /**
   * Point
   */


  var Point = /*#__PURE__*/function () {
    function Point(curve, type) {
      _classCallCheck__default['default'](this, Point);

      assert$4(curve instanceof Curve);
      assert$4(type >>> 0 === type);
      this.curve = curve;
      this.type = type;
      this.pre = null;
    }

    _createClass__default['default'](Point, [{
      key: "_init",
      value: function _init() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "_getNAF",
      value: function _getNAF(width) {
        assert$4(width >>> 0 === width);
        if (this.pre && this.pre.naf) return this.pre.naf;
        if (width === 0) return null;
        var size = 1 << width - 2;
        var points = new Array(size);
        var dbl = size === 1 ? null : this.dbl();
        points[0] = this;

        for (var i = 1; i < size; i++) {
          points[i] = points[i - 1].add(dbl);
        }

        return new NAF(width, points);
      }
    }, {
      key: "_safeNAF",
      value: function _safeNAF(width) {
        return this._getNAF(width);
      }
    }, {
      key: "_getWindows",
      value: function _getWindows(width, bits) {
        assert$4(width >>> 0 === width);
        assert$4(bits >>> 0 === bits);
        if (this.pre && this.pre.windows) return this.pre.windows;
        if (width === 0) return null;
        var size = 1 << width;
        var steps = (bits + width - 1) / width >>> 0;
        var points = new Array(steps * size);
        var g = this.toP();

        for (var i = 0; i < steps; i++) {
          points[i * size] = this.curve.point();

          for (var j = 1; j < size; j++) {
            points[i * size + j] = points[i * size + j - 1].add(g);
          }

          g = g.dblp(width);
        }

        return new Windows(width, bits, points);
      }
    }, {
      key: "_getDoubles",
      value: function _getDoubles(step, power) {
        assert$4(step >>> 0 === step);
        assert$4(power >>> 0 === power);
        if (this.pre && this.pre.doubles) return this.pre.doubles;
        if (step === 0) return null;
        var len = Math.ceil(power / step) + 1;
        var points = new Array(len);
        var acc = this;
        var k = 0;
        points[k++] = acc;

        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++) {
            acc = acc.dbl();
          }

          points[k++] = acc;
        }

        assert$4(k === len);
        return new Doubles(step, points);
      }
    }, {
      key: "_getBeta",
      value: function _getBeta() {
        return null;
      }
    }, {
      key: "_getBlinding",
      value: function _getBlinding(rng) {
        if (this.pre && this.pre.blinding) return this.pre.blinding;
        if (!rng) return null;
        if (this.curve.n.isZero()) return null; // Pregenerate a random blinding value:
        //
        //   blind = random integer in [1,n-1]
        //   unblind = G * blind
        //
        // We intend to subtract the blinding value
        // from scalars before multiplication. We
        // can add the unblinding point once the
        // multiplication is complete.

        var blind = this.curve.randomScalar(rng);
        var unblind = this.mul(blind);
        return new Blinding(blind, unblind);
      }
    }, {
      key: "_hasWindows",
      value: function _hasWindows(k) {
        assert$4(k instanceof bnBrowser);
        if (!this.pre || !this.pre.windows) return false;
        var bits = this.pre.windows.bits;
        return bits >= k.bitLength();
      }
    }, {
      key: "_hasDoubles",
      value: function _hasDoubles(k) {
        assert$4(k instanceof bnBrowser);
        if (!this.pre || !this.pre.doubles) return false;
        var _this$pre$doubles = this.pre.doubles,
            step = _this$pre$doubles.step,
            points = _this$pre$doubles.points;
        var power = k.bitLength() + 1;
        return points.length >= Math.ceil(power / step) + 1;
      }
    }, {
      key: "_getJNAF",
      value: function _getJNAF(point) {
        assert$4(point instanceof Point);
        assert$4(point.type === this.type); // Create comb for JSF.

        return [this, // 1
        this.add(point), // 3
        this.sub(point), // 5
        point // 7
        ];
      }
    }, {
      key: "_blind",
      value: function _blind(k, rng) {
        // [SIDE1] Page 5, Section 4.
        // [BLIND] Page 20, Section 7.
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red); // Scalar splitting (requires precomputation).
        //
        // Blind a multiplication by first subtracting
        // a blinding value from the scalar. Example:
        //
        //   b = random integer in [1,n-1]
        //   B = P * b (precomputed)
        //   Q = P * (k - b) + B
        //
        // Note that Joye describes a different method
        // (multiplier randomization) which computes:
        //
        //   B = random point in E
        //   Q = (P + B) * k - B * k
        //
        // Our method is more similar to the "scalar
        // splitting" technique described in the
        // second source above.
        //
        // The blinding value and its corresponding
        // point are randomly generated and computed
        // on boot. As long as an attacker is not
        // able to observe the boot, this should give
        // a decent bit of protection against various
        // channel attacks.

        if (this.pre && this.pre.blinding) {
          var _this$pre$blinding = this.pre.blinding,
              blind = _this$pre$blinding.blind,
              unblind = _this$pre$blinding.unblind;
          var t = k.sub(blind);
          return [this, t, unblind];
        } // Randomization is not possible without
        // an RNG. Do a normal multiplication.


        if (!rng) return [this, k, null]; // If we have no precomputed blinding
        // factor, there are two possibilities
        // for randomization:
        //
        // 1. Randomize the multiplier by adding
        //    a random multiple of `n`.
        //
        // 2. Re-scale the point itself by a
        //    random factor.
        //
        // The first option can be accomplished
        // with some like:
        //
        //   a = random integer in [1,n-1]
        //   r = a * n
        //   Q = P * (k + r)
        //
        // The second is accomplished with:
        //
        //   a = random element in F(p)
        //   R = (x * a^2, y * a^3, z * a)
        //   Q = R * k
        //
        // If we have precomputed doubles / naf
        // points, we opt for the first method
        // to avoid randomizing everything.

        if (this.pre) {
          if (this.curve.n.isZero()) return [this, k, null];
          var a = this.curve.randomScalar(rng);
          var r = a.mul(this.curve.n);

          var _t = r.iadd(k);

          return [this, _t, null];
        } // If there is no precomputation _at all_,
        // we opt for the second method.


        var p = this.randomize(rng);
        return [p, k, null];
      }
    }, {
      key: "clone",
      value: function clone() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "swap",
      value: function swap(point, flag) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "precompute",
      value: function precompute(bits, rng) {
        assert$4(bits >>> 0 === bits);
        if (!this.pre) this.pre = new Precomp();
        if (!this.pre.naf) this.pre.naf = this._getNAF(9);
        if (!this.pre.doubles) this.pre.doubles = this._getDoubles(4, bits + 1);
        if (!this.pre.beta) this.pre.beta = this._getBeta();
        if (!this.pre.blinding) this.pre.blinding = this._getBlinding(rng);
        return this;
      }
    }, {
      key: "validate",
      value: function validate() {
        return this.curve.validate(this);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        return this;
      }
    }, {
      key: "scale",
      value: function scale(a) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "randomize",
      value: function randomize(rng) {
        var z = this.curve.randomField(rng);
        return this.scale(z);
      }
    }, {
      key: "neg",
      value: function neg() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "add",
      value: function add(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "sub",
      value: function sub(point) {
        assert$4(point instanceof Point);
        return this.add(point.neg());
      }
    }, {
      key: "dbl",
      value: function dbl() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "dblp",
      value: function dblp(pow) {
        // Repeated doubling. This can
        // be optimized by child classes.
        assert$4(pow >>> 0 === pow);
        var r = this;

        for (var i = 0; i < pow; i++) {
          r = r.dbl();
        }

        return r;
      }
    }, {
      key: "uadd",
      value: function uadd(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "usub",
      value: function usub(point) {
        assert$4(point instanceof Point);
        return this.uadd(point.neg());
      }
    }, {
      key: "udbl",
      value: function udbl() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "zaddu",
      value: function zaddu(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "zaddc",
      value: function zaddc(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "zdblu",
      value: function zdblu() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "diffAdd",
      value: function diffAdd(p, q) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "diffAddDbl",
      value: function diffAddDbl(p, q) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "recover",
      value: function recover() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "getX",
      value: function getX() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "getY",
      value: function getY() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "eq",
      value: function eq(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "cmp",
      value: function cmp(point) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isInfinity",
      value: function isInfinity() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isOrder2",
      value: function isOrder2() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isOdd",
      value: function isOdd() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isEven",
      value: function isEven() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isSquare",
      value: function isSquare() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "eqX",
      value: function eqX(x) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "eqR",
      value: function eqR(x) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "isSmall",
      value: function isSmall() {
        // Test whether the point is of small order.
        if (this.isInfinity()) return false; // P * h = O

        return this.jmulH().isInfinity();
      }
    }, {
      key: "hasTorsion",
      value: function hasTorsion() {
        // Test whether the point is in another subgroup.
        if (this.isInfinity()) return false; // P * n != O

        return !this.jmul(this.curve.n).isInfinity();
      }
    }, {
      key: "order",
      value: function order() {
        // Calculate point order.
        var _this$curve = this.curve,
            h = _this$curve.h,
            n = _this$curve.n;
        var p = this.toJ();
        var q = new bnBrowser(1);

        while (!p.isInfinity()) {
          q.iaddn(1);

          if (q.cmp(h) > 0) {
            q = n.clone();
            break;
          }

          p = p.add(this);
        }

        return q;
      }
    }, {
      key: "mul",
      value: function mul(k) {
        return this.jmul(k);
      }
    }, {
      key: "muln",
      value: function muln(k) {
        return this.jmuln(k);
      }
    }, {
      key: "mulSimple",
      value: function mulSimple(k) {
        return this.jmulSimple(k);
      }
    }, {
      key: "mulBlind",
      value: function mulBlind(k, rng) {
        return this.jmulBlind(k, rng);
      }
    }, {
      key: "mulConst",
      value: function mulConst(k, rng) {
        return this.jmulConst(k, rng);
      }
    }, {
      key: "mulAdd",
      value: function mulAdd(k1, p2, k2) {
        return this.jmulAdd(k1, p2, k2);
      }
    }, {
      key: "mulAddSimple",
      value: function mulAddSimple(k1, p2, k2) {
        return this.jmulAddSimple(k1, p2, k2);
      }
    }, {
      key: "mulH",
      value: function mulH() {
        return this.jmulH();
      }
    }, {
      key: "div",
      value: function div(k) {
        return this.jdiv(k);
      }
    }, {
      key: "divn",
      value: function divn(k) {
        return this.jdivn(k);
      }
    }, {
      key: "divH",
      value: function divH() {
        return this.jdivH();
      }
    }, {
      key: "jmul",
      value: function jmul(k) {
        if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
        if (this.curve.endo && this.type === types$1.AFFINE) return this.curve._endoWnafMulAdd([this], [k]);
        return this.curve._wnafMul(5, this, k);
      }
    }, {
      key: "jmuln",
      value: function jmuln(k) {
        assert$4((k | 0) === k);
        return this.jmulSimple(new bnBrowser(k));
      }
    }, {
      key: "jmulSimple",
      value: function jmulSimple(k) {
        return this.curve._simpleMul(this, k);
      }
    }, {
      key: "jmulBlind",
      value: function jmulBlind(k) {
        var rng = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var _this$_blind = this._blind(k, rng),
            _this$_blind2 = _slicedToArray__default['default'](_this$_blind, 3),
            p = _this$_blind2[0],
            t = _this$_blind2[1],
            unblind = _this$_blind2[2];

        var q = p.jmul(t);
        if (unblind) return q.add(unblind);
        return q;
      }
    }, {
      key: "jmulConst",
      value: function jmulConst(k) {
        var rng = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var _this$_blind3 = this._blind(k, rng),
            _this$_blind4 = _slicedToArray__default['default'](_this$_blind3, 3),
            p = _this$_blind4[0],
            t = _this$_blind4[1],
            unblind = _this$_blind4[2];

        var q = this.curve._constMul(p, t, rng);

        if (unblind) return q.uadd(unblind);
        return q;
      }
    }, {
      key: "jmulAdd",
      value: function jmulAdd(k1, p2, k2) {
        if (this.curve.endo && this.type === types$1.AFFINE) return this.curve._endoWnafMulAdd([this, p2], [k1, k2]);
        return this.curve._wnafMulAdd(5, [this, p2], [k1, k2]);
      }
    }, {
      key: "jmulAddSimple",
      value: function jmulAddSimple(k1, p2, k2) {
        return this.curve._simpleMulAdd([this, p2], [k1, k2]);
      }
    }, {
      key: "jmulH",
      value: function jmulH() {
        var word = this.curve.h.word(0); // Optimize for powers of two.

        if ((word & word - 1) === 0) {
          var bits = this.curve.h.bitLength();
          return this.toJ().dblp(bits - 1);
        }

        return this.jmulSimple(this.curve.h);
      }
    }, {
      key: "jdiv",
      value: function jdiv(k) {
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red);
        return this.jmul(k.invert(this.curve.n));
      }
    }, {
      key: "jdivn",
      value: function jdivn(k) {
        assert$4(!this.curve.n.isZero());
        if (this.curve.h.cmpn(k) === 0) return this.jdivH();
        return this.jdiv(new bnBrowser(k));
      }
    }, {
      key: "jdivH",
      value: function jdivH() {
        if (this.curve.n.isZero()) return this.toJ();
        if (this.curve.h.cmpn(1) === 0) return this.toJ();
        if (this.curve.hi === null) this.curve.hi = this.curve.h.invert(this.curve.n);
        return this.jmul(this.curve.hi);
      }
    }, {
      key: "ladder",
      value: function ladder(k) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "ladderSimple",
      value: function ladderSimple(k) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "ladderBlind",
      value: function ladderBlind(k, rng) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "ladderConst",
      value: function ladderConst(k, rng) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "toP",
      value: function toP() {
        return this.normalize();
      }
    }, {
      key: "toJ",
      value: function toJ() {
        return this;
      }
    }, {
      key: "toX",
      value: function toX() {
        return this;
      }
    }, {
      key: "key",
      value: function key() {
        if (this.isInfinity()) return "".concat(this.curve.uid, ":oo");
        this.normalize();
        var x = this.getX().toString(16);
        var y = this.getY().toString(16);
        return "".concat(this.curve.uid, ":").concat(x, ",").concat(y);
      }
    }, {
      key: "encode",
      value: function encode(compact) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "encodeX",
      value: function encodeX() {
        throw new Error('Not implemented.');
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        throw new Error('Not implemented.');
      }
    }, {
      key: custom$2,
      value: function value() {
        return '<Point>';
      }
    }], [{
      key: "decode",
      value: function decode(curve, bytes) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "decodeX",
      value: function decodeX(curve, bytes) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "decodeEven",
      value: function decodeEven(curve, bytes) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "decodeSquare",
      value: function decodeSquare(curve, bytes) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(curve, json) {
        throw new Error('Not implemented.');
      }
    }]);

    return Point;
  }();
  /**
   * ShortCurve
   */


  var ShortCurve = /*#__PURE__*/function (_Curve) {
    _inherits__default['default'](ShortCurve, _Curve);

    var _super = _createSuper$c(ShortCurve);

    function ShortCurve(conf) {
      var _this;

      _classCallCheck__default['default'](this, ShortCurve);

      _this = _super.call(this, ShortPoint, 'short', conf);
      _this.a = bnBrowser.fromJSON(conf.a).toRed(_this.red);
      _this.b = bnBrowser.fromJSON(conf.b).toRed(_this.red);
      _this.c = bnBrowser.fromJSON(conf.c || '0').toRed(_this.red);
      _this.ai = _this.a.isZero() ? _this.zero : _this.a.redInvert();
      _this.zi = _this.z.isZero() ? _this.zero : _this.z.redInvert();
      _this.zeroA = _this.a.isZero();
      _this.threeA = _this.a.eq(_this.three.redNeg());
      _this.redN = _this.n.toRed(_this.red);
      _this.pmodn = _this.p.clone();
      _this.highOrder = _this.n.cmp(_this.p) >= 0;
      _this.smallGap = false;

      _this._finalize(conf);

      return _this;
    }

    _createClass__default['default'](ShortCurve, [{
      key: "_finalize",
      value: function _finalize(conf) {
        _get__default['default'](_getPrototypeOf__default['default'](ShortCurve.prototype), "_finalize", this).call(this, conf); // Precalculate endomorphism.


        if (conf.endo != null) this.endo = Endo.fromJSON(this, conf.endo);else this.endo = this._getEndomorphism();

        if (!this.n.isZero()) {
          this.pmodn = this.p.mod(this.n); // Check for Maxwell's trick (see eqR).

          this.smallGap = this.p.div(this.n).cmpn(1) <= 0;
        }

        return this;
      }
    }, {
      key: "_short",
      value: function _short(a0, odd) {
        return ShortCurve._isomorphism(this.a, this.b, a0, odd);
      }
    }, {
      key: "_mont",
      value: function _mont(b0, odd) {
        // Short Weierstrass->Montgomery Equivalence.
        //
        // [ARITH1] Page 286, Section 13.2.3.c.
        // [SAFE] "Ladders".
        //
        // Transformation:
        //
        //   r = A / (3 * B)
        //   s = +-sqrt(3 * r^2 + a)
        //   A = 3 * r / s
        //   B = 1 / s
        var _this$_findRS = this._findRS(odd),
            _this$_findRS2 = _slicedToArray__default['default'](_this$_findRS, 2),
            r = _this$_findRS2[0],
            s = _this$_findRS2[1];

        var b = s.redInvert();
        var a = r.redMuln(3).redMul(b);
        if (b0 != null) return MontCurve._isomorphism(a, b, b0);
        return [a, b];
      }
    }, {
      key: "_edwards",
      value: function _edwards(a0, odd) {
        // Short Weierstrass->Twisted Edwards Equivalence.
        //
        // [TWISTEQ] Section 1.
        //
        // Transformation:
        //
        //   r = (a' + d') / 6
        //   s = +-sqrt(3 * r^2 + a)
        //   a' = 3 * r + 2 * s
        //   d' = 3 * r - 2 * s
        var _this$_findRS3 = this._findRS(odd),
            _this$_findRS4 = _slicedToArray__default['default'](_this$_findRS3, 2),
            r = _this$_findRS4[0],
            s = _this$_findRS4[1];

        var r3 = r.redMuln(3);
        var s2 = s.redMuln(2);
        var a = r3.redAdd(s2);
        var d = r3.redSub(s2);
        if (a0 != null) return EdwardsCurve._isomorphism(a, d, a0);
        return [a, d];
      }
    }, {
      key: "_findRS",
      value: function _findRS(sign) {
        // Find `r` and `s` for equivalence.
        //
        // [ARITH1] Page 286, Section 13.2.3.c.
        // [SAFE] "Ladders".
        //
        // Computation:
        //
        //   r = solve(r^3 + a * r + b == 0, r)
        //   s = +-sqrt(3 * r^2 + a)
        //
        // Computing `r` is non-trivial. We need
        // to solve `r^3 + a * r + b = 0`, but we
        // don't have a polynomial solver, so we
        // loop over random points until we find
        // one with 2-torsion. Multiplying by the
        // subgroup order should yield a point of
        // ((A / 3) / B, 0) which is a solution.
        assert$4(sign == null || typeof sign === 'boolean');
        assert$4(this.h.word(0) >= 4);
        assert$4(!this.n.isZero());
        var x = this.one.redNeg();
        var p;

        for (;;) {
          x.redIAdd(this.one);

          try {
            p = this.pointFromX(x.clone());
          } catch (e) {
            continue;
          }

          p = p.mul(this.n);
          if (p.isInfinity()) continue;
          if (!p.y.isZero()) continue;
          break;
        }

        var r = p.x;
        var r2 = r.redSqr();
        var s = r2.redMuln(3).redIAdd(this.a).redSqrt();

        if (sign != null) {
          if (s.redIsOdd() !== sign) s.redINeg();
        }

        return [r, s];
      }
    }, {
      key: "_scale0",
      value: function _scale0(a, b) {
        // We can extract the isomorphism factors with:
        //
        //   u4 = a' / a
        //   u6 = b' / b
        //   u2 = +-sqrt(u4)
        //   u = +-sqrt(u2)
        //   u3 = u2 * u
        //
        // `u2` should be picked such that `u4 * u2 = u6`.
        //
        // If a = 0, we can do:
        //
        //   u6 = b' / b
        //   u2 = u6^(1 / 3)
        //   u = +-sqrt(u2)
        //   u3 = u2 * u
        //
        // Where `u2` is any root that is square.
        //
        // If b = 0, we can do:
        //
        //   u4 = a' / a
        //   u2 = +-sqrt(u4)
        //   u = +-sqrt(u2)
        //   u3 = u2 * u
        //
        // Where `u2` is any root that is square.
        assert$4(this.a.isZero() === a.isZero());
        assert$4(this.b.isZero() === b.isZero());

        if (this.a.isZero()) {
          var _u = this.b.redDiv(this.field(b)); // Todo: figure out how to check index.


          var _u2 = uncube(_u);

          var _u3 = _u2.redSqrt();

          var _u4 = _u2.redMul(_u3);

          assert$4(_u4.redSqr().eq(_u));
          assert$4(!_u3.isZero());
          return [_u2, _u4];
        }

        if (this.b.isZero()) {
          var _u5 = this.a.redDiv(this.field(a));

          var _u6 = _u5.redSqrt(); // Todo: figure out how to check oddness.


          if (_u6.redJacobi() !== 1) _u6.redINeg();

          var _u7 = _u6.redSqrt();

          var _u8 = _u6.redMul(_u7);

          assert$4(_u8.redMul(_u7).eq(_u5));
          assert$4(!_u7.isZero());
          return [_u6, _u8];
        }

        var u4 = this.a.redDiv(this.field(a));
        var u6 = this.b.redDiv(this.field(b));
        var u2 = u4.redSqrt();
        if (!u4.redMul(u2).eq(u6)) u2.redINeg();
        assert$4(u4.redMul(u2).eq(u6));
        var u = u2.redSqrt();
        var u3 = u2.redMul(u);
        assert$4(!u.isZero());
        return [u2, u3];
      }
    }, {
      key: "_scale1",
      value: function _scale1(x, y) {
        // If base points are available, it is much
        // easier, with:
        //
        //   u2 = x' / x
        //   u3 = y' / y
        //   u = +-sqrt(u2)
        //
        // `u` should be picked such that `u2 * u = u3`.
        var u2 = this.g.x.redDiv(this.field(x));
        var u3 = this.g.y.redDiv(this.field(y));
        var u = u2.redSqrt();
        if (!u2.redMul(u).eq(u3)) u.redINeg();
        assert$4(u2.redMul(u).eq(u3));
        assert$4(!u.isZero());
        return [u2, u3];
      }
    }, {
      key: "_scaleShort",
      value: function _scaleShort(curve) {
        assert$4(curve instanceof ShortCurve);
        if (this.g.isInfinity() || curve.g.isInfinity()) return this._scale0(curve.a, curve.b);
        return this._scale1(curve.g.x, curve.g.y);
      }
    }, {
      key: "_scaleMont",
      value: function _scaleMont(curve) {
        assert$4(curve instanceof MontCurve);

        if (this.g.isInfinity() || curve.g.isInfinity()) {
          var _curve$_short = curve._short(),
              _curve$_short2 = _slicedToArray__default['default'](_curve$_short, 2),
              a = _curve$_short2[0],
              b = _curve$_short2[1];

          return this._scale0(a, b);
        }

        var _curve$g = curve.g,
            x = _curve$g.x,
            y = _curve$g.y;
        var nx = x.redAdd(curve.a3).redMul(curve.bi);
        var ny = y.redMul(curve.bi);
        return this._scale1(nx, ny);
      }
    }, {
      key: "_scaleEdwards",
      value: function _scaleEdwards(curve) {
        assert$4(curve instanceof EdwardsCurve);

        if (this.g.isInfinity() || curve.g.isInfinity()) {
          var _curve$_short3 = curve._short(),
              _curve$_short4 = _slicedToArray__default['default'](_curve$_short3, 2),
              a = _curve$_short4[0],
              b = _curve$_short4[1];

          return this._scale0(a, b);
        }

        var _curve$g2 = curve.g,
            x = _curve$g2.x,
            y = _curve$g2.y,
            z = _curve$g2.z;
        var a5 = curve.a.redMuln(5);
        var d5 = curve.d.redMuln(5);
        var dma = curve.d.redSub(curve.a);
        var d5a = d5.redSub(curve.a);
        var da5 = curve.d.redSub(a5);
        var ypz = y.redAdd(z);
        var ymz = y.redSub(z);
        var xx = d5a.redMul(y).redIAdd(da5.redMul(z));
        var xz = ymz.redMuln(12);
        var yy = dma.redMul(ypz).redMul(z);
        var yz = ymz.redMul(x).redIMuln(4);
        var zi = xz.redMul(yz).redInvert();
        var nx = xx.redMul(yz).redMul(zi);
        var ny = yy.redMul(xz).redMul(zi);
        return this._scale1(nx, ny);
      }
    }, {
      key: "_getEndomorphism",
      value: function _getEndomorphism() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        // Compute endomorphism.
        //
        // [GECC] Example 3.76, Page 128, Section 3.5.
        // No curve params.
        if (this.n.isZero() || this.g.isInfinity()) return null; // No efficient endomorphism.

        if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1) return null; // Solve beta^3 mod p = 1.

        var _this$_getEndoRoots = this._getEndoRoots(this.p),
            _this$_getEndoRoots2 = _slicedToArray__default['default'](_this$_getEndoRoots, 2),
            b1 = _this$_getEndoRoots2[0],
            b2 = _this$_getEndoRoots2[1]; // Choose the smallest beta by default.


        var beta = [b1, b2][index & 1].toRed(this.red); // Solve lambda^3 mod n = 1.

        var _this$_getEndoRoots3 = this._getEndoRoots(this.n),
            _this$_getEndoRoots4 = _slicedToArray__default['default'](_this$_getEndoRoots3, 2),
            l1 = _this$_getEndoRoots4[0],
            l2 = _this$_getEndoRoots4[1]; // Choose the lambda matching selected beta.
        // Note that P * lambda = (x * beta, y).


        var p = this.point(this.g.x.redMul(beta), this.g.y);
        var lambda;

        if (this.g.mul(l1).eq(p)) {
          lambda = l1;
        } else {
          assert$4(this.g.mul(l2).eq(p));
          lambda = l2;
        } // Get basis vectors.


        var basis = this._getEndoBasis(lambda); // Precompute `g1` and `g2`.


        var pre = this._getEndoPrecomp(basis);

        return new Endo(beta, lambda, basis, pre);
      }
    }, {
      key: "_getEndoRoots",
      value: function _getEndoRoots(num) {
        // Find roots for x^2 + x + 1 in F.
        //
        // [GECC] Example 3.76, Page 128, Section 3.5.
        // [GLV] Page 192, Section 2 (Endomorphisms).
        //
        // The above document doesn't fully explain how
        // to derive these and only "hints" at it, as
        // mentioned by Hal Finney[1], but we're basically
        // computing two possible cube roots of 1 here.
        //
        // Note that we could also compute[2]:
        //
        //   beta = 2^((p - 1) / 3) mod p
        //   lambda = 3^((n - 1) / 3) mod n
        //
        // As an extension of Fermat's little theorem:
        //
        //   g^(p - 1) mod p == 1
        //
        // It is suspected[3] this is how Hal Finney[4]
        // computed his original endomorphism roots.
        //
        // @indutny's method for computing cube roots
        // of unity[5] appears to be the method described
        // on wikipedia[6][7].
        //
        // Sage produces the same solution:
        //
        //   sage: solve(x^2 + x + 1 == 0, x)
        //   [x == -1/2*I*sqrt(3) - 1/2, x == 1/2*I*sqrt(3) - 1/2]
        //
        // This can be reduced to:
        //
        //   x = (+-sqrt(-3) - 1) / 2
        //
        // [1] https://bitcointalk.org/index.php?topic=3238.msg45565#msg45565
        // [2] https://crypto.stackexchange.com/a/22739
        // [3] https://bitcoin.stackexchange.com/a/35872
        // [4] https://github.com/halfinney/bitcoin/commit/dc411b5
        // [5] https://en.wikipedia.org/wiki/Cube_root_of_unity
        // [6] https://en.wikipedia.org/wiki/Splitting_field#Cubic_example
        // [7] http://mathworld.wolfram.com/SplittingField.html
        var red = num === this.p ? this.red : bnBrowser.mont(num);
        var two = new bnBrowser(2).toRed(red);
        var three = new bnBrowser(3).toRed(red);
        var i2 = two.redInvert(); // S1 = sqrt(-3) / 2

        var s1 = three.redNeg().redSqrt().redMul(i2); // S2 = -S1

        var s2 = s1.redNeg(); // R1 = S1 - 1 / 2

        var r1 = s1.redSub(i2).fromRed(); // R2 = S2 - 1 / 2

        var r2 = s2.redSub(i2).fromRed();
        return [r1, r2].sort(bnBrowser.cmp);
      }
    }, {
      key: "_getEndoBasis",
      value: function _getEndoBasis(lambda) {
        // Compute endomorphic basis.
        //
        // This essentially computes Cornacchia's algorithm
        // for solving x^2 + d * y^2 = m (d = lambda, m = order).
        //
        // https://en.wikipedia.org/wiki/Cornacchia%27s_algorithm
        //
        // [GECC] Algorithm 3.74, Page 127, Section 3.5.
        // [GLV] Page 196, Section 4 (Decomposing K).
        //
        // Balanced length-two representation of a multiplier.
        //
        // 1. Run the extended euclidean algorithm with inputs n
        //    and lambda. The algorithm produces a sequence of
        //    equations si*n + ti*lam = ri where s0=1, t0=0,
        //    r0=n, s1=0, t1=1, r1=lam, and the remainders ri
        //    and are non-negative and strictly decreasing. Let
        //    l be the greatest index for which rl >= sqrt(n).
        var _this$_egcdSqrt = this._egcdSqrt(lambda),
            _this$_egcdSqrt2 = _slicedToArray__default['default'](_this$_egcdSqrt, 6),
            rl = _this$_egcdSqrt2[0],
            tl = _this$_egcdSqrt2[1],
            rl1 = _this$_egcdSqrt2[2],
            tl1 = _this$_egcdSqrt2[3],
            rl2 = _this$_egcdSqrt2[4],
            tl2 = _this$_egcdSqrt2[5]; // 2. Set (a1, b1) <- (rl+1, -tl+1).


        var a1 = rl1;
        var b1 = tl1.neg(); // 3. If (rl^2 + tl^2) <= (rl+2^2 + tl+2^2)
        //    then set (a2, b2) <- (rl, -tl).
        //    else set (a2, b2) <- (rl+2, -tl+2).

        var lhs = rl.sqr().iadd(tl.sqr());
        var rhs = rl2.sqr().iadd(tl2.sqr());
        var a2, b2;

        if (lhs.cmp(rhs) <= 0) {
          a2 = rl;
          b2 = tl.neg();
        } else {
          a2 = rl2;
          b2 = tl2.neg();
        }

        return [new Vector(a1, b1), new Vector(a2, b2)];
      }
    }, {
      key: "_egcdSqrt",
      value: function _egcdSqrt(lambda) {
        // Extended Euclidean algorithm for integers.
        //
        // [GECC] Algorithm 2.19, Page 40, Section 2.2.
        // [GLV] Page 196, Section 4 (Decomposing K).
        assert$4(lambda instanceof bnBrowser);
        assert$4(!lambda.red);
        assert$4(lambda.sign() > 0);
        assert$4(this.n.sign() > 0); // Note that we insert the approximate square
        // root checks as described in algorithm 3.74.
        //
        // Algorithm 2.19 is defined as:
        //
        // 1. u <- a
        //    v <- b
        //
        // 2. x1 <- 1
        //    y1 <- 0
        //    x2 <- 0
        //    y2 <- 1
        //
        // 3. while u != 0 do
        //
        // 3.1. q <- floor(v / u)
        //      r <- v - q * u
        //      x <- x2 - q * x1
        //      y <- y2 - q * y1
        //
        // 3.2. v <- u
        //      u <- r
        //      x2 <- x1
        //      x1 <- x
        //      y2 <- y1
        //      y1 <- y
        //
        // 4. d <- v
        //    x <- x2
        //    y <- y2
        //
        // 5. Return (d, x, y).
        // Start with an approximate square root of n.

        var sqrtn = this.n.ushrn(this.n.bitLength() >>> 1);
        var u = lambda; // r1

        var v = this.n.clone(); // r0

        var x1 = new bnBrowser(1); // t1

        var y1 = new bnBrowser(0); // t0

        var x2 = new bnBrowser(0); // s1

        var y2 = new bnBrowser(1); // s0
        // All vectors are roots of: a + b * lambda = 0 (mod n).

        var rl, tl; // First vector.

        var rl1, tl1; // Inner.

        var i = 0;
        var j = 0;
        var p; // Compute EGCD.

        while (!u.isZero() && i < 2) {
          var q = v.quo(u);
          var r = v.sub(q.mul(u));
          var x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1)); // Check for r < sqrt(n).

          if (j === 0 && r.cmp(sqrtn) < 0) {
            rl = p;
            tl = x1;
            rl1 = r;
            tl1 = x;
            j = 1; // 1 more round.
          }

          p = r;
          v = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
          i += j;
        } // Should never happen.


        assert$4(j !== 0, 'Could not find r < sqrt(n).'); // Second vector.

        var rl2 = x2;
        var tl2 = x1;
        return [rl, tl, rl1, tl1, rl2, tl2];
      }
    }, {
      key: "_getEndoPrecomp",
      value: function _getEndoPrecomp(basis) {
        // Precompute `g1` and `g2` to avoid round division.
        //
        // [JCEN12] Page 5, Section 4.3.
        //
        // Computation:
        //
        //   d = a1 * b2 - b1 * a2
        //   t = ceil(log2(d+1)) + 16
        //   g1 = round((2^t * b2) / d)
        //   g2 = round((2^t * b1) / d)
        //
        // Where `d` is equal to `n`.
        //
        // As far as `t` goes, the paper above adds 2,
        // whereas libsecp256k1 adds 16 (a total of 272).
        assert$4(Array.isArray(basis));
        assert$4(basis.length === 2);
        assert$4(basis[0] instanceof Vector);
        assert$4(basis[1] instanceof Vector);

        var _basis = _slicedToArray__default['default'](basis, 2),
            v1 = _basis[0],
            v2 = _basis[1];

        var d = v1.a.mul(v2.b).isub(v1.b.mul(v2.a));
        var shift = d.bitLength() + 16;
        var pow = bnBrowser.shift(1, shift);
        var g1 = pow.mul(v2.b).divRound(d);
        var g2 = pow.mul(v1.b).divRound(d);
        assert$4(d.eq(this.n));
        return [g1, g2];
      }
    }, {
      key: "_endoSplit",
      value: function _endoSplit(k) {
        // Balanced length-two representation of a multiplier.
        //
        // [GECC] Algorithm 3.74, Page 127, Section 3.5.
        //
        // Also note that it is possible to precompute[1]
        // values in order to avoid the division[2][3][4].
        //
        // This involves precomputing `g1` and `g2 (see
        // above). `c1` and `c2` can then be computed as
        // follows:
        //
        //   t = ceil(log2(n+1)) + 16
        //   c1 = (k * g1) >> t
        //   c2 = -((k * g2) >> t)
        //
        // Where `>>` is an _unsigned_ right shift. Also
        // note that the last bit discarded in the shift
        // must be stored. If it is 1, then add 1 to the
        // scalar (absolute addition).
        //
        // It's worth noting that libsecp256k1 uses a
        // different calculation along the lines of:
        //
        //   t = ceil(log2(n+1)) + 16
        //   c1 = ((k * g1) >> t) * -b1
        //   c2 = ((k * -g2) >> t) * -b2
        //   k2 = c1 + c2
        //   k1 = k2 * -lambda + k
        //
        // So, in the future, we can consider changing
        // step 4 to:
        //
        //   4. Compute c1 = (k * g1) >> t
        //          and c2 = -((k * g2) >> t).
        //
        //   const shift = this.scalarBits + 16;
        //   const [g1, g2] = this.endo.pre;
        //   const c1 = k.mulShift(g1, shift);
        //   const c2 = k.mulShift(g2, shift).ineg();
        //
        // Once we're brave enough, that is.
        //
        // [1] [JCEN12] Page 5, Section 4.3.
        // [2] https://github.com/bitcoin-core/secp256k1/blob/0b70241/src/scalar_impl.h#L259
        // [3] https://github.com/bitcoin-core/secp256k1/pull/21
        // [4] https://github.com/bitcoin-core/secp256k1/pull/127
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red);
        assert$4(!this.n.isZero());

        var _this$endo$basis = _slicedToArray__default['default'](this.endo.basis, 2),
            v1 = _this$endo$basis[0],
            v2 = _this$endo$basis[1]; // 4. Compute c1 = round(b2 * k / n)
        //        and c2 = round(-b1 * k / n).


        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n); // 5. Compute k1 = k - c1 * a1 - c2 * a2
        //        and k2 = -c1 * b1 - c2 * b2.

        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.ineg().mul(v1.b);
        var q2 = c2.mul(v2.b); // Calculate answer.

        var k1 = k.sub(p1).isub(p2);
        var k2 = q1.isub(q2); // 6. Return (k1, k2).

        return [k1, k2];
      }
    }, {
      key: "_endoBeta",
      value: function _endoBeta(point) {
        assert$4(point instanceof ShortPoint);
        return [point, point._getBeta()];
      }
    }, {
      key: "_endoWnafMulAdd",
      value: function _endoWnafMulAdd(points, coeffs) {
        // Point multiplication with efficiently computable endomorphisms.
        //
        // [GECC] Algorithm 3.77, Page 129, Section 3.5.
        // [GLV] Page 193, Section 3 (Using Efficient Endomorphisms).
        //
        // Note it may be possible to do this 4-dimensionally [4GLV].
        assert$4(Array.isArray(points));
        assert$4(Array.isArray(coeffs));
        assert$4(points.length === coeffs.length);
        assert$4(this.endo != null);
        var len = points.length;
        var npoints = new Array(len * 2);
        var ncoeffs = new Array(len * 2);

        for (var i = 0; i < len; i++) {
          var _this$_endoBeta = this._endoBeta(points[i]),
              _this$_endoBeta2 = _slicedToArray__default['default'](_this$_endoBeta, 2),
              p1 = _this$_endoBeta2[0],
              p2 = _this$_endoBeta2[1];

          var _this$_endoSplit = this._endoSplit(coeffs[i]),
              _this$_endoSplit2 = _slicedToArray__default['default'](_this$_endoSplit, 2),
              k1 = _this$_endoSplit2[0],
              k2 = _this$_endoSplit2[1];

          npoints[i * 2 + 0] = p1;
          ncoeffs[i * 2 + 0] = k1;
          npoints[i * 2 + 1] = p2;
          ncoeffs[i * 2 + 1] = k2;
        }

        return this._wnafMulAdd(5, npoints, ncoeffs);
      }
    }, {
      key: "_icart",
      value: function _icart(u0) {
        // Icart's Method.
        //
        // Distribution: 5/8.
        //
        // [ICART] Page 4, Section 2.
        // [H2EC] "Icart Method".
        //
        // Assumptions:
        //
        //   - p = 2 (mod 3).
        //   - u != 0.
        //
        // Map:
        //
        //   u = 1, if u = 0
        //   v = (3 * a - u^4) / (6 * u)
        //   w = (2 * p - 1) / 3
        //   x = (v^2 - b - u^6 / 27)^w + u^2 / 3
        //   y = u * x + v
        var a = this.a,
            b = this.b,
            i3 = this.i3,
            one = this.one;
        var i27 = i3.redSqr().redMul(i3);
        var w = this.p.ushln(1).isubn(1).idivn(3);
        var u = u0.clone();
        u.cinject(one, u.czero());
        var u2 = u.redSqr();
        var u4 = u2.redSqr();
        var u6 = u4.redMul(u2);
        var u6i = u.redMuln(6).redFermat();
        var v = a.redMuln(3).redISub(u4).redMul(u6i);
        var v2 = v.redSqr();
        var u6d27 = u6.redMul(i27);
        var u2d3 = u2.redMul(i3);
        var x = v2.redISub(b).redISub(u6d27).redPow(w).redIAdd(u2d3);
        var y = u.redMul(x).redIAdd(v);
        return this.point(x, y);
      }
    }, {
      key: "_sswu",
      value: function _sswu(u) {
        // Simplified Shallue-Woestijne-Ulas Method.
        //
        // Distribution: 3/8.
        //
        // [SSWU1] Page 15-16, Section 7. Appendix G.
        // [SSWU2] Page 5, Theorem 2.3.
        // [H2EC] "Simplified Shallue-van de Woestijne-Ulas Method".
        //
        // Assumptions:
        //
        //   - a != 0, b != 0.
        //   - Let z be a non-square in F(p).
        //   - z != -1.
        //   - The polynomial g(x) - z is irreducible over F(p).
        //   - g(b / (z * a)) is square in F(p).
        //   - u != 0, u != +-sqrt(-1 / z).
        //
        // Map:
        //
        //   g(x) = x^3 + a * x + b
        //   t1 = 1 / (z^2 * u^4 + z * u^2)
        //   x1 = (-b / a) * (1 + t1)
        //   x1 = b / (z * a), if t1 = 0
        //   x2 = z * u^2 * x1
        //   x = x1, if g(x1) is square
        //     = x2, otherwise
        //   y = sign(u) * abs(sqrt(g(x)))
        var b = this.b,
            z = this.z,
            ai = this.ai,
            zi = this.zi,
            one = this.one;
        var e = this.p.subn(2);
        var z2 = z.redSqr();
        var ba = b.redNeg().redMul(ai);
        var bza = b.redMul(zi).redMul(ai);
        var u2 = u.redSqr();
        var u4 = u2.redSqr();
        var t1 = z2.redMul(u4).redIAdd(z.redMul(u2)).redPow(e);
        var x1 = ba.redMul(one.redAdd(t1));
        x1.cinject(bza, t1.czero());
        var x2 = z.redMul(u2).redMul(x1);
        var y1 = this.solveY2(x1);
        var y2 = this.solveY2(x2);
        var alpha = y1.redIsSquare() | 0;
        var x = x1.cinject(x2, alpha ^ 1);
        var y = y1.cinject(y2, alpha ^ 1).redSqrt();
        y.cinject(y.redNeg(), y.redIsOdd() ^ u.redIsOdd());
        return this.point(x, y);
      }
    }, {
      key: "_sswui",
      value: function _sswui(p, hint) {
        // Inverting the Map (Simplified Shallue-Woestijne-Ulas).
        //
        // Assumptions:
        //
        //   - a^2 * x^2 - 2 * a * b * x - 3 * b^2 is square in F(p).
        //   - If r < 3 then x != -b / a.
        //
        // Unlike SVDW, the preimages here are evenly
        // distributed (more or less). SSWU covers ~3/8
        // of the curve points. Each preimage has a 1/2
        // chance of mapping to either x1 or x2.
        //
        // Assuming the point is within that set, each
        // point has a 1/4 chance of inverting to any
        // of the preimages. This means we can simply
        // randomly select a preimage if one exists.
        //
        // However, the [SVDW2] sampling method seems
        // slighly faster in practice for [SQUARED].
        //
        // Map:
        //
        //   c = sqrt(a^2 * x^2 - 2 * a * b * x - 3 * b^2)
        //   u1 = -(a * x + b - c) / (2 * (a * x + b) * z)
        //   u2 = -(a * x + b + c) / (2 * (a * x + b) * z)
        //   u3 = -(a * x + b - c) / (2 * b * z)
        //   u4 = -(a * x + b + c) / (2 * b * z)
        //   r = random integer in [1,4]
        //   u = sign(y) * abs(sqrt(ur))
        var a = this.a,
            b = this.b,
            z = this.z;
        var x = p.x,
            y = p.y;
        var r = hint & 3;
        var a2x2 = a.redSqr().redMul(x.redSqr());
        var abx2 = a.redMul(b).redMul(x).redIMuln(2);
        var b23 = b.redSqr().redMuln(3);
        var axb = a.redMul(x).redIAdd(b);

        var _sqrt = sqrt(a2x2.redISub(abx2).redISub(b23)),
            _sqrt2 = _slicedToArray__default['default'](_sqrt, 2),
            s0 = _sqrt2[0],
            c = _sqrt2[1];

        var n0 = axb.redSub(c).redINeg();
        var n1 = axb.redAdd(c).redINeg();
        var d0 = axb.redMul(z).redIMuln(2);
        var d1 = b.redMul(z).redIMuln(2);
        n0.cinject(n1, r & 1); // r = 1 or 3

        d0.cinject(d1, r >>> 1); // r = 2 or 3

        var _divSqrt = divSqrt(n0, d0),
            _divSqrt2 = _slicedToArray__default['default'](_divSqrt, 2),
            s1 = _divSqrt2[0],
            u = _divSqrt2[1];

        u.cinject(u.redNeg(), u.redIsOdd() ^ y.redIsOdd());
        if (!(s0 & s1)) throw new Error('Invalid point.');
        return u;
      }
    }, {
      key: "_svdwf",
      value: function _svdwf(u) {
        // Shallue-van de Woestijne Method.
        //
        // Distribution: 9/16.
        //
        // [SVDW1] Section 5.
        // [SVDW2] Page 8, Section 3.
        //         Page 15, Section 6, Algorithm 1.
        // [H2EC] "Shallue-van de Woestijne Method".
        //
        // Assumptions:
        //
        //   - p = 1 (mod 3).
        //   - a = 0, b != 0.
        //   - Let z be a unique element in F(p).
        //   - g((sqrt(-3 * z^2) - z) / 2) is square in F(p).
        //   - u != 0, u != +-sqrt(-g(z)).
        //
        // Map:
        //
        //   g(x) = x^3 + b
        //   c = sqrt(-3 * z^2)
        //   t1 = u^2 + g(z)
        //   t2 = 1 / (u^2 * t1)
        //   t3 = u^4 * t2 * c
        //   x1 = (c - z) / 2 - t3
        //   x2 = t3 - (c + z) / 2
        //   x3 = z - t1^3 * t2 / (3 * z^2)
        //   x = x1, if g(x1) is square
        //     = x2, if g(x2) is square
        //     = x3, otherwise
        //   y = sign(u) * abs(sqrt(g(x)))
        var c = this.c,
            z = this.z,
            zi = this.zi,
            i2 = this.i2,
            i3 = this.i3;
        var e = this.p.subn(2);
        var gz = this.solveY2(z);
        var z3 = i3.redMul(zi.redSqr());
        var u2 = u.redSqr();
        var u4 = u2.redSqr();
        var t1 = u2.redAdd(gz);
        var t2 = u2.redMul(t1).redPow(e);
        var t3 = u4.redMul(t2).redMul(c);
        var t4 = t1.redSqr().redMul(t1);
        var x1 = c.redSub(z).redMul(i2).redISub(t3);
        var x2 = t3.redSub(c.redAdd(z).redMul(i2));
        var x3 = z.redSub(t4.redMul(t2).redMul(z3));
        var y1 = this.solveY2(x1);
        var y2 = this.solveY2(x2);
        var y3 = this.solveY2(x3);
        var alpha = y1.redIsSquare() | 0;
        var beta = y2.redIsSquare() | 0;
        x1.cinject(x2, (alpha ^ 1) & beta);
        y1.cinject(y2, (alpha ^ 1) & beta);
        x1.cinject(x3, (alpha ^ 1) & (beta ^ 1));
        y1.cinject(y3, (alpha ^ 1) & (beta ^ 1));
        return [x1, y1];
      }
    }, {
      key: "_svdw",
      value: function _svdw(u) {
        var _this$_svdwf = this._svdwf(u),
            _this$_svdwf2 = _slicedToArray__default['default'](_this$_svdwf, 2),
            x = _this$_svdwf2[0],
            yy = _this$_svdwf2[1];

        var y = yy.redSqrt();
        y.cinject(y.redNeg(), y.redIsOdd() ^ u.redIsOdd());
        return this.point(x, y);
      }
    }, {
      key: "_svdwi",
      value: function _svdwi(p, hint) {
        // Inverting the Map (Shallue-van de Woestijne).
        //
        // [SQUARED] Algorithm 1, Page 8, Section 3.3.
        // [SVDW2] Page 12, Section 5.
        // [SVDW3] "Inverting the map".
        //
        // Assumptions:
        //
        //   - If r = 1 then x != -(c + z) / 2.
        //   - If r = 2 then x != (c - z) / 2.
        //   - If r > 2 then (t0 - t1 + t2) is square in F(p).
        //   - f(f^-1(x)) = x where f is the map function.
        //
        // We use the sampling method from [SVDW2],
        // _not_ [SQUARED]. This seems to have a
        // better distribution in practice.
        //
        // Note that [SVDW3] also appears to be
        // incorrect in terms of distribution.
        //
        // The distribution of f(u), assuming u is
        // random, is (1/2, 1/4, 1/4).
        //
        // To mirror this, f^-1(x) should simply
        // pick (1/2, 1/4, 1/8, 1/8).
        //
        // To anyone running the forward map, our
        // strings will appear to be random.
        //
        // Map:
        //
        //   g(x) = x^3 + b
        //   c = sqrt(-3 * z^2)
        //   t0 = 9 * (x^2 * z^2 + z^4)
        //   t1 = 18 * x * z^3
        //   t2 = 12 * g(z) * (x - z)
        //   t3 = sqrt(t0 - t1 + t2)
        //   t4 = t3 * z
        //   u1 = g(z) * (c - 2 * x - z) / (c + 2 * x + z)
        //   u2 = g(z) * (c + 2 * x + z) / (c - 2 * x - z)
        //   u3 = (3 * (z^3 - x * z^2) - 2 * g(z) + t4) / 2
        //   u4 = (3 * (z^3 - x * z^2) - 2 * g(z) - t4) / 2
        //   r = random integer in [1,4]
        //   u = sign(y) * abs(sqrt(ur))
        var b = this.b,
            c = this.c,
            z = this.z,
            two = this.two;
        var x = p.x,
            y = p.y;
        var r = hint & 3;
        var z2 = z.redSqr();
        var z3 = z2.redMul(z);
        var z4 = z2.redSqr();
        var gz = z3.redAdd(b);
        var gz2 = gz.redMuln(2);
        var xx = x.redSqr();
        var x2z = x.redMuln(2).redIAdd(z);
        var xz2 = x.redMul(z2);
        var c0 = c.redSub(x2z);
        var c1 = c.redAdd(x2z);
        var t0 = xx.redMul(z2).redIAdd(z4).redIMuln(9);
        var t1 = x.redMul(z3).redIMuln(18);
        var t2 = gz.redMul(x.redSub(z)).redIMuln(12);

        var _sqrt3 = sqrt(t0.redISub(t1).redIAdd(t2)),
            _sqrt4 = _slicedToArray__default['default'](_sqrt3, 2),
            s0 = _sqrt4[0],
            t3 = _sqrt4[1];

        var s1 = r - 2 >>> 31 | s0;
        var t4 = t3.redMul(z);
        var t5 = z3.redISub(xz2).redIMuln(3).redISub(gz2);
        var n0 = gz.redMul(c0);
        var n1 = gz.redMul(c1);
        var n2 = t5.redAdd(t4);
        var n3 = t5.redSub(t4);
        var d0 = two.clone();
        n0.cinject(n1, (r ^ 1) - 1 >>> 31); // r = 1

        n0.cinject(n2, (r ^ 2) - 1 >>> 31); // r = 2

        n0.cinject(n3, (r ^ 3) - 1 >>> 31); // r = 3

        d0.cinject(c1, (r ^ 0) - 1 >>> 31); // r = 0

        d0.cinject(c0, (r ^ 1) - 1 >>> 31); // r = 1

        var _divSqrt3 = divSqrt(n0, d0),
            _divSqrt4 = _slicedToArray__default['default'](_divSqrt3, 2),
            s2 = _divSqrt4[0],
            u = _divSqrt4[1];

        var _this$_svdwf3 = this._svdwf(u),
            _this$_svdwf4 = _slicedToArray__default['default'](_this$_svdwf3, 1),
            x0 = _this$_svdwf4[0];

        var s3 = x0.ceq(x);
        u.cinject(u.redNeg(), u.redIsOdd() ^ y.redIsOdd());
        if (!(s1 & s2 & s3)) throw new Error('Invalid point.');
        return u;
      }
    }, {
      key: "isElliptic",
      value: function isElliptic() {
        var a = this.a,
            b = this.b;
        var a2 = a.redSqr();
        var a3 = a2.redMul(a);
        var b2 = b.redSqr();
        var d = b2.redMuln(27).redIAdd(a3.redMuln(4)); // 4 * a^3 + 27 * b^2 != 0

        return !d.isZero();
      }
    }, {
      key: "jinv",
      value: function jinv() {
        // [ARITH1] Page 71, Section 4.4.
        // http://mathworld.wolfram.com/j-Invariant.html
        var a = this.a,
            b = this.b;
        var a2 = a.redSqr();
        var a3 = a2.redMul(a);
        var b2 = b.redSqr();
        var t0 = a3.redMuln(4);
        var lhs = t0.redMuln(1728);
        var rhs = b2.redMuln(27).redIAdd(t0);
        if (rhs.isZero()) throw new Error('Curve is not elliptic.'); // (1728 * 4 * a^3) / (4 * a^3 + 27 * b^2)

        return lhs.redDiv(rhs).fromRed();
      }
    }, {
      key: "point",
      value: function point(x, y) {
        var inf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return new ShortPoint(this, x, y, inf);
      }
    }, {
      key: "jpoint",
      value: function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      }
    }, {
      key: "solveX",
      value: function solveX(y) {
        assert$4(y instanceof bnBrowser);
        if (!this.a.isZero()) throw new Error('Not implemented.'); // x^3 = y^2 - b

        var y2 = y.redSqr();
        var x3 = y2.redSub(this.b);
        return cubeRoots(x3);
      }
    }, {
      key: "solveY2",
      value: function solveY2(x) {
        // [GECC] Page 89, Section 3.2.2.
        // https://hyperelliptic.org/EFD/g1p/auto-shortw.html
        assert$4(x instanceof bnBrowser); // y^2 = x^3 + a * x + b

        var x3 = x.redSqr().redMul(x);
        var y2 = x3.redIAdd(this.b);

        if (!this.zeroA) {
          // Save some cycles for a = -3.
          if (this.threeA) y2.redIAdd(x.redMuln(-3));else y2.redIAdd(this.a.redMul(x));
        }

        return y2;
      }
    }, {
      key: "validate",
      value: function validate(point) {
        assert$4(point instanceof ShortPoint);
        if (point.inf) return true;
        var x = point.x,
            y = point.y;
        var y2 = this.solveY2(x);
        return y.redSqr().eq(y2);
      }
    }, {
      key: "pointFromX",
      value: function pointFromX(x) {
        var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        assert$4(x instanceof bnBrowser);
        assert$4(sign == null || typeof sign === 'boolean');
        if (!x.red) x = x.toRed(this.red);
        var y = this.solveY(x);

        if (sign != null) {
          if (this.h.cmpn(1) > 0) {
            if (y.isZero() && sign) throw new Error('Invalid point.');
          }

          if (y.redIsOdd() !== sign) y.redINeg();
        }

        return this.point(x, y);
      }
    }, {
      key: "pointFromY",
      value: function pointFromY(y) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        assert$4(y instanceof bnBrowser);
        assert$4(index >>> 0 === index);
        if (!y.red) y = y.toRed(this.red);
        var coords = this.solveX(y);
        if (index >= coords.length) throw new Error('Invalid X coordinate index.');
        var x = coords[index];
        return this.point(x, y);
      }
    }, {
      key: "isIsomorphic",
      value: function isIsomorphic(curve) {
        // [GECC] Page 84, Section 3.1.5.
        // [ARITH1] Page 286, Section 13.2.3.c.
        assert$4(curve instanceof Curve);
        if (!curve.p.eq(this.p)) return false;
        var u2, u3;

        try {
          var _this$_scale = this._scale(curve);

          var _this$_scale2 = _slicedToArray__default['default'](_this$_scale, 2);

          u2 = _this$_scale2[0];
          u3 = _this$_scale2[1];
        } catch (e) {
          return false;
        } // E(a,b) <-> E(au^4,bu^6)


        if (curve.type === 'short') {
          // a' = a * u^4, b' = b * u^6
          var a = this.field(curve.a).redMul(u2.redSqr());
          var b = this.field(curve.b).redMul(u3.redSqr());
          return this.a.eq(a) && this.b.eq(b);
        } // E(a,b) <-> M(A,B)


        if (curve.type === 'mont') {
          // (A / (3 * B))^3 + a * (A / (3 * B)) + b = 0
          var a3 = curve.a3,
              bi = curve.bi;
          var x = this.field(a3.redMul(bi)).redMul(u2);
          var y2 = this.solveY2(x);
          return y2.isZero();
        } // E(a,b) <-> E(a,d)


        if (curve.type === 'edwards') {
          // ((a' + d') / 6)^3 + a * ((a' + d') / 6) + b = 0
          var _x = this.field(curve.ad6).redMul(u2);

          var _y = this.solveY2(_x);

          return _y.isZero();
        }

        return false;
      }
    }, {
      key: "isIsogenous",
      value: function isIsogenous(curve) {
        assert$4(curve instanceof Curve);
        return false;
      }
    }, {
      key: "pointFromShort",
      value: function pointFromShort(point) {
        // [GECC] Page 84, Section 3.1.5.
        // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).
        assert$4(point instanceof ShortPoint);

        if (this.isIsomorphic(point.curve)) {
          // Isomorphic maps for E(a,b)<->E(au^4,bu^6):
          //
          //   x' = x * u^2
          //   y' = y * u^3
          //
          // Where a * u^4 = a' and b * u^6 = b'.
          if (point.isInfinity()) return this.point();

          var _this$_scale3 = this._scale(point.curve),
              _this$_scale4 = _slicedToArray__default['default'](_this$_scale3, 2),
              u2 = _this$_scale4[0],
              u3 = _this$_scale4[1];

          var x = this.field(point.x);
          var y = this.field(point.y);
          var nx = x.redMul(u2);
          var ny = y.redMul(u3);
          return this.point(nx, ny);
        }

        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromMont",
      value: function pointFromMont(point) {
        // [ALT] Appendix E.2 (Switching between Alternative Representations).
        // [MONT2] "Equivalence with Weierstrass curves"
        assert$4(point instanceof MontPoint);

        if (this.isIsomorphic(point.curve)) {
          // Equivalence for M(A,B)->E(a,b):
          //
          //   x = (u + A / 3) / B
          //   y = v / B
          //
          // Undefined if ((u^3 + A * u^2 + u) / B) is not square.
          if (point.isInfinity()) return this.point();
          var _point$curve = point.curve,
              a3 = _point$curve.a3,
              bi = _point$curve.bi;

          var _this$_scale5 = this._scale(point.curve),
              _this$_scale6 = _slicedToArray__default['default'](_this$_scale5, 2),
              u2 = _this$_scale6[0],
              u3 = _this$_scale6[1];

          var nx = point.x.redAdd(a3).redMul(bi);
          var ny = point.y.redMul(bi);
          return this.point(this.field(nx).redMul(u2), this.field(ny).redMul(u3));
        }

        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromEdwards",
      value: function pointFromEdwards(point) {
        // [TWISTEQ] Section 2.
        assert$4(point instanceof EdwardsPoint);

        if (this.isIsomorphic(point.curve)) {
          // Equivalence for E(a,d)->E(a',b'):
          //
          //   x' = ((5 * d - a) * y + d - 5 * a) / (12 * (y - 1))
          //   y' = (d - a) * (y + 1) / (4 * x * (y - 1))
          //
          // Undefined for x = 0 or y = 1.
          //
          // Exceptional Cases:
          //   - (0, 1) -> O
          //   - (0, -1) -> ((a + d) / 6, 0)
          //
          // Unexceptional Cases:
          //   - (sqrt(1 / a), 0) -> ((5 * a - d) / 12, (a - d) / 4 * sqrt(a))
          var _point$curve2 = point.curve,
              a = _point$curve2.a,
              d = _point$curve2.d,
              ad6 = _point$curve2.ad6;

          var _this$_scale7 = this._scale(point.curve),
              _this$_scale8 = _slicedToArray__default['default'](_this$_scale7, 2),
              u2 = _this$_scale8[0],
              u3 = _this$_scale8[1];

          if (point.isInfinity()) return this.point();

          if (point.x.isZero()) {
            var _x2 = this.field(ad6).redMul(u2);

            return this.point(_x2, this.zero);
          }

          var x = point.x,
              y = point.y,
              z = point.z;
          var a5 = a.redMuln(5);
          var d5 = d.redMuln(5);
          var dma = d.redSub(a);
          var d5a = d5.redSub(a);
          var da5 = d.redSub(a5);
          var ypz = y.redAdd(z);
          var ymz = y.redSub(z);
          var xx = d5a.redMul(y).redIAdd(da5.redMul(z));
          var xz = ymz.redMuln(12);
          var yy = dma.redMul(ypz).redMul(z);
          var yz = ymz.redMul(x).redIMuln(4);
          return this.cpoint(this.field(xx).redMul(u2), this.field(xz), this.field(yy).redMul(u3), this.field(yz));
        }

        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromUniform",
      value: function pointFromUniform(u) {
        assert$4(u instanceof bnBrowser); // z = 0 or b = 0

        if (this.z.isZero() || this.b.isZero()) throw new Error('Not implemented.'); // a != 0, b != 0

        if (!this.a.isZero()) return this._sswu(u); // p = 1 mod 3, a = 0, b != 0

        if (!this.c.isZero()) return this._svdw(u);
        throw new Error('Not implemented.');
      }
    }, {
      key: "pointToUniform",
      value: function pointToUniform(p, hint) {
        assert$4(p instanceof ShortPoint);
        assert$4(hint >>> 0 === hint); // z = 0 or b = 0

        if (this.z.isZero() || this.b.isZero()) throw new Error('Not implemented.'); // P = O

        if (p.isInfinity()) throw new Error('Invalid point.'); // Add a random torsion component.

        var i = (hint >>> 4 & 15) % this.torsion.length;
        var q = p.add(this.torsion[i]); // a != 0, b != 0

        if (!this.a.isZero()) return this._sswui(q, hint); // p = 1 mod 3, a = 0, b != 0

        if (!this.c.isZero()) return this._svdwi(q, hint);
        throw new Error('Not implemented.');
      }
    }, {
      key: "mulAll",
      value: function mulAll(points, coeffs) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortCurve.prototype), "mulAll", this).call(this, points, coeffs).toP();
      }
    }, {
      key: "mulAllSimple",
      value: function mulAllSimple(points, coeffs) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortCurve.prototype), "mulAllSimple", this).call(this, points, coeffs).toP();
      }
    }, {
      key: "decodePoint",
      value: function decodePoint(bytes) {
        return ShortPoint.decode(this, bytes);
      }
    }, {
      key: "encodeX",
      value: function encodeX(point) {
        assert$4(point instanceof Point);
        return point.encodeX();
      }
    }, {
      key: "decodeEven",
      value: function decodeEven(bytes) {
        return ShortPoint.decodeEven(this, bytes);
      }
    }, {
      key: "decodeSquare",
      value: function decodeSquare(bytes) {
        return ShortPoint.decodeSquare(this, bytes);
      }
    }, {
      key: "toShort",
      value: function toShort(a0, odd) {
        var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var _this$_short = this._short(a0, odd),
            _this$_short2 = _slicedToArray__default['default'](_this$_short, 2),
            a = _this$_short2[0],
            b = _this$_short2[1];

        var curve = new ShortCurve({
          red: this.red,
          prime: this.prime,
          p: this.p,
          a: a,
          b: b,
          n: this.n,
          h: this.h
        });

        if (sign != null) {
          var _curve$_scale = curve._scale(this),
              _curve$_scale2 = _slicedToArray__default['default'](_curve$_scale, 2),
              u3 = _curve$_scale2[1];

          if (u3.redIsOdd() !== sign) u3.redINeg();
        }

        if (!this.g.isInfinity()) curve.g = curve.pointFromShort(this.g);

        for (var i = 0; i < this.h.word(0); i++) {
          curve.torsion[i] = curve.pointFromShort(this.torsion[i]);
        }

        return curve;
      }
    }, {
      key: "toMont",
      value: function toMont(b0, odd) {
        var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var _this$_mont = this._mont(b0, odd),
            _this$_mont2 = _slicedToArray__default['default'](_this$_mont, 2),
            a = _this$_mont2[0],
            b = _this$_mont2[1];

        var curve = new MontCurve({
          red: this.red,
          prime: this.prime,
          p: this.p,
          a: a,
          b: b,
          n: this.n,
          h: this.h
        });

        if (sign != null) {
          var _this$_scale9 = this._scale(curve),
              _this$_scale10 = _slicedToArray__default['default'](_this$_scale9, 2),
              u3 = _this$_scale10[1];

          if (u3.redIsOdd() !== sign) u3.redINeg();
        }

        if (!this.g.isInfinity()) curve.g = curve.pointFromShort(this.g);

        for (var i = 0; i < this.h.word(0); i++) {
          curve.torsion[i] = curve.pointFromShort(this.torsion[i]);
        }

        return curve;
      }
    }, {
      key: "toEdwards",
      value: function toEdwards(a0, odd) {
        var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var _this$_edwards = this._edwards(a0, odd),
            _this$_edwards2 = _slicedToArray__default['default'](_this$_edwards, 2),
            a = _this$_edwards2[0],
            d = _this$_edwards2[1];

        var curve = new EdwardsCurve({
          red: this.red,
          prime: this.prime,
          p: this.p,
          a: a,
          d: d,
          n: this.n,
          h: this.h
        });

        if (sign != null) {
          var _this$_scale11 = this._scale(curve),
              _this$_scale12 = _slicedToArray__default['default'](_this$_scale11, 2),
              u3 = _this$_scale12[1];

          if (u3.redIsOdd() !== sign) u3.redINeg();
        }

        if (!this.g.isInfinity()) {
          curve.g = curve.pointFromShort(this.g);
          curve.g.normalize();
        }

        if (curve.isComplete()) {
          for (var i = 0; i < this.h.word(0); i++) {
            curve.torsion[i] = curve.pointFromShort(this.torsion[i]);
            curve.torsion[i].normalize();
          }
        }

        return curve;
      }
    }, {
      key: "pointFromJSON",
      value: function pointFromJSON(json) {
        return ShortPoint.fromJSON(this, json);
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        var json = _get__default['default'](_getPrototypeOf__default['default'](ShortCurve.prototype), "toJSON", this).call(this, pre);

        json.a = this.a.fromRed().toJSON();
        json.b = this.b.fromRed().toJSON();
        if (!this.c.isZero()) json.c = this.c.fromRed().toJSON();
        return json;
      }
    }], [{
      key: "_isomorphism",
      value: function _isomorphism(curveA, curveB, custom, odd) {
        // Short Weierstrass Isomorphism.
        //
        // [GECC] Page 84, Section 3.1.5.
        // [ARITH1] Page 274, Section 13.1.5.
        // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).
        //
        // Find `u` such that `a * u^4 = a'` and `b * u^6 = b'`.
        //
        // Transformation:
        //
        //   u4 = a' / a
        //   u2 = +-sqrt(u4)
        //   u6 = u4 * u2
        //   a' = a * u4
        //   b' = b * u6
        //
        // Where `u2` is any root that is square.
        //
        // If a = 0, we can do:
        //
        //   a' = 0
        //   b' = b'
        //
        // Where (b' / b)^(1 / 3) is square.
        //
        // If b = 0, we can do:
        //
        //   a' = a'
        //   b' = 0
        //
        // Where sqrt(a' / a) is square.
        assert$4(curveA instanceof bnBrowser);
        assert$4(curveB instanceof bnBrowser);
        assert$4(custom instanceof bnBrowser);
        assert$4(odd == null || typeof odd === 'boolean');
        assert$4(!curveA.isZero() || !curveB.isZero());
        if (custom.isZero()) throw new Error('Invalid coefficient.');

        if (curveA.isZero()) {
          var customB = custom;

          var _u9 = customB.redDiv(curveB); // Todo: allow index flag.


          var _u10 = uncube(_u9); // Already checked in uncube().


          assert$4(_u10.redJacobi() === 1);
          return [curveA.clone(), customB.clone()];
        }

        if (curveB.isZero()) {
          var _customA = custom;

          var _u11 = _customA.redDiv(curveA);

          var _u12 = _u11.redSqrt(); // Todo: allow odd flag.


          if (_u12.redJacobi() !== 1) _u12.redINeg();
          if (_u12.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');
          return [_customA.clone(), curveB.clone()];
        }

        var customA = custom;
        var u4 = customA.redDiv(curveA);
        var u2 = u4.redSqrt();

        if (odd != null) {
          if (u2.redIsOdd() !== odd) u2.redINeg();
        } else {
          if (u2.redJacobi() !== 1) u2.redINeg();
        }

        if (u2.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');
        var u6 = u4.redMul(u2);
        var a = curveA.redMul(u4);
        var b = curveB.redMul(u6);
        assert$4(a.eq(customA));
        return [a, b];
      }
    }]);

    return ShortCurve;
  }(Curve);
  /**
   * ShortPoint
   */


  var ShortPoint = /*#__PURE__*/function (_Point) {
    _inherits__default['default'](ShortPoint, _Point);

    var _super2 = _createSuper$c(ShortPoint);

    function ShortPoint(curve, x, y, inf) {
      var _this2;

      _classCallCheck__default['default'](this, ShortPoint);

      assert$4(curve instanceof ShortCurve);
      _this2 = _super2.call(this, curve, types$1.AFFINE);
      _this2.x = _this2.curve.zero;
      _this2.y = _this2.curve.zero;
      _this2.inf = 1;
      if (x != null) _this2._init(x, y, inf);
      return _this2;
    }

    _createClass__default['default'](ShortPoint, [{
      key: "_init",
      value: function _init(x, y, inf) {
        assert$4(x instanceof bnBrowser);
        assert$4(y instanceof bnBrowser);
        this.x = x;
        this.y = y;
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = inf | 0;
      }
    }, {
      key: "_safeNAF",
      value: function _safeNAF(width) {
        assert$4(width >>> 0 === width);
        if (this.pre && this.pre.naf) return this.pre.naf; // Avoid inversions.

        if (width > 1) return this.toJ()._getNAF(width);
        return this._getNAF(width);
      }
    }, {
      key: "_getBeta",
      value: function _getBeta() {
        var _this3 = this;

        if (!this.curve.endo) return null;
        if (this.pre && this.pre.beta) return this.pre.beta; // Augment the point with our beta value.
        // This is the counterpart to `k2` after
        // the endomorphism split of `k`.
        //
        // Note that if we have precomputation,
        // we have to clone and update all of the
        // precomputed points below.

        var xb = this.x.redMul(this.curve.endo.beta);
        var beta = this.curve.point(xb, this.y);

        if (this.pre) {
          beta.pre = this.pre.map(function (point) {
            var xb = point.x.redMul(_this3.curve.endo.beta);
            return _this3.curve.point(xb, point.y);
          });
          this.pre.beta = beta;
        }

        return beta;
      }
    }, {
      key: "_getJNAF",
      value: function _getJNAF(point) {
        assert$4(point instanceof ShortPoint);
        if (this.inf | point.inf) return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "_getJNAF", this).call(this, point); // Create comb for JSF.

        var comb = [this, // 1
        null, // 3
        null, // 5
        point // 7
        ]; // Try to avoid Jacobian points, if possible.

        if (this.y.eq(point.y)) {
          comb[1] = this.add(point);
          comb[2] = this.toJ().sub(point);
        } else if (this.y.eq(point.y.redNeg())) {
          comb[1] = this.toJ().add(point);
          comb[2] = this.sub(point);
        } else {
          comb[1] = this.toJ().add(point);
          comb[2] = this.toJ().sub(point);
        }

        return comb;
      }
    }, {
      key: "clone",
      value: function clone() {
        return this.curve.point(this.x.clone(), this.y.clone(), this.inf);
      }
    }, {
      key: "swap",
      value: function swap(point, flag) {
        assert$4(point instanceof ShortPoint);
        var cond = (flag >> 31 | -flag >> 31) & 1;
        var inf1 = this.inf;
        var inf2 = point.inf;
        this.x.cswap(point.x, flag);
        this.y.cswap(point.y, flag);
        this.inf = inf1 & (cond ^ 1) | inf2 & cond;
        point.inf = inf2 & (cond ^ 1) | inf1 & cond;
        return this;
      }
    }, {
      key: "scale",
      value: function scale(a) {
        return this.toJ().scale(a);
      }
    }, {
      key: "neg",
      value: function neg() {
        // P = O
        if (this.inf) return this; // -(X1, Y1) = (X1, -Y1)

        return this.curve.point(this.x, this.y.redNeg());
      }
    }, {
      key: "add",
      value: function add(p) {
        // [GECC] Page 80, Section 3.1.2.
        //
        // Addition Law:
        //
        //   l = (y1 - y2) / (x1 - x2)
        //   x3 = l^2 - x1 - x2
        //   y3 = l * (x1 - x3) - y1
        //
        // 1I + 2M + 1S + 6A
        assert$4(p instanceof ShortPoint); // O + P = P

        if (this.inf) return p; // P + O = P

        if (p.inf) return this; // P + P, P + -P

        if (this.x.eq(p.x)) {
          // P + -P = O
          if (!this.y.eq(p.y)) return this.curve.point(); // P + P = 2P

          return this.dbl();
        } // X1 != X2, Y1 = Y2


        if (this.y.eq(p.y)) {
          // X3 = -X1 - X2
          var _nx = this.x.redNeg().redISub(p.x); // Y3 = -Y1


          var _ny = this.y.redNeg(); // Skip the inverse.


          return this.curve.point(_nx, _ny);
        } // H = X1 - X2


        var h = this.x.redSub(p.x); // R = Y1 - Y2

        var r = this.y.redSub(p.y); // L = R / H

        var l = r.redDiv(h); // X3 = L^2 - X1 - X2

        var nx = l.redSqr().redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1

        var ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      }
    }, {
      key: "dbl",
      value: function dbl() {
        // [GECC] Page 80, Section 3.1.2.
        //
        // Addition Law (doubling):
        //
        //   l = (3 * x1^2 + a) / (2 * y1)
        //   x3 = l^2 - 2 * x1
        //   y3 = l * (x1 - x3) - y1
        //
        // 1I + 2M + 2S + 3A + 2*2 + 1*3
        // P = O
        if (this.inf) return this; // Y1 = 0

        if (this.y.isZero()) return this.curve.point(); // XX = X1^2

        var xx = this.x.redSqr(); // M = 3 * XX + a

        var m = xx.redIMuln(3).redIAdd(this.curve.a); // Z = 2 * Y1

        var z = this.y.redMuln(2); // L = M / Z

        var l = m.redDiv(z); // X3 = L^2 - 2 * X1

        var nx = l.redSqr().redISub(this.x).redISub(this.x); // Y3 = L * (X1 - X3) - Y1

        var ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      }
    }, {
      key: "dblp",
      value: function dblp(pow) {
        return this.toJ().dblp(pow).toP();
      }
    }, {
      key: "uadd",
      value: function uadd(p) {
        // [SIDE2] Page 5, Section 3.
        // [SIDE3] Page 4, Section 3.
        //
        // Addition Law (unified):
        //
        //   l = ((x1 + x2)^2 - (x1 * x2) + a) / (y1 + y2)
        //   x3 = l^2 - x1 - x2
        //   y3 = l * (x1 - x3) - y1
        //
        // If x1 != x2 and y1 = -y2, we switch
        // back to the regular addition lambda:
        //
        //   l = (y1 - y2) / (x1 - x2)
        //
        // 1I + 3M + 2S + 10A
        assert$4(p instanceof ShortPoint); // M = Y1 + Y2

        var m = this.y.redAdd(p.y); // A = (X1 + X2)^2

        var a = this.x.redAdd(p.x).redSqr(); // B = X1 * X2

        var b = this.x.redMul(p.x); // R = A - B + a

        var r = a.redISub(b).redIAdd(this.curve.a); // Check for degenerate case (X1 != X2, Y1 = -Y2).

        var degenerate = m.czero() & r.czero(); // M = X1 - X2 (if degenerate)

        m.cinject(this.x.redSub(p.x), degenerate); // R = Y1 - Y2 (if degenerate)

        r.cinject(this.y.redSub(p.y), degenerate); // Check for negation (X1 = X2, Y1 = -Y2).

        var negated = m.czero() & ((this.inf | p.inf) ^ 1); // M = 1 (if M = 0)

        m.cinject(this.curve.one, m.czero()); // L = R / M

        var l = r.redMul(m.redFermat()); // X3 = L^2 - X1 - X2

        var nx = l.redSqr().redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1

        var ny = l.redMul(this.x.redSub(nx)).redISub(this.y); // Check for infinity.

        var inf = negated | this.inf & p.inf; // Case 1: O + P = P

        nx.cinject(p.x, this.inf);
        ny.cinject(p.y, this.inf); // Case 2: P + O = P

        nx.cinject(this.x, p.inf);
        ny.cinject(this.y, p.inf); // Case 3 & 4: P + -P = O, O + O = O

        nx.cinject(this.curve.zero, inf);
        ny.cinject(this.curve.zero, inf);
        return this.curve.point(nx, ny, inf);
      }
    }, {
      key: "udbl",
      value: function udbl() {
        return this.uadd(this);
      }
    }, {
      key: "recover",
      value: function recover(x1, z1, x2, z2) {
        // Brier-Joye Y-coordinate Recovery.
        //
        // [SIDE2] Proposition 3, Page 7, Section 4.
        //
        // 14M + 3S + 5A + 2*2 + 1*a + 1*b
        assert$4(x1 instanceof bnBrowser);
        assert$4(z1 instanceof bnBrowser);
        assert$4(x2 instanceof bnBrowser);
        assert$4(z2 instanceof bnBrowser); // P = O

        if (this.inf) return this.curve.jpoint(); // Z = Z1 * Z2

        var z = z1.redMul(z2); // ZZ = Z^2

        var zz = z.redSqr(); // ZZZ = ZZ * Z

        var zzz = zz.redMul(z); // U0 = X0 * Z

        var u0 = this.x.redMul(z); // U1 = X1 * Z2

        var u1 = x1.redMul(z2); // U2 = X2 * Z1

        var u2 = x2.redMul(z1); // A = 2 * b * ZZZ

        var a = this.curve.b.redMul(zzz).redIMuln(2); // B = a * ZZ + U0 * U1

        var b = u0.redMul(u1).redIAdd(this.curve.a.redMul(zz)); // C = U0 + U1

        var c = u0.redAdd(u1); // D = U0 - U1

        var d = u0.redISub(u1); // E = A + B * C

        var e = a.redIAdd(b.redMul(c)); // F = U2 * D^2

        var f = u2.redMul(d.redSqr()); // G = E - F

        var g = e.redISub(f); // H = 2 * Y0 * ZZZ

        var h = this.y.redMul(zzz).redIMuln(2); // I = X1 * H

        var i = x1.redMul(h); // J = G * Z1

        var j = g.redMul(z1); // K = Z1 * H

        var k = z1.redMul(h); // X3 = I * K

        var nx = i.redMul(k); // Y3 = J * K^2

        var ny = j.redMul(k.redSqr()); // Z3 = K

        var nz = k;
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "getX",
      value: function getX() {
        if (this.inf) throw new Error('Invalid point.');
        return this.x.fromRed();
      }
    }, {
      key: "getY",
      value: function getY() {
        if (this.inf) throw new Error('Invalid point.');
        return this.y.fromRed();
      }
    }, {
      key: "eq",
      value: function eq(p) {
        assert$4(p instanceof ShortPoint); // P = Q

        if (this === p) return true; // P = O

        if (this.inf) return p.inf !== 0; // Q = O

        if (p.inf) return false; // X1 = X2, Y1 = Y2

        return this.x.eq(p.x) && this.y.eq(p.y);
      }
    }, {
      key: "cmp",
      value: function cmp(point) {
        assert$4(point instanceof ShortPoint);
        if (this.inf && !point.inf) return -1;
        if (!this.inf && point.inf) return 1;
        if (this.inf && point.inf) return 0;
        return this.order().cmp(point.order()) || this.getX().cmp(point.getX()) || this.getY().cmp(point.getY());
      }
    }, {
      key: "isInfinity",
      value: function isInfinity() {
        // Infinity cannot be represented in
        // the affine space, except by a flag.
        return this.inf !== 0;
      }
    }, {
      key: "isOrder2",
      value: function isOrder2() {
        if (this.inf) return false;
        return this.y.isZero();
      }
    }, {
      key: "isOdd",
      value: function isOdd() {
        if (this.inf) return false;
        return this.y.redIsOdd();
      }
    }, {
      key: "isEven",
      value: function isEven() {
        if (this.inf) return false;
        return this.y.redIsEven();
      }
    }, {
      key: "isSquare",
      value: function isSquare() {
        if (this.inf) return false;
        return this.y.redJacobi() !== -1;
      }
    }, {
      key: "eqX",
      value: function eqX(x) {
        assert$4(x instanceof bnBrowser);
        assert$4(!x.red);
        if (this.inf) return false;
        return this.getX().eq(x);
      }
    }, {
      key: "eqR",
      value: function eqR(x) {
        assert$4(x instanceof bnBrowser);
        assert$4(!x.red);
        assert$4(!this.curve.n.isZero());
        if (this.inf) return false;
        return this.getX().imod(this.curve.n).eq(x);
      }
    }, {
      key: "mul",
      value: function mul(k) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "mul", this).call(this, k).toP();
      }
    }, {
      key: "muln",
      value: function muln(k) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "muln", this).call(this, k).toP();
      }
    }, {
      key: "mulSimple",
      value: function mulSimple(k) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "mulSimple", this).call(this, k).toP();
      }
    }, {
      key: "mulBlind",
      value: function mulBlind(k, rng) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "mulBlind", this).call(this, k, rng).toP();
      }
    }, {
      key: "mulConst",
      value: function mulConst(k, rng) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "mulConst", this).call(this, k, rng).toP();
      }
    }, {
      key: "mulAdd",
      value: function mulAdd(k1, p2, k2) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "mulAdd", this).call(this, k1, p2, k2).toP();
      }
    }, {
      key: "mulAddSimple",
      value: function mulAddSimple(k1, p2, k2) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "mulAddSimple", this).call(this, k1, p2, k2).toP();
      }
    }, {
      key: "mulH",
      value: function mulH() {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "mulH", this).call(this).toP();
      }
    }, {
      key: "div",
      value: function div(k) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "div", this).call(this, k).toP();
      }
    }, {
      key: "divn",
      value: function divn(k) {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "divn", this).call(this, k).toP();
      }
    }, {
      key: "divH",
      value: function divH() {
        return _get__default['default'](_getPrototypeOf__default['default'](ShortPoint.prototype), "divH", this).call(this).toP();
      }
    }, {
      key: "toP",
      value: function toP() {
        return this;
      }
    }, {
      key: "toJ",
      value: function toJ() {
        // (X3, Y3, Z3) = (1, 1, 0)
        if (this.inf) return this.curve.jpoint(); // (X3, Y3, Z3) = (X1, Y1, 1)

        return this.curve.jpoint(this.x, this.y, this.curve.one);
      }
    }, {
      key: "encode",
      value: function encode(compact) {
        // [SEC1] Page 10, Section 2.3.3.
        if (compact == null) compact = true;
        assert$4(typeof compact === 'boolean');
        var fieldSize = this.curve.fieldSize; // We do not serialize points at infinity.

        if (this.inf) throw new Error('Invalid point.'); // Compressed form (0x02 = even, 0x03 = odd).

        if (compact) {
          var _p = Buffer.alloc(1 + fieldSize);

          var _x3 = this.curve.encodeField(this.getX());

          _p[0] = 0x02 | this.y.redIsOdd();

          _x3.copy(_p, 1);

          return _p;
        } // Uncompressed form (0x04).


        var p = Buffer.alloc(1 + fieldSize * 2);
        var x = this.curve.encodeField(this.getX());
        var y = this.curve.encodeField(this.getY());
        p[0] = 0x04;
        x.copy(p, 1);
        y.copy(p, 1 + fieldSize);
        return p;
      }
    }, {
      key: "encodeX",
      value: function encodeX() {
        // [SCHNORR] "Specification".
        // [BIP340] "Specification".
        return this.curve.encodeField(this.getX());
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        if (this.inf) return [];
        var x = this.getX().toJSON();
        var y = this.getY().toJSON();
        if (pre === true && this.pre) return [x, y, this.pre.toJSON()];
        return [x, y];
      }
    }, {
      key: "toPretty",
      value: function toPretty() {
        if (this.inf) return [];
        var size = this.curve.fieldSize * 2;

        var x = _toPretty(this.getX(), size);

        var y = _toPretty(this.getY(), size);

        return [x, y];
      }
    }, {
      key: custom$2,
      value: function value() {
        if (this.inf) return '<ShortPoint: Infinity>';
        return '<ShortPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>';
      }
    }], [{
      key: "decode",
      value: function decode(curve, bytes) {
        // [SEC1] Page 11, Section 2.3.4.
        assert$4(curve instanceof ShortCurve);
        assert$4(Buffer.isBuffer(bytes));
        var len = curve.fieldSize;
        if (bytes.length < 1 + len) throw new Error('Not a point.'); // Point forms:
        //
        //   0x00 -> Infinity (openssl, unsupported)
        //   0x02 -> Compressed Even
        //   0x03 -> Compressed Odd
        //   0x04 -> Uncompressed
        //   0x06 -> Hybrid Even (openssl)
        //   0x07 -> Hybrid Odd (openssl)
        //
        // Note that openssl supports serializing points
        // at infinity as {0}. We choose not to support it
        // because it's strange and not terribly useful.

        var form = bytes[0];

        switch (form) {
          case 0x02:
          case 0x03:
            {
              if (bytes.length !== 1 + len) throw new Error('Invalid point size for compressed.');
              var x = curve.decodeField(bytes.slice(1, 1 + len));
              if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');
              var p = curve.pointFromX(x, form === 0x03);
              assert$4(!p.isInfinity());
              return p;
            }

          case 0x04:
          case 0x06:
          case 0x07:
            {
              if (bytes.length !== 1 + len * 2) throw new Error('Invalid point size for uncompressed.');

              var _x4 = curve.decodeField(bytes.slice(1, 1 + len));

              var y = curve.decodeField(bytes.slice(1 + len, 1 + 2 * len)); // [GECC] Algorithm 4.3, Page 180, Section 4.

              if (_x4.cmp(curve.p) >= 0 || y.cmp(curve.p) >= 0) throw new Error('Invalid point.'); // OpenSSL hybrid encoding.

              if (form !== 0x04 && form !== (0x06 | y.isOdd())) throw new Error('Invalid hybrid encoding.');

              var _p2 = curve.point(_x4, y);

              if (!_p2.validate()) throw new Error('Invalid point.');
              assert$4(!_p2.isInfinity());
              return _p2;
            }

          default:
            {
              throw new Error('Unknown point format.');
            }
        }
      }
    }, {
      key: "decodeEven",
      value: function decodeEven(curve, bytes) {
        // [BIP340] "Specification".
        assert$4(curve instanceof ShortCurve);
        var x = curve.decodeField(bytes);
        if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');
        return curve.pointFromX(x, false);
      }
    }, {
      key: "decodeSquare",
      value: function decodeSquare(curve, bytes) {
        // [SCHNORR] "Specification".
        // [BIP340] "Specification".
        assert$4(curve instanceof ShortCurve);
        var x = curve.decodeField(bytes);
        if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');
        return curve.pointFromX(x);
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(curve, json) {
        assert$4(curve instanceof ShortCurve);
        assert$4(Array.isArray(json));
        assert$4(json.length === 0 || json.length === 2 || json.length === 3);
        if (json.length === 0) return curve.point();
        var x = bnBrowser.fromJSON(json[0]);
        var y = bnBrowser.fromJSON(json[1]);
        var point = curve.point(x, y);
        if (json.length > 2 && json[2] != null) point.pre = Precomp.fromJSON(point, json[2]);
        return point;
      }
    }]);

    return ShortPoint;
  }(Point);
  /**
   * JPoint
   */


  var JPoint = /*#__PURE__*/function (_Point2) {
    _inherits__default['default'](JPoint, _Point2);

    var _super3 = _createSuper$c(JPoint);

    function JPoint(curve, x, y, z) {
      var _this4;

      _classCallCheck__default['default'](this, JPoint);

      assert$4(curve instanceof ShortCurve);
      _this4 = _super3.call(this, curve, types$1.JACOBIAN);
      _this4.x = _this4.curve.one;
      _this4.y = _this4.curve.one;
      _this4.z = _this4.curve.zero;
      _this4.zOne = 0;
      if (x != null) _this4._init(x, y, z);
      return _this4;
    }

    _createClass__default['default'](JPoint, [{
      key: "_init",
      value: function _init(x, y, z) {
        assert$4(x instanceof bnBrowser);
        assert$4(y instanceof bnBrowser);
        assert$4(z == null || z instanceof bnBrowser);
        this.x = x;
        this.y = y;
        this.z = z || this.curve.one;
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z.eq(this.curve.one) | 0;
      }
    }, {
      key: "clone",
      value: function clone() {
        return this.curve.jpoint(this.x.clone(), this.y.clone(), this.z.clone());
      }
    }, {
      key: "swap",
      value: function swap(point, flag) {
        assert$4(point instanceof JPoint);
        var cond = (flag >> 31 | -flag >> 31) & 1;
        var zOne1 = this.zOne;
        var zOne2 = point.zOne;
        this.x.cswap(point.x, flag);
        this.y.cswap(point.y, flag);
        this.z.cswap(point.z, flag);
        this.zOne = zOne1 & (cond ^ 1) | zOne2 & cond;
        point.zOne = zOne2 & (cond ^ 1) | zOne1 & cond;
        return this;
      }
    }, {
      key: "validate",
      value: function validate() {
        // [GECC] Example 3.20, Page 88, Section 3.
        var _this$curve2 = this.curve,
            a = _this$curve2.a,
            b = _this$curve2.b; // P = O

        if (this.isInfinity()) return true; // Z1 = 1

        if (this.zOne) return this.curve.validate(this.toP()); // y^2 = x^3 + a * x * z^4 + b * z^6

        var lhs = this.y.redSqr();
        var x3 = this.x.redSqr().redMul(this.x);
        var z2 = this.z.redSqr();
        var z4 = z2.redSqr();
        var z6 = z4.redMul(z2);
        var rhs = x3.redIAdd(b.redMul(z6));

        if (!this.curve.zeroA) {
          // Save some cycles for a = -3.
          if (this.curve.threeA) rhs.redIAdd(z4.redIMuln(-3).redMul(this.x));else rhs.redIAdd(a.redMul(z4).redMul(this.x));
        }

        return lhs.eq(rhs);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#scaling-z
        // 1I + 3M + 1S
        // Z = 1
        if (this.zOne) return this; // P = O

        if (this.isInfinity()) return this; // A = 1 / Z1

        var a = this.z.redInvert(); // AA = A^2

        var aa = a.redSqr(); // X3 = X1 * AA

        this.x = this.x.redMul(aa); // Y3 = Y1 * AA * A

        this.y = this.y.redMul(aa).redMul(a); // Z3 = 1

        this.z = this.curve.one;
        this.zOne = 1;
        return this;
      }
    }, {
      key: "scale",
      value: function scale(a) {
        assert$4(a instanceof bnBrowser); // P = O

        if (this.isInfinity()) return this.curve.jpoint(); // AA = A^2

        var aa = a.redSqr(); // X3 = X1 * AA

        var nx = this.x.redMul(aa); // Y3 = Y1 * AA * A

        var ny = this.y.redMul(aa).redMul(a); // Z3 = Z1 * A

        var nz = this.z.redMul(a);
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "neg",
      value: function neg() {
        // -(X1, Y1, Z1) = (X1, -Y1, Z1)
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      }
    }, {
      key: "add",
      value: function add(p) {
        assert$4(p instanceof Point);
        if (p.type === types$1.AFFINE) return this._mixedAdd(p);
        return this._add(p);
      }
    }, {
      key: "_add",
      value: function _add(p) {
        assert$4(p instanceof JPoint); // O + P = P

        if (this.isInfinity()) return p; // P + O = P

        if (p.isInfinity()) return this; // Z1 = 1, Z2 = 1

        if (this.zOne && p.zOne) return this._addAA(p); // Z1 = 1

        if (this.zOne) return p._addJA(this); // Z2 = 1

        if (p.zOne) return this._addJA(p);
        return this._addJJ(p);
      }
    }, {
      key: "_mixedAdd",
      value: function _mixedAdd(p) {
        assert$4(p instanceof ShortPoint); // O + P = P

        if (this.isInfinity()) return p.toJ(); // P + O = P

        if (p.isInfinity()) return this; // Z1 = 1, Z2 = 1

        if (this.zOne) return this._addAA(p);
        return this._addJA(p);
      }
    }, {
      key: "_addJJ",
      value: function _addJJ(p) {
        // No assumptions.
        // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-1998-cmo-2
        // 12M + 4S + 6A + 1*2 (implemented as: 12M + 4S + 7A)
        // Z1Z1 = Z1^2
        var z1z1 = this.z.redSqr(); // Z2Z2 = Z2^2

        var z2z2 = p.z.redSqr(); // U1 = X1 * Z2Z2

        var u1 = this.x.redMul(z2z2); // U2 = X2 * Z1Z1

        var u2 = p.x.redMul(z1z1); // S1 = Y1 * Z2 * Z2Z2

        var s1 = this.y.redMul(p.z).redMul(z2z2); // S2 = Y2 * Z1 * Z1Z1

        var s2 = p.y.redMul(this.z).redMul(z1z1); // H = U2 - U1

        var h = u2.redISub(u1); // r = S2 - S1

        var r = s2.redISub(s1); // H = 0

        if (h.isZero()) {
          if (!r.isZero()) return this.curve.jpoint();
          return this.dbl();
        } // HH = H^2


        var hh = h.redSqr(); // HHH = H * HH

        var hhh = h.redMul(hh); // V = U1 * HH

        var v = u1.redMul(hh); // X3 = r^2 - HHH - 2 * V

        var nx = r.redSqr().redISub(hhh).redISub(v).redISub(v); // Y3 = r * (V - X3) - S1 * HHH

        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(hhh)); // Z3 = Z1 * Z2 * H

        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "_addJA",
      value: function _addJA(p) {
        // Assumes Z2 = 1.
        // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-madd
        // 8M + 3S + 6A + 5*2 (implemented as: 8M + 3S + 7A + 4*2)
        // Z1Z1 = Z1^2
        var z1z1 = this.z.redSqr(); // U2 = X2 * Z1Z1

        var u2 = p.x.redMul(z1z1); // S2 = Y2 * Z1 * Z1Z1

        var s2 = p.y.redMul(this.z).redMul(z1z1); // H = U2 - X1

        var h = u2.redISub(this.x); // r = 2 * (S2 - Y1)

        var r = s2.redISub(this.y).redIMuln(2); // H = 0

        if (h.isZero()) {
          if (!r.isZero()) return this.curve.jpoint();
          return this.dbl();
        } // I = (2 * H)^2


        var i = h.redMuln(2).redSqr(); // J = H * I

        var j = h.redMul(i); // V = X1 * I

        var v = this.x.redMul(i); // X3 = r^2 - J - 2 * V

        var nx = r.redSqr().redISub(j).redISub(v).redISub(v); // Y3 = r * (V - X3) - 2 * Y1 * J

        var ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2)); // Z3 = 2 * Z1 * H

        var nz = this.z.redMul(h).redIMuln(2);
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "_addAA",
      value: function _addAA(p) {
        // Assumes Z1 = 1, Z2 = 1.
        // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-mmadd-2007-bl
        // 4M + 2S + 6A + 4*2 + 1*4 (implemented as: 4M + 2S + 7A + 3*2 + 1*4)
        // H = X2 - X1
        var h = p.x.redSub(this.x); // r = 2 * (Y2 - Y1)

        var r = p.y.redSub(this.y).redIMuln(2); // H = 0

        if (h.isZero()) {
          if (!r.isZero()) return this.curve.jpoint();
          return this.dbl();
        } // HH = H^2


        var hh = h.redSqr(); // I = 4 * HH

        var i = hh.redIMuln(4); // J = H * I

        var j = h.redMul(i); // V = X1 * I

        var v = this.x.redMul(i); // X3 = r^2 - J - 2 * V

        var nx = r.redSqr().redISub(j).redISub(v).redISub(v); // Y3 = r * (V - X3) - 2 * Y1 * J

        var ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2)); // Z3 = 2 * H

        var nz = h.redIMuln(2);
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "dbl",
      value: function dbl() {
        // P = O
        if (this.isInfinity()) return this; // Y1 = 0

        if (this.y.isZero()) return this.curve.jpoint(); // Z1 = 1

        if (this.zOne) return this._dblA(); // a = 0

        if (this.curve.zeroA) return this._dbl0(); // a = -3

        if (this.curve.threeA) return this._dbl3();
        return this._dblJ();
      }
    }, {
      key: "_dblJ",
      value: function _dblJ() {
        // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2
        // 3M + 6S + 4A + 1*a + 2*2 + 1*3 + 1*4 + 1*8
        // (implemented as: 3M + 6S + 5A + 1*a + 1*2 + 1*3 + 1*4 + 1*8)
        // XX = X1^2
        var xx = this.x.redSqr(); // YY = Y1^2

        var yy = this.y.redSqr(); // ZZ = Z1^2

        var zz = this.z.redSqr(); // S = 4 * X1 * YY

        var s = this.x.redMul(yy).redIMuln(4); // M = 3 * XX + a * ZZ^2

        var m = xx.redIMuln(3).redIAdd(this.curve.a.redMul(zz.redSqr())); // T = M^2 - 2 * S

        var t = m.redSqr().redISub(s).redISub(s); // X3 = T

        var nx = t; // Y3 = M * (S - T) - 8 * YY^2

        var ny = m.redMul(s.redISub(t)).redISub(yy.redSqr().redIMuln(8)); // Z3 = 2 * Y1 * Z1

        var nz = this.y.redMul(this.z).redIMuln(2);
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "_dblA",
      value: function _dblA() {
        // Assumes Z = 1.
        // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-mdbl-2007-bl
        // 1M + 5S + 7A + 3*2 + 1*3 + 1*8
        // (implemented as: 1M + 5S + 8A + 2*2 + 1*3 + 1*8)
        // XX = X1^2
        var xx = this.x.redSqr(); // YY = Y1^2

        var yy = this.y.redSqr(); // YYYY = YY^2

        var yyyy = yy.redSqr(); // + XYY2 = (X1 + YY)^2

        var xyy2 = yy.redIAdd(this.x).redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

        var s = xyy2.redISub(xx).redISub(yyyy).redIMuln(2); // M = 3 * XX + a

        var m = xx.redIMuln(3).redIAdd(this.curve.a); // T = M^2 - 2 * S

        var t = m.redSqr().redISub(s).redISub(s); // X3 = T

        var nx = t; // Y3 = M * (S - T) - 8 * YYYY

        var ny = m.redMul(s.redISub(t)).redISub(yyyy.redIMuln(8)); // Z3 = 2 * Y1

        var nz = this.y.redMuln(2);
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "_dbl0",
      value: function _dbl0() {
        // Assumes a = 0.
        // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
        // 2M + 5S + 6A + 3*2 + 1*3 + 1*8
        // (implemented as: 2M + 5S + 7A + 2*2 + 1*3 + 1*8)
        // A = X1^2
        var a = this.x.redSqr(); // B = Y1^2

        var b = this.y.redSqr(); // C = B^2

        var c = b.redSqr(); // + XB2 = (X1 + B)^2

        var xb2 = b.redIAdd(this.x).redSqr(); // D = 2 * ((X1 + B)^2 - A - C)

        var d = xb2.redISub(a).redISub(c).redIMuln(2); // E = 3 * A

        var e = a.redIMuln(3); // F = E^2

        var f = e.redSqr(); // X3 = F - 2 * D

        var nx = f.redISub(d).redISub(d); // Y3 = E * (D - X3) - 8 * C

        var ny = e.redMul(d.redISub(nx)).redISub(c.redIMuln(8)); // Z3 = 2 * Y1 * Z1

        var nz = this.y.redMul(this.z).redIMuln(2);
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "_dbl3",
      value: function _dbl3() {
        // Assumes a = -3.
        // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
        // 3M + 5S + 8A + 1*3 + 1*4 + 2*8
        // (implemented as: 3M + 5S + 8A + 1*2 + 1*3 + 1*4 + 1*8)
        // delta = Z1^2
        var delta = this.z.redSqr(); // gamma = Y1^2

        var gamma = this.y.redSqr(); // beta = X1 * gamma

        var beta = this.x.redMul(gamma); // + xmdelta = X1 - delta

        var xmdelta = this.x.redSub(delta); // + xpdelta = X1 + delta

        var xpdelta = this.x.redAdd(delta); // alpha = 3 * (X1 - delta) * (X1 + delta)

        var alpha = xmdelta.redMul(xpdelta).redIMuln(3); // + beta4 = 4 * beta

        var beta4 = beta.redIMuln(4); // + beta8 = 2 * beta4

        var beta8 = beta4.redMuln(2); // + gamma28 = 8 * gamma^2

        var gamma28 = gamma.redSqr().redIMuln(8); // X3 = alpha^2 - 8 * beta

        var nx = alpha.redSqr().redISub(beta8); // Z3 = (Y1 + Z1)^2 - gamma - delta

        var nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta); // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2

        var ny = alpha.redMul(beta4.redISub(nx)).redISub(gamma28);
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "dblp",
      value: function dblp(pow) {
        assert$4(pow >>> 0 === pow); // a = 0 or a = -3

        if (this.curve.zeroA || this.curve.threeA) return _get__default['default'](_getPrototypeOf__default['default'](JPoint.prototype), "dblp", this).call(this, pow); // m = 0

        if (pow === 0) return this; // P = O

        if (this.isInfinity()) return this;
        return this._dblp(pow);
      }
    }, {
      key: "_dblp",
      value: function _dblp(pow) {
        // Repeated point doubling (Jacobian coordinates).
        //
        // [GECC] Algorithm 3.23, Page 93, Section 3.2.
        //
        // Modified version of:
        //   https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2
        //
        // Divergences from the above formula are marked with diff notation.
        //
        // Implemented as:
        //   1M + 2S + 1*2 + N * (4M + 4S + 4A + 1*a + 1*3 + 2*2)
        //   e.g. N = 1 => 5M + 6S + 4A + 1*a + 1*3 + 3*2
        //
        // Repeated doubling also explained here:
        //   https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates
        //
        // Note that the above sources change:
        //   M = 3 * XX + a * ZZZZ
        // To:
        //   M = 3 * (XX - ZZZZ)
        //
        // In order to assume a = -3.
        var _this$curve3 = this.curve,
            a = _this$curve3.a,
            i2 = _this$curve3.i2; // Reuse results (y is always y*2).

        var x = this.x;
        var z = this.z; // + Y1 = Y1 * 2

        var y = this.y.redMuln(2); // + ZZZZ = Z1^4

        var zzzz = z.redPown(4);

        for (var i = 0; i < pow; i++) {
          // Y1 = 0
          if (y.isZero()) return this.curve.jpoint(); // XX = X1^2

          var xx = x.redSqr(); // YY = Y1^2

          var yy = y.redSqr(); // + YYYY = YY^2

          var yyyy = yy.redSqr(); // - M = 3 * XX + a * ZZ^2
          // + M = 3 * XX + a * ZZZZ

          var m = xx.redIMuln(3).redIAdd(a.redMul(zzzz)); // - S = 4 * X1 * YY
          // + S = X1 * YY

          var s = x.redMul(yy); // T = M^2 - 2 * S

          var t = m.redSqr().redISub(s).redISub(s); // X3 = T

          var nx = t; // - Y3 = M * (S - T) - 8 * YY^2
          // + Y3 = M * (S - T) * 2 - YYYY

          var ny = m.redMul(s.redISub(t)).redIMuln(2).redISub(yyyy); // Z3 = 2 * Y1 * Z1

          var nz = y.redMul(z); // + ZZZZ = ZZZZ * YYYY

          if (i + 1 < pow) zzzz = zzzz.redMul(yyyy); // + X1 = X3

          x = nx; // + Y1 = Y3

          y = ny; // + Z1 = Z3

          z = nz;
        }

        return this.curve.jpoint(x, y.redMul(i2), z);
      }
    }, {
      key: "uadd",
      value: function uadd(p) {
        assert$4(p instanceof Point);
        if (p.type === types$1.AFFINE) return this._uadd(p.toJ());
        return this._uadd(p);
      }
    }, {
      key: "_uadd",
      value: function _uadd(p) {
        // Strongly unified Jacobian addition (Brier and Joye).
        //
        // [SIDE2] Page 6, Section 3.
        // [SIDE3] Page 4, Section 3.
        //
        // The above documents use projective coordinates[1]
        // and have been modified for jacobian coordinates. A
        // further modification, taken from libsecp256k1[2],
        // handles the degenerate case of: x1 != x2, y1 = -y2.
        //
        // [1] https://hyperelliptic.org/EFD/g1p/auto-shortw-projective.html#addition-add-2002-bj
        // [2] https://github.com/bitcoin-core/secp256k1/blob/ee9e68c/src/group_impl.h#L525
        //
        // 11M + 8S + 7A + 1*a + 2*4 + 1*3 + 2*2 (a != 0)
        // 11M + 6S + 6A + 2*4 + 1*3 + 2*2 (a = 0)
        assert$4(p instanceof JPoint);
        var _this$curve4 = this.curve,
            zero = _this$curve4.zero,
            one = _this$curve4.one; // Z1Z1 = Z1^2

        var z1z1 = this.z.redSqr(); // Z2Z2 = Z2^2

        var z2z2 = p.z.redSqr(); // U1 = X1 * Z2Z2

        var u1 = this.x.redMul(z2z2); // U2 = X2 * Z1Z1

        var u2 = p.x.redMul(z1z1); // S1 = Y1 * Z2Z2 * Z2

        var s1 = this.y.redMul(z2z2).redMul(p.z); // S2 = Y2 * Z1Z1 * Z1

        var s2 = p.y.redMul(z1z1).redMul(this.z); // Z = Z1 * Z2

        var z = this.z.redMul(p.z); // T = U1 + U2

        var t = u1.redAdd(u2); // M = S1 + S2

        var m = s1.redAdd(s2); // R = T^2 - U1 * U2

        var r = t.redSqr().redISub(u1.redMul(u2)); // R = R + a * Z^4 (if a != 0)

        if (!this.curve.zeroA) {
          var zzzz = z.redPown(4); // Save some cycles for a = -3.

          if (this.curve.threeA) r.redIAdd(zzzz.redIMuln(-3));else r.redIAdd(this.curve.a.redMul(zzzz));
        } // Check for degenerate case (X1 != X2, Y1 = -Y2).


        var degenerate = m.czero() & r.czero(); // M = U1 - U2 (if degenerate)

        m.cinject(u1.redSub(u2), degenerate); // R = S1 - S2 (if degenerate)

        r.cinject(s1.redSub(s2), degenerate); // L = M^2

        var l = m.redSqr(); // G = T * L

        var g = t.redMul(l); // LL = L^2

        var ll = l.redSqr(); // LL = 0 (if degenerate)

        ll.cinject(zero, degenerate); // W = R^2

        var w = r.redSqr(); // F = Z * M

        var f = z.redMul(m); // H = 3 * G - 2 * W

        var h = g.redMuln(3).redISub(w).redISub(w); // X3 = 4 * (W - G)

        var nx = w.redISub(g).redIMuln(4); // Y3 = 4 * (R * H - LL)

        var ny = r.redMul(h).redISub(ll).redIMuln(4); // Z3 = 2 * F

        var nz = f.redIMuln(2); // Check for infinity.

        var inf1 = this.z.czero();
        var inf2 = p.z.czero();
        var inf3 = nz.czero() & ((inf1 | inf2) ^ 1); // Case 1: O + P = P

        nx.cinject(p.x, inf1);
        ny.cinject(p.y, inf1);
        nz.cinject(p.z, inf1); // Case 2: P + O = P

        nx.cinject(this.x, inf2);
        ny.cinject(this.y, inf2);
        nz.cinject(this.z, inf2); // Case 3: P + -P = O

        nx.cinject(one, inf3);
        ny.cinject(one, inf3);
        nz.cinject(zero, inf3);
        return this.curve.jpoint(nx, ny, nz);
      }
    }, {
      key: "udbl",
      value: function udbl() {
        var p = this._udbl();

        var inf = this.z.czero() | this.y.czero(); // Case 1 & 2: 2 * O = O, 2 * (X, 0) = O

        p.x.cinject(this.curve.one, inf);
        p.y.cinject(this.curve.one, inf);
        p.z.cinject(this.curve.zero, inf);
        return p;
      }
    }, {
      key: "_udbl",
      value: function _udbl() {
        // a = 0
        if (this.curve.zeroA) return this._dbl0(); // a = -3

        if (this.curve.threeA) return this._dbl3();
        return this._dblJ();
      }
    }, {
      key: "zaddu",
      value: function zaddu(p) {
        // Co-Z addition with update (ZADDU).
        // [COZ] Algorithm 19, Page 15, Appendix C.
        // 5M + 2S + 7A
        assert$4(p instanceof JPoint); // H = X1 - X2

        var h = this.x.redSub(p.x); // R = Y1 - Y2

        var r = this.y.redSub(p.y); // HH = H^2

        var hh = h.redSqr(); // V1 = X1 * HH

        var v1 = this.x.redMul(hh); // V2 = X2 * HH

        var v2 = p.x.redMul(hh); // X4 = V1

        var x4 = v1; // X3 = R^2 - V1 - V2

        var x3 = r.redSqr().redISub(v1).redISub(v2); // Y4 = Y1 * (V1 - V2)

        var y4 = this.y.redMul(v1.redSub(v2)); // Y3 = R * (X4 - X3) - Y4

        var y3 = r.redMul(x4.redSub(x3)).redISub(y4); // Z4 = Z1 * H

        var z4 = this.z.redMul(h); // Z3 = Z4

        var z3 = z4; // R = (X3, Y3, Z3)
        // P = (X4, Y4, Z4)

        return [this.curve.jpoint(x3, y3, z3), this.curve.jpoint(x4, y4, z4)];
      }
    }, {
      key: "zaddc",
      value: function zaddc(p) {
        // Co-Z addition with conjugate (ZADDC).
        // [COZ] Algorithm 20, Page 15, Appendix C.
        // 6M + 3S + 14A + 1*2
        assert$4(p instanceof JPoint); // H = X1 - X2

        var h = this.x.redSub(p.x); // R = Y1 - Y2

        var r = this.y.redSub(p.y); // M = Y1 + Y2

        var m = this.y.redAdd(p.y); // HH = H^2

        var hh = h.redSqr(); // V1 = X1 * HH

        var v1 = this.x.redMul(hh); // V2 = X2 * HH

        var v2 = p.x.redMul(hh); // X4 = (Y1 + Y2)^2 - V1 - V2

        var x4 = m.redSqr().redISub(v1).redISub(v2); // X3 = R^2 - V1 - V2

        var x3 = r.redSqr().redISub(v1).redISub(v2); // Y = Y1 * (V2 - V1)

        var y = this.y.redMul(v2.redISub(v1)); // Z = R + 2 * Y2

        var z = p.y.redMuln(2).redIAdd(r); // I = V1 - X4

        var i = v1.redISub(x4); // J = X4 + I - X3

        var j = x4.redAdd(i).redISub(x3); // Y4 = Z * I + Y

        var y4 = z.redMul(i).redIAdd(y); // Y3 = R * J + Y

        var y3 = r.redMul(j).redIAdd(y); // Z4 = Z1 * H

        var z4 = this.z.redMul(h); // Z3 = Z4

        var z3 = z4; // R = (X3, Y3, Z3)
        // S = (X4, Y4, Z4)

        return [this.curve.jpoint(x3, y3, z3), this.curve.jpoint(x4, y4, z4)];
      }
    }, {
      key: "zdblu",
      value: function zdblu() {
        // Co-Z doubling with update (DBLU).
        // [COZ] Algorithm 21, Page 15, Appendix C.
        //
        // 1M + 5S + 8A + 4*2 + 1*8
        //
        // Note that the original formula assumed Z1=1.
        // We have modified it to allow for scaled points.
        //
        // New Cost: 2M + 5S + 8A + 1*a + 1*3 + 2*2 + 1*8
        // XX = X1^2
        var xx = this.x.redSqr(); // YY = Y1^2

        var yy = this.y.redSqr(); // YYYY = YY^2

        var yyyy = yy.redSqr(); // S = (X1 + YY)^2

        var s = this.x.redAdd(yy).redSqr(); // M = 3 * XX

        var m = xx.redMuln(3); // M = M + a * Z1^4 (if a != 0)

        if (!this.curve.zeroA) {
          var zzzz = this.z.redPown(4); // Save some cycles for a = -3.

          if (this.curve.threeA) m.redIAdd(zzzz.redIMuln(-3));else m.redIAdd(this.curve.a.redMul(zzzz));
        } // X4 = 2 * (S - XX - YYYY)


        var x4 = s.redISub(xx).redISub(yyyy).redIMuln(2); // X3 = M^2 - X4 - X4

        var x3 = m.redSqr().redISub(x4).redISub(x4); // Y4 = 8 * YYYY

        var y4 = yyyy.redIMuln(8); // Y3 = (X4 - X3) * M - Y4

        var y3 = x4.redSub(x3).redMul(m).redISub(y4); // Z4 = 2 * (Y1 * Z1)

        var z4 = this.y.redMul(this.z).redIMuln(2); // Z3 = Z4

        var z3 = z4; // R = (X3, Y3, Z3)
        // P = (X4, Y4, Z4)

        return [this.curve.jpoint(x3, y3, z3), this.curve.jpoint(x4, y4, z4)];
      }
    }, {
      key: "recover",
      value: function recover(x1, z1, x2, z2) {
        return this.toP().recover(x1, z1, x2, z2);
      }
    }, {
      key: "getX",
      value: function getX() {
        if (this.isInfinity()) throw new Error('Invalid point.');
        this.normalize();
        return this.x.fromRed();
      }
    }, {
      key: "getY",
      value: function getY() {
        if (this.isInfinity()) throw new Error('Invalid point.');
        this.normalize();
        return this.y.fromRed();
      }
    }, {
      key: "eq",
      value: function eq(p) {
        assert$4(p instanceof JPoint); // P = Q

        if (this === p) return true; // P = O

        if (this.isInfinity()) return p.isInfinity(); // Q = O

        if (p.isInfinity()) return false; // Z1 = Z2

        if (this.z.eq(p.z)) {
          return this.x.eq(p.x) && this.y.eq(p.y);
        } // X1 * Z2^2 == X2 * Z1^2


        var zz1 = this.z.redSqr();
        var zz2 = p.z.redSqr();
        var x1 = this.x.redMul(zz2);
        var x2 = p.x.redMul(zz1);
        if (!x1.eq(x2)) return false; // Y1 * Z2^3 == Y2 * Z1^3

        var zzz1 = zz1.redMul(this.z);
        var zzz2 = zz2.redMul(p.z);
        var y1 = this.y.redMul(zzz2);
        var y2 = p.y.redMul(zzz1);
        return y1.eq(y2);
      }
    }, {
      key: "cmp",
      value: function cmp(point) {
        assert$4(point instanceof JPoint);
        var inf1 = this.isInfinity();
        var inf2 = point.isInfinity();
        if (inf1 && !inf2) return -1;
        if (!inf1 && inf2) return 1;
        if (inf1 && inf2) return 0;
        return this.order().cmp(point.order()) || this.getX().cmp(point.getX()) || this.getY().cmp(point.getY());
      }
    }, {
      key: "isInfinity",
      value: function isInfinity() {
        // Z1 = 0
        return this.z.isZero();
      }
    }, {
      key: "isOrder2",
      value: function isOrder2() {
        if (this.isInfinity()) return false;
        return this.y.isZero();
      }
    }, {
      key: "isOdd",
      value: function isOdd() {
        if (this.isInfinity()) return false;
        this.normalize();
        return this.y.redIsOdd();
      }
    }, {
      key: "isEven",
      value: function isEven() {
        if (this.isInfinity()) return false;
        this.normalize();
        return this.y.redIsEven();
      }
    }, {
      key: "isSquare",
      value: function isSquare() {
        if (this.isInfinity()) return false;
        return this.y.redMul(this.z).redJacobi() !== -1;
      }
    }, {
      key: "eqX",
      value: function eqX(x) {
        // Verify that integer `x` is equal to field
        // element `x` by scaling it by our z coordinate.
        // This optimization is mentioned in and used for
        // bip-schnorr[1]. This avoids having to affinize
        // the resulting point during verification.
        //
        // [1] [SCHNORR] "Optimizations".
        assert$4(x instanceof bnBrowser);
        assert$4(!x.red);
        if (this.isInfinity()) return false;
        var zz = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zz);
        return this.x.eq(rx);
      }
    }, {
      key: "eqR",
      value: function eqR(x) {
        // Similar to the optimization above, this
        // optimization, suggested by Maxwell[1],
        // compares an integer to an X coordinate
        // by scaling it.
        //
        // Since a signature's R value is modulo N
        // in ECDSA, we may be dealing with an R
        // value greater than N in actuality.
        //
        // If the equality check fails, we can
        // scale N itself by Z and add it to the
        // X field element (up until a certain
        // limit) and repeat the check.
        //
        // If P is more than 100 times larger than
        // N, we don't gain much here, so we just
        // affinize and do the comparison.
        //
        // [1] https://github.com/bitcoin-core/secp256k1/commit/ce7eb6f
        assert$4(x instanceof bnBrowser);
        assert$4(!x.red);
        if (!this.curve.smallGap) return this.toP().eqR(x);
        if (this.isInfinity()) return false;
        if (x.cmp(this.curve.p) >= 0) return false;
        var zz = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zz);
        if (this.x.eq(rx)) return true;
        if (this.curve.highOrder) return false;
        if (x.cmp(this.curve.pmodn) >= 0) return false;
        var rn = this.curve.redN.redMul(zz);
        rx.redIAdd(rn);
        return this.x.eq(rx);
      }
    }, {
      key: "toP",
      value: function toP() {
        // P = O
        if (this.isInfinity()) return this.curve.point();
        this.normalize(); // (X3, Y3) = (X1 / Z1^2, Y1 / Z1^3)

        return this.curve.point(this.x, this.y);
      }
    }, {
      key: "toJ",
      value: function toJ() {
        return this;
      }
    }, {
      key: "encode",
      value: function encode(compact) {
        return this.toP().encode(compact);
      }
    }, {
      key: "encodeX",
      value: function encodeX() {
        return this.toP().encodeX();
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        return this.toP().toJSON(pre);
      }
    }, {
      key: "toPretty",
      value: function toPretty() {
        return this.toP().toPretty();
      }
    }, {
      key: custom$2,
      value: function value() {
        if (this.isInfinity()) return '<JPoint: Infinity>';
        return '<JPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';
      }
    }], [{
      key: "decode",
      value: function decode(curve, bytes) {
        return ShortPoint.decode(curve, bytes).toJ();
      }
    }, {
      key: "decodeEven",
      value: function decodeEven(curve, bytes) {
        return ShortPoint.decodeEven(curve, bytes).toJ();
      }
    }, {
      key: "decodeSquare",
      value: function decodeSquare(curve, bytes) {
        return ShortPoint.decodeSquare(curve, bytes).toJ();
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(curve, json) {
        return ShortPoint.fromJSON(curve, json).toJ();
      }
    }]);

    return JPoint;
  }(Point);
  /**
   * MontCurve
   */


  var MontCurve = /*#__PURE__*/function (_Curve2) {
    _inherits__default['default'](MontCurve, _Curve2);

    var _super4 = _createSuper$c(MontCurve);

    function MontCurve(conf) {
      var _this5;

      _classCallCheck__default['default'](this, MontCurve);

      _this5 = _super4.call(this, MontPoint, 'mont', conf);
      _this5.a = bnBrowser.fromJSON(conf.a).toRed(_this5.red);
      _this5.b = bnBrowser.fromJSON(conf.b).toRed(_this5.red);
      _this5.bi = _this5.b.redInvert();
      _this5.a2 = _this5.a.redAdd(_this5.two);
      _this5.a24 = _this5.a2.redMul(_this5.i4);
      _this5.a3 = _this5.a.redMul(_this5.i3);
      _this5.a0 = _this5.a.redMul(_this5.bi);
      _this5.b0 = _this5.bi.redSqr();

      _this5._finalize(conf);

      return _this5;
    }

    _createClass__default['default'](MontCurve, [{
      key: "_short",
      value: function _short(a0, odd) {
        // Montgomery->Short Weierstrass Equivalence.
        //
        // [MONT2] "Equivalence with Weierstrass curves".
        //
        // Transformation:
        //
        //   a = (3 - A^2) / (3 * B^2)
        //   b = (2 * A^3 - 9 * A) / (27 * B^3)
        var a = this.a,
            b = this.b,
            three = this.three;
        var a2 = a.redSqr();
        var a3 = a2.redMul(a);
        var b2 = b.redSqr();
        var b3 = b2.redMul(b);
        var n0 = three.redSub(a2);
        var d0 = b2.redMuln(3);
        var n1 = a3.redMuln(2).redISub(a.redMuln(9));
        var d1 = b3.redMuln(27);
        var wa = n0.redDiv(d0);
        var wb = n1.redDiv(d1);
        if (a0 != null) return ShortCurve._isomorphism(wa, wb, a0, odd);
        return [wa, wb];
      }
    }, {
      key: "_mont",
      value: function _mont(b0) {
        return MontCurve._isomorphism(this.a, this.b, b0);
      }
    }, {
      key: "_edwards",
      value: function _edwards(a0) {
        var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        // Montgomery->Twisted Edwards Transformation.
        //
        // [MONT1] Page 11, Section 4.3.5.
        // [TWISTED] Theorem 3.2, Page 4, Section 3.
        //
        // Equivalence:
        //
        //   a = (A + 2) / B
        //   d = (A - 2) / B
        //
        // Isomorphism:
        //
        //   a = a'
        //   d = a' * (A - 2) / (A + 2)
        //
        // Where ((A + 2) / (B * a')) is square.
        //
        // If `d` is square, we can usually find
        // a complete curve by using the `invert`
        // option. This will create an isomorphism
        // chain of: M(A,B)->E(a,d)->E(d,a).
        //
        // The equivalence between E(a,d) and
        // E(d,a) is:
        //
        //   (x, y) = (x, 1 / y)
        //
        // Meaning our map to E(d,a) is:
        //
        //   x = u / v
        //   y = 1 / ((u - 1) / (u + 1))
        //     = (u + 1) / (u - 1)
        assert$4(typeof invert === 'boolean');
        var two = this.two,
            bi = this.bi;
        var a = this.a.redAdd(two).redMul(bi);
        var d = this.a.redSub(two).redMul(bi);
        if (invert) a.swap(d);
        if (a0 != null) return EdwardsCurve._isomorphism(a, d, a0);
        return [a, d];
      }
    }, {
      key: "_scaleShort",
      value: function _scaleShort(curve) {
        assert$4(curve instanceof ShortCurve);

        var _curve$_scale3 = curve._scale(this),
            _curve$_scale4 = _slicedToArray__default['default'](_curve$_scale3, 2),
            u2 = _curve$_scale4[0],
            u3 = _curve$_scale4[1];

        return [this.field(u2.redInvert()), this.field(u3.redInvert())];
      }
    }, {
      key: "_scaleMont",
      value: function _scaleMont(curve) {
        // We can extract the isomorphism factor with:
        //
        //   c = +-sqrt(B / B')
        //
        // If base points are available, we can do:
        //
        //   c = v' / v
        assert$4(curve instanceof MontCurve);
        if (this.g.isInfinity() || curve.g.isInfinity()) return this.field(curve.b).redDivSqrt(this.b);
        return this.g.y.redDiv(this.field(curve.g.y));
      }
    }, {
      key: "_scaleEdwards",
      value: function _scaleEdwards(curve, invert) {
        // We _could_ do something like:
        //
        //   B = 4 / (a - d)
        //   c = +-sqrt(B / B')
        //
        // Which can be reduced to:
        //
        //   c = +-sqrt(4 / ((a - d) * B'))
        //
        // If base points are available:
        //
        //   v = u' / x
        //   c = v' / v
        //
        // Which can be reduced to:
        //
        //   c = v' * x / u'
        //
        // However, the way our maps are
        // written, we can re-use the Edwards
        // isomorphism factor when going the
        // other direction.
        assert$4(curve instanceof EdwardsCurve);

        var c = curve._scale(this, invert);

        return this.field(c);
      }
    }, {
      key: "_solveY0",
      value: function _solveY0(x) {
        assert$4(x instanceof bnBrowser); // y^2 = x^3 + A * x^2 + B * x

        var a = this.a0;
        var b = this.b0;
        var x2 = x.redSqr();
        var x3 = x2.redMul(x);
        var y2 = x3.redIAdd(a.redMul(x2)).redIAdd(b.redMul(x));
        return y2;
      }
    }, {
      key: "_elligator2",
      value: function _elligator2(u) {
        // Elligator 2.
        //
        // Distribution: 1/2.
        //
        // [ELL2] Page 11, Section 5.2.
        // [H2EC] "Elligator 2 Method".
        //        "Mappings for Montgomery curves".
        // [SAFE] "Indistinguishability from uniform random strings".
        //
        // Assumptions:
        //
        //   - y^2 = x^3 + A * x^2 + B * x.
        //   - A != 0, B != 0.
        //   - A^2 - 4 * B is non-zero and non-square in F(p).
        //   - Let z be a non-square in F(p).
        //   - u != +-sqrt(-1 / z).
        //
        // Note that Elligator 2 is defined over the form:
        //
        //   y'^2 = x'^3 + A' * x'^2 + B' * x'
        //
        // Instead of:
        //
        //   B * y^2 = x^3 + A * x^2 + x
        //
        // Where:
        //
        //   A' = A / B
        //   B' = 1 / B^2
        //   x' = x / B
        //   y' = y / B
        //
        // And:
        //
        //   x = B * x'
        //   y = B * y'
        //
        // This is presumably the result of Elligator 2
        // being designed in long Weierstrass form. If
        // we want to support B != 1, we need to do the
        // conversion.
        //
        // Map:
        //
        //   g(x) = x^3 + A * x^2 + B * x
        //   x1 = -A / (1 + z * u^2)
        //   x1 = -A, if x1 = 0
        //   x2 = -x1 - A
        //   x = x1, if g(x1) is square
        //     = x2, otherwise
        //   y = sign(u) * abs(sqrt(g(x)))
        var lhs = this.a0.redNeg();
        var rhs = this.one.redAdd(this.z.redMul(u.redSqr()));
        rhs.cinject(this.one, rhs.czero());
        var x1 = lhs.redMul(rhs.redFermat());
        var x2 = x1.redNeg().redISub(this.a0);

        var y1 = this._solveY0(x1);

        var y2 = this._solveY0(x2);

        var alpha = y1.redIsSquare() | 0;
        var x0 = x1.cinject(x2, alpha ^ 1);
        var y0 = y1.cinject(y2, alpha ^ 1).redSqrt();
        y0.cinject(y0.redNeg(), y0.redIsOdd() ^ u.redIsOdd());
        var x = this.b.redMul(x0);
        var y = this.b.redMul(y0);
        return this.point(x, y);
      }
    }, {
      key: "_invert2",
      value: function _invert2(p, hint) {
        // Inverting the Map (Elligator 2).
        //
        // [ELL2] Page 12, Section 5.3.
        //
        // Assumptions:
        //
        //   - -z * x * (x + A) is square in F(p).
        //   - If r = 1 then x != 0.
        //   - If r = 2 then x != -A.
        //
        // Map:
        //
        //   u1 = -(x + A) / (x * z)
        //   u2 = -x / ((x + A) * z)
        //   r = random integer in [1,2]
        //   u = sign(y) * abs(sqrt(ur))
        //
        // Note that `0 / 0` can only occur if `A == 0`
        // (this violates the assumptions of Elligator 2).
        var x = p.x,
            y = p.y;
        var r = hint & 1;
        var x0 = x.redMul(this.bi);
        var y0 = y.redMul(this.bi);
        var n = x0.redAdd(this.a0);
        var d = x0;
        n.cswap(d, r);
        var lhs = n.redINeg();
        var rhs = d.redMul(this.z);

        var _divSqrt5 = divSqrt(lhs, rhs),
            _divSqrt6 = _slicedToArray__default['default'](_divSqrt5, 2),
            sqr = _divSqrt6[0],
            u = _divSqrt6[1];

        u.cinject(u.redNeg(), u.redIsOdd() ^ y0.redIsOdd());
        if (!sqr) throw new Error('Invalid point.');
        return u;
      }
    }, {
      key: "_constMul",
      value: function _constMul(p, k, rng) {
        // Use the single-coordinate ladder in
        // combination with y-coordinate recovery
        // to compute an affine point.
        //
        // There are a few edge cases here, some
        // of them documented by Mike Hamburg[1].
        //
        // There are two primary edge cases here:
        //
        //   1. P * k = O where k = n - 1.
        //   2. P * k = O where P is small order.
        //
        // The first occurs due to the fact that
        // the Okeya-Sakurai formula requires
        // one to compute both Q and Q+P. In the
        // case of k=n-1, Q+P becomes infinity.
        //
        // In other words:
        //
        //   Q2 = P * (n - 1) + P = O
        //
        // The second edge case is a side effect
        // of the differential addition used in
        // the ladder. This covers the first two
        // cases mentioned by Hamburg.
        //
        // [1] https://tinyurl.com/y4q2dey9
        assert$4(p instanceof MontPoint);
        var x = p.toX();

        var _x$ladderConst = x.ladderConst(k, rng),
            _x$ladderConst2 = _slicedToArray__default['default'](_x$ladderConst, 2),
            a = _x$ladderConst2[0],
            b = _x$ladderConst2[1];

        var q = p.recover(a, b);
        return k.isNeg() ? q.neg() : q;
      }
    }, {
      key: "isElliptic",
      value: function isElliptic() {
        var a2 = this.a.redSqr();
        var d = this.b.redMul(a2.redSub(this.four)); // B * (A^2 - 4) != 0

        return !d.isZero();
      }
    }, {
      key: "jinv",
      value: function jinv() {
        // [MONT3] Page 3, Section 2.
        var a = this.a,
            three = this.three,
            four = this.four;
        var a2 = a.redSqr();
        var t0 = a2.redSub(three);
        var lhs = t0.redPown(3).redIMuln(256);
        var rhs = a2.redSub(four);
        if (rhs.isZero()) throw new Error('Curve is not elliptic.'); // (256 * (A^2 - 3)^3) / (A^2 - 4)

        return lhs.redDiv(rhs).fromRed();
      }
    }, {
      key: "point",
      value: function point(x, y) {
        var inf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return new MontPoint(this, x, y, inf);
      }
    }, {
      key: "jpoint",
      value: function jpoint(x, y, z) {
        assert$4(x == null && y == null && z == null);
        return this.point();
      }
    }, {
      key: "xpoint",
      value: function xpoint(x, z) {
        return new XPoint(this, x, z);
      }
    }, {
      key: "solveY2",
      value: function solveY2(x) {
        // [MONT3] Page 3, Section 2.
        // https://hyperelliptic.org/EFD/g1p/auto-montgom.html
        assert$4(x instanceof bnBrowser); // B * y^2 = x^3 + A * x^2 + x

        var x2 = x.redSqr();
        var x3 = x2.redMul(x);
        var by2 = x3.redIAdd(this.a.redMul(x2)).redIAdd(x);
        var y2 = by2.redMul(this.bi);
        return y2;
      }
    }, {
      key: "validate",
      value: function validate(point) {
        assert$4(point instanceof MontPoint);
        if (point.isInfinity()) return true;
        var x = point.x,
            y = point.y;
        var y2 = this.solveY2(x);
        return y.redSqr().eq(y2);
      }
    }, {
      key: "pointFromX",
      value: function pointFromX(x) {
        var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        assert$4(x instanceof bnBrowser);
        assert$4(sign == null || typeof sign === 'boolean');
        if (!x.red) x = x.toRed(this.red);
        var y = this.solveY(x);

        if (sign != null) {
          if (y.isZero() && sign) throw new Error('Invalid point.');
          if (y.redIsOdd() !== sign) y.redINeg();
        }

        return this.point(x, y);
      }
    }, {
      key: "isIsomorphic",
      value: function isIsomorphic(curve, invert) {
        // [MONT3] Page 3, Section 2.1.
        assert$4(curve instanceof Curve);
        if (!curve.p.eq(this.p)) return false; // M(A,B) <-> M(A,B')

        if (curve.type === 'mont') {
          var a = this.field(curve.a);
          var b = this.field(curve.b); // A' = A

          if (!this.a.eq(a)) return false; // B' != 0

          if (this.b.isZero()) return false; // jacobi(B / B') = 1

          var c = b.redDiv(this.b);
          return c.redJacobi() === 1;
        }

        return curve.isIsomorphic(this, invert);
      }
    }, {
      key: "isIsogenous",
      value: function isIsogenous(curve) {
        assert$4(curve instanceof Curve);
        if (curve.type === 'mont') return false;
        return curve.isIsogenous(this);
      }
    }, {
      key: "pointFromShort",
      value: function pointFromShort(point) {
        // [ALT] Appendix E.2 (Switching between Alternative Representations).
        // [MONT2] "Equivalence with Weierstrass curves"
        assert$4(point instanceof ShortPoint);

        if (this.isIsomorphic(point.curve)) {
          // Equivalence for E(a,b)->M(A,B):
          //
          //   u = B * x - A / 3
          //   v = B * y
          //
          // Undefined if ((u^3 + A * u^2 + u) / B) is not square.
          if (point.isInfinity()) return this.point();
          var a3 = this.a3,
              b = this.b;

          var _this$_scale13 = this._scale(point.curve),
              _this$_scale14 = _slicedToArray__default['default'](_this$_scale13, 2),
              u2 = _this$_scale14[0],
              u3 = _this$_scale14[1];

          var x = this.field(point.x).redMul(u2);
          var y = this.field(point.y).redMul(u3);
          var u = b.redMul(x).redISub(a3);
          var v = b.redMul(y);
          return this.point(u, v);
        }

        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromMont",
      value: function pointFromMont(point) {
        // [MONT3] Page 3, Section 2.1.
        assert$4(point instanceof MontPoint);

        if (this.isIsomorphic(point.curve)) {
          // Isomorphic maps for M(A,B)<->M(A,B'):
          //
          //   u' = u
          //   v' = +-sqrt(B / B') * v
          //
          // Undefined if (B / B') is not square.
          if (point.isInfinity()) return this.point();

          var c = this._scale(point.curve);

          var u = this.field(point.x);
          var v = this.field(point.y);
          var nu = u;
          var nv = c.redMul(v);
          return this.point(nu, nv);
        }

        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromEdwards",
      value: function pointFromEdwards(point) {
        // [RFC7748] Section 4.1 & 4.2.
        // [MONT3] Page 6, Section 2.5.
        // [TWISTED] Theorem 3.2, Page 4, Section 3.
        assert$4(point instanceof EdwardsPoint);
        assert$4(point.curve.p.eq(this.p)); // Edwards `x`, `y`, `z`.

        var x = this.field(point.x);
        var y = this.field(point.y);
        var z = this.field(point.z);

        if (this.isIsogenous(point.curve)) {
          // 4-isogeny maps for E(1,d)->M(2-4d,1):
          //
          //   u = y^2 / x^2
          //   v = (2 - x^2 - y^2) * y / x^3
          //
          // Undefined for x = 0.
          //
          // Exceptional Cases:
          //   - (0, 1) -> O
          //   - (0, -1) -> (0, 0)
          //
          // Unexceptional Cases:
          //   - (+-1, 0) -> (0, 0)
          if (point.isInfinity()) return this.point();
          if (point.x.isZero()) return this.point(this.zero, this.zero);
          var c = z.redSqr().redIMuln(2);
          var uu = y.redSqr();
          var uz = x.redSqr();
          var vv = c.redISub(uz).redISub(uu).redMul(y);
          var vz = uz.redMul(x);
          return this.cpoint(uu, uz, vv, vz);
        }

        if (this.isIsomorphic(point.curve, true)) {
          // Isomorphic maps for E(d,a)->M(A,B):
          //
          //   u = (y + 1) / (y - 1)
          //   v = +-sqrt((A - 2) / (B * a)) * u / x
          //
          // Undefined for x = 0 or y = 1.
          //
          // Exceptional Cases:
          //   - (0, 1) -> O
          //   - (0, -1) -> (0, 0)
          //
          // Unexceptional Cases:
          //   - (+-sqrt(1 / a), 0) -> (-1, +-sqrt((A - 2) / B))
          if (point.isInfinity()) return this.point();
          if (point.x.isZero()) return this.point(this.zero, this.zero);

          var _c = this._scale(point.curve, true);

          var _uu = y.redAdd(z);

          var _uz = y.redSub(z);

          var _vv = _c.redMul(z).redMul(_uu);

          var _vz = x.redMul(_uz);

          return this.cpoint(_uu, _uz, _vv, _vz);
        }

        if (this.isIsomorphic(point.curve, false)) {
          // Isomorphic maps for E(a,d)->M(A,B):
          //
          //   u = (1 + y) / (1 - y)
          //   v = +-sqrt((A + 2) / (B * a)) * u / x
          //
          // Undefined for x = 0 or y = 1.
          //
          // Exceptional Cases:
          //   - (0, 1) -> O
          //   - (0, -1) -> (0, 0)
          //
          // Unexceptional Cases:
          //   - (+-sqrt(1 / a), 0) -> (1, +-sqrt((A + 2) / B))
          if (point.isInfinity()) return this.point();
          if (point.x.isZero()) return this.point(this.zero, this.zero);

          var _c2 = this._scale(point.curve, false);

          var _uu2 = z.redAdd(y);

          var _uz2 = z.redSub(y);

          var _vv2 = _c2.redMul(z).redMul(_uu2);

          var _vz2 = x.redMul(_uz2);

          return this.cpoint(_uu2, _uz2, _vv2, _vz2);
        }

        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromUniform",
      value: function pointFromUniform(u) {
        assert$4(u instanceof bnBrowser); // z = 0 or A = 0

        if (this.z.isZero() || this.a.isZero()) throw new Error('Not implemented.');
        return this._elligator2(u);
      }
    }, {
      key: "pointToUniform",
      value: function pointToUniform(p, hint) {
        assert$4(p instanceof MontPoint);
        assert$4(hint >>> 0 === hint); // z = 0 or A = 0

        if (this.z.isZero() || this.a.isZero()) throw new Error('Not implemented.'); // P = O

        if (p.isInfinity()) throw new Error('Invalid point.'); // Add a random torsion component.

        var i = (hint >>> 4 & 15) % this.torsion.length;
        var q = p.add(this.torsion[i]);
        return this._invert2(q, hint);
      }
    }, {
      key: "decodePoint",
      value: function decodePoint(bytes, sign) {
        return MontPoint.decode(this, bytes, sign);
      }
    }, {
      key: "encodeX",
      value: function encodeX(point) {
        assert$4(point instanceof XPoint);
        return point.encode();
      }
    }, {
      key: "decodeX",
      value: function decodeX(bytes) {
        return XPoint.decode(this, bytes);
      }
    }, {
      key: "toShort",
      value: function toShort(a0, odd) {
        var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var _this$_short3 = this._short(a0, odd),
            _this$_short4 = _slicedToArray__default['default'](_this$_short3, 2),
            a = _this$_short4[0],
            b = _this$_short4[1];

        var curve = new ShortCurve({
          red: this.red,
          prime: this.prime,
          p: this.p,
          a: a,
          b: b,
          n: this.n,
          h: this.h
        });

        if (sign != null) {
          var _curve$_scale5 = curve._scale(this),
              _curve$_scale6 = _slicedToArray__default['default'](_curve$_scale5, 2),
              u3 = _curve$_scale6[1];

          if (u3.redIsOdd() !== sign) u3.redINeg();
        }

        if (!this.g.isInfinity()) curve.g = curve.pointFromMont(this.g);

        for (var i = 0; i < this.h.word(0); i++) {
          curve.torsion[i] = curve.pointFromMont(this.torsion[i]);
        }

        return curve;
      }
    }, {
      key: "toMont",
      value: function toMont(b0) {
        var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var _this$_mont3 = this._mont(b0),
            _this$_mont4 = _slicedToArray__default['default'](_this$_mont3, 2),
            a = _this$_mont4[0],
            b = _this$_mont4[1];

        var curve = new MontCurve({
          red: this.red,
          prime: this.prime,
          p: this.p,
          a: a,
          b: b,
          n: this.n,
          h: this.h,
          z: this.z
        });

        if (sign != null) {
          var c = curve._scale(this);

          if (c.redIsOdd() !== sign) c.redINeg();
        }

        if (!this.g.isInfinity()) curve.g = curve.pointFromMont(this.g);

        for (var i = 0; i < this.h.word(0); i++) {
          curve.torsion[i] = curve.pointFromMont(this.torsion[i]);
        }

        return curve;
      }
    }, {
      key: "toEdwards",
      value: function toEdwards(a0, invert) {
        var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var _this$_edwards3 = this._edwards(a0, invert),
            _this$_edwards4 = _slicedToArray__default['default'](_this$_edwards3, 2),
            a = _this$_edwards4[0],
            d = _this$_edwards4[1];

        var curve = new EdwardsCurve({
          red: this.red,
          prime: this.prime,
          p: this.p,
          a: a,
          d: d,
          n: this.n,
          h: this.h,
          z: this.z
        });

        if (sign != null) {
          var c = curve._scale(this, invert);

          if (c.redIsOdd() !== sign) c.redINeg();
        }

        if (!this.g.isInfinity()) {
          curve.g = curve.pointFromMont(this.g);
          curve.g.normalize();
        }

        if (curve.isComplete()) {
          for (var i = 0; i < this.h.word(0); i++) {
            curve.torsion[i] = curve.pointFromMont(this.torsion[i]);
            curve.torsion[i].normalize();
          }
        }

        return curve;
      }
    }, {
      key: "pointFromJSON",
      value: function pointFromJSON(json) {
        return MontPoint.fromJSON(this, json);
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        var json = _get__default['default'](_getPrototypeOf__default['default'](MontCurve.prototype), "toJSON", this).call(this, pre);

        json.a = this.a.fromRed().toJSON();
        json.b = this.b.fromRed().toJSON();
        return json;
      }
    }], [{
      key: "_isomorphism",
      value: function _isomorphism(curveA, curveB, customB) {
        // Montgomery Isomorphism.
        //
        // [MONT3] Page 3, Section 2.1.
        //
        // Transformation:
        //
        //   A' = A
        //   B' = B'
        //
        // Where (B / B') is square.
        assert$4(curveA instanceof bnBrowser);
        assert$4(curveB instanceof bnBrowser);
        assert$4(customB instanceof bnBrowser);
        var a = curveA.clone();
        var b = customB.clone();
        var c = curveB.redDiv(customB);
        if (c.redJacobi() !== 1) throw new Error('Invalid `b` coefficient.');
        return [a, b];
      }
    }]);

    return MontCurve;
  }(Curve);
  /**
   * MontPoint
   */


  var MontPoint = /*#__PURE__*/function (_Point3) {
    _inherits__default['default'](MontPoint, _Point3);

    var _super5 = _createSuper$c(MontPoint);

    function MontPoint(curve, x, y, inf) {
      var _this6;

      _classCallCheck__default['default'](this, MontPoint);

      assert$4(curve instanceof MontCurve);
      _this6 = _super5.call(this, curve, types$1.AFFINE);
      _this6.x = _this6.curve.zero;
      _this6.y = _this6.curve.zero;
      _this6.inf = 1;
      if (x != null) _this6._init(x, y, inf);
      return _this6;
    }

    _createClass__default['default'](MontPoint, [{
      key: "_init",
      value: function _init(x, y, inf) {
        assert$4(x instanceof bnBrowser);
        assert$4(y instanceof bnBrowser);
        this.x = x;
        this.y = y;
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = inf | 0;
      }
    }, {
      key: "clone",
      value: function clone() {
        return this.curve.point(this.x.clone(), this.y.clone(), this.inf);
      }
    }, {
      key: "swap",
      value: function swap(point, flag) {
        assert$4(point instanceof MontPoint);
        var cond = (flag >> 31 | -flag >> 31) & 1;
        var inf1 = this.inf;
        var inf2 = point.inf;
        this.x.cswap(point.x, flag);
        this.y.cswap(point.y, flag);
        this.inf = inf1 & (cond ^ 1) | inf2 & cond;
        point.inf = inf2 & (cond ^ 1) | inf1 & cond;
        return this;
      }
    }, {
      key: "scale",
      value: function scale(a) {
        return this.clone();
      }
    }, {
      key: "randomize",
      value: function randomize(rng) {
        return this.clone();
      }
    }, {
      key: "neg",
      value: function neg() {
        // P = O
        if (this.inf) return this; // -(X1, Y1) = (X1, -Y1)

        return this.curve.point(this.x, this.y.redNeg());
      }
    }, {
      key: "add",
      value: function add(p) {
        // [MONT1] Page 8, Section 4.3.2.
        //
        // Addition Law:
        //
        //   l = (y2 - y1) / (x2 - x1)
        //   x3 = b * l^2 - a - x1 - x2
        //   y3 = l * (x1 - x3) - y1
        //
        // 1I + 2M + 1S + 7A + 1*b
        assert$4(p instanceof MontPoint); // O + P = P

        if (this.inf) return p; // P + O = P

        if (p.inf) return this; // P + P, P + -P

        if (this.x.eq(p.x)) {
          // P + -P = O
          if (!this.y.eq(p.y)) return this.curve.point(); // P + P = 2P

          return this.dbl();
        } // H = X2 - X1


        var h = p.x.redSub(this.x); // R = Y2 - Y1

        var r = p.y.redSub(this.y); // L = R / H

        var l = r.redDiv(h); // K = b * L^2

        var k = this.curve.b.redMul(l.redSqr()); // X3 = K - a - X1 - X2

        var nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1

        var ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      }
    }, {
      key: "dbl",
      value: function dbl() {
        // [MONT1] Page 8, Section 4.3.2.
        //
        // Addition Law (doubling):
        //
        //   l = (3 * x1^2 + 2 * a * x1 + 1) / (2 * b * y1)
        //   x3 = b * l^2 - a - 2 * x1
        //   y3 = l * (x1 - x3) - y1
        //
        // 1I + 3M + 2S + 7A + 1*a + 1*b + 1*b + 2*2 + 1*3
        // P = O
        if (this.inf) return this; // Y1 = 0

        if (this.y.isZero()) return this.curve.point(); // M1 = 3 * X1^2

        var m1 = this.x.redSqr().redIMuln(3); // M2 = 2 * a * X1

        var m2 = this.curve.a.redMul(this.x).redIMuln(2); // M = M1 + M2 + 1

        var m = m1.redIAdd(m2).redIAdd(this.curve.one); // Z = 2 * b * Y1

        var z = this.curve.b.redMul(this.y).redIMuln(2); // L = M / Z

        var l = m.redDiv(z); // K = b * L^2

        var k = this.curve.b.redMul(l.redSqr()); // X3 = K - a - 2 * X1

        var nx = k.redISub(this.curve.a).redISub(this.x).redISub(this.x); // Y3 = L * (X1 - X3) - Y1

        var ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      }
    }, {
      key: "uadd",
      value: function uadd(p) {
        // [MONT1] Page 8, Section 4.3.2.
        // 1I + 3M + 2S + 9A + 1*a + 2*b + 2*2 + 1*3
        assert$4(p instanceof MontPoint); // H = X2 - X1

        var h = p.x.redSub(this.x); // R = Y2 - Y1

        var r = p.y.redSub(this.y); // M1 = 3 * X1^2

        var m1 = this.x.redSqr().redIMuln(3); // M2 = 2 * a * X1

        var m2 = this.curve.a.redMul(this.x).redIMuln(2); // M = M1 + M2 + 1

        var m = m1.redIAdd(m2).redIAdd(this.curve.one); // Z = 2 * b * Y1

        var z = this.curve.b.redMul(this.y).redIMuln(2); // Check for doubling (X1 = X2, Y1 = Y2).

        var double = h.czero() & r.czero(); // R = M (if double)

        r.cinject(m, double); // H = Z (if double)

        h.cinject(z, double); // Check for negation (X1 = X2, Y1 = -Y2).

        var negated = h.czero() & ((this.inf | p.inf) ^ 1); // H = 1 (if H = 0)

        h.cinject(this.curve.one, h.czero()); // L = R / H

        var l = r.redMul(h.redFermat()); // K = b * L^2

        var k = this.curve.b.redMul(l.redSqr()); // X3 = K - a - X1 - X2

        var nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1

        var ny = l.redMul(this.x.redSub(nx)).redISub(this.y); // Check for infinity.

        var inf = negated | this.inf & p.inf; // Case 1: O + P = P

        nx.cinject(p.x, this.inf);
        ny.cinject(p.y, this.inf); // Case 2: P + O = P

        nx.cinject(this.x, p.inf);
        ny.cinject(this.y, p.inf); // Case 3 & 4: P + -P = O, O + O = O

        nx.cinject(this.curve.zero, inf);
        ny.cinject(this.curve.zero, inf);
        return this.curve.point(nx, ny, inf);
      }
    }, {
      key: "udbl",
      value: function udbl() {
        return this.uadd(this);
      }
    }, {
      key: "recover",
      value: function recover(p1, p2) {
        // Okeya-Sakurai Y-coordinate Recovery.
        //
        // [MONT3] Algorithm 5, Page 13, Section 4.3.
        //         Algorithm 6, Page 14, Section 4.3.
        //
        // 1I + 12M + 1S + 6A + 1*a + 1*b + 2*2
        assert$4(p1 instanceof XPoint);
        assert$4(p2 instanceof XPoint); // P = O

        if (this.inf) return this.curve.point(); // A = X0 * Z1

        var a = this.x.redMul(p1.z); // B = X1 + A

        var b = p1.x.redAdd(a); // C = (X1 - A)^2 * X2

        var c = p1.x.redSub(a).redSqr().redMul(p2.x); // D = 2 * a * Z1

        var d = this.curve.a.redMul(p1.z).redIMuln(2); // E = B + D

        var e = b.redIAdd(d); // F = X0 * X1 + Z1

        var f = this.x.redMul(p1.x).redIAdd(p1.z); // G = E * F

        var g = e.redMul(f); // H = D * Z1

        var h = d.redMul(p1.z); // I = (G - H) * Z2

        var i = g.redISub(h).redMul(p2.z); // J = 2 * b * Y0

        var j = this.curve.b.redMul(this.y).redIMuln(2); // K = J * Z1 * Z2

        var k = j.redMul(p1.z).redMul(p2.z); // X = K * X1

        var x = k.redMul(p1.x); // Y = I - C

        var y = i.redISub(c); // Z = K * Z1

        var z = k.redMul(p1.z); // Z = 0

        if (z.isZero()) return this.curve.point(); // L = 1 / Z

        var l = z.redInvert(); // X3 = X * L

        var nx = x.redMul(l); // Y3 = Y * L

        var ny = y.redMul(l);
        return this.curve.point(nx, ny);
      }
    }, {
      key: "getX",
      value: function getX() {
        if (this.inf) throw new Error('Invalid point.');
        return this.x.fromRed();
      }
    }, {
      key: "getY",
      value: function getY() {
        if (this.inf) throw new Error('Invalid point.');
        return this.y.fromRed();
      }
    }, {
      key: "eq",
      value: function eq(p) {
        assert$4(p instanceof MontPoint); // P = Q

        if (this === p) return true; // P = O

        if (this.inf) return p.inf !== 0; // Q = O

        if (p.inf) return false; // X1 = X2, Y1 = Y2

        return this.x.eq(p.x) && this.y.eq(p.y);
      }
    }, {
      key: "cmp",
      value: function cmp(point) {
        assert$4(point instanceof MontPoint);
        if (this.inf && !point.inf) return -1;
        if (!this.inf && point.inf) return 1;
        if (this.inf && point.inf) return 0;
        return this.order().cmp(point.order()) || this.getX().cmp(point.getX()) || this.getY().cmp(point.getY());
      }
    }, {
      key: "isInfinity",
      value: function isInfinity() {
        // Infinity cannot be represented in
        // the affine space, except by a flag.
        return this.inf !== 0;
      }
    }, {
      key: "isOrder2",
      value: function isOrder2() {
        if (this.inf) return false;
        return this.y.isZero();
      }
    }, {
      key: "isOdd",
      value: function isOdd() {
        if (this.inf) return false;
        return this.y.redIsOdd();
      }
    }, {
      key: "isEven",
      value: function isEven() {
        if (this.inf) return false;
        return this.y.redIsEven();
      }
    }, {
      key: "toP",
      value: function toP() {
        return this;
      }
    }, {
      key: "toJ",
      value: function toJ() {
        return this;
      }
    }, {
      key: "toX",
      value: function toX() {
        // (X3, Z3) = (1, 0)
        if (this.inf) return this.curve.xpoint(); // (X3, Z3) = (X1, 1)

        return this.curve.xpoint(this.x, this.curve.one);
      }
    }, {
      key: "encode",
      value: function encode() {
        return this.toX().encode();
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        if (this.inf) return [];
        var x = this.getX().toJSON();
        var y = this.getY().toJSON();
        return [x, y];
      }
    }, {
      key: "toPretty",
      value: function toPretty() {
        if (this.inf) return [];
        var size = this.curve.fieldSize * 2;

        var x = _toPretty(this.getX(), size);

        var y = _toPretty(this.getY(), size);

        return [x, y];
      }
    }, {
      key: custom$2,
      value: function value() {
        if (this.inf) return '<MontPoint: Infinity>';
        return '<MontPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>';
      }
    }], [{
      key: "decode",
      value: function decode(curve, bytes, sign) {
        assert$4(curve instanceof MontCurve);
        return curve.decodeX(bytes).toP(sign);
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(curve, json) {
        assert$4(curve instanceof MontCurve);
        assert$4(Array.isArray(json));
        assert$4(json.length === 0 || json.length === 2 || json.length === 3);
        if (json.length === 0) return curve.point();
        var x = bnBrowser.fromJSON(json[0]);
        var y = bnBrowser.fromJSON(json[1]);
        return curve.point(x, y);
      }
    }]);

    return MontPoint;
  }(Point);
  /**
   * XPoint
   */


  var XPoint = /*#__PURE__*/function (_Point4) {
    _inherits__default['default'](XPoint, _Point4);

    var _super6 = _createSuper$c(XPoint);

    function XPoint(curve, x, z) {
      var _this7;

      _classCallCheck__default['default'](this, XPoint);

      assert$4(curve instanceof MontCurve);
      _this7 = _super6.call(this, curve, types$1.PROJECTIVE);
      _this7.x = _this7.curve.one;
      _this7.z = _this7.curve.zero;
      if (x != null) _this7._init(x, z);
      return _this7;
    }

    _createClass__default['default'](XPoint, [{
      key: "_init",
      value: function _init(x, z) {
        assert$4(x instanceof bnBrowser);
        assert$4(z == null || z instanceof bnBrowser);
        this.x = x;
        this.z = z || this.curve.one;
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
      }
    }, {
      key: "clone",
      value: function clone() {
        return this.curve.xpoint(this.x.clone(), this.z.clone());
      }
    }, {
      key: "swap",
      value: function swap(point, flag) {
        assert$4(point instanceof XPoint);
        this.x.cswap(point.x, flag);
        this.z.cswap(point.z, flag);
        return this;
      }
    }, {
      key: "precompute",
      value: function precompute(power, rng) {
        // No-op.
        return this;
      }
    }, {
      key: "validate",
      value: function validate() {
        if (this.isInfinity()) return true; // B * y^2 * z = x^3 + A * x^2 * z + x * z^2

        var x = this.x,
            z = this.z;
        var x2 = x.redSqr();
        var x3 = x2.redMul(x);
        var z2 = z.redSqr();
        var ax2 = this.curve.a.redMul(x2).redMul(z);
        var by2 = x3.redIAdd(ax2).redIAdd(x.redMul(z2));
        var y2 = by2.redMul(this.curve.bi); // sqrt(y^2 * z^4) = y * z^2

        return y2.redMul(z).redJacobi() !== -1;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#scaling-scale
        // 1I + 1M
        // P = O
        if (this.isInfinity()) return this; // Z1 = 1

        if (this.z.eq(this.curve.one)) return this; // X3 = X1 / Z1

        this.x = this.x.redDiv(this.z); // Z3 = 1

        this.z = this.curve.one;
        return this;
      }
    }, {
      key: "scale",
      value: function scale(a) {
        assert$4(a instanceof bnBrowser); // P = O

        if (this.isInfinity()) return this.curve.xpoint(); // X3 = X1 * A

        var nx = this.x.redMul(a); // Y3 = Y1 * A

        var nz = this.z.redMul(a);
        return this.curve.xpoint(nx, nz);
      }
    }, {
      key: "neg",
      value: function neg() {
        // -(X1, Z1) = (X1, Z1)
        return this;
      }
    }, {
      key: "dbl",
      value: function dbl() {
        // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
        // 2M + 2S + 4A + 1*a24
        // A = X1 + Z1
        var a = this.x.redAdd(this.z); // AA = A^2

        var aa = a.redSqr(); // B = X1 - Z1

        var b = this.x.redSub(this.z); // BB = B^2

        var bb = b.redSqr(); // C = AA - BB

        var c = aa.redSub(bb); // X3 = AA * BB

        var nx = aa.redMul(bb); // Z3 = C * (BB + a24 * C)

        var nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));
        return this.curve.xpoint(nx, nz);
      }
    }, {
      key: "diffAdd",
      value: function diffAdd(p2, p3) {
        // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
        // 4M + 2S + 6A
        assert$4(p2 instanceof XPoint);
        assert$4(p3 instanceof XPoint); // A = X2 + Z2

        var a = p2.x.redAdd(p2.z); // B = X2 - Z2

        var b = p2.x.redSub(p2.z); // C = X3 + Z3

        var c = p3.x.redAdd(p3.z); // D = X3 - Z3

        var d = p3.x.redSub(p3.z); // DA = D * A

        var da = d.redMul(a); // CB = C * B

        var cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2

        var x5 = this.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2

        var z5 = this.x.redMul(da.redISub(cb).redSqr());
        return this.curve.xpoint(x5, z5);
      }
    }, {
      key: "diffAddDbl",
      value: function diffAddDbl(p2, p3) {
        // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#ladder-ladd-1987-m-3
        // 6M + 4S + 8A + 1*a24
        assert$4(p2 instanceof XPoint);
        assert$4(p3 instanceof XPoint); // A = X2 + Z2

        var a = p2.x.redAdd(p2.z); // AA = A^2

        var aa = a.redSqr(); // B = X2 - Z2

        var b = p2.x.redSub(p2.z); // BB = B^2

        var bb = b.redSqr(); // E = AA - BB

        var e = aa.redSub(bb); // C = X3 + Z3

        var c = p3.x.redAdd(p3.z); // D = X3 - Z3

        var d = p3.x.redSub(p3.z); // DA = D * A

        var da = d.redMul(a); // CB = C * B

        var cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2

        var x5 = this.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2

        var z5 = this.x.redMul(da.redISub(cb).redSqr()); // X4 = AA * BB

        var x4 = aa.redMul(bb); // Z4 = E * (BB + a24 * E)

        var z4 = e.redMul(bb.redIAdd(this.curve.a24.redMul(e)));
        return [this.curve.xpoint(x4, z4), this.curve.xpoint(x5, z5)];
      }
    }, {
      key: "getX",
      value: function getX() {
        if (this.isInfinity()) throw new Error('Invalid point.');
        this.normalize();
        return this.x.fromRed();
      }
    }, {
      key: "getY",
      value: function getY(sign) {
        return this.toP(sign).getY();
      }
    }, {
      key: "eq",
      value: function eq(p) {
        assert$4(p instanceof XPoint); // P = Q

        if (this === p) return true; // P = O

        if (this.isInfinity()) return p.isInfinity(); // Q = O

        if (p.isInfinity()) return false; // Z1 = Z2

        if (this.z.eq(p.z)) return this.x.eq(p.x); // X1 * Z2 == X2 * Z1

        var x1 = this.x.redMul(p.z);
        var x2 = p.x.redMul(this.z);
        return x1.eq(x2);
      }
    }, {
      key: "cmp",
      value: function cmp(point) {
        assert$4(point instanceof XPoint);
        var inf1 = this.isInfinity();
        var inf2 = point.isInfinity();
        if (inf1 && !inf2) return -1;
        if (!inf1 && inf2) return 1;
        if (inf1 && inf2) return 0;
        return this.order().cmp(point.order()) || this.getX().cmp(point.getX());
      }
    }, {
      key: "isInfinity",
      value: function isInfinity() {
        // Z1 = 0
        return this.z.isZero();
      }
    }, {
      key: "isOrder2",
      value: function isOrder2() {
        if (this.isInfinity()) return false;
        return this.x.isZero();
      }
    }, {
      key: "isOdd",
      value: function isOdd() {
        return false;
      }
    }, {
      key: "isEven",
      value: function isEven() {
        return false;
      }
    }, {
      key: "hasTorsion",
      value: function hasTorsion() {
        if (this.isInfinity()) return false; // X1 = 0, Z1 != 0 (edge case)

        if (this.x.isZero()) return true;
        return _get__default['default'](_getPrototypeOf__default['default'](XPoint.prototype), "hasTorsion", this).call(this);
      }
    }, {
      key: "order",
      value: function order() {
        try {
          return this.toP().order();
        } catch (e) {
          return new bnBrowser(1);
        }
      }
    }, {
      key: "jmul",
      value: function jmul(k) {
        return this.ladder(k)[0];
      }
    }, {
      key: "jmulSimple",
      value: function jmulSimple(k) {
        return this.ladderSimple(k)[0];
      }
    }, {
      key: "jmulBlind",
      value: function jmulBlind(k, rng) {
        return this.ladderBlind(k, rng)[0];
      }
    }, {
      key: "jmulConst",
      value: function jmulConst(k, rng) {
        return this.ladderConst(k, rng)[0];
      }
    }, {
      key: "jmulAdd",
      value: function jmulAdd(k1, p2, k2) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "jmulAddSimple",
      value: function jmulAddSimple(k1, p2, k2) {
        throw new Error('Not implemented.');
      }
    }, {
      key: "ladder",
      value: function ladder(k) {
        // Multiply with the Montgomery Ladder.
        //
        // [MONT3] Algorithm 4, Page 12, Section 4.2.
        //
        // Note that any clamping is meant to
        // be done _outside_ of this function.
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red);
        var bits = k.bitLength();
        var a = this.curve.xpoint();
        var b = this;

        for (var i = bits - 1; i >= 0; i--) {
          var bit = k.bit(i);

          if (bit === 0) {
            var _this$diffAddDbl = this.diffAddDbl(a, b);

            var _this$diffAddDbl2 = _slicedToArray__default['default'](_this$diffAddDbl, 2);

            a = _this$diffAddDbl2[0];
            b = _this$diffAddDbl2[1];
          } else {
            var _this$diffAddDbl3 = this.diffAddDbl(b, a);

            var _this$diffAddDbl4 = _slicedToArray__default['default'](_this$diffAddDbl3, 2);

            b = _this$diffAddDbl4[0];
            a = _this$diffAddDbl4[1];
          }
        }

        return [a, b];
      }
    }, {
      key: "ladderSimple",
      value: function ladderSimple(k) {
        // Montgomery Ladder with explicit
        // additions and doubling (testing).
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red);
        var bits = k.bitLength();
        var a = this.curve.xpoint();
        var b = this; // Climb the ladder.

        for (var i = bits - 1; i >= 0; i--) {
          var bit = k.bit(i);

          if (bit === 0) {
            b = this.diffAdd(b, a);
            a = a.dbl();
          } else {
            a = this.diffAdd(a, b);
            b = b.dbl();
          }
        }

        return [a, b];
      }
    }, {
      key: "ladderBlind",
      value: function ladderBlind(k, rng) {
        if (!rng) return this.ladder(k); // Randomize if available.

        return this.randomize(rng).ladder(k);
      }
    }, {
      key: "ladderConst",
      value: function ladderConst(k, rng) {
        // Multiply with the Montgomery Ladder.
        //
        // [MONT3] Algorithm 7, Page 16, Section 5.3.
        //         Algorithm 8, Page 16, Section 5.3.
        //
        // [RFC7748] Page 7, Section 5.
        //
        // Note that any clamping is meant to
        // be done _outside_ of this function.
        assert$4(k instanceof bnBrowser);
        assert$4(!k.red);
        var bits = Math.max(k.bitLength(), this.curve.fieldBits);
        var bytes = bits + 7 >>> 3; // Recode scalar to base256.

        var exp = k.toArray('le', bytes); // Randomize if available.

        var point = rng ? this.randomize(rng) : this; // Clone points (for safe swapping).

        var a = this.curve.xpoint().clone();
        var b = point.clone();
        var swap = 0; // Climb the ladder.

        for (var i = bits - 1; i >= 0; i--) {
          var bit = exp[i >> 3] >> (i & 7) & 1; // Maybe swap.

          a.swap(b, swap ^ bit); // Single coordinate add+double.

          var _point$diffAddDbl = point.diffAddDbl(a, b);

          var _point$diffAddDbl2 = _slicedToArray__default['default'](_point$diffAddDbl, 2);

          a = _point$diffAddDbl2[0];
          b = _point$diffAddDbl2[1];
          swap = bit;
        } // Finalize loop.


        a.swap(b, swap);
        return [a, b];
      }
    }, {
      key: "toP",
      value: function toP() {
        var sign = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        assert$4(sign == null || typeof sign === 'boolean');
        if (this.isInfinity()) return this.curve.point();
        this.normalize();
        return this.curve.pointFromX(this.x, sign);
      }
    }, {
      key: "toJ",
      value: function toJ() {
        return this;
      }
    }, {
      key: "toX",
      value: function toX() {
        return this;
      }
    }, {
      key: "key",
      value: function key() {
        if (this.isInfinity()) return "".concat(this.curve.uid, ":oo");
        this.normalize();
        var x = this.getX().toString(16);
        return "".concat(this.curve.uid, ":").concat(x);
      }
    }, {
      key: "encode",
      value: function encode() {
        // [RFC7748] Section 5.
        return this.curve.encodeField(this.getX());
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        return this.toP().toJSON(pre);
      }
    }, {
      key: "toPretty",
      value: function toPretty() {
        return this.toP().toPretty();
      }
    }, {
      key: custom$2,
      value: function value() {
        if (this.isInfinity()) return '<XPoint: Infinity>';
        return '<XPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';
      }
    }], [{
      key: "decode",
      value: function decode(curve, bytes) {
        assert$4(curve instanceof MontCurve); // [RFC7748] Section 5.

        var x = curve.decodeField(bytes); // We're supposed to ignore the hi bit
        // on montgomery points... I think. If
        // we don't, the X25519 test vectors
        // break, which is pretty convincing
        // evidence. This is a no-op for X448.

        x.iumaskn(curve.fieldBits); // Note: montgomery points are meant to be
        // reduced by the prime and do not have to
        // be explicitly validated in order to do
        // the montgomery ladder.

        var p = curve.xpoint(x, curve.one);
        assert$4(!p.isInfinity());
        return p;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(curve, json) {
        return MontPoint.fromJSON(curve, json).toX();
      }
    }]);

    return XPoint;
  }(Point);
  /**
   * EdwardsCurve
   */


  var EdwardsCurve = /*#__PURE__*/function (_Curve3) {
    _inherits__default['default'](EdwardsCurve, _Curve3);

    var _super7 = _createSuper$c(EdwardsCurve);

    function EdwardsCurve(conf) {
      var _this8;

      _classCallCheck__default['default'](this, EdwardsCurve);

      _this8 = _super7.call(this, EdwardsPoint, 'edwards', conf);
      _this8.a = bnBrowser.fromJSON(conf.a).toRed(_this8.red);
      _this8.d = bnBrowser.fromJSON(conf.d).toRed(_this8.red);
      _this8.s = bnBrowser.fromJSON(conf.s || '0').toRed(_this8.red);
      _this8.si = _this8.s.isZero() ? _this8.zero : _this8.s.redInvert();
      _this8.k = _this8.d.redMuln(2);
      _this8.smi = -_this8.d.redNeg().word(0);
      _this8.ad6 = _this8.a.redAdd(_this8.d).redMul(_this8.i6);
      _this8.twisted = !_this8.a.eq(_this8.one);
      _this8.oneA = _this8.a.eq(_this8.one);
      _this8.mOneA = _this8.a.eq(_this8.one.redNeg());
      _this8.smallD = _this8.prime != null && _this8.d.redNeg().length === 1;
      _this8.alt = null;

      _this8._finalize(conf);

      return _this8;
    }

    _createClass__default['default'](EdwardsCurve, [{
      key: "_short",
      value: function _short(a0, odd) {
        // Twisted Edwards->Short Weierstrass Equivalence.
        //
        // [TWISTEQ] Section 2.
        //
        // Transformation:
        //
        //   a' = -(a^2 + 14 * a * d + d^2) / 48
        //   b' = (33 * (a^2 * d + a * d^2) - a^3 - d^3) / 864
        var a = this.a,
            d = this.d;
        var a2 = a.redSqr();
        var a3 = a2.redMul(a);
        var d2 = d.redSqr();
        var d3 = d2.redMul(d);
        var ad14 = a.redMul(d).redIMuln(14);
        var a2d = a2.redMul(d);
        var ad2 = a.redMul(d2);
        var t0 = a2d.redIAdd(ad2).redIMuln(33);
        var wa = a2.redAdd(ad14).redIAdd(d2).redDivn(-48);
        var wb = t0.redISub(a3).redISub(d3).redDivn(864);
        if (a0 != null) return ShortCurve._isomorphism(wa, wb, a0, odd);
        return [wa, wb];
      }
    }, {
      key: "_mont",
      value: function _mont(b0) {
        var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        // Twisted Edwards->Montgomery Transformation.
        //
        // [TWISTED] Theorem 3.2, Page 4, Section 3.
        //
        // Equivalence:
        //
        //   A = 2 * (a + d) / (a - d)
        //   B = 4 / (a - d)
        //
        // Isomorphism:
        //
        //   A = 2 * (a + d) / (a - d)
        //   B = B'
        //
        // Where ((4 / (a - d)) / B') is square.
        //
        // If `4 / (a - d)` is non-square, we can
        // usually force B=1 by using the `invert`
        // option. This will create an isomorphism
        // chain of: E(a,d)->E(d,a)->M(-A,-B).
        //
        // The equivalence between E(a,d) and E(d,a)
        // is:
        //
        //   (x, y) = (x, 1 / y)
        //
        // Meaning our map to M(-A,-B) is:
        //
        //   u = (1 + 1 / y) / (1 - 1 / y)
        //     = (y + 1) / (y - 1)
        //   v = u / x
        assert$4(typeof invert === 'boolean');
        var apd, amd;

        if (invert) {
          apd = this.d.redAdd(this.a);
          amd = this.d.redSub(this.a);
        } else {
          apd = this.a.redAdd(this.d);
          amd = this.a.redSub(this.d);
        }

        var z = amd.redInvert();
        var a = apd.redMuln(2).redMul(z);
        var b = z.redMuln(4);
        if (b0 != null) return MontCurve._isomorphism(a, b, b0);
        return [a, b];
      }
    }, {
      key: "_edwards",
      value: function _edwards(a0) {
        return EdwardsCurve._isomorphism(this.a, this.d, a0);
      }
    }, {
      key: "_scaleShort",
      value: function _scaleShort(curve) {
        assert$4(curve instanceof ShortCurve);

        var _curve$_scale7 = curve._scale(this),
            _curve$_scale8 = _slicedToArray__default['default'](_curve$_scale7, 2),
            u2 = _curve$_scale8[0],
            u3 = _curve$_scale8[1];

        return [this.field(u2.redInvert()), this.field(u3.redInvert())];
      }
    }, {
      key: "_scaleMont",
      value: function _scaleMont(curve) {
        var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        // Calculate isomorphism factor between
        // Twisted Edwards and Montgomery with:
        //
        //   a = (A + 2) / B
        //   c = +-sqrt(a / a')
        //
        // Which can be reduced to:
        //
        //   c = +-sqrt((A + 2) / (B * a'))
        //
        // If base points are available, we can do:
        //
        //   x = u / v
        //   c = x' / x
        //
        // Which can be reduced to:
        //
        //   c = v * x' / u
        //
        // We can now calculate the Edwards `x` with:
        //
        //   x' = c * u / v
        //
        // And likewise, the Montgomery `v`:
        //
        //   v = c * u / x'
        assert$4(curve instanceof MontCurve);
        assert$4(typeof invert === 'boolean');

        if (this.g.isInfinity() || curve.g.isInfinity()) {
          var _curve$_edwards = curve._edwards(null, invert),
              _curve$_edwards2 = _slicedToArray__default['default'](_curve$_edwards, 1),
              a = _curve$_edwards2[0];

          return this.field(a).redDivSqrt(this.a);
        }

        var x = curve.g.x.redDiv(curve.g.y);
        return this.g.x.redDiv(this.field(x));
      }
    }, {
      key: "_scaleEdwards",
      value: function _scaleEdwards(curve) {
        // We can extract the isomorphism factor with:
        //
        //   c = +-sqrt(a / a')
        //
        // If base points are available, we can do:
        //
        //   c = x' / x
        assert$4(curve instanceof EdwardsCurve);
        if (this.g.isInfinity() || curve.g.isInfinity()) return this.field(curve.a).redDivSqrt(this.a);
        return this.g.x.redDiv(this.field(curve.g.x));
      }
    }, {
      key: "_mulA",
      value: function _mulA(num) {
        assert$4(num instanceof bnBrowser); // n * a = n

        if (this.oneA) return num.clone(); // n * a = -n

        if (this.mOneA) return num.redNeg();
        return this.a.redMul(num);
      }
    }, {
      key: "_mulD",
      value: function _mulD(num) {
        assert$4(num instanceof bnBrowser); // -d < 0x4000000

        if (this.smallD) return num.redMuln(this.smi);
        return this.d.redMul(num);
      }
    }, {
      key: "_elligator1",
      value: function _elligator1(t) {
        // Elligator 1.
        //
        // Distribution: 1/2.
        //
        // [ELL1] Page 6, Section 3.
        //        Page 15, Appendix A.
        // [ELL2] Page 7, Section 3.2.
        //
        // Assumptions:
        //
        //   - Let p be a prime power congruent to 3 mod 4.
        //   - Let s be a nonzero element of F(p).
        //   - Let c = 2 / s^2.
        //   - Let r = c + 1 / c.
        //   - Let d = -(c + 1)^2 / (c - 1)^2.
        //   - (s^2 - 2) * (s^2 + 2) != 0.
        //   - c * (c - 1) * (c + 1) != 0.
        //   - r != 0.
        //   - d is not square.
        //   - x^2 + y^2 = 1 + d * x^2 * y^2.
        //   - u * v * X * Y * x * (Y + 1) != 0.
        //   - Y^2 = X^5 + (r^2 - 2) * X^3 + X.
        //
        // Elligator 1, as devised by Fouque et al,
        // takes place on the hyperelliptic curve of:
        //
        //   y^2 = x^5 + (r^2 - 2) * x^3 + x
        //
        // Not only must our Edwards curve be complete,
        // with a prime congruent to 3 mod 4, and a = 1,
        // our curve must be isomorphic to a hyperelliptic
        // curve of the above form. Roughly one half of
        // all Edwards curves are isomorphic to a curve
        // of said form.
        //
        // We can derive the isomorphism with:
        //
        //   c = (d +- 2 * sqrt(-d) - 1) / (d + 1)
        //   s = +-sqrt(2 / c)
        //   r = c + 1 / c
        //
        // Note that even if your curve is an Elligator 1
        // curve, Elligator 2 is probably still preferable,
        // as it has nearly the same properties (i.e. the
        // same distribution), and is much less complex.
        //
        // Map:
        //
        //   f(a) = a^((p - 1) / 2)
        //   u = (1 - t) / (1 + t)
        //   v = u^5 + (r^2 - 2) * u^3 + u
        //   X = f(v) * u
        //   Y = (f(v) * v)^((p + 1) / 4) * f(v) * f(u^2 + 1 / c^2)
        //   Y = 1, if u = 0
        //   x = (c - 1) * s * X * (1 + X) / Y
        //   y = (r * X - (1 + X)^2) / (r * X + (1 + X)^2)
        //
        // When t = +-1, we create the hyperelliptic
        // 2-torsion point of (0, 0). This needs to be
        // mapped to (0, -1) in Edwards form, but the x
        // denominator becomes zero. As far as I can
        // tell, this is the only exceptional case.
        //
        // The only other exceptional case initially
        // appears to be when the y denominator sums to
        // zero (when t = sqrt(4 / r + 1)), however, the
        // hyperelliptic `X` is negated by the sign of
        // `v`, making this impossible.
        var s = this.s,
            si = this.si,
            i2 = this.i2,
            one = this.one,
            two = this.two;
        var c = si.redSqr().redIMuln(2);
        var ci = s.redSqr().redMul(i2);
        var ci2 = ci.redSqr();
        var r = c.redAdd(ci);
        var r2 = r.redSqr().redISub(two);
        var cm1 = c.redSub(one);
        var e0 = this.p.subn(2);
        var e1 = this.p.subn(1).iushrn(1);
        var e2 = this.p.addn(1).iushrn(2);
        var uu = one.redSub(t);
        var uz = one.redAdd(t);
        var u = uu.redMul(uz.redPow(e0));
        var u2 = u.redSqr();
        var u3 = u2.redMul(u);
        var u5 = u3.redMul(u2);
        var v = u5.redAdd(r2.redMul(u3)).redIAdd(u);
        var f0 = v.redPow(e1);
        var f1 = u2.redAdd(ci2).redPow(e1);
        var f2 = f0.redMul(f1);
        var X = f0.redMul(u);
        var Y = f0.redMul(v).redPow(e2).redMul(f2);
        var X1 = one.redAdd(X);
        var rX = r.redMul(X);
        var X12 = X1.redSqr();
        var xx = cm1.redMul(s).redMul(X).redMul(X1);
        var xz = Y.cinject(this.one, u.czero());
        var yy = rX.redSub(X12);
        var yz = rX.redAdd(X12);
        return this.cpoint(xx, xz, yy, yz);
      }
    }, {
      key: "_invert1",
      value: function _invert1(p, hint) {
        // Inverting the Map (Elligator 1).
        //
        // [ELL1] Page 6, Section 3.
        //        Page 15, Appendix A.
        // [ELL2] Page 7, Section 3.3.
        //
        // Assumptions:
        //
        //   - y + 1 != 0.
        //   - (1 + n * r)^2 - 1 is square in F(p).
        //   - If n * r = -2 then x = 2 * s * (c - 1) * f(c) / r.
        //   - Y = (c - 1) * s * X * (1 + X) / x.
        //
        // Map:
        //
        //   f(a) = a^((p - 1) / 2)
        //   n = (y - 1) / (2 * (y + 1))
        //   X = -(1 + n * r) + ((1 + n * r)^2 - 1)^((p + 1) / 4)
        //   z = f((c - 1) * s * X * (1 + X) * x * (X^2 + 1 / c^2))
        //   u = z * X
        //   t = (1 - u) / (1 + u)
        var s = this.s,
            si = this.si,
            i2 = this.i2,
            one = this.one;
        var x = p.x,
            y = p.y,
            z = p.z;
        var sign = hint & 1;
        var c = si.redSqr().redIMuln(2);
        var ci = s.redSqr().redMul(i2);
        var ci2 = ci.redSqr();
        var r = c.redAdd(ci);
        var cm1 = c.redSub(one);
        var e0 = this.p.subn(2);
        var e1 = this.p.subn(1).iushrn(1);
        var e2 = this.p.addn(1).iushrn(2);
        var nn = y.redSub(z);
        var nz = y.redAdd(z).redIMuln(2);
        var n = nn.redMul(nz.redPow(e0));
        var nr1 = one.redAdd(n.redMul(r));
        var w2 = nr1.redSqr().redISub(one);
        var w = w2.redPow(e2);
        var sqr = w.redSqr().ceq(w2);
        var X = w.redSub(nr1);
        var X1 = one.redAdd(X);
        var YY = cm1.redMul(s).redMul(X).redMul(X1);
        var Y = YY.redMul(x.redMul(z));
        var X2 = X.redSqr().redIAdd(ci2);
        var Z = Y.redMul(X2).redPow(e1);
        var u = Z.redMul(X);
        var tt = one.redSub(u);
        var tz = one.redAdd(u);
        var t = tt.redMul(tz.redPow(e0));
        t.cinject(t.redNeg(), t.redIsOdd() ^ sign);
        if (!sqr) throw new Error('Invalid point.');
        return t;
      }
    }, {
      key: "_alt",
      value: function _alt() {
        if (!this.alt) this.alt = this.toMont();
        return this.alt;
      }
    }, {
      key: "isElliptic",
      value: function isElliptic() {
        var ad = this.a.redMul(this.d);
        var amd = this.a.redSub(this.d); // a * d * (a - d) != 0

        return !ad.redMul(amd).isZero();
      }
    }, {
      key: "jinv",
      value: function jinv() {
        // [TWISTED] Definition 2.1, Page 3, Section 2.
        var a = this.a,
            d = this.d;
        var ad = a.redMul(d);
        var amd4 = a.redSub(d).redPown(4);
        var a2 = a.redSqr();
        var d2 = d.redSqr();
        var t0 = a2.redAdd(ad.redMuln(14)).redIAdd(d2);
        var lhs = t0.redPown(3).redIMuln(16);
        var rhs = ad.redMul(amd4);
        if (rhs.isZero()) throw new Error('Curve is not elliptic.'); // 16 * (a^2 + 14 * a * d + d^2)^3 / (a * d * (a - d)^4)

        return lhs.redDiv(rhs).fromRed();
      }
    }, {
      key: "isComplete",
      value: function isComplete() {
        return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;
      }
    }, {
      key: "point",
      value: function point(x, y, z, t) {
        return new EdwardsPoint(this, x, y, z, t);
      }
    }, {
      key: "jpoint",
      value: function jpoint(x, y, z) {
        assert$4(x == null && y == null && z == null);
        return this.point();
      }
    }, {
      key: "cpoint",
      value: function cpoint(xx, xz, yy, yz) {
        assert$4(xx instanceof bnBrowser);
        assert$4(xz instanceof bnBrowser);
        assert$4(yy instanceof bnBrowser);
        assert$4(yz instanceof bnBrowser);
        var x = xx.redMul(yz);
        var y = yy.redMul(xz);
        var z = xz.redMul(yz);
        var t = xx.redMul(yy);
        return this.point(x, y, z, t);
      }
    }, {
      key: "solveX2",
      value: function solveX2(y) {
        // [RFC8032] Section 5.1.3 & 5.2.3.
        assert$4(y instanceof bnBrowser); // x^2 = (y^2 - 1) / (d * y^2 - a)

        var y2 = y.redSqr();

        var rhs = this._mulD(y2).redISub(this.a);

        var lhs = y2.redISub(this.one);
        var x2 = lhs.redDiv(rhs);
        return x2;
      }
    }, {
      key: "solveX",
      value: function solveX(y) {
        // Optimize with inverse square root trick.
        //
        // Note that `0 / 0` can only occur if
        // `a == d` (i.e. the curve is singular).
        var y2 = y.redSqr();

        var rhs = this._mulD(y2).redISub(this.a);

        var lhs = y2.redISub(this.one);
        return lhs.redDivSqrt(rhs);
      }
    }, {
      key: "solveY2",
      value: function solveY2(x) {
        assert$4(x instanceof bnBrowser); // y^2 = (a * x^2 - 1) / (d * x^2 - 1)

        var x2 = x.redSqr();

        var lhs = this._mulA(x2).redISub(this.one);

        var rhs = this._mulD(x2).redISub(this.one);

        var y2 = lhs.redDiv(rhs);
        return y2;
      }
    }, {
      key: "solveY",
      value: function solveY(x) {
        // Optimize with inverse square root trick.
        //
        // Note that `0 / 0` can only occur if
        // `a == d` (i.e. the curve is singular).
        var x2 = x.redSqr();

        var lhs = this._mulA(x2).redISub(this.one);

        var rhs = this._mulD(x2).redISub(this.one);

        return lhs.redDivSqrt(rhs);
      }
    }, {
      key: "validate",
      value: function validate(point) {
        // [TWISTED] Definition 2.1, Page 3, Section 2.
        //           Page 11, Section 6.
        assert$4(point instanceof EdwardsPoint); // Z1 = 1

        if (point.zOne) {
          // a * x^2 + y^2 = 1 + d * x^2 * y^2
          var _x5 = point.x.redSqr();

          var _y2 = point.y.redSqr();

          var _dxy = this._mulD(_x5).redMul(_y2);

          var _lhs = this._mulA(_x5).redIAdd(_y2);

          var _rhs = this.one.redAdd(_dxy);

          var _tz = point.t;

          var _xy = point.x.redMul(point.y);

          return _lhs.eq(_rhs) && _tz.eq(_xy);
        } // (a * x^2 + y^2) * z^2 = z^4 + d * x^2 * y^2


        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var z2 = point.z.redSqr();
        var z4 = z2.redSqr();

        var dxy = this._mulD(x2).redMul(y2);

        var lhs = this._mulA(x2).redIAdd(y2).redMul(z2);

        var rhs = z4.redIAdd(dxy);
        var tz = point.t.redMul(point.z);
        var xy = point.x.redMul(point.y);
        return lhs.eq(rhs) && tz.eq(xy);
      }
    }, {
      key: "pointFromX",
      value: function pointFromX(x) {
        var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        assert$4(x instanceof bnBrowser);
        assert$4(sign == null || typeof sign === 'boolean');
        if (!x.red) x = x.toRed(this.red);
        var y = this.solveY(x);

        if (sign != null) {
          if (y.isZero() && sign) throw new Error('Invalid point.');
          if (y.redIsOdd() !== sign) y.redINeg();
        }

        return this.point(x, y);
      }
    }, {
      key: "pointFromY",
      value: function pointFromY(y) {
        var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        assert$4(y instanceof bnBrowser);
        assert$4(sign == null || typeof sign === 'boolean');
        if (!y.red) y = y.toRed(this.red);
        var x = this.solveX(y);

        if (sign != null) {
          if (x.isZero() && sign) throw new Error('Invalid point.');
          if (x.redIsOdd() !== sign) x.redINeg();
        }

        return this.point(x, y);
      }
    }, {
      key: "isIsomorphic",
      value: function isIsomorphic(curve) {
        var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        // [TWISTED] Theorem 3.2, Page 4, Section 3.
        //           Definition 2.1, Page 3, Section 2.
        assert$4(curve instanceof Curve);
        assert$4(typeof invert === 'boolean');
        if (!curve.p.eq(this.p)) return false; // E(a,d) <-> E(a,b)

        if (curve.type === 'short') return curve.isIsomorphic(this); // E(a,d) <-> M(A,B)
        // E(a,d) <-> M(-A,-B)

        if (curve.type === 'mont') {
          // A * (a - d) = 2 * (a + d)
          var a = this.field(curve.a);
          var apd, amd;

          if (invert) {
            apd = this.d.redAdd(this.a);
            amd = this.d.redSub(this.a);
          } else {
            apd = this.a.redAdd(this.d);
            amd = this.a.redSub(this.d);
          }

          return a.redMul(amd).eq(apd.redIMuln(2));
        } // E(a,d) <-> E(a',a'd/a)


        if (curve.type === 'edwards') {
          // a' * d = a * d'
          var _a = this.field(curve.a);

          var d = this.field(curve.d);
          return this.a.redMul(d).eq(_a.redMul(this.d));
        }

        return false;
      }
    }, {
      key: "isIsogenous",
      value: function isIsogenous(curve) {
        // Check for the 4-isogenies described by Hamburg:
        // https://moderncrypto.org/mail-archive/curves/2016/000806.html
        assert$4(curve instanceof Curve);
        if (!curve.p.eq(this.p)) return false; // E(1,d) <-> M(2-4d,1)

        if (curve.type === 'mont') {
          if (!this.a.eq(this.one)) return false;
          var a = this.field(curve.a);
          var b = this.field(curve.b);
          var d24 = this.two.redSub(this.d.redMuln(4));
          return a.eq(d24) && b.eq(this.one);
        } // E(a,d) <-> E(-a,d-a)


        if (curve.type === 'edwards') {
          var _a2 = this.field(curve.a);

          var d = this.field(curve.d);
          return _a2.eq(this.a.redNeg()) && d.eq(this.d.redSub(this.a));
        }

        return false;
      }
    }, {
      key: "pointFromShort",
      value: function pointFromShort(point) {
        // [TWISTEQ] Section 1.
        assert$4(point instanceof ShortPoint);

        if (this.isIsomorphic(point.curve)) {
          // Equivalence for E(a,b)->E(a',d'):
          //
          //   x' = (6 * x - a' - d') / (6 * y)
          //   y' = (12 * x - 5 * a' + d') / (12 * x + a' - 5 * d')
          //
          // Undefined for x = (5 * d' - a') / 12 or y = 0.
          //
          // Exceptional Cases:
          //   - O -> (0, 1)
          //   - ((a' + d') / 6, 0) -> (0, -1)
          //   - ((5 * d' - a') / 12, (d' - a') / 4 * sqrt(d')) -> (sqrt(1/d'), oo)
          //
          // Unexceptional Cases:
          //   - ((5 * a' - d') / 12, (a' - d') / 4 * sqrt(a')) -> (sqrt(1/a'), 0)
          if (point.isInfinity()) return this.point();
          if (point.y.isZero()) return this.point(this.zero, this.one.redNeg());
          var a = this.a,
              d = this.d;

          var _this$_scale15 = this._scale(point.curve),
              _this$_scale16 = _slicedToArray__default['default'](_this$_scale15, 2),
              u2 = _this$_scale16[0],
              u3 = _this$_scale16[1];

          var a5 = a.redMuln(5);
          var d5 = d.redMuln(5);
          var x = this.field(point.x).redMul(u2);
          var y = this.field(point.y).redMul(u3);
          var x6 = x.redMuln(6);
          var x12 = x.redMuln(12);
          var xx = x6.redSub(a).redISub(d);
          var xz = y.redMuln(6);
          var yy = x12.redSub(a5).redIAdd(d);
          var yz = x12.redAdd(a).redISub(d5);
          return this.cpoint(xx, xz, yy, yz);
        }

        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromMont",
      value: function pointFromMont(point) {
        // [RFC7748] Section 4.1 & 4.2.
        // [MONT3] Page 6, Section 2.5.
        // [TWISTED] Theorem 3.2, Page 4, Section 3.
        assert$4(point instanceof MontPoint);
        assert$4(point.curve.p.eq(this.p)); // Montgomery `u`, `v`.

        var u = this.field(point.x);
        var v = this.field(point.y);

        if (this.isIsogenous(point.curve)) {
          // 4-isogeny maps for M(2-4d,1)->E(1,d):
          //
          //   x = 4 * v * (u^2 - 1) / (u^4 - 2 * u^2 + 4 * v^2 + 1)
          //   y = -(u^5 - 2 * u^3 - 4 * u * v^2 + u) /
          //        (u^5 - 2 * u^2 * v^2 - 2 * u^3 - 2 * v^2 + u)
          //
          // Undefined for u = 0 and v = 0.
          //
          // Exceptional Cases:
          //   - O -> (0, 1)
          //   - (0, 0) -> (0, 1)
          //
          // Unexceptional Cases:
          //   - (-1, +-sqrt(A - 2)) -> (0, 1)
          //   - (1, +-sqrt(A + 2)) -> (0, -1)
          //
          // The point (1, v) is invalid on Curve448.
          if (point.isInfinity()) return this.point();
          if (point.x.isZero()) return this.point();
          var u2 = u.redSqr();
          var u3 = u2.redMul(u);
          var u4 = u3.redMul(u);
          var u5 = u4.redMul(u);
          var v2 = v.redSqr();
          var a = v.redMuln(4);
          var b = u2.redSub(this.one);
          var c = u2.redMuln(2);
          var d = v2.redMuln(4);
          var e = u3.redIMuln(2);
          var f = u.redMul(v2).redIMuln(4);
          var g = u2.redMul(v2).redIMuln(2);
          var h = v2.redIMuln(2);
          var xx = a.redMul(b);
          var xz = u4.redISub(c).redIAdd(d).redIAdd(this.one);
          var yy = u5.redSub(e).redISub(f).redIAdd(u).redINeg();
          var yz = u5.redISub(g).redISub(e).redISub(h).redIAdd(u);
          return this.cpoint(xx, xz, yy, yz).divn(4);
        }

        if (this.isIsomorphic(point.curve, true)) {
          // Isomorphic maps for M(-A,-B)->E(a,d):
          //
          //   x = +-sqrt((A - 2) / (B * a)) * u / v
          //   y = (u + 1) / (u - 1)
          //
          // Undefined for u = 1 or v = 0.
          //
          // Exceptional Cases:
          //   - O -> (0, 1)
          //   - (0, 0) -> (0, -1)
          //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / d), oo)
          //
          // Unexceptional Cases:
          //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / a), 0)
          //
          // The point (1, v) is invalid on Curve448.
          if (point.isInfinity()) return this.point();
          if (point.x.isZero()) return this.point(this.zero, this.one.redNeg());

          var _c3 = this._scale(point.curve, true);

          var _xx = _c3.redMul(u);

          var _xz = v;

          var _yy = u.redAdd(this.one);

          var _yz = u.redSub(this.one);

          return this.cpoint(_xx, _xz, _yy, _yz);
        }

        if (this.isIsomorphic(point.curve, false)) {
          // Isomorphic maps for M(A,B)->E(a,d):
          //
          //   x = +-sqrt((A + 2) / (B * a)) * u / v
          //   y = (u - 1) / (u + 1)
          //
          // Undefined for u = -1 or v = 0.
          //
          // Exceptional Cases:
          //   - O -> (0, 1)
          //   - (0, 0) -> (0, -1)
          //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / d), oo)
          //
          // Unexceptional Cases:
          //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / a), 0)
          //
          // The point (-1, v) is invalid on Curve25519.
          if (point.isInfinity()) return this.point();
          if (point.x.isZero()) return this.point(this.zero, this.one.redNeg());

          var _c4 = this._scale(point.curve, false);

          var _xx2 = _c4.redMul(u);

          var _xz2 = v;

          var _yy2 = u.redSub(this.one);

          var _yz2 = u.redAdd(this.one);

          return this.cpoint(_xx2, _xz2, _yy2, _yz2);
        }

        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromEdwards",
      value: function pointFromEdwards(point) {
        // [TWISTED] Definition 2.1, Page 3, Section 2.
        // [ISOGENY] Page 2, Section 2.
        assert$4(point instanceof EdwardsPoint);
        assert$4(point.curve.p.eq(this.p)); // Edwards `x`, `y`, `z`, `t`.

        var a = this.field(point.curve.a);
        var x = this.field(point.x);
        var y = this.field(point.y);
        var z = this.field(point.z);
        var t = this.field(point.t);

        if (this.isIsogenous(point.curve)) {
          // 4-isogeny maps for E(a,d)<->E(-a,d-a):
          //
          //   x' = (2 * x * y) / (y^2 - a * x^2)
          //   y' = (y^2 + a * x^2) / (2 - y^2 - a * x^2)
          //
          // Undefined for y^2 - a * x^2 = 0
          //            or y^2 + a * x^2 = 2.
          var xy = x.redMul(y);
          var x2 = x.redSqr();
          var y2 = y.redSqr();
          var z2 = z.redSqr();
          var ax2 = a.redMul(x2);
          var xx = xy.redIMuln(2);
          var xz = y2.redSub(ax2);
          var yy = y2.redAdd(ax2);
          var yz = z2.redIMuln(2).redISub(yy);
          var p = this.cpoint(xx, xz, yy, yz);
          return !this.twisted ? p.divn(4) : p;
        }

        if (this.isIsomorphic(point.curve)) {
          // Isomorphic maps for E(a,d)<->E(a',a'd/a):
          //
          //   x' = +-sqrt(a / a') * x
          //   y' = y
          //
          // Undefined when (a / a') is not square.
          var c = this._scale(point.curve);

          var nx = c.redMul(x);
          var ny = y;
          var nz = z;
          var nt = c.redMul(t);
          return this.point(nx, ny, nz, nt);
        }

        throw new Error('Not implemented.');
      }
    }, {
      key: "pointFromUniform",
      value: function pointFromUniform(u) {
        var curve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        assert$4(u instanceof bnBrowser);
        assert$4(u.red === this.red);
        assert$4(curve == null || curve instanceof MontCurve);
        if (!curve) curve = this._alt();
        var u0 = curve.field(u);
        var p0 = curve.pointFromUniform(u0);
        return this.pointFromMont(p0);
      }
    }, {
      key: "pointToUniform",
      value: function pointToUniform(p, hint) {
        var curve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        assert$4(p instanceof EdwardsPoint);
        assert$4(hint >>> 0 === hint);
        assert$4(curve == null || curve instanceof MontCurve);
        if (!curve) curve = this._alt(); // Add a random torsion component.

        var i = (hint >> 4 & 15) % this.torsion.length;
        var q = p.add(this.torsion[i]); // Convert and invert.

        var p0 = curve.pointFromEdwards(q);
        var u0 = curve.pointToUniform(p0, hint & 15);
        return this.field(u0);
      }
    }, {
      key: "pointFromHash",
      value: function pointFromHash(bytes, pake) {
        var curve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        assert$4(curve == null || curve instanceof MontCurve);
        if (!curve) curve = this._alt();
        var p0 = curve.pointFromHash(bytes, pake);
        return this.pointFromMont(p0);
      }
    }, {
      key: "pointToHash",
      value: function pointToHash(p, subgroup, rng) {
        var curve = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        assert$4(p instanceof EdwardsPoint);
        assert$4(subgroup >>> 0 === subgroup);
        assert$4(curve == null || curve instanceof MontCurve);
        if (!curve) curve = this._alt(); // Add a random torsion component.

        var i = subgroup % this.torsion.length;
        var q = p.add(this.torsion[i]); // Convert and invert.

        var p0 = curve.pointFromEdwards(q);
        return curve.pointToHash(p0, 0, rng);
      }
    }, {
      key: "decodePoint",
      value: function decodePoint(bytes) {
        return EdwardsPoint.decode(this, bytes);
      }
    }, {
      key: "toShort",
      value: function toShort(a0, odd) {
        var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var _this$_short5 = this._short(a0, odd),
            _this$_short6 = _slicedToArray__default['default'](_this$_short5, 2),
            a = _this$_short6[0],
            b = _this$_short6[1];

        var curve = new ShortCurve({
          red: this.red,
          prime: this.prime,
          p: this.p,
          a: a,
          b: b,
          n: this.n,
          h: this.h
        });

        if (sign != null) {
          var _curve$_scale9 = curve._scale(this),
              _curve$_scale10 = _slicedToArray__default['default'](_curve$_scale9, 2),
              u3 = _curve$_scale10[1];

          if (u3.redIsOdd() !== sign) u3.redINeg();
        }

        if (!this.g.isInfinity()) curve.g = curve.pointFromEdwards(this.g);

        for (var i = 0; i < this.h.word(0); i++) {
          curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);
        }

        return curve;
      }
    }, {
      key: "toMont",
      value: function toMont(b0, invert) {
        var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var _this$_mont5 = this._mont(b0, invert),
            _this$_mont6 = _slicedToArray__default['default'](_this$_mont5, 2),
            a = _this$_mont6[0],
            b = _this$_mont6[1];

        var curve = new MontCurve({
          red: this.red,
          prime: this.prime,
          p: this.p,
          a: a,
          b: b,
          n: this.n,
          h: this.h,
          z: this.z
        });

        if (sign != null) {
          var c = this._scale(curve, invert);

          if (c.redIsOdd() !== sign) c.redINeg();
        }

        if (!this.g.isInfinity()) curve.g = curve.pointFromEdwards(this.g);

        for (var i = 0; i < this.h.word(0); i++) {
          curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);
        }

        return curve;
      }
    }, {
      key: "toEdwards",
      value: function toEdwards(a0) {
        var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var _this$_edwards5 = this._edwards(a0),
            _this$_edwards6 = _slicedToArray__default['default'](_this$_edwards5, 2),
            a = _this$_edwards6[0],
            d = _this$_edwards6[1];

        var curve = new EdwardsCurve({
          red: this.red,
          prime: this.prime,
          p: this.p,
          a: a,
          d: d,
          n: this.n,
          h: this.h,
          z: this.z
        });

        if (sign != null) {
          var c = curve._scale(this);

          if (c.redIsOdd() !== sign) c.redINeg();
        }

        if (!this.g.isInfinity()) {
          curve.g = curve.pointFromEdwards(this.g);
          curve.g.normalize();
        }

        if (curve.isComplete()) {
          for (var i = 0; i < this.h.word(0); i++) {
            curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);
            curve.torsion[i].normalize();
          }
        }

        return curve;
      }
    }, {
      key: "pointFromJSON",
      value: function pointFromJSON(json) {
        return EdwardsPoint.fromJSON(this, json);
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        var json = _get__default['default'](_getPrototypeOf__default['default'](EdwardsCurve.prototype), "toJSON", this).call(this, pre);

        json.a = this.a.fromRed().toJSON();
        json.d = this.d.fromRed().toJSON();
        if (!this.s.isZero()) json.s = this.s.fromRed().toJSON();
        return json;
      }
    }], [{
      key: "_isomorphism",
      value: function _isomorphism(curveA, curveD, customA) {
        // Twisted Edwards Isomorphism.
        //
        // [TWISTED] Definition 2.1, Page 3, Section 2.
        //
        // Transformation:
        //
        //   a' = a'
        //   d' = a' * d / a
        //
        // Where (a / a') is square.
        assert$4(curveA instanceof bnBrowser);
        assert$4(curveD instanceof bnBrowser);
        assert$4(customA instanceof bnBrowser);
        var a = customA.clone();
        var d = customA.redMul(curveD).redDiv(curveA);
        var c = curveA.redDiv(customA);
        if (c.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');
        return [a, d];
      }
    }]);

    return EdwardsCurve;
  }(Curve);
  /**
   * EdwardsPoint
   */


  var EdwardsPoint = /*#__PURE__*/function (_Point5) {
    _inherits__default['default'](EdwardsPoint, _Point5);

    var _super8 = _createSuper$c(EdwardsPoint);

    function EdwardsPoint(curve, x, y, z, t) {
      var _this9;

      _classCallCheck__default['default'](this, EdwardsPoint);

      assert$4(curve instanceof EdwardsCurve);
      _this9 = _super8.call(this, curve, types$1.EXTENDED);
      _this9.x = _this9.curve.zero;
      _this9.y = _this9.curve.one;
      _this9.z = _this9.curve.one;
      _this9.t = _this9.curve.zero;
      _this9.zOne = 1;
      if (x != null) _this9._init(x, y, z, t);
      return _this9;
    }

    _createClass__default['default'](EdwardsPoint, [{
      key: "_init",
      value: function _init(x, y, z, t) {
        assert$4(x instanceof bnBrowser);
        assert$4(y instanceof bnBrowser);
        assert$4(z == null || z instanceof bnBrowser);
        assert$4(t == null || t instanceof bnBrowser);
        this.x = x;
        this.y = y;
        this.z = z || this.curve.one;
        this.t = t || null;
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z.eq(this.curve.one) | 0;

        this._check();

        if (!this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne) this.t = this.t.redDiv(this.z);
        }
      }
    }, {
      key: "_check",
      value: function _check() {
        // In order to achieve complete
        // addition formulas, `a` must
        // be a square (always the case
        // for a=1), and `d` must be a
        // non-square.
        //
        // If this is not the case, the
        // addition formulas may have
        // exceptional cases where Z3=0.
        //
        // In particular, this can occur
        // when: Q*h = -P*h and Q != -P.
        //
        // This is assuming 4-torsion is
        // involved (the 4-torsion point
        // is _not_ representable when
        // `d` is square).
        if (this.z.isZero()) throw new Error('Invalid point.');
      }
    }, {
      key: "clone",
      value: function clone() {
        return this.curve.point(this.x.clone(), this.y.clone(), this.z.clone(), this.t.clone());
      }
    }, {
      key: "swap",
      value: function swap(point, flag) {
        assert$4(point instanceof EdwardsPoint);
        var cond = (flag >> 31 | -flag >> 31) & 1;
        var zOne1 = this.zOne;
        var zOne2 = point.zOne;
        this.x.cswap(point.x, flag);
        this.y.cswap(point.y, flag);
        this.z.cswap(point.z, flag);
        this.t.cswap(point.t, flag);
        this.zOne = zOne1 & (cond ^ 1) | zOne2 & cond;
        point.zOne = zOne2 & (cond ^ 1) | zOne1 & cond;
        return this;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#scaling-z
        // 1I + 2M (+ 1M if extended)
        // Z1 = 1
        if (this.zOne) return this; // A = 1 / Z1

        var a = this.z.redInvert(); // X3 = X1 * A

        this.x = this.x.redMul(a); // Y3 = Y1 * A

        this.y = this.y.redMul(a); // T3 = T1 * A

        this.t = this.t.redMul(a); // Z3 = 1

        this.z = this.curve.one;
        this.zOne = 1;
        return this;
      }
    }, {
      key: "scale",
      value: function scale(a) {
        assert$4(a instanceof bnBrowser); // X3 = X1 * A

        var nx = this.x.redMul(a); // Y3 = Y1 * A

        var ny = this.y.redMul(a); // Z3 = Z1 * A

        var nz = this.z.redMul(a); // T3 = T1 * A

        var nt = this.t.redMul(a);
        return this.curve.point(nx, ny, nz, nt);
      }
    }, {
      key: "neg",
      value: function neg() {
        // -(X1, Y1, Z1, T1) = (-X1, Y1, Z1, -T1)
        var nx = this.x.redNeg();
        var ny = this.y;
        var nz = this.z;
        var nt = this.t.redNeg();
        return this.curve.point(nx, ny, nz, nt);
      }
    }, {
      key: "add",
      value: function add(p) {
        assert$4(p instanceof EdwardsPoint); // P = O

        if (this.isInfinity()) return p; // Q = O

        if (p.isInfinity()) return this; // Z1 = 1

        if (this.zOne) return p._add(this, 0);
        return this._add(p, 0);
      }
    }, {
      key: "_add",
      value: function _add(p, flag) {
        // a = -1
        if (this.curve.mOneA) return this._addM1(p, flag);
        return this._addA(p, flag);
      }
    }, {
      key: "_addM1",
      value: function _addM1(p, flag) {
        // Assumes a = -1.
        //
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3
        // 8M + 8A + 1*k + 1*2
        //
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-madd-2008-hwcd-3
        // 7M + 8A + 1*k + 1*2
        var zOne = p.zOne & (flag ^ 1); // A = (Y1 - X1) * (Y2 - X2)

        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)); // B = (Y1 + X1) * (Y2 + X2)

        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)); // C = T1 * k * T2

        var c = this.t.redMul(this.curve.k).redMul(p.t); // D = Z1 * 2 * Z2

        var d = zOne ? this.z.redAdd(this.z) : this.z.redMul(p.z).redIMuln(2); // E = B - A

        var e = b.redSub(a); // F = D - C

        var f = d.redSub(c); // G = D + C

        var g = d.redIAdd(c); // H = B + A

        var h = b.redIAdd(a); // X3 = E * F

        var nx = e.redMul(f); // Y3 = G * H

        var ny = g.redMul(h); // T3 = E * H

        var nt = e.redMul(h); // Z3 = F * G

        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      }
    }, {
      key: "_addA",
      value: function _addA(p, flag) {
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // 9M + 7A + 1*a + 1*d
        //
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-madd-2008-hwcd
        // 8M + 7A + 1*a + 1*d
        var zOne = p.zOne & (flag ^ 1); // A = X1 * X2

        var a = this.x.redMul(p.x); // B = Y1 * Y2

        var b = this.y.redMul(p.y); // C = T1 * d * T2

        var c = this.curve._mulD(this.t).redMul(p.t); // D = Z1 * Z2


        var d = zOne ? this.z.clone() : this.z.redMul(p.z); // + XYXY = (X1 + Y1) * (X2 + Y2)

        var xyxy = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)); // E = (X1 + Y1) * (X2 + Y2) - A - B

        var e = xyxy.redISub(a).redISub(b); // F = D - C

        var f = d.redSub(c); // G = D + C

        var g = d.redIAdd(c); // H = B - a * A

        var h = b.redISub(this.curve._mulA(a)); // X3 = E * F

        var nx = e.redMul(f); // Y3 = G * H

        var ny = g.redMul(h); // T3 = E * H

        var nt = e.redMul(h); // Z3 = F * G

        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      }
    }, {
      key: "dbl",
      value: function dbl() {
        // P = O
        if (this.isInfinity()) return this;
        return this._dbl(0);
      }
    }, {
      key: "_dbl",
      value: function _dbl(flag) {
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // 4M + 4S + 6A + 1*a + 1*2
        //
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-mdbl-2008-hwcd
        // 3M + 4S + 7A + 1*a + 1*2
        var zOne = this.zOne & (flag ^ 1); // A = X1^2

        var a = this.x.redSqr(); // B = Y1^2

        var b = this.y.redSqr(); // C = 2 * Z1^2

        var c = zOne ? this.curve.two : this.z.redSqr().redIMuln(2); // D = a * A

        var d = this.curve._mulA(a); // E = (X1 + Y1)^2 - A - B


        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b); // G = D + B

        var g = d.redAdd(b); // F = G - C

        var f = g.redSub(c); // H = D - B

        var h = d.redISub(b); // X3 = E * F

        var nx = e.redMul(f); // Y3 = G * H

        var ny = g.redMul(h); // T3 = E * H

        var nt = e.redMul(h); // Z3 = F * G

        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      }
    }, {
      key: "uadd",
      value: function uadd(p) {
        assert$4(p instanceof EdwardsPoint);
        return this._add(p, 1);
      }
    }, {
      key: "udbl",
      value: function udbl() {
        return this._dbl(1);
      }
    }, {
      key: "getX",
      value: function getX() {
        this.normalize();
        return this.x.fromRed();
      }
    }, {
      key: "getY",
      value: function getY() {
        this.normalize();
        return this.y.fromRed();
      }
    }, {
      key: "eq",
      value: function eq(p) {
        assert$4(p instanceof EdwardsPoint);
        assert$4(!this.z.isZero());
        assert$4(!p.z.isZero()); // P = Q

        if (this === p) return true; // Z1 = Z2

        if (this.z.eq(p.z)) {
          return this.x.eq(p.x) && this.y.eq(p.y);
        } // X1 * Z2 == X2 * Z1


        var x1 = this.x.redMul(p.z);
        var x2 = p.x.redMul(this.z);
        if (!x1.eq(x2)) return false;
        var y1 = this.y.redMul(p.z);
        var y2 = p.y.redMul(this.z);
        return y1.eq(y2);
      }
    }, {
      key: "cmp",
      value: function cmp(point) {
        assert$4(point instanceof EdwardsPoint);
        return this.order().cmp(point.order()) || this.getY().cmp(point.getY()) || this.getX().cmp(point.getX());
      }
    }, {
      key: "isInfinity",
      value: function isInfinity() {
        assert$4(!this.z.isZero()); // X1 = 0

        if (!this.x.isZero()) return false; // Y1 = Z1

        return this.y.eq(this.z);
      }
    }, {
      key: "isOrder2",
      value: function isOrder2() {
        if (this.isInfinity()) return false;
        return this.x.isZero();
      }
    }, {
      key: "isOdd",
      value: function isOdd() {
        this.normalize();
        return this.x.redIsOdd();
      }
    }, {
      key: "isEven",
      value: function isEven() {
        this.normalize();
        return this.x.redIsEven();
      }
    }, {
      key: "toP",
      value: function toP() {
        return this.normalize();
      }
    }, {
      key: "toJ",
      value: function toJ() {
        return this;
      }
    }, {
      key: "encode",
      value: function encode() {
        // [RFC8032] Section 5.1.2.
        var y = this.getY(); // Note: `x` normalized from `getY()` call.

        y.setn(this.curve.signBit, this.x.redIsOdd());
        return this.curve.encodeAdjusted(y);
      }
    }, {
      key: "toJSON",
      value: function toJSON(pre) {
        if (this.isInfinity()) return [];
        var x = this.getX().toJSON();
        var y = this.getY().toJSON();
        if (pre === true && this.pre) return [x, y, this.pre.toJSON()];
        return [x, y];
      }
    }, {
      key: "toPretty",
      value: function toPretty() {
        var size = this.curve.fieldSize * 2;

        var x = _toPretty(this.getX(), size);

        var y = _toPretty(this.getY(), size);

        return [x, y];
      }
    }, {
      key: custom$2,
      value: function value() {
        if (this.isInfinity()) return '<EdwardsPoint: Infinity>';
        return '<EdwardsPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';
      }
    }], [{
      key: "decode",
      value: function decode(curve, bytes) {
        // [RFC8032] Section 5.1.3.
        assert$4(curve instanceof EdwardsCurve);
        var y = curve.decodeAdjusted(bytes);
        var sign = y.testn(curve.signBit) !== 0;
        y.setn(curve.signBit, 0);
        if (y.cmp(curve.p) >= 0) throw new Error('Invalid point.');
        return curve.pointFromY(y, sign);
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(curve, json) {
        assert$4(curve instanceof EdwardsCurve);
        assert$4(Array.isArray(json));
        assert$4(json.length === 0 || json.length === 2 || json.length === 3);
        if (json.length === 0) return curve.point();
        var x = bnBrowser.fromJSON(json[0]);
        var y = bnBrowser.fromJSON(json[1]);
        var point = curve.point(x, y);
        if (json.length > 2 && json[2] != null) point.pre = Precomp.fromJSON(point, json[2]);
        return point;
      }
    }]);

    return EdwardsPoint;
  }(Point);
  /**
   * Precomp
   */


  var Precomp = /*#__PURE__*/function () {
    function Precomp() {
      _classCallCheck__default['default'](this, Precomp);

      this.naf = null;
      this.windows = null;
      this.doubles = null;
      this.blinding = null;
      this.beta = null;
    }

    _createClass__default['default'](Precomp, [{
      key: "map",
      value: function map(func) {
        assert$4(typeof func === 'function');
        var out = new this.constructor();
        if (this.naf) out.naf = this.naf.map(func);
        if (this.doubles) out.doubles = this.doubles.map(func);
        return out;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          naf: this.naf ? this.naf.toJSON() : null,
          windows: this.windows ? this.windows.toJSON() : null,
          doubles: this.doubles ? this.doubles.toJSON() : null,
          blinding: this.blinding ? this.blinding.toJSON() : undefined
        };
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(point, json) {
        assert$4(point instanceof Point);
        assert$4(json && _typeof__default['default'](json) === 'object');
        if (json.naf != null) this.naf = NAF.fromJSON(point, json.naf);
        if (json.windows != null) this.windows = Windows.fromJSON(point, json.windows);
        if (json.doubles != null) this.doubles = Doubles.fromJSON(point, json.doubles);
        if (json.blinding != null) this.blinding = Blinding.fromJSON(point, json.blinding);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(point, json) {
        return new this().fromJSON(point, json);
      }
    }]);

    return Precomp;
  }();
  /**
   * NAF
   */


  var NAF = /*#__PURE__*/function () {
    function NAF(width, points) {
      _classCallCheck__default['default'](this, NAF);

      this.width = width;
      this.points = points;
    }

    _createClass__default['default'](NAF, [{
      key: "map",
      value: function map(func) {
        assert$4(typeof func === 'function');
        var width = this.width;
        var points = [];

        var _iterator = _createForOfIteratorHelper$2(this.points),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var point = _step.value;
            points.push(func(point));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return new this.constructor(width, points);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          width: this.width,
          points: this.points.slice(1).map(function (point) {
            return point.toJSON();
          })
        };
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(point, json) {
        assert$4(point instanceof Point);
        assert$4(json && _typeof__default['default'](json) === 'object');
        assert$4(json.width >>> 0 === json.width);
        assert$4(Array.isArray(json.points));
        var curve = point.curve;
        var width = json.width;
        var points = [point];

        var _iterator2 = _createForOfIteratorHelper$2(json.points),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            points.push(curve.pointFromJSON(item));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return new this(width, points);
      }
    }]);

    return NAF;
  }();
  /**
   * Windows
   */


  var Windows = /*#__PURE__*/function () {
    function Windows(width, bits, points) {
      _classCallCheck__default['default'](this, Windows);

      this.width = width;
      this.bits = bits;
      this.points = points;
    }

    _createClass__default['default'](Windows, [{
      key: "toJSON",
      value: function toJSON() {
        return {
          width: this.width,
          bits: this.bits,
          points: this.points.slice(1).map(function (point) {
            return point.toJSON();
          })
        };
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(point, json) {
        assert$4(point instanceof Point);
        assert$4(json && _typeof__default['default'](json) === 'object');
        assert$4(json.width >>> 0 === json.width);
        assert$4(json.bits >>> 0 === json.bits);
        assert$4(Array.isArray(json.points));
        var curve = point.curve;
        var width = json.width,
            bits = json.bits;
        var points = [point];

        var _iterator3 = _createForOfIteratorHelper$2(json.points),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var item = _step3.value;
            points.push(curve.pointFromJSON(item));
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return new this(width, bits, points);
      }
    }]);

    return Windows;
  }();
  /**
   * Doubles
   */


  var Doubles = /*#__PURE__*/function () {
    function Doubles(step, points) {
      _classCallCheck__default['default'](this, Doubles);

      this.step = step;
      this.points = points;
    }

    _createClass__default['default'](Doubles, [{
      key: "map",
      value: function map(func) {
        assert$4(typeof func === 'function');
        var step = this.step;
        var points = [];

        var _iterator4 = _createForOfIteratorHelper$2(this.points),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var point = _step4.value;
            points.push(func(point));
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return new this.constructor(step, points);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          step: this.step,
          points: this.points.slice(1).map(function (point) {
            return point.toJSON();
          })
        };
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(point, json) {
        assert$4(point instanceof Point);
        assert$4(json && _typeof__default['default'](json) === 'object');
        assert$4(json.step >>> 0 === json.step);
        assert$4(Array.isArray(json.points));
        var curve = point.curve;
        var step = json.step;
        var points = [point];

        var _iterator5 = _createForOfIteratorHelper$2(json.points),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var item = _step5.value;
            points.push(curve.pointFromJSON(item));
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return new this(step, points);
      }
    }]);

    return Doubles;
  }();
  /**
   * Blinding
   */


  var Blinding = /*#__PURE__*/function () {
    function Blinding(blind, unblind) {
      _classCallCheck__default['default'](this, Blinding);

      this.blind = blind;
      this.unblind = unblind;
    }

    _createClass__default['default'](Blinding, [{
      key: "toJSON",
      value: function toJSON() {
        return {
          blind: this.blind.toJSON(),
          unblind: this.unblind.toJSON()
        };
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(point, json) {
        assert$4(point instanceof Point);
        assert$4(json && _typeof__default['default'](json) === 'object');
        var curve = point.curve;
        var blind = bnBrowser.fromJSON(json.blind);
        var unblind = curve.pointFromJSON(json.unblind);
        return new this(blind, unblind);
      }
    }]);

    return Blinding;
  }();
  /**
   * Endo
   */


  var Endo = /*#__PURE__*/function () {
    function Endo(beta, lambda, basis, pre) {
      _classCallCheck__default['default'](this, Endo);

      this.beta = beta;
      this.lambda = lambda;
      this.basis = basis;
      this.pre = pre;
    }

    _createClass__default['default'](Endo, [{
      key: "toJSON",
      value: function toJSON() {
        return {
          beta: this.beta.fromRed().toJSON(),
          lambda: this.lambda.toJSON(),
          basis: [this.basis[0].toJSON(), this.basis[1].toJSON()],
          pre: [this.pre[0].toJSON(), this.pre[1].toJSON()]
        };
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(curve, json) {
        assert$4(curve instanceof Curve);
        assert$4(json && _typeof__default['default'](json) === 'object');
        assert$4(Array.isArray(json.basis));
        assert$4(Array.isArray(json.pre));
        assert$4(json.basis.length === 2);
        assert$4(json.pre.length === 2);
        var beta = bnBrowser.fromJSON(json.beta).toRed(curve.red);
        var lambda = bnBrowser.fromJSON(json.lambda);
        var basis = [Vector.fromJSON(json.basis[0]), Vector.fromJSON(json.basis[1])];
        var pre = [bnBrowser.fromJSON(json.pre[0]), bnBrowser.fromJSON(json.pre[1])];
        return new this(beta, lambda, basis, pre);
      }
    }]);

    return Endo;
  }();
  /**
   * Vector
   */


  var Vector = /*#__PURE__*/function () {
    function Vector(a, b) {
      _classCallCheck__default['default'](this, Vector);

      this.a = a;
      this.b = b;
    }

    _createClass__default['default'](Vector, [{
      key: "toJSON",
      value: function toJSON() {
        return {
          a: this.a.toJSON(),
          b: this.b.toJSON()
        };
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(json) {
        assert$4(json && _typeof__default['default'](json) === 'object');
        var a = bnBrowser.fromJSON(json.a);
        var b = bnBrowser.fromJSON(json.b);
        return new this(a, b);
      }
    }]);

    return Vector;
  }();
  /**
   * P192
   * https://tinyurl.com/fips-186-2 (page 29)
   * https://tinyurl.com/fips-186-3 (page 88)
   */


  var P192$1 = /*#__PURE__*/function (_ShortCurve) {
    _inherits__default['default'](P192, _ShortCurve);

    var _super9 = _createSuper$c(P192);

    function P192(pre) {
      _classCallCheck__default['default'](this, P192);

      return _super9.call(this, {
        id: 'P192',
        ossl: 'prime192v1',
        type: 'short',
        endian: 'be',
        hash: 'SHA256',
        prime: 'p192',
        // 2^192 - 2^64 - 1 (= 3 mod 4)
        p: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff'],
        // -3 mod p
        a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff fffffffc'],
        b: ['64210519 e59c80e7 0fa7e9ab 72243049', 'feb8deec c146b9b1'],
        n: ['ffffffff ffffffff ffffffff 99def836', '146bc9b1 b4d22831'],
        h: '1',
        // Icart
        z: '-5',
        g: [['188da80e b03090f6 7cbf20eb 43a18800', 'f4ff0afd 82ff1012'], ['07192b95 ffc8da78 631011ed 6b24cdd5', '73f977a1 1e794811'], pre]
      });
    }

    return P192;
  }(ShortCurve);
  /**
   * P224
   * https://tinyurl.com/fips-186-2 (page 30)
   * https://tinyurl.com/fips-186-3 (page 88)
   */


  var P224$1 = /*#__PURE__*/function (_ShortCurve2) {
    _inherits__default['default'](P224, _ShortCurve2);

    var _super10 = _createSuper$c(P224);

    function P224(pre) {
      _classCallCheck__default['default'](this, P224);

      return _super10.call(this, {
        id: 'P224',
        ossl: 'secp224r1',
        type: 'short',
        endian: 'be',
        hash: 'SHA256',
        prime: 'p224',
        // 2^224 - 2^96 + 1 (no congruence)
        p: ['ffffffff ffffffff ffffffff ffffffff', '00000000 00000000 00000001'],
        // -3 mod p
        a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff fffffffe'],
        b: ['b4050a85 0c04b3ab f5413256 5044b0b7', 'd7bfd8ba 270b3943 2355ffb4'],
        n: ['ffffffff ffffffff ffffffff ffff16a2', 'e0b8f03e 13dd2945 5c5c2a3d'],
        h: '1',
        // SSWU
        z: '1f',
        g: [['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3', '56c21122 343280d6 115c1d21'], ['bd376388 b5f723fb 4c22dfe6 cd4375a0', '5a074764 44d58199 85007e34'], pre]
      });
    }

    return P224;
  }(ShortCurve);
  /**
   * P256
   * https://tinyurl.com/fips-186-2 (page 31)
   * https://tinyurl.com/fips-186-3 (page 89)
   */


  var P256 = /*#__PURE__*/function (_ShortCurve3) {
    _inherits__default['default'](P256, _ShortCurve3);

    var _super11 = _createSuper$c(P256);

    function P256(pre) {
      _classCallCheck__default['default'](this, P256);

      return _super11.call(this, {
        id: 'P256',
        ossl: 'prime256v1',
        type: 'short',
        endian: 'be',
        hash: 'SHA256',
        prime: null,
        // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
        p: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff ffffffff'],
        // -3 mod p
        a: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff fffffffc'],
        b: ['5ac635d8 aa3a93e7 b3ebbd55 769886bc', '651d06b0 cc53b0f6 3bce3c3e 27d2604b'],
        n: ['ffffffff 00000000 ffffffff ffffffff', 'bce6faad a7179e84 f3b9cac2 fc632551'],
        h: '1',
        // SSWU
        z: '-a',
        g: [['6b17d1f2 e12c4247 f8bce6e5 63a440f2', '77037d81 2deb33a0 f4a13945 d898c296'], ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16', '2bce3357 6b315ece cbb64068 37bf51f5'], pre]
      });
    }

    return P256;
  }(ShortCurve);
  /**
   * P384
   * https://tinyurl.com/fips-186-2 (page 32)
   * https://tinyurl.com/fips-186-3 (page 89)
   */


  var P384 = /*#__PURE__*/function (_ShortCurve4) {
    _inherits__default['default'](P384, _ShortCurve4);

    var _super12 = _createSuper$c(P384);

    function P384(pre) {
      _classCallCheck__default['default'](this, P384);

      return _super12.call(this, {
        id: 'P384',
        ossl: 'secp384r1',
        type: 'short',
        endian: 'be',
        hash: 'SHA384',
        prime: null,
        // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
        p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff fffffffe', 'ffffffff 00000000 00000000 ffffffff'],
        // -3 mod p
        a: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff fffffffe', 'ffffffff 00000000 00000000 fffffffc'],
        b: ['b3312fa7 e23ee7e4 988e056b e3f82d19', '181d9c6e fe814112 0314088f 5013875a', 'c656398d 8a2ed19d 2a85c8ed d3ec2aef'],
        n: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff c7634d81 f4372ddf', '581a0db2 48b0a77a ecec196a ccc52973'],
        h: '1',
        // Icart
        z: '-c',
        g: [['aa87ca22 be8b0537 8eb1c71e f320ad74', '6e1d3b62 8ba79b98 59f741e0 82542a38', '5502f25d bf55296c 3a545e38 72760ab7'], ['3617de4a 96262c6f 5d9e98bf 9292dc29', 'f8f41dbd 289a147c e9da3113 b5f0b8c0', '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'], pre]
      });
    }

    return P384;
  }(ShortCurve);
  /**
   * P521
   * https://tinyurl.com/fips-186-2 (page 33)
   * https://tinyurl.com/fips-186-3 (page 90)
   */


  var P521$1 = /*#__PURE__*/function (_ShortCurve5) {
    _inherits__default['default'](P521, _ShortCurve5);

    var _super13 = _createSuper$c(P521);

    function P521(pre) {
      _classCallCheck__default['default'](this, P521);

      return _super13.call(this, {
        id: 'P521',
        ossl: 'secp521r1',
        type: 'short',
        endian: 'be',
        hash: 'SHA512',
        prime: 'p521',
        // 2^521 - 1 (= 3 mod 4)
        p: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff'],
        // -3 mod p
        a: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'fffffffc'],
        b: ['00000051 953eb961 8e1c9a1f 929a21a0', 'b68540ee a2da725b 99b315f3 b8b48991', '8ef109e1 56193951 ec7e937b 1652c0bd', '3bb1bf07 3573df88 3d2c34f1 ef451fd4', '6b503f00'],
        n: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'fffffffa 51868783 bf2f966b 7fcc0148', 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e', '91386409'],
        h: '1',
        // SSWU
        z: '-4',
        g: [['000000c6 858e06b7 0404e9cd 9e3ecb66', '2395b442 9c648139 053fb521 f828af60', '6b4d3dba a14b5e77 efe75928 fe1dc127', 'a2ffa8de 3348b3c1 856a429b f97e7e31', 'c2e5bd66'], ['00000118 39296a78 9a3bc004 5c8a5fb4', '2c7d1bd9 98f54449 579b4468 17afbd17', '273e662c 97ee7299 5ef42640 c550b901', '3fad0761 353c7086 a272c240 88be9476', '9fd16650'], pre]
      });
    }

    return P521;
  }(ShortCurve);
  /**
   * SECP256K1
   * https://www.secg.org/SEC2-Ver-1.0.pdf (page 15, section 2.7.1)
   * https://www.secg.org/sec2-v2.pdf (page 9, section 2.4.1)
   */


  var SECP256K1 = /*#__PURE__*/function (_ShortCurve6) {
    _inherits__default['default'](SECP256K1, _ShortCurve6);

    var _super14 = _createSuper$c(SECP256K1);

    function SECP256K1(pre) {
      _classCallCheck__default['default'](this, SECP256K1);

      return _super14.call(this, {
        id: 'SECP256K1',
        ossl: 'secp256k1',
        type: 'short',
        endian: 'be',
        hash: 'SHA256',
        prime: 'k256',
        // 2^256 - 2^32 - 977 (= 3 mod 4)
        p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe fffffc2f'],
        a: '0',
        b: '7',
        n: ['ffffffff ffffffff ffffffff fffffffe', 'baaedce6 af48a03b bfd25e8c d0364141'],
        h: '1',
        // SVDW
        z: '1',
        // sqrt(-3)
        c: ['0a2d2ba9 3507f1df 233770c2 a797962c', 'c61f6d15 da14ecd4 7d8d27ae 1cd5f852'],
        g: [['79be667e f9dcbbac 55a06295 ce870b07', '029bfcdb 2dce28d9 59f2815b 16f81798'], ['483ada77 26a3c465 5da4fbfc 0e1108a8', 'fd17b448 a6855419 9c47d08f fb10d4b8'], pre],
        // Precomputed endomorphism.
        endo: {
          beta: ['7ae96a2b 657c0710 6e64479e ac3434e9', '9cf04975 12f58995 c1396c28 719501ee'],
          lambda: ['5363ad4c c05c30e0 a5261c02 8812645a', '122e22ea 20816678 df02967c 1b23bd72'],
          basis: [{
            a: '3086d221a7d46bcde86c90e49284eb15',
            b: '-e4437ed6010e88286f547fa90abfe4c3'
          }, {
            a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
            b: '3086d221a7d46bcde86c90e49284eb15'
          }],
          pre: ['3086d221a7d46bcde86c90e49284eb153dab', '-e4437ed6010e88286f547fa90abfe4c42212']
        }
      });
    }

    return SECP256K1;
  }(ShortCurve);
  /**
   * BRAINPOOLP256
   * https://tools.ietf.org/html/rfc5639#section-3.4
   */


  var BRAINPOOLP256 = /*#__PURE__*/function (_ShortCurve7) {
    _inherits__default['default'](BRAINPOOLP256, _ShortCurve7);

    var _super15 = _createSuper$c(BRAINPOOLP256);

    function BRAINPOOLP256(pre) {
      _classCallCheck__default['default'](this, BRAINPOOLP256);

      return _super15.call(this, {
        id: 'BRAINPOOLP256',
        ossl: 'brainpoolP256r1',
        type: 'short',
        endian: 'be',
        hash: 'SHA256',
        prime: null,
        // (= 3 mod 4)
        p: ['a9fb57db a1eea9bc 3e660a90 9d838d72', '6e3bf623 d5262028 2013481d 1f6e5377'],
        a: ['7d5a0975 fc2c3057 eef67530 417affe7', 'fb8055c1 26dc5c6c e94a4b44 f330b5d9'],
        b: ['26dc5c6c e94a4b44 f330b5d9 bbd77cbf', '95841629 5cf7e1ce 6bccdc18 ff8c07b6'],
        n: ['a9fb57db a1eea9bc 3e660a90 9d838d71', '8c397aa3 b561a6f7 901e0e82 974856a7'],
        h: '1',
        // Icart
        z: '-2',
        g: [['8bd2aeb9 cb7e57cb 2c4b482f fc81b7af', 'b9de27e1 e3bd23c2 3a4453bd 9ace3262'], ['547ef835 c3dac4fd 97f8461a 14611dc9', 'c2774513 2ded8e54 5c1d54c7 2f046997'], pre]
      });
    }

    return BRAINPOOLP256;
  }(ShortCurve);
  /**
   * BRAINPOOLP384
   * https://tools.ietf.org/html/rfc5639#section-3.6
   */


  var BRAINPOOLP384 = /*#__PURE__*/function (_ShortCurve8) {
    _inherits__default['default'](BRAINPOOLP384, _ShortCurve8);

    var _super16 = _createSuper$c(BRAINPOOLP384);

    function BRAINPOOLP384(pre) {
      _classCallCheck__default['default'](this, BRAINPOOLP384);

      return _super16.call(this, {
        id: 'BRAINPOOLP384',
        ossl: 'brainpoolP384r1',
        type: 'short',
        endian: 'be',
        hash: 'SHA384',
        prime: null,
        // (= 3 mod 4)
        p: ['8cb91e82 a3386d28 0f5d6f7e 50e641df', '152f7109 ed5456b4 12b1da19 7fb71123', 'acd3a729 901d1a71 87470013 3107ec53'],
        a: ['7bc382c6 3d8c150c 3c72080a ce05afa0', 'c2bea28e 4fb22787 139165ef ba91f90f', '8aa5814a 503ad4eb 04a8c7dd 22ce2826'],
        b: ['04a8c7dd 22ce2826 8b39b554 16f0447c', '2fb77de1 07dcd2a6 2e880ea5 3eeb62d5', '7cb43902 95dbc994 3ab78696 fa504c11'],
        n: ['8cb91e82 a3386d28 0f5d6f7e 50e641df', '152f7109 ed5456b3 1f166e6c ac0425a7', 'cf3ab6af 6b7fc310 3b883202 e9046565'],
        h: '1',
        // SSWU
        z: '-5',
        g: [['1d1c64f0 68cf45ff a2a63a81 b7c13f6b', '8847a3e7 7ef14fe3 db7fcafe 0cbd10e8', 'e826e034 36d646aa ef87b2e2 47d4af1e'], ['8abe1d75 20f9c2a4 5cb1eb8e 95cfd552', '62b70b29 feec5864 e19c054f f9912928', '0e464621 77918111 42820341 263c5315'], pre]
      });
    }

    return BRAINPOOLP384;
  }(ShortCurve);
  /**
   * BRAINPOOLP512
   * https://tools.ietf.org/html/rfc5639#section-3.7
   */


  var BRAINPOOLP512 = /*#__PURE__*/function (_ShortCurve9) {
    _inherits__default['default'](BRAINPOOLP512, _ShortCurve9);

    var _super17 = _createSuper$c(BRAINPOOLP512);

    function BRAINPOOLP512(pre) {
      _classCallCheck__default['default'](this, BRAINPOOLP512);

      return _super17.call(this, {
        id: 'BRAINPOOLP512',
        ossl: 'brainpoolP512r1',
        type: 'short',
        endian: 'be',
        hash: 'SHA512',
        prime: null,
        // (= 3 mod 4)
        p: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07', 'cb308db3 b3c9d20e d6639cca 70330871', '7d4d9b00 9bc66842 aecda12a e6a380e6', '2881ff2f 2d82c685 28aa6056 583a48f3'],
        a: ['7830a331 8b603b89 e2327145 ac234cc5', '94cbdd8d 3df91610 a83441ca ea9863bc', '2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5', '7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca'],
        b: ['3df91610 a83441ca ea9863bc 2ded5d5a', 'a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7', '2bf2c7b9 e7c1ac4d 77fc94ca dc083e67', '984050b7 5ebae5dd 2809bd63 8016f723'],
        n: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07', 'cb308db3 b3c9d20e d6639cca 70330870', '553e5c41 4ca92619 41866119 7fac1047', '1db1d381 085ddadd b5879682 9ca90069'],
        h: '1',
        // Icart
        z: '7',
        g: [['81aee4bd d82ed964 5a21322e 9c4c6a93', '85ed9f70 b5d916c1 b43b62ee f4d0098e', 'ff3b1f78 e2d0d48d 50d1687b 93b97d5f', '7c6d5047 406a5e68 8b352209 bcb9f822'], ['7dde385d 566332ec c0eabfa9 cf7822fd', 'f209f700 24a57b1a a000c55b 881f8111', 'b2dcde49 4a5f485e 5bca4bd8 8a2763ae', 'd1ca2b2f a8f05406 78cd1e0f 3ad80892'], pre]
      });
    }

    return BRAINPOOLP512;
  }(ShortCurve);
  /**
   * X25519
   * https://tools.ietf.org/html/rfc7748#section-4.1
   */


  var X25519 = /*#__PURE__*/function (_MontCurve) {
    _inherits__default['default'](X25519, _MontCurve);

    var _super18 = _createSuper$c(X25519);

    function X25519() {
      _classCallCheck__default['default'](this, X25519);

      return _super18.call(this, {
        id: 'X25519',
        ossl: 'X25519',
        type: 'mont',
        endian: 'le',
        hash: 'SHA512',
        prime: 'p25519',
        // 2^255 - 19 (= 5 mod 8)
        p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],
        // 486662
        a: '76d06',
        b: '1',
        n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],
        h: '8',
        // Elligator 2
        z: '2',
        g: [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000009'], // See: https://www.rfc-editor.org/errata/eid4730
        ['5f51e65e 475f794b 1fe122d3 88b72eb3', '6dc2b281 92839e4d d6163a5d 81312c14']],
        torsion: [[], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000001'], ['6be4f497 f9a9c2af c21fa77a d7f4a6ef', '635a11c7 284a9363 e9a248ef 9c884415']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000001'], ['141b0b68 06563d50 3de05885 280b5910', '9ca5ee38 d7b56c9c 165db710 6377bbd8']], [['57119fd0 dd4e22d8 868e1c58 c45c4404', '5bef839c 55b1d0b1 248c50a3 bc959c5f'], ['68c59389 3d458e64 31c6ca00 45fb5015', '20a44346 8eaa68dd 0f103842 048065b7']], [['57119fd0 dd4e22d8 868e1c58 c45c4404', '5bef839c 55b1d0b1 248c50a3 bc959c5f'], ['173a6c76 c2ba719b ce3935ff ba04afea', 'df5bbcb9 71559722 f0efc7bd fb7f9a36']], [['00b8495f 16056286 fdb1329c eb8d09da', '6ac49ff1 fae35616 aeb8413b 7c7aebe0'], ['3931c129 569e83a5 29482c14 e628b457', '933bfc29 ed801b4d 68871483 92507b1a']], [['00b8495f 16056286 fdb1329c eb8d09da', '6ac49ff1 fae35616 aeb8413b 7c7aebe0'], ['46ce3ed6 a9617c5a d6b7d3eb 19d74ba8', '6cc403d6 127fe4b2 9778eb7c 6daf84d3']]]
      });
    }

    return X25519;
  }(MontCurve);
  /**
   * X448
   * https://tools.ietf.org/html/rfc7748#section-4.2
   */


  var X448 = /*#__PURE__*/function (_MontCurve2) {
    _inherits__default['default'](X448, _MontCurve2);

    var _super19 = _createSuper$c(X448);

    function X448() {
      _classCallCheck__default['default'](this, X448);

      return _super19.call(this, {
        id: 'X448',
        ossl: 'X448',
        type: 'mont',
        endian: 'le',
        hash: 'SHAKE256',
        prime: 'p448',
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],
        // 156326
        a: '262a6',
        b: '1',
        n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],
        h: '4',
        // Elligator 2
        z: '-1',
        g: [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000005'], ['7d235d12 95f5b1f6 6c98ab6e 58326fce', 'cbae5d34 f55545d0 60f75dc2 8df3f6ed', 'b8027e23 46430d21 1312c4b1 50677af7', '6fd7223d 457b5b1a']],
        torsion: [[], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['ba4d3a08 29b6112f 8812e51b a0bb2abe', 'bc1cb08e b48e5569 36ba50fd d2e7d68a', 'f8cb3216 0522425b 3f990812 abbe635a', 'd37a21e1 7551b193']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['45b2c5f7 d649eed0 77ed1ae4 5f44d541', '43e34f71 4b71aa96 c945af01 2d182975', '0734cde9 faddbda4 c066f7ed 54419ca5', '2c85de1e 8aae4e6c']]]
      });
    }

    return X448;
  }(MontCurve);
  /**
   * MONT448
   * Isomorphic to Ed448-Goldilocks.
   */


  var MONT448 = /*#__PURE__*/function (_MontCurve3) {
    _inherits__default['default'](MONT448, _MontCurve3);

    var _super20 = _createSuper$c(MONT448);

    function MONT448() {
      _classCallCheck__default['default'](this, MONT448);

      return _super20.call(this, {
        id: 'MONT448',
        ossl: null,
        type: 'mont',
        endian: 'le',
        hash: 'SHAKE256',
        prime: 'p448',
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],
        // -78160 / -39082 mod p
        a: ['b2cf97d2 d43459a9 31ed36b1 fc4e3cb5', '5d93f8d2 22746997 60ccffc6 49961ed6', 'c5b05fca c24864ed 6fb59697 931b78da', '84ddecd8 ca2b5cfb'],
        b: '1',
        n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],
        h: '4',
        // Elligator 2
        z: '-1',
        g: [['ac0d24cc c6c75cb0 eb71f81e 7a6edf51', '48e88aee 009a2a24 e795687e c28e125a', '3e6730a6 0d46367b aa7fe99d 152128dc', '41321bc7 7817f059'], ['5a4437f6 80c0d0db 9b061276 d5d0ffcc', 'e786ff33 b6a53d30 98746425 82e66f09', '4433dae7 7244a6e2 6b11e905 7228f483', '556c41a5 913f55fe']],
        torsion: [[], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['bec92fd0 6da2acf2 b4e261e8 7cef0d34', '22e75c18 3c589857 b71924e5 73c2f9ce', 'e18da5f2 466e2f39 3c2eedf0 f105a60a', 'b40c717d 4f1e1fd7']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['4136d02f 925d530d 4b1d9e17 8310f2cb', 'dd18a3e7 c3a767a8 48e6db19 8c3d0631', '1e725a0d b991d0c6 c3d1120f 0efa59f5', '4bf38e82 b0e1e028']]]
      });
    }

    return MONT448;
  }(MontCurve);
  /**
   * ED25519
   * https://tools.ietf.org/html/rfc8032#section-5.1
   */


  var ED25519 = /*#__PURE__*/function (_EdwardsCurve) {
    _inherits__default['default'](ED25519, _EdwardsCurve);

    var _super21 = _createSuper$c(ED25519);

    function ED25519(pre) {
      _classCallCheck__default['default'](this, ED25519);

      return _super21.call(this, {
        id: 'ED25519',
        ossl: 'ED25519',
        type: 'edwards',
        endian: 'le',
        hash: 'SHA512',
        prefix: 'SigEd25519 no Ed25519 collisions',
        context: false,
        prime: 'p25519',
        // 2^255 - 19 (= 5 mod 8)
        p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],
        a: '-1',
        // -121665 / 121666 mod p
        d: ['52036cee 2b6ffe73 8cc74079 7779e898', '00700a4d 4141d8ab 75eb4dca 135978a3'],
        n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],
        h: '8',
        // Elligator 2
        z: '2',
        g: [['216936d3 cd6e53fe c0a4e231 fdd6dc5c', '692cc760 9525a7b2 c9562d60 8f25d51a'], // 4/5
        ['66666666 66666666 66666666 66666666', '66666666 66666666 66666666 66666658'], pre],
        torsion: [[['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000001']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000'], ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffec']], [['2b832480 4fc1df0b 2b4d0099 3dfbd7a7', '2f431806 ad2fe478 c4ee1b27 4a0ea0b0'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000']], [['547cdb7f b03e20f4 d4b2ff66 c2042858', 'd0bce7f9 52d01b87 3b11e4d8 b5f15f3d'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000']], [['1fd5b9a0 06394a28 e9339932 38de4abb', '5c193c70 13e5e238 dea14646 c545d14a'], ['05fc536d 880238b1 3933c6d3 05acdfd5', 'f098eff2 89f4c345 b027b2c2 8f95e826']], [['602a465f f9c6b5d7 16cc66cd c721b544', 'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'], ['05fc536d 880238b1 3933c6d3 05acdfd5', 'f098eff2 89f4c345 b027b2c2 8f95e826']], [['1fd5b9a0 06394a28 e9339932 38de4abb', '5c193c70 13e5e238 dea14646 c545d14a'], ['7a03ac92 77fdc74e c6cc392c fa53202a', '0f67100d 760b3cba 4fd84d3d 706a17c7']], [['602a465f f9c6b5d7 16cc66cd c721b544', 'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'], ['7a03ac92 77fdc74e c6cc392c fa53202a', '0f67100d 760b3cba 4fd84d3d 706a17c7']]]
      });
    }

    return ED25519;
  }(EdwardsCurve);
  /**
   * ISO448
   * https://tools.ietf.org/html/rfc7748#section-4.2
   * https://git.zx2c4.com/goldilocks/tree/_aux/ristretto/ristretto.sage#n658
   */


  var ISO448 = /*#__PURE__*/function (_EdwardsCurve2) {
    _inherits__default['default'](ISO448, _EdwardsCurve2);

    var _super22 = _createSuper$c(ISO448);

    function ISO448(pre) {
      _classCallCheck__default['default'](this, ISO448);

      return _super22.call(this, {
        id: 'ISO448',
        ossl: null,
        type: 'edwards',
        endian: 'le',
        hash: 'SHAKE256',
        prefix: 'SigEd448',
        context: true,
        prime: 'p448',
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],
        a: '1',
        // 39082 / 39081 mod p
        d: ['d78b4bdc 7f0daf19 f24f38c2 9373a2cc', 'ad461572 42a50f37 809b1da3 412a12e7', '9ccc9c81 264cfe9a d0809970 58fb61c4', '243cc32d baa156b9'],
        n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],
        h: '4',
        // Elligator 2
        z: '-1',
        g: [['79a70b2b 70400553 ae7c9df4 16c792c6', '1128751a c9296924 0c25a07d 728bdc93', 'e21f7787 ed697224 9de732f3 8496cd11', '69871309 3e9c04fc'], // Note: the RFC has this wrong.
        ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 80000000', '00000000 00000000 00000000 00000000', '00000000 00000001'], pre],
        torsion: [[['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000001']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000001'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']]]
      });
    }

    return ISO448;
  }(EdwardsCurve);
  /**
   * ED448
   * https://tools.ietf.org/html/rfc8032#section-5.2
   */


  var ED448 = /*#__PURE__*/function (_EdwardsCurve3) {
    _inherits__default['default'](ED448, _EdwardsCurve3);

    var _super23 = _createSuper$c(ED448);

    function ED448(pre) {
      _classCallCheck__default['default'](this, ED448);

      return _super23.call(this, {
        id: 'ED448',
        ossl: 'ED448',
        type: 'edwards',
        endian: 'le',
        hash: 'SHAKE256',
        prefix: 'SigEd448',
        context: true,
        prime: 'p448',
        // 2^448 - 2^224 - 1 (= 3 mod 4)
        p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],
        a: '1',
        // -39081 mod p
        d: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffff6756'],
        n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],
        h: '4',
        // Elligator 2
        z: '-1',
        g: [['4f1970c6 6bed0ded 221d15a6 22bf36da', '9e146570 470f1767 ea6de324 a3d3a464', '12ae1af7 2ab66511 433b80e1 8b00938e', '2626a82b c70cc05e'], ['693f4671 6eb6bc24 88762037 56c9c762', '4bea7373 6ca39840 87789c1e 05a0c2d7', '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad', '9808795b f230fa14'], pre],
        torsion: [[['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000001']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000'], ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe']], [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000001'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']], [['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff fffffffe'], ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000']]]
      });
    }

    return ED448;
  }(EdwardsCurve);
  /*
   * Curve Registry
   */


  var curves = {
    __proto__: null,
    P192: P192$1,
    P224: P224$1,
    P256: P256,
    P384: P384,
    P521: P521$1,
    SECP256K1: SECP256K1,
    BRAINPOOLP256: BRAINPOOLP256,
    BRAINPOOLP384: BRAINPOOLP384,
    BRAINPOOLP512: BRAINPOOLP512,
    X25519: X25519,
    X448: X448,
    MONT448: MONT448,
    ED25519: ED25519,
    ISO448: ISO448,
    ED448: ED448
  };
  var cache = {
    __proto__: null,
    P192: null,
    P224: null,
    P256: null,
    P384: null,
    P521: null,
    SECP256K1: null,
    BRAINPOOLP256: null,
    BRAINPOOLP384: null,
    BRAINPOOLP512: null,
    X25519: null,
    X448: null,
    MONT448: null,
    ED25519: null,
    ISO448: null,
    ED448: null
  };

  function curve(name) {
    assert$4(typeof name === 'string');
    var key = name.toUpperCase();
    var curve = cache[key];

    if (!curve) {
      var _Curve4 = curves[key];
      if (!_Curve4) throw new Error("Curve not found: \"".concat(name, "\"."));

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      curve = _construct__default['default'](_Curve4, args);
      cache[key] = curve;
    }

    return curve;
  }

  function register(name, Curve) {
    assert$4(typeof name === 'string');
    assert$4(typeof Curve === 'function');
    var key = name.toUpperCase();
    if (curves[key]) throw new Error("Curve already registered: \"".concat(name, "\"."));
    curves[key] = Curve;
    cache[key] = null;
  }
  /*
   * Scalar Recoding
   */


  function getNAF(k, width, max) {
    // Computing the width-w NAF of a positive integer.
    //
    // [GECC] Algorithm 3.35, Page 100, Section 3.3.
    //
    // The above document describes a rather abstract
    // method of recoding. The more optimal method
    // below was ported from libsecp256k1.
    assert$4(k instanceof bnBrowser);
    assert$4(!k.red);
    assert$4(width >>> 0 === width);
    assert$4(max >>> 0 === max);
    var naf = new Array(max);
    var bits = k.bitLength() + 1;
    var sign = k.sign() | 1;
    assert$4(bits <= max);

    for (var _i7 = 0; _i7 < max; _i7++) {
      naf[_i7] = 0;
    }

    var i = 0;
    var carry = 0;
    var word;

    while (i < bits) {
      if (k.bit(i) === carry) {
        i += 1;
        continue;
      }

      word = k.bits(i, width) + carry;
      carry = word >> width - 1 & 1;
      word -= carry << width;
      naf[i] = sign * word;
      i += width;
    }

    assert$4(carry === 0);
    return naf;
  }

  function getFixedNAF(k, width, max, step) {
    assert$4(step >>> 0 === step); // Recode to NAF.

    var naf = getNAF(k, width, max); // Translate into more windowed form.

    var len = Math.ceil(naf.length / step);
    var repr = new Array(len);
    var i = 0;

    for (var j = 0; j < naf.length; j += step) {
      var nafW = 0;

      for (var _k = j + step - 1; _k >= j; _k--) {
        nafW = (nafW << 1) + naf[_k];
      }

      repr[i++] = nafW;
    }

    assert$4(i === len);
    return repr;
  }

  function getJSF(k1, k2, max) {
    // Joint sparse form.
    //
    // [GECC] Algorithm 3.50, Page 111, Section 3.3.
    assert$4(k1 instanceof bnBrowser);
    assert$4(k2 instanceof bnBrowser);
    assert$4(!k1.red);
    assert$4(!k2.red);
    assert$4(max >>> 0 === max);
    var jsf = [new Array(max), new Array(max)];
    var bits = Math.max(k1.bitLength(), k2.bitLength()) + 1;
    var s1 = k1.sign() | 1;
    var s2 = k2.sign() | 1;
    assert$4(bits <= max);
    var d1 = 0;
    var d2 = 0;

    for (var i = 0; i < bits; i++) {
      var b1 = k1.bits(i, 3);
      var b2 = k2.bits(i, 3); // First phase.

      var m14 = (b1 & 3) + d1 & 3;
      var m24 = (b2 & 3) + d2 & 3;
      var u1 = 0;
      var u2 = 0;
      if (m14 === 3) m14 = -1;
      if (m24 === 3) m24 = -1;

      if (m14 & 1) {
        var m8 = (b1 & 7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
      }

      if (m24 & 1) {
        var _m = (b2 & 7) + d2 & 7;

        if ((_m === 3 || _m === 5) && m14 === 2) u2 = -m24;else u2 = m24;
      }

      jsf[0][i] = u1 * s1;
      jsf[1][i] = u2 * s2; // Second phase.

      if (2 * d1 === u1 + 1) d1 = 1 - d1;
      if (2 * d2 === u2 + 1) d2 = 1 - d2;
    }

    for (var _i8 = bits; _i8 < max; _i8++) {
      jsf[0][_i8] = 0;
      jsf[1][_i8] = 0;
    }

    return jsf;
  }

  function getJNAF(c1, c2, max) {
    var jsf = getJSF(c1, c2, max);
    var naf = new Array(max); // JSF -> NAF conversion.

    for (var i = 0; i < max; i++) {
      var ja = jsf[0][i];
      var jb = jsf[1][i];
      naf[i] = jsfIndex[(ja + 1) * 3 + (jb + 1)];
    }

    return naf;
  }

  function getLadderBits(k, n) {
    // [TIMING] Page 16, Section 6.
    assert$4(k instanceof bnBrowser);
    assert$4(n instanceof bnBrowser); // Ensure positive.

    var k0 = k.abs(); // Inflate scalar.

    var k1 = k0.add(n);
    var k2 = k1.add(n); // Get bit lengths.

    var kb = k1.bitLength();
    var nb = n.bitLength(); // k' = k + 2 * n, if ceil(log2(k + n)) <= ceil(log2(n)),
    //    = k + n, otherwise

    k1.cinject(k2, kb - nb - 1 >>> 31); // Track sign.

    var sign = k.isNeg() & 1; // Calculate the new scalar's length.

    var bits = k1.bitLength(); // Recode scalar to base256.

    var exp = k1.toArray('le');
    return [sign, bits, exp];
  }

  function getCOZBits(k, n) {
    assert$4(k instanceof bnBrowser);
    assert$4(n instanceof bnBrowser); // Reduce.

    var u = k.mod(n); // Negate scalar.

    var v = n.sub(u); // Get bit lengths.

    var ub = u.bitLength();
    var vb = v.bitLength(); // Negate if ceil(log2(k)) < ceil(log2(-k)).

    var sign = ub - vb >>> 31; // Possibly negate.

    u.cinject(v, sign); // Calculate the new scalar's length.

    var bits = u.bitLength(); // Recode scalar to base256.

    var exp = u.toArray('le'); // Final edge case.

    var m1 = u.ceq(n.subn(1));
    return [sign, bits, exp, m1];
  }
  /*
   * Helpers
   */


  function assert$4(val, msg) {
    if (!val) {
      var _err = new Error(msg || 'Assertion failed');

      if (Error.captureStackTrace) Error.captureStackTrace(_err, assert$4);
      throw _err;
    }
  }

  function sqrt(a) {
    assert$4(a instanceof bnBrowser);

    try {
      return [1, a.redSqrt()];
    } catch (e) {
      if (e.message === 'X is not a square mod P.') return [0, a.clone()];
      throw e;
    }
  }

  function divSqrt(u, v) {
    assert$4(u instanceof bnBrowser);
    assert$4(v instanceof bnBrowser);

    try {
      return [1, u.redDivSqrt(v)];
    } catch (e) {
      if (e.message === 'Not invertible.' || e.message === 'X is not a square mod P.') {
        return [0, u.clone()];
      }

      throw e;
    }
  }

  function cubeRoot(x) {
    assert$4(x instanceof bnBrowser);
    assert$4(x.red);
    var p = x.red.m;
    if (p.cmpn(3) <= 0) return x.clone(); // p = 2 mod 3

    if (p.modrn(3) === 2) {
      // e = (2 * p - 1) / 3
      var e = p.ushln(1).isubn(1).idivn(3);
      return x.redPow(e);
    }

    var mod9 = p.modrn(9); // p = 4 mod 9

    if (mod9 === 4) {
      // e = (2 * p + 1) / 9
      var _e = p.ushln(1).iaddn(1).idivn(9);

      var r = x.redPow(_e);
      var c = r.redSqr().redMul(r);
      if (!c.eq(x)) throw new Error('X is not a cube mod P.');
      return r;
    } // p = 7 mod 9


    if (mod9 === 7) {
      // e = (p + 2) / 9
      var _e2 = p.addn(2).idivn(9);

      var _r = x.redPow(_e2);

      var _c5 = _r.redSqr().redMul(_r);

      if (!_c5.eq(x)) throw new Error('X is not a cube mod P.');
      return _r;
    }

    throw new Error('Not implemented.');
  }

  function cubeRoots(x) {
    var r0 = cubeRoot(x); // p = 1 mod 3

    if (x.red.m.modrn(3) === 1) {
      // Multiply by roots of unity to find other roots.
      var two = new bnBrowser(2).toRed(x.red);
      var three = new bnBrowser(3).toRed(x.red);
      var i2 = two.redInvert();
      var s1 = three.redNeg().redSqrt().redMul(i2);
      var s2 = s1.redNeg();
      var u1 = s1.redSub(i2);
      var u2 = s2.redSub(i2);
      var r1 = r0.redMul(u1);
      var r2 = r0.redMul(u2);
      return [r0, r1, r2];
    } // p = 2 mod 3 guarantees 1 cube root per element.


    return [r0];
  }

  function uncube(x) {
    // Find a cube root which is also a quadratic residue.
    var _iterator6 = _createForOfIteratorHelper$2(cubeRoots(x)),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var root = _step6.value;
        if (root.redJacobi() >= 0) return root;
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    throw new Error('X^(1/3) is not a square mod P.');
  }

  function randomInt$1(rng) {
    return bnBrowser.randomBits(rng, 32).toNumber();
  }

  function memoize$1(method, self) {
    var cache = new WeakMap();
    return function memoized(curve, invert) {
      var i = invert & 1;
      var item = cache.get(curve);
      if (item && item[i] !== null) return item[i];
      var result = method.call(self, curve, invert);
      if (!cache.has(curve)) cache.set(curve, [null, null]);
      cache.get(curve)[i] = result;
      return result;
    };
  }

  function _toPretty(x, size) {
    assert$4(x instanceof bnBrowser);
    assert$4(size >>> 0 === size);
    if (size & 7) size += 8 - (size & 7);
    var str = x.toString(16, size);
    var chunks = [];
    var out = [];
    assert$4((str.length & 7) === 0);

    for (var i = 0; i < str.length; i += 8) {
      chunks.push(str.slice(i, i + 8));
    }

    for (var _i9 = 0; _i9 < chunks.length; _i9 += 4) {
      out.push(chunks.slice(_i9, _i9 + 4).join(' '));
    }

    return out;
  }
  /*
   * Expose
   */


  var Curve_1 = Curve;
  var Point_1 = Point;
  var ShortCurve_1 = ShortCurve;
  var ShortPoint_1 = ShortPoint;
  var JPoint_1 = JPoint;
  var MontCurve_1 = MontCurve;
  var MontPoint_1 = MontPoint;
  var XPoint_1 = XPoint;
  var EdwardsCurve_1 = EdwardsCurve;
  var EdwardsPoint_1 = EdwardsPoint;
  var curves_1 = curves;
  var curve_1 = curve;
  var register_1 = register;
  var elliptic = {
    Curve: Curve_1,
    Point: Point_1,
    ShortCurve: ShortCurve_1,
    ShortPoint: ShortPoint_1,
    JPoint: JPoint_1,
    MontCurve: MontCurve_1,
    MontPoint: MontPoint_1,
    XPoint: XPoint_1,
    EdwardsCurve: EdwardsCurve_1,
    EdwardsPoint: EdwardsPoint_1,
    curves: curves_1,
    curve: curve_1,
    register: register_1
  };

  /*
   * Util
   */


  function countLeft(data) {
    assert_1$1(Buffer.isBuffer(data));
    var i = 0;

    while (i < data.length && data[i] === 0x00) {
      i += 1;
    }

    var bits = (data.length - i) * 8;
    if (bits === 0) return 0;
    bits -= 8;
    var oct = data[i];

    while (oct) {
      bits += 1;
      oct >>>= 1;
    }

    return bits;
  }

  function countRight(data) {
    assert_1$1(Buffer.isBuffer(data));
    var i = data.length;

    while (i > 0 && data[i - 1] === 0x00) {
      i -= 1;
    }

    var bits = i * 8;
    if (bits === 0) return 0;
    bits -= 8;
    var oct = data[i - 1];

    while (oct) {
      bits += 1;
      oct >>>= 1;
    }

    return bits;
  }

  function compareLeft(x, y) {
    assert_1$1(Buffer.isBuffer(x));
    assert_1$1(Buffer.isBuffer(y));
    var xpos = 0;
    var xlen = x.length;
    var ypos = 0;
    var ylen = y.length;

    while (xlen > 0 && x[xpos] === 0x00) {
      xpos += 1;
      xlen -= 1;
    }

    while (ylen > 0 && y[ypos] === 0x00) {
      ypos += 1;
      ylen -= 1;
    }

    if (xlen < ylen) return -1;
    if (xlen > ylen) return 1;

    for (var i = 0; i < xlen; i++) {
      if (x[xpos + i] < y[ypos + i]) return -1;
      if (x[xpos + i] > y[ypos + i]) return 1;
    }

    return 0;
  }

  function compareRight(x, y) {
    assert_1$1(Buffer.isBuffer(x));
    assert_1$1(Buffer.isBuffer(y));
    var xlen = x.length;
    var ylen = y.length;

    while (xlen > 0 && x[xlen - 1] === 0x00) {
      xlen -= 1;
    }

    while (ylen > 0 && y[ylen - 1] === 0x00) {
      ylen -= 1;
    }

    if (xlen < ylen) return -1;
    if (xlen > ylen) return 1;

    for (var i = xlen - 1; i >= 0; i--) {
      if (x[i] < y[i]) return -1;
      if (x[i] > y[i]) return 1;
    }

    return 0;
  }

  function trimLeft(data) {
    assert_1$1(Buffer.isBuffer(data));
    var i = 0;

    while (i < data.length && data[i] === 0x00) {
      i += 1;
    }

    return data.slice(i);
  }

  function trimRight(data) {
    assert_1$1(Buffer.isBuffer(data));
    var i = data.length;

    while (i > 0 && data[i - 1] === 0x00) {
      i -= 1;
    }

    return data.slice(0, i);
  }

  function padLeft(data, size) {
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(size >>> 0 === size);
    if (data.length > size) data = trimLeft(data);
    if (data.length > size) throw new RangeError("Buffer expected to be ".concat(size, " bytes in size."));
    var out = Buffer.alloc(size, 0x00);
    data.copy(out, size - data.length);
    return out;
  }

  function padRight(data, size) {
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(size >>> 0 === size);
    if (data.length > size) data = trimRight(data);
    if (data.length > size) throw new RangeError("Buffer expected to be ".concat(size, " bytes in size."));
    var out = Buffer.alloc(size, 0x00);
    data.copy(out, 0);
    return out;
  }
  /*
   * Expose
   */


  var countLeft_1 = countLeft;
  var countRight_1 = countRight;
  var compareLeft_1 = compareLeft;
  var compareRight_1 = compareRight;
  var trimLeft_1 = trimLeft;
  var trimRight_1 = trimRight;
  var padLeft_1 = padLeft;
  var padRight_1 = padRight;
  var util$1 = {
    countLeft: countLeft_1,
    countRight: countRight_1,
    compareLeft: compareLeft_1,
    compareRight: compareRight_1,
    trimLeft: trimLeft_1,
    trimRight: trimRight_1,
    padLeft: padLeft_1,
    padRight: padRight_1
  };

  var padRight$1 = util$1.padRight;
  /**
   * ECDH
   */

  var ECDH = /*#__PURE__*/function () {
    function ECDH(id, eid, pre) {
      _classCallCheck__default['default'](this, ECDH);

      assert_1$1(typeof id === 'string');
      assert_1$1(!eid || typeof eid === 'string');
      this.id = id;
      this.type = 'ecdh';
      this.eid = eid || null;
      this._pre = pre || null;
      this._curve = null;
      this._edwards = null;
      this.native = 0;
    }

    _createClass__default['default'](ECDH, [{
      key: "privateKeyGenerate",
      value: function privateKeyGenerate() {
        var key = randomBrowser.randomBytes(this.curve.scalarSize);
        return this.curve.clamp(key);
      }
    }, {
      key: "privateKeyVerify",
      value: function privateKeyVerify(key) {
        assert_1$1(Buffer.isBuffer(key));
        return key.length === this.curve.scalarSize;
      }
    }, {
      key: "privateKeyExport",
      value: function privateKeyExport(key, sign) {
        var pub = this.publicKeyCreate(key);

        var _this$publicKeyExport = this.publicKeyExport(pub, sign),
            x = _this$publicKeyExport.x,
            y = _this$publicKeyExport.y;

        return {
          d: Buffer.from(key),
          x: x,
          y: y
        };
      }
    }, {
      key: "privateKeyImport",
      value: function privateKeyImport(json) {
        assert_1$1(json && _typeof__default['default'](json) === 'object');
        return padRight$1(json.d, this.curve.scalarSize);
      }
    }, {
      key: "publicKeyCreate",
      value: function publicKeyCreate(key) {
        var a = this.curve.decodeClamped(key);

        if (this.edwards && this.edwards.g.pre) {
          var _A = this.edwards.g.mulBlind(a);

          var P = this.curve.pointFromEdwards(_A);
          return P.encode();
        }

        var G = this.curve.g.toX();
        var A = G.mulBlind(a, randomBrowser);
        return A.encode();
      }
    }, {
      key: "publicKeyConvert",
      value: function publicKeyConvert(key, sign) {
        assert_1$1(sign == null || typeof sign === 'boolean');
        if (!this.edwards) throw new Error('No equivalent edwards curve.');
        var A = this.curve.decodePoint(key);
        var P = this.edwards.pointFromMont(A);

        if (sign != null) {
          if (P.isOdd() !== sign) return P.neg().encode();
        }

        return P.encode();
      }
    }, {
      key: "publicKeyFromUniform",
      value: function publicKeyFromUniform(bytes) {
        var u = this.curve.decodeUniform(bytes);
        var A = this.curve.pointFromUniform(u);
        return A.encode();
      }
    }, {
      key: "publicKeyToUniform",
      value: function publicKeyToUniform(key) {
        var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : randomBrowser.randomInt();
        var A = this.curve.decodePoint(key);
        var u = this.curve.pointToUniform(A, hint);
        return this.curve.encodeUniform(u, hint >>> 8);
      }
    }, {
      key: "publicKeyFromHash",
      value: function publicKeyFromHash(bytes) {
        var pake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var A = this.curve.pointFromHash(bytes, pake);
        return A.encode();
      }
    }, {
      key: "publicKeyToHash",
      value: function publicKeyToHash(key) {
        var subgroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : randomBrowser.randomInt();
        var A = this.curve.decodePoint(key);
        return this.curve.pointToHash(A, subgroup, randomBrowser);
      }
    }, {
      key: "publicKeyVerify",
      value: function publicKeyVerify(key) {
        assert_1$1(Buffer.isBuffer(key));
        var A;

        try {
          A = this.curve.decodeX(key);
        } catch (e) {
          return false;
        }

        return A.validate();
      }
    }, {
      key: "publicKeyIsSmall",
      value: function publicKeyIsSmall(key) {
        assert_1$1(Buffer.isBuffer(key));
        var A;

        try {
          A = this.curve.decodeX(key);
        } catch (e) {
          return false;
        }

        if (!A.validate()) return false;
        return A.isSmall();
      }
    }, {
      key: "publicKeyHasTorsion",
      value: function publicKeyHasTorsion(key) {
        assert_1$1(Buffer.isBuffer(key));
        var A;

        try {
          A = this.curve.decodeX(key);
        } catch (e) {
          return false;
        }

        if (!A.validate()) return false;
        return A.hasTorsion();
      }
    }, {
      key: "publicKeyExport",
      value: function publicKeyExport(key, sign) {
        var _this$curve$decodePoi = this.curve.decodePoint(key, sign),
            x = _this$curve$decodePoi.x,
            y = _this$curve$decodePoi.y;

        return {
          x: this.curve.encodeField(x.fromRed()),
          y: this.curve.encodeField(y.fromRed())
        };
      }
    }, {
      key: "publicKeyImport",
      value: function publicKeyImport(json) {
        assert_1$1(json && _typeof__default['default'](json) === 'object');
        var x = padRight$1(json.x, this.curve.fieldSize);
        var A = this.curve.decodeX(x);
        if (!A.validate()) throw new Error('Invalid point.');
        return A.encode();
      }
    }, {
      key: "derive",
      value: function derive(pub, priv) {
        var A = this.curve.decodeX(pub);
        var a = this.curve.decodeClamped(priv);
        var P = A.mulConst(a, randomBrowser);
        return P.encode();
      }
    }, {
      key: "curve",
      get: function get() {
        if (!this._curve) this._curve = elliptic.curve(this.id);
        return this._curve;
      }
    }, {
      key: "edwards",
      get: function get() {
        if (this.eid && !this._edwards) {
          this._edwards = elliptic.curve(this.eid, this._pre);

          this._edwards.precompute(randomBrowser);

          this._pre = null;
        }

        return this._edwards;
      }
    }, {
      key: "size",
      get: function get() {
        return this.curve.fieldSize;
      }
    }, {
      key: "bits",
      get: function get() {
        return this.curve.fieldBits;
      }
    }]);

    return ECDH;
  }();
  /*
   * Expose
   */


  var ecdh = ECDH;

  var naf = {
    width: 9,
    points: [["67ae9c4a22928f491ff4ae743edac83a6343981981624886ac62485fd3f8e25c", "1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4"], ["49fda73eade3587bfcef7cf7d12da5de5c2819f93e1be1a591409cc0322ef233", "5f4825b298feae6fe02c6e148992466631282eca89430b5d10d21f83d676c8ed"], ["14568685fcf4bd4ee9e3ee194b1d810783e809f3bbf1ce955855981af50e4107", "31c563e32b47d52f87ce6468dd36ad41f0882b46f7abf23d12c4c4b59f4062b8"], ["357cc970c80071651bf336e06f9422b886d80e5c2e4e0294d3e023065185715c", "7f3d23c2c2dd0df4b2befce956f2d2fd1f789013236e4430c74e44845522f1c0"], ["14e528b1154be417b6cf078dd6712438d381a5b2c593d552ff2fd2c1207cf3cb", "2d9082313f21ab975a6f7ce340ff0fce1258591c3c9c58d4308f2dc36a033713"], ["107427e0d5f366ccdb33adf0282d304f8843e3e88d22b7b83780e073b7c05fed", "12dbb00ded538b7478466022d2da89b83740cfb2289a272387efe1aeea401f80"], ["4f162deaec2ec435dc5ac6f95d20419ed9631374770189cb90617f3e66a18dc1", "12cbfb2d04ff22f55162f70164d29331ace5af18a19a9aa1946d4cc4ad2e5cdf"], ["7dc52d5a7db816e9b850741ea2fd72918d94985b85a20b4dc5597853a876df6a", "6f6d2bca60003ef9f24ac245cc919fb717b188723b34f901cd6cfe9bec97be04"], ["1d81f74a5ba45c7022e8c140d763b9c1b0e281a5304696e74f791a3a04a94472", "3f185a93d95a4347227c5bb6ddd65cf42e1830823f435f3083fe6102691d55b9"], ["6f0ac78e5eb90e87958588f9d47541edf252cb1dde3d073cc45e3e7ef9365716", "6628d116b7975ae5f323e5ddf4f8cc35ae06d5c5c7d8a56effc66051336d289e"], ["2188ac423c67db5625915e05222a391bcaf91f05d9b7cc2cab5798b2d2e14d95", "23240c559c57b79a4df69a23fc46e50504277b1fa49369ab663d79782b33c0ee"], ["794241471ed9ceb009384b370cb8790fca98552ecb822dc06b19362c36353455", "71e918c03cdfca7207772e8d18ee8f9d92d79a0a83f378912362bc68d311dcd0"], ["163bc180c22dfc5da23c5c052107bba93a88b4360aa1d4e729611d8f5a7f8079", "631107a6ba83f7458194b9766a0a54f638ca20daf800384dbae1498677501939"], ["39a32a30f3eb1da0eb7e3903b8ace3da3890b24b61a3a9e79db663b5db0f7a5d", "4d4c54675dc1f1c9a1af9ca0010045dc803c16af345823136dd203715d67c491"], ["38085391a0e2831f59c33fcce7591515784d359925f11ff958e0e4658efac0e9", "42918001a829f49b5634e34ab7fac21b30e24660669ed91955cc31944a19e62a"], ["5e3573b049d6135ffbbbbd9a480617434f2455b4a591f719e91153eeb75a32a1", "54bc665420c789da1105d53983c1a0fc33bcc2690cd9b37d6566e21a85892871"], ["7ed068b25b82c05fdc0e46bd80a357f3acd2f5c3b9330bc8d474e5b28270f6eb", "01da83a187da8ccca704d46557a462551d70df7f943a681c3b97b1db6a21b7d3"], ["05ca3370e7516f6686111b72650aab4c5484407f14b515ade03951c6a14a0aa3", "6f407fc537b95277966e7f0f5e64b86904bf7baee091cee6011a3611834c6903"], ["624cb312b698bbd6dbca79b8d2b53cb5d8b3ab33c19306e87c18211f095ab9c3", "5b3336b2751e97c793731ac9b9a2243b6229f6d0bbea6b619395d0e5200bd8a3"], ["1ddf6ece608fe2901b34b7e4f47cfcb75e947e293c704d8121b11a31a051b5f9", "5e2dc58e9a48a749ce5296d229cfb34f96a147a8246d2e9844d52b52112ea94e"], ["396b384f3d61cfc060308fbb1c941ebc9418e2d9abd81316e08d625f48c0e101", "7223e5f7b66d1ca24962bac273a7aa6618cc60cb8a64a8837e0261107e7ad644"], ["53cc3dca3410277fb38d75e4ac0dde8e77a99c817170dbc9696cffe7890fbd50", "2592a3aafce64d7c69f4de468d5d5aa19845f5ca08f64a0a40e37d23ececbbe1"], ["34705fe600f5aed77b29d3eacdffcd45d886904156d43dc550bb7fc889cc1368", "299153c141a8950ffbcc8e9352993e642fa39a476200dd4acf42e158dbe3b01e"], ["5969255bd089181b991fce96b1792ba330a14f8a0b061f8118c9c336b8504618", "680a805fa0ae93c2a12b193517fb1147d355547e4ab18a9d6ca21575bbb4d7a4"], ["27d1d57fa8808d3d452df14bda4248b37902752163b1fd499a92456c59918ecb", "0a42f1c0f4c5d7de9e82904f0b4ff63988d31fedb8aad9d8ae009c7a1dff09c3"], ["0811d14bfdfdcf2144edd9cf55bce584a9ba17aec3eac8aaa82987ad703d9b8a", "42bea70d46f3ee0df0ec77d24c5495ea56ada2e0415920470c4746b68306376e"], ["4de090761b863cb0f0650297f154a8e66d00c5119c38e5dd05303d905d527a4a", "5eef0efd105361ce198a30e09e7e7edffbe3d70189e63ca68cf6057b9772baa8"], ["1d45517858ce45556aaee056ebab7e0ef3dc9ae3740aed570f3e76bfb4fc4817", "0b5a9d8fe8b7ccb04c0a5ef77798a3ec6e1bc1138604eb05e83844f0d4c5c699"], ["4285edbe9117f30aae1ef5ee419eb1d472106c6b3d7f3ce3701e39324b0eeafc", "503aa6104a682bcf2c0a60c84f4c22b50b0caa0fed8db87dedc7173eae04bdbd"], ["3ef830cbeff9b79039b1b6bd9bb52bbcfa56d008d91b9703ea1c80351f8687d6", "62349ff5d8dbd216a874769eec152ef9734bea9240eed623992c7553dc8ee4c8"], ["649a996e6d4d3b60ccb526939ed8929134107e03e2fd4648eaa2fa9830822c1a", "1648311b942fe95d492a1ace5e5235c1aea860d036d2475cc8964cd1acedee9c"], ["3a95596d97770d050d1ecc075d58a74f5fe6b4b8222740534ba22c8be73f9d56", "15a80cdcc03317a830fa4a7461de6bac136993e0a797f83b405c161a34c98fd7"], ["2d265d3fe1c88903ca93685209418deec5af886bf0d9fdb3f499d831cbb76ce1", "08376fb0663d3aa220948612b519af4a6a1f956622b15a305fb2e60a84210b3c"], ["642cb15498d8c6b25803f3e56b98e2ea185ac808cbeab5eb0a610ed5babb9385", "21b5ca5020a9e5a2334c0bee15193ea16c909963ffa6e1d93df4b239abeaeb3e"], ["38e576301ff6cdd0822a19c6d610d445d3967e2bada903abb6220f68c6e79bef", "458fe689e31a24952d2817dda4349109c1b26ef31699fa36c4f8389eeb60eac0"], ["372bec78d75011a0ef2233cd08790a7f15c1ec1e3a78cac8d6652678641780db", "32e9e47cf2f48612ed3e2c2006ea0c0c8476d3562aa88cefb67ec97abdb538e8"], ["1aa3756aabcc3eb65afee34e0a15dd67bfb9fb199eb131f4cc6a3ca9ec4d1c77", "42333e27831add6eb49af80e17347c63c26dd684758096ee3dbdbe03a49159ae"], ["38db16447d79d3590c4a36e20286beadfbae91a4eed2e5e7dd4f975ac0537dc5", "1c48ccaed60ec12ce862ea71165bba7df1739845df2a857f4ef0a0f714f96daa"], ["176b78984cddfddef90bae619c6a98e951d9a7ac7d6af218ae7e76b273212fb7", "7b5b93eda77443f366e2a127abe12212aad8536767ec1c5861143f777db85852"], ["042d154bf7b4a7bd73897ae528c6bc552ea58d74f8109e8e4052d3e9d38bb0f6", "42d1831323e279f9f7ee9e3470ba20ca7edc3245eca5d8ffa182de120a71fc90"], ["1f8d28dd4f286a8d0687b626b01204434bf5874a9550d6e375116490c154e108", "1ce82e2360367e06f41757fd45239f9bc2c61609139446b09b55a9c43da98bb8"], ["613eb914c015076e9ae8356bf508c289e50b1c87d9e2546f6e406362e248e5e5", "3edbaafcd8c41ef4aa18b254137d201a2ef0ca4ca28807156bc949e920b97353"], ["27bf43826bf0310b4b3e3a405eff790a1d77a8d48b04891246cff8e193cb03a9", "16a24d749cc1d234fbe8af9cfd782c3aaa5869d6db0afa7b4d4c67037514f2ea"], ["769a6a59746d7bead417bdd9c3b5f5ae1dbd924083ffd9e88df7714f57a675c2", "22dc1267cfb2b41c590abb7dc3df45619af688d0421f2bdfb50748335ec5da25"], ["795734ee4fcc24194219d25d41a2889cdb942f765848e9df63bff0b158c7224d", "756420ab5c71127d39d2e79907634a177af0e483e08484ea4d7b76f7100669b5"], ["644d12fc5e7fcac5aeb5911d8240971a99fc59fdd2903f46958e6896aefbcf46", "173450789fcd40172e8124fea56f7aedad2ee13fa8fc5209cc8cb572175216dc"], ["5deca767ef17b9e8d4f351f5c8ad1fcc50e97a2ed687516bf5210679fd6c1110", "4ddf2207da12f700708089989da016f3307ce5721c9e27c952599d67898aa396"], ["296dcb24cb3185d037a94bef93c97cacd09fc7050ba8472da59d4a689d9d2848", "0b17dc85a4acf73833fab728f15abccac97cd09e57975bd996d3e1dd8b060f7b"], ["408a3f1af2e77dfe94f8e225b40dfc146abb1002db7bcf15fde61c1a6cf1b93f", "4f01ec38854c15a879e7c7924f048e2ec951dcdf04a614088b68fbcc0954e1c8"], ["07d2d9234970cdc9483e0a7c5ec52c49077c440e0a993a1e624f90b8fafbbf07", "6ac2190030c210ae3e07b9239f6ee7affba263866ee7831a564c511f703f2295"], ["2982d553002082320aa899b9b6887e40dedf11868fa931689795d93d58452873", "215e16ca447978624cad0ea6bf45aada4eca914425ee275db2a26e980dc349b6"], ["1d8649515cb49e136d2895b6276569e5c711fe1a343eeb5a3daaa8d0e7b42d1a", "5b21e2f2978f343a3e9ec3316cdc111af3b55f34afa5fc3fcbf6c26c1bb7fb6c"], ["5460df4d607147939cdbc04dbdcbdffd37c5eafdd501b50a67213a23ee724a97", "69dfc7004263ccb52487d34ab134b80bb3030273999739cb9cdc16d71b9abcd8"], ["24623476f0af9f42ca15a0697ad23abeaf5ed9dc4d2b44f7e8175486598125bb", "6aebe4a1a22d9e31194dcde6d33ff3af77dda15c22b2ecba9329849b8c042687"], ["64e507a02bfd8a8413117bac253b17f94b2911681ebc07c92da0de6a651dd538", "513ac992d72b463da110afb612fbae36590248a0507d845ee95fab2d1caa03a4"], ["47f3bd11324f6bee230a22a5bb06a3ccddbc0473b810689efaeef894a654bf0e", "7e05db9b3ff886bf32608dfc8d14eaa91e2e2ef230e7c75618060e4285c492be"], ["4a6d22703a7045d02d656015ea2d168385d42963a739a895e4fd87b3e55c5e0f", "4c58d7a8c6ded0451798e51f16ffa5b637a87aa5defb119ba868d8cccf61776d"], ["3e22af70a548097244d7798964598172a90391f84c59b04cea7af283ba368eb5", "689d8b7cda23b8dea197c5119fbbbd81dd4b59a36cc283dbe292b5b6519a2968"], ["61a6ba2ca42d9d557b3a2ff0867c1b8bb8fc40192d31ff637431a302bc065a10", "63d805f5a79f845ea2915a25cf0a8cab2e0255212a1bd3c8852b25579b63721d"], ["03d963eeae48556e88305f91c478efcfd2168c346b9ba185884ec8621e8cb414", "74b75cc839a944ad8c639719d20fd9d48d2099ef24c8633eabec7a9ec1e7e183"], ["0f04da69e0202f7b44c58b103c88de09a0599951fedb17e7f2152d6b93a58ae9", "1fbc1c9cd03c4cfd46e8e90019debf86e8036587eade038346f91070c800b8c4"], ["797899e488353ed0c6666aff11913b33be0190833766e809b2a68cbc671a9cfe", "5dd70a33ff94a84b3fe660f7070e6179e86b5c846689265bf985ce424b8909cc"], ["735b64bb872606510e4e7d57833eb7ffdc4aa0dbaa242439806be68379f77cdd", "384aaaee3ca7ba2436fcb65910859ca5ec30c10af11df7d777d287bc1a2bce2c"], ["6f6ea532a62cf4766f55a0a72a86b55e73fe9d3328ee94bfc271e122f99dc1ac", "61d8203ef6da5d0b584541c02331c7f58617cf8d4f26d11776236ce8b113ac10"], ["5d99a2a3d4aed730b827b68ed836a9910dce4e7b93faf456981ad6cd85748773", "7eeacf5680fb6108a8b7edb45f7134644111b08e17c236469685af5a79474b9e"], ["31d0b4bb57bd7b69363c064a49bf3c3b9d7635bcc287e7b3059d3d99fd8382e8", "1592e581034e13d47d02b8966f5359097e652391be8fb1e803f4219a22aba2c0"], ["424cf5c498bbbe8fa7e5c3247049cc3f45946d0e5f38c44a36a6c84b60a84aa0", "34acd712d334a2315dc8fd00c5c9b7c5c9f29bca27380a018882a5ab4a0fcb43"], ["33a6ae0522936ba774837aa7959972f9804e3ef02ae84c8039be6595598be247", "37022798cc08be9b4ded34c1c5062ab3a26081d375cadf517972fb48135a6602"], ["5939635b72aeba595b5f6e376d11a3e07d4b1153ab4d0a7ab267b8bcc47cc3cb", "382162eb33db2322cbe01a38fa4d13720b6d8edfaf8116a628725ef4293a6c27"], ["3649e78d2ae9fb0ee86b691c27386efce4f3e383790e3cfee2bd59c2e85c4036", "09b0d9e0dd82e697b9be9d61ce0d1410e281122b483125c48f7942b22f5d5be4"], ["62c7585d1677b7619d8200175346ec99118416d8fdf0103730d165934e96a973", "5fef7955ee07304429995433a468d68dec4ecf6b08bbe8cd06869080094044de"], ["0c94537d311e17f5b0c58989b5be7e40c88b978a8c074a1e9bb07a713f77f6d3", "6deaaa5001bcbbbe9ae436fe42f7042ce74fbf83c14058427fad4587ed33c4e2"], ["6f5c6894a8d3877312e608c11809c15dffec3df551711095c8cfc810533e1b3e", "74eadab9389b40d6ac6cc0d6e333d628ced60a9ef7617751c20630d23477af7b"], ["4e16e88e171f9a07e11f97bba65c0fe5483501f255343afb3335ed47fbcee08f", "41bcd7dd328871247cb7995bc6bd2e1961e94b0fb12e5fb2f264f9ad2cf47d4c"], ["65d8484cef146e6c232fb262c2ac8200a52c63ccec26ff6f038aa5c74982c741", "67283346bbae9391952b141e57ca8e3a36f0363d3b81b1c0f2b3c30a92c74235"], ["1c588485b64be8cb99bf97f065e75a82138ea2e035ba90b63745354e9cf729f8", "7c9a18d6ebf5465a197989cfb9b5b2a66a5402f46c4708ac04187c6b157a0d77"], ["2c80c4ad0aebcafab7e9d2519a329f8a1c7df21cb6b1acec7403c0204d6dce71", "7f8e62983160756e35356df95d44467e621c7274372997ca74a9fb760b4db36f"], ["1e1e5fc87fa2c49e2c44d5718e3d73c73a91a64ac1374652080bd9004291b9c6", "153828e90ed8d94c0f86e0eb54ccb31073cd29ed62c34cd9f2dbc5d98872e597"], ["0ce0488a30ed446d445efb1bd21ba32ec3d05d538e6393bc0e58e0849ad57129", "7278074ac66ac779136f4d6a334b27633645dea0fc98d137e3dbd4015d12b5a1"], ["01a6b81f7285f293f19ba019b009aed8280ce285af42fab91e87fb0bbfa6dea4", "60f910dc7c9a82e7836f36acfe7ec26b9babfa8bf26b2945b3c1a43b0c19b4dc"], ["79b4ce3c6990023859646690c9ea800174902acfa1aad7ff34eca032dbde7150", "53a1053d3fc6c749bf8a928854f392d09fa851ba963ca661bffbe74f012ba45b"], ["220ee355b5c39c1901ed34c0f50f7778ad1bedcd7259ae167c16514ffe333498", "05fd9374986e1e06035dbfada0117035b96b159354262f2b2695af1256d6aa2a"], ["1e2f97d2cb4a19ca40403b364253da71f65d2d4665894267e3c6a9db8b4a3a18", "22804fb035acb519210ff99ed7a974a725d896a77933789b4dd45a37dea3466d"], ["35b8699fa20987876ac3b3086965b05f8cc809d71cab45e017c68ac96e24ed5b", "155079de21981778dc438353bf2c6a65967a1a33ebb74c866fb42f4e3cce3e39"], ["3cb40c55f5f19c52958e8c4ecd9c459b1d3268b3971b2286d3e58d1fc6b6a6bd", "379e1f1f59df05c74485615b87441ba6203f0cdddc6873a883d4cc6dd1b75921"], ["6ad916290e0d003ce5c961679f77704dcd768589d7cb728c60f56852031803bf", "1e602b4a6725832a56944234f84c4f85f79911b55beef903549089925f2ccbea"], ["7c0162492ae668160aa56a60e8bd43ec088555f750d2223cc37362dead5de123", "34e60b446eae100d4c3abc6cb02e4ca559457fb5a9030a290a2568fa4cbf118f"], ["354c25bf7b3e83dd0c5e1f39b82e3567edeb5337634056c1091cd6a016caacdf", "7abb271ef121630f85a9a1049b3ad78d5b889f533b37a713b8801de46770fc3a"], ["1e581a4bcf7504f33f4342b2097504d13f9b5a27f4790a6cdde1242209862850", "2164d56564360fd2b5dba2f2c6ef1045ab448c3b60b2f2196c2f74625fc39e07"], ["533b56f18283ee79b9a180b887c298961bd9aaa6fa3ef97fcb0d5688e694bc3d", "6011366753812df2bce83634a92dbac18dd1cffdbf9a97fa1b1d5b49e0026764"], ["4b508b94e6e2e6cd260a20664ea7d727ad20587b63ebe826032e0d20cdc6627b", "1e8ecd6ff5aabae78172a0214d07a5013992d133af58afa74049de726df2a6c4"], ["3398c0c0219f5ac87a8c73fcd17b89311d120a53f5231cb761030c194fed4265", "025b234a1dc8662c068c4ba903939c2f79f3f7a3ae64e5edbf667b13599142d9"], ["5941a17b04cd3465031cb6745cb94eed24e1ff8d38a6e832f1637ae8e89c78e6", "5309792c546b6cda458be331957763b5adb5d535d54a4a61023678faa2ee02ee"], ["2cb490d2c0047fcbaffe1df26640bee73c158af6fec91343d606ce9d124a20c9", "2e2952ebf089200aebfa3947f241e2fe85797afebdc1ea06d9d26de1b446a964"], ["79305236b583232a91c63c7d9ca3750be7ee21711e4d6d257c39ae398212bde1", "6f9ecdfa953e302c2014fd8512405e4be0d48302acd15e93936e8dba7d01053b"], ["57d9fcb884b94664f35387fa6665cd9bc8136f90d804d77416ea99c3c653ee63", "14197e65f0a3599c0b9fcef75b5fbb93580d1b2457b59fb70ce7b9bac88d0fbc"], ["6d99df2c28c9fa1e38acddefd3e0931109143d873f3330377a9926bdacdd6523", "2f21987905f397f092fc56c5ccd301a1e6afa3c4611627e25017b2e68d07c150"], ["749d19591f1755bd481fa12a288166aac42911654c8c551395b265116269ceb9", "7ec145aa7558d0342cd87b1750933cb6f3717e727a86a1cc1f2b0c274213688d"], ["340f7f5ae19292957902635a5786d14fa38036b324ae759da501e32b8c4073f1", "64e231a413f1379a26f4e8223ff91fe2ccd865549571d3c6c28871964b40a0ea"], ["4aa33e00bf6e92cac4e84384e5dde0727394233afd5d24d357a8afeb94b08109", "3385bb4fbc441937ee01b671d506227a654fd6c1c532cf5221710c6c56ec7e21"], ["34b2ffca05f01088de266306c5cc122661e9308eab16929774e58565afc0e4eb", "7662faf0f70e82c062c2b835fc6da3353d3cb20b80611ffa6ef2982cf62fa605"], ["820fcb51326f1536ddb8dc1052aa198406c7e48f2c81e7664d15f8f9d3715e", "756574c23bb01170b97d9fa1663a8ff2f5b97eaa5cd53f34140c1bcec8c262d9"], ["0861d7e84cec6d6e33641ff6c85202fc0e9160797809ddc2193802499caf05d3", "34936e0a5dc7e2a6217d475fbb8c1c607fb8b3565908a04fd5948abdd399c59f"], ["5b4a1dc887ef684d7b4b165b70acb70842a2fa105935af15ecb4a097e33b8f2b", "54d21511c05805e5298a72372b8289e9d59c46dc8b5c368bbfda620b68aa652c"], ["755493ed60b13f03f9c019362a5af73fb49842dd6916e2572b1b6a312cd20cfc", "0750bcbf7e449cec422b93ace1489e1b177d4dbbaa781d315c74d54bb444e9a9"], ["5f1c341065b6a81ed2edb6bc38ba81b4c2e3fe2058e5baa13e1406eb2c5b4b4b", "6179ebfa7f8086f26820fc99ca2f94c1be19bca672d79cea5b02a836119e06ba"], ["1915024ee86acfba3f61ced9707521197195166fb1c4639bf3b3fcf0bf0ded46", "5f2e0547032221d2b00937cf524590e3d90901ef0286ea0b032c1a81461b6d92"], ["4e942d95930f38c8786ff4a8e576e7a29fb7627afe1fff91cda5006ba0624f5d", "45902f695d512d70ce4c1e0520c0060896b94e14d2960b2fcf2ed5e138e0217b"], ["63e45f3d91ab915d412bbaa17d1d249e1a1445077fbfaa6be7d35041c5116a91", "46dad5a4ec2ad0b86938f5e09f1c03b53b660fc5137648b08527cd20708003da"], ["5e2ddd2175417f72c9962c503ac5adf94ed11f28b9d41fccb6a4512886f3cc87", "3523b218478911145af1dc431feb7db0a04066eb6e2ade3c7b67d11bc55323aa"], ["62ff30a6b179a26e7247a8312cb3af3289e5d722f76a29f203aa623889aa05ec", "562beb7999019346beaa80dfd5b95d614e1ff96c1cb1037f65c44997b797d066"], ["14988b5d62084fb8335c2f261cdeddc1b634b09cedfce713ff5f0a0bb588a556", "447068731fb98e821b8e413b3b48f2d1c8bea308f05aac877006b0f4c3b0cab3"], ["1ac777f708a5942cc434236920e82ccc6af920c0a0676712255aa7082b37a5b6", "52a6f88d92af1887c781501c6e3a88169a2831b74aefd416f22b47e8335ce317"], ["5959792833b71bd5042b78e42212af671f5f87a08eafd8cdde2dcec8140e4bb3", "41ce94633eabb8a1b08fac66f762997ed8c9e2af3558e1f6586ad6a5bf5b7b64"], ["4464a7962e6722b457336fe98c91765b1ff178f9e892e90129e65fa7688a0607", "3d1510b92fd33c501f058a7a86bddedf1b83f9b6e4f04829d321117013f891fe"], ["62906d81e7f800e662519f4324ab4c8aac197661c729eed3e744d09efe721c08", "4b68efb5b1b709ab86e3253d70bee87ba07875c04a64ecf7e35cd8cdc6c0f7d8"], ["4300ff025ac78ef36e58ee7d0d732cf76cd0929fe265b3a093a57f23fc326757", "2f92880570846ff2e90d91f16bce3705c9c3ca8011cc543091463b623e4b3c01"], ["5427ba28d94652527a9b0c76f57a451e46bdc06cbc8a2481df17f66ffb1524e3", "547a97c4afc8d1f74a5d51f7e524f68472f589cc0b396b21368628721537d722"], ["424c4493810bfd5e3ffa21776326d8ff62bf8fe74504d7a2db5d3f74e5ce1015", "74d0daa832d40405d01551a58b330ffc5abd5356230d6d7cabeb5b1a55046f32"], ["54e10980d81b4ae8778896684295fa5c5475e8d68ec2a26e1b0a65383507b3cd", "6b1eb48da6886c4d88cea720e9dc8b0d8c51a8f0e1943afa31a40eeb553c0676"], ["732eb9e9ebb556e9f024c5574166738f4707b0fd005f568212ab575c1db71ddb", "1fc6b00c89e48114d6b13d9920a0c78093994f2b08df147bdbb56bead2cea165"], ["74029c04b34b7f314855fee42a04d0ddfdeb92ef3bf7cff629928a97733d96fb", "501f63a252dfbc090733b5a208bfe08f81c91419ce3d2d6c0de8cdc5a5625014"], ["04524402ebb71a60bf1055001000203a6d4917f112e50dd766cdd7b718a6edd7", "71c9e2d15cdc47c565a696ffbe55277570930ed7ade13b9a254059365d5bf338"], ["2555c620a50f2bbeeacac66228a96941fa733aa6070855331613578ed7c12794", "2b3c1bc5cda7f93242561dbf7572237ac43bf013553230633a5e18b7e71597e5"], ["555ea607b0ad18afaf70d7450543d7ffb5b883a3cad3e2778826ca97bf3211a6", "6df903158f51aa530d411720a760f8ad0ce9904d54955fda74a349be58eddf5f"], ["4db3cfa284207a250a9c83e1fec07e804d70065da586ff2c2a7d2bcb92e6fca6", "2a4fbf1c51dc0b2a7783db2be3bd35c2d6462470c88c8b73ae3ce8503fa07154"], ["5174e33ffdf28a87184a4d6427d821cbaa3b88ac293a90ca7e1eeae8c5050b16", "315ca6bc8e35e4a3d06f89e1db1575b16197963ee8e64746fa998ccd403561cc"]]
  };
  var doubles = {
    step: 4,
    points: [["23a4860627e53aeeb8e22b1508249c9109578d33e7bf237459b2596d6c28f9f8", "709696f2827fc3729f980f2e3aad6e78b06a11ff8e079c27d87aab37c16727eb"], ["5e7e07ed4e1decbfe6e9cbc126905449d4b578fbb561576d20b8bcdd0cc2a556", "0f55755c51f102796bf5ebaa81d3260e7d1b3d9ac127d9a80e142031566cf6c7"], ["7d13c0248b891b47eb524f2692008e2f97b199bac426cb5902b9003a29ded6ea", "59a976ab2c01a81a91f1a56c75ccc77a9e1e9e878e9fe9c3952080a6805b20d5"], ["5de7faa2ee4e70132f541f79ca07cd54a39fe1347a6844d19e9d678a8411a565", "2c9f23641e1c2e0aab8ea9926b432d92c0e8bc08901d6ff6df85e4cef854ec36"], ["06b349eebfed4dad4a805b63a6ed2231a565cda752d9477ff427dd9a8c9ab5ed", "07a09289ff3e1f9aab68aa374c48df65f550c2323607b97744dee990608b64f8"], ["0af367956af630266b1cc760154256ed79da960dddca9d72a1e8cf27d8d43a77", "21108d900134d3b3708dd28ace96b0b23dda9100e4b6a62a8131bd2f2ba408c5"], ["1e45a60140a3b2dee9b8dc6ff307154a1b410bcd38e0e38fb10b2f6da1afbe2b", "0e730da473dffd60d2f3241a85e68acb47d26e5043ad047d893f072c8dda0a76"], ["4d1e116d136158c5ddabd4276832800f2c081c1072de6f2d931797a46abc0cbb", "6d415be49d4e35b65cc51354b5008f8c43e84b7b5e8a4b84f44e1efb10c9b91a"], ["2b6b892ae94b454b2c2d92bb947fc4d506d173d281779c2c153c001ded42d3d0", "7f1cf64e0e180fc4d6e12c1b5c5285f376e979616a52c94a0dea4d48c5880cd2"], ["0f6c3a96e0032a9394337a02ffb2c83ba70efb8f566feab530fc90fa3b4710e5", "3d4e97e286378675038a4b58e84224ee515e1d6697ac79389f78479be167635a"], ["52ee53b981dfbc41ddaa5ddc2754c4175f4811aa45f8e2b19a425657c238a83e", "7eb0a1be3400dec87b388cad51613957643cdf0595b891cc6f925fb36da7f1c3"], ["52a837bc7a7bc9459bcc2ecf80f74d9ed99def0342e18cfbe8e799fbc504fd52", "50d6460185d8924e5485f23f36a98c86053514d163547adab6fe91478a411196"], ["6b2bd5d00fab38ceca21a27d6aaec82626b14b555d859527718f8ca404eba4", "727340c27a15f6ab3d80547f0827c56ab1ba33bc30d1ef3909ea9a3af10c67e5"], ["71dd75fe35761c01a48597ec730bc33237902fd4ad8612cbed1031eebdf40de4", "39674a4532078e34378667beae5cb55f814ead9bbaf7e01b3b69533e9f88a411"], ["57426aefc21be9ccf162e23d25ac3002ba8534351e65613f870f690f2fd46cf5", "6b45b002fb4e8a6f59a6ffb006ed71f75434217333b266325204c7d1ac2e1f34"], ["6222bd88bf2df9d5d44b60cfb4a08a960078db7ed51a35eb3e0b6b8ff4eda202", "0325bb42ea4ed025dd6bdaed261b7c4f5410b608ba902b068f1efa5782e45313"], ["71ac99647b61b9eca6f0c23432a518f738aee708d5932d4ef0f172240250a226", "3a96c2c028ebe5f48913be30147e41bc5e1cab9595d5404138a9aa1b5574cf25"], ["1f6a1fd8cc0e05b2742ba0fc0369b5247670543637dd033e64dbce90b2f23e9f", "779964401ee869a9b31c0ef874a86440ba85d25c2ce932bd31a0865869605e19"], ["22e2c039067920c42980dcb3a905fc91601c2b34e819ce1532ada4a5fc39d5cc", "631cf9945a09bf26d7e595b3f8e3390696870512820df63c5418577089e1a8bb"], ["608de273a9f6a534219d7aaede3cf65a81e4dc03d7a2765eced1d2b7be4610f4", "3b31d0113f98d81ab1312fb2837aa9c8dcc7960f84eb371358c6d841f67144fa"], ["3f748617ca63ab3e44c6e34f63e7328ea56a2a146da34368a57dca181254fe02", "0fed89e6420fc47b3938a2891ba9acee4cbb2899ee4e9ca15a13dc527dc1641e"], ["69d98b5ecc35d56c97c0bf312955d199befe116b417d70f5f57e2dfd0af81ce5", "3e26d487fbfe36ab44e0ca3b248fe94bce92a69b8154d50e2d5481f8259f4e8e"], ["1e34443347f9e627b3531157faab6eaca1bc3114df4a1423cc12bf8417b5d622", "295955a5ed061eca7f87b9485666ba9489ec20a9c484224dc920350bb4a6fc79"], ["51f4ff8c599b1c96da82941520a9f5abf4a31eb8b84fc95056145ceb3b5775d0", "35ac9588d46e41f3f6f99aee3852eeb4b12e807807d4bd1b7f8406b0d7863ac1"], ["3faa2a093a19a02424f65a10955101f4dc015c43b2dfce8e001507abd741b845", "7a1de10dacfda389ca663b15574bdc8ae8c5b6e7cee647e77b11ddbfc6eb8edc"], ["1924416956ea2c1269062588569b18178011ea7cba1a3266284f48aa01d5a90f", "0c8e28127b7dcdd206fb6fee96eb88cfc7db7319826ac8cdb8b1fb8adaf021de"], ["49761c57ce3c8c4f1435d495903e2f536f3be3712e76af8d0b5a8b7d1ebc8fac", "3225035e1065094ef32d7f3e7a6f8ff2748025f96e0c0b44eb35576b61e150a8"], ["4339fa86a23242851a16afc3ab05b352a7b4bf53599a49dd7e29d364fc3a757b", "6d07cc3462bae9160bbebb997510817040767faa9dbd13f158a5fe8a63a34b0e"], ["6bda13918dcbaf8529d6326ae7a9c278b72417c2188c5ea4f062fc50639295fb", "2c3fa803b162ee887d0d97a6734866f992f846625f314117075da54bb6c20a36"], ["4da4821314574d4fed4dcf692c8b15b99b73f13633210333ce7871359b6e6424", "314016034673d2d20529bc93a2dab6e462bcb5f66e1f4a6bf2170759a40a6e65"], ["0b2cea0029ee963c0034b61bf19e384435f14554a7d297b5144838c38e375586", "47ea95da28d39aaade5edb8ed941c687603cfdd1508776e96d6683199e99daea"], ["4c27afff3c45f32c952d3984e14e29a098e685c9c2e723e5fc8047ae60b7e824", "5f2c99e6526dc87d95f11eb626c29c3a90d0be1e51a4c49e5bbabd114bf5a66b"], ["53e2a4ed1bbb48bd016c524a02f797654cfc969849f867681da94e341f377534", "5a2334fdda642732a3c9520ce06581aa7f0f082882554c37b8d390a25a9bd559"], ["7b8d2c823baafe0d878a55e8af1db150dec85b1424a4901f9beffd3a6196e3d6", "1c45a557b3624f9b89ed15b3c3e1a065f1b453d948f7cf45d9494483f8af0c85"], ["78877b5d8777410997dacaeea59400fc9db4421fac02c4282301c67d35fb7ffe", "0341b46c328333e4484ce8607619014d41775c408c88856d2f9e19812d90fbf5"], ["2b556bbc070b5c4bae9e575836d1d68ee9fbe800448c0d2c233f78185eed3f91", "7ba01332807ebd892e00ddb368c0fa1b3f19b5b32efd90b178d984e1d7174d6f"], ["0f72556998b0044799f0fd03210ded3d984e3843bbaf3c1d5d692bc94d43c4e7", "16c19c5037c103d447caef4efe6bd81a490e7c668f6870f1b080863b5315df5e"], ["1cd96ef237b213cd446f13b3ec40d32ecc593bc6ea71e77efc284341a5f3da1a", "7a626aeb91efcb5f9777264f5e17ced8b411f68c713673ef0f184a5ccd60dbe3"], ["31a75b21cb532622a7caf9e29e652ac4e47b1450edf6655acaf3797b55a7ca46", "77006e7cf104982f8865081a2ff8a6911546755e31c3586353b0bd0826c5d790"], ["543d84cb04fb2bf787b7aa382eaab5cd8d050ad8ee52aa8a285b945652014031", "0358fdc5b63ed49e693d838f182b275846f42dd49a42ec2e6e932ba4de59ef20"], ["0a2818f5f5d8937800c30ac6b847db2cdef655b864126302249144a5a15b205a", "187c76a49af10851bb049ba97c0fbbb14b2621522a4e8d9670ea46e56c9a1bd6"], ["7efb45d3a2851109d7a8d50ddb08fe308bbf674c019b965cdad4570a141e648a", "0fe1198b11a1bf56867091c69d71f8b7792257dda321d43652e818acd0c28cda"], ["472e960dd122a534f52377235350549df4a1dd7a08cfc580bff5fb4b0a70aa7b", "10585d04fc529fef4c0c0776154fc7ebbaedbae8a99937e47598d0578932b7cc"], ["04892cfff7f94ff7f07c1241e3ac4945bc46ea9d6a3c1c3adbce109a9afceb6a", "3ae2aa25e2555135a7a3251c11a3f8eebe81758bc1c3e2cbc6e6ca461a543130"], ["2401d311a3abfd2583f1c6aa519c1f18ff730a0abf730ddcc9c9739b04d8a85e", "653224f3488cae1ae19a414a9932035a2bf2c46803b5532bbb645e62387ee34d"], ["0ea2c846a535a115972161612a192588d92d68a3c9050eae91b2817b94e68325", "3b82a8337b05f11bbac176a113be183a50a0331f3d3116f24b971b5a8b0d031b"], ["0fb3f87c2c6c89c65b74299b77f3736546a8b9e41b19197476bff27354e1c128", "1034d42c15a2bfe3e682fad49dbc2812caadf0c584bc30b51625b85d74e9d5f7"], ["1bc7af1e38185e7c2d8d04371c7e177d7a9ddee1b81d7d26db7ad644c7dad28d", "61d909d855661f2f7a5eef87795dc0491d027e12631b270fcaf2f65900314833"], ["469d0960dbd0ef9c91c4597ccf7c209549b187ff63bd378b7dac577198d74a4d", "0b5f21c7f86832241f2157c288bdc9394f83f8d57457f6d9f6b345e4909478cb"], ["5e9ac4ab2f4a3c3526e1317f913d69e3826fe862efd0c80d9310319170c5cbeb", "505f00fa8aee03ccbd2f33529ae1e4e4bcf2644fe673d0b0290ec32be5b51bab"], ["11cd80e1fdcbc565efed81d17f3f54643ffeed1cff38f3825e115adbd82759f1", "43f11943f7ef3fa68b980fee45e98134f1df22263b2d14419d61ffe62822dbe0"], ["3328bc121616a9477165ed282053d203c24f4826076c638a2c6723d42c9bfadb", "2bbf3f26c21b5cb273e5f4f0114c6718c5eb7291939b7697c74333cdfafac039"], ["0ba774bb605dd804cae6887e81f6bd2c59e024fac8bf5f5c48a841a037c28398", "54ba013ad2d04dcdfb5a151b7347ee9a10067ddd0a3907e9bc337a77bf911321"], ["1074ff0267662dc2b4ce65aaa0229c375a3d0d843ce9349233949581c869b64c", "299be0decb680ec28923da4d049770107d42c180b460da13a7b1efc7e6d5b022"], ["25ed76d78c87c3bd64b4331902c5a853734283e25f19f320295667b80a340d35", "179b5f92f545c7b326b3a63fb0b32a0f52b4159988436d5af50c1d0d76373947"], ["75d942c04210dcde5d1bd4fabfc732d3f95568e399382c0423c83c41cb05dc3f", "696cc14856cdc13c8fd7e2c5771731cbf38e3fad47a424679765c4874e35ab2d"], ["5d9324f56975477d5945599eeeccec67708c996cd3f3f2818bf2591507e3502a", "10985a3cfd573205281aec24e2c8b41f5cd8cdfc9d7be34675cf306bbe1b4f6a"], ["7511066c0e12105a7b937c7ecef367d5afe6e621e5cabf4e490b09b7ada7ee07", "604df365b8391cbca8848f88daa700b770da5bb136f70bfb0a3ea33ba386fcd5"], ["2596e5b3cf5494e60d2a750d03c66abc2e0183af53620b893f9cf9fc3b76dc26", "68a0a7ac9a0cc093884a6b84f45a2cde595194e0f48dbd566fa78a3174b182fe"], ["28bd38d44030dd9ca028b2a2f31a795f4c7a5e85a785df7847e3d525e99d4787", "552dd7405c4183733ad3c4e7ccb999b4fed81b7a4444aab499d41d6d78d5bbfc"], ["59233a3346f61135f431f96cf0197e24ad38240b222c010a6ce538cf4c24347b", "3cce55908611d2b93f221613f09cfc4dbcd2e2b609233eea5439ad1908a10b20"], ["5830f025f1078d408948f73096af97de1e9e70b3be85890acb21132c34ff961f", "67d451752c2433ffe66e47242e301e56db2b2f8203553cab9de717e25793d41e"], ["6a0c8b194571e874b82d904da36d43096bbe36d512e24ff8dcb2b00b57ffd3ec", "5f85adb7749cc735ec838bcccfe7d4b52902c6132998d7ac8e032cad031c42b8"], ["53b3f967bff8760948dec5e9282f35d1434a5503790b9012e17faefbe7c4d699", "404462283c8664a17daa5b4059dcd10e2699fd86d0140de9f3e8ad0566098ae5"]]
  };
  var ed25519 = {
    naf: naf,
    doubles: doubles
  };

  var ed25519$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    naf: naf,
    doubles: doubles,
    'default': ed25519
  });

  var pre = getCjsExportFromNamespace(ed25519$1);

  /*
   * Expose
   */


  var x25519 = new ecdh('X25519', 'ED25519', pre);

  var x25519Browser = x25519;

  /*
   * Box
   */
  // In the future, could be implemented as:
  //
  // function seal(msg, pub, priv = null) {
  //   return ecies.encrypt(x25519, null, msg, pub, priv);
  // }
  //
  // function open(msg, priv) {
  //   return ecies.decrypt(x25519, null, msg, priv);
  // }


  function seal$1(msg, pub) {
    var priv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    if (priv == null) priv = x25519Browser.privateKeyGenerate();
    var ourPub = x25519Browser.publicKeyCreate(priv);
    var secret = x25519Browser.derive(pub, priv);
    var key = secretboxBrowser.derive(secret);
    var nonce = randomBrowser.randomBytes(24);
    var sealed = secretboxBrowser.seal(msg, key, nonce);
    return Buffer.concat([ourPub, nonce, sealed]);
  }

  function open$1(msg, priv) {
    assert$3(Buffer.isBuffer(msg));
    if (msg.length < 32 + 24) throw new Error('Invalid secret box size.');
    var theirPub = msg.slice(0, 32);
    var nonce = msg.slice(32, 32 + 24);
    var sealed = msg.slice(32 + 24);
    var secret = x25519Browser.derive(theirPub, priv);
    var key = secretboxBrowser.derive(secret);
    return secretboxBrowser.open(sealed, key, nonce);
  }
  /*
   * Expose
   */


  var native_1$4 = secretboxBrowser.native;
  var seal_1$1 = seal$1;
  var open_1$1 = open$1;
  var box_1 = {
    native: native_1$4,
    seal: seal_1$1,
    open: open_1$1
  };

  var chacha20Browser = chacha20;

  /*
   * Constants
   */


  var PI = new Uint8Array([0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d, 0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2, 0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32, 0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82, 0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc, 0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26, 0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03, 0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7, 0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a, 0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec, 0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39, 0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31, 0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9, 0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9, 0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e, 0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad]);
  /**
   * ARC2
   */

  var ARC2 = /*#__PURE__*/function () {
    function ARC2() {
      var bits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      var ekb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

      _classCallCheck__default['default'](this, ARC2);

      assert_1$1(bits === -1 || bits >>> 0 === bits);
      assert_1$1(ekb === -1 || ekb >>> 0 === ekb);
      assert_1$1(bits === -1 || bits === 40 || bits === 64 || bits === 128);
      assert_1$1(ekb === -1 || ekb <= 1024);
      this.bits = bits;
      this.ekb = ekb;
      this.k = new Uint16Array(64);
      this.r = new Uint16Array(4);
    }

    _createClass__default['default'](ARC2, [{
      key: "init",
      value: function init(key) {
        // Initialization logic borrowed from nettle.
        assert_1$1(Buffer.isBuffer(key));
        if (this.bits === -1) assert_1$1(key.length >= 1 && key.length <= 128);else assert_1$1(key.length * 8 === this.bits);
        var ekb = this.ekb;
        if (ekb === -1) ekb = key.length * 8;
        var L = Buffer.alloc(128, 0x00);

        for (var i = 0; i < key.length; i++) {
          L[i] = key[i];
        }

        for (var _i = key.length; _i < 128; _i++) {
          L[_i] = PI[L[_i - key.length] + L[_i - 1] & 0xff];
        }

        L[0] = PI[L[0]];

        if (ekb > 0 && ekb < 1024) {
          var len = ekb + 7 >>> 3;

          var _i2 = 128 - len;

          var x = PI[L[_i2] & 255 >> (7 & -ekb)];
          L[_i2] = x;

          while (_i2--) {
            x = PI[x ^ L[_i2 + len]];
            L[_i2] = x;
          }
        }

        for (var _i3 = 0; _i3 < 64; _i3++) {
          this.k[_i3] = readU16$1(L, _i3 * 2);
        }

        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        var r = this.r;
        r[0] = readU16$1(input, ipos + 0);
        r[1] = readU16$1(input, ipos + 2);
        r[2] = readU16$1(input, ipos + 4);
        r[3] = readU16$1(input, ipos + 6);
        var j = 0;

        while (j <= 16) {
          // mix r[0]
          r[0] += this.k[j];
          r[0] += r[3] & r[2];
          r[0] += ~r[3] & r[1];
          r[0] = rotl16(r[0], 1);
          j += 1; // mix r[1]

          r[1] += this.k[j];
          r[1] += r[0] & r[3];
          r[1] += ~r[0] & r[2];
          r[1] = rotl16(r[1], 2);
          j += 1; // mix r[2]

          r[2] += this.k[j];
          r[2] += r[1] & r[0];
          r[2] += ~r[1] & r[3];
          r[2] = rotl16(r[2], 3);
          j += 1; // mix r[3]

          r[3] += this.k[j];
          r[3] += r[2] & r[1];
          r[3] += ~r[2] & r[0];
          r[3] = rotl16(r[3], 5);
          j += 1;
        }

        r[0] += this.k[r[3] & 63];
        r[1] += this.k[r[0] & 63];
        r[2] += this.k[r[1] & 63];
        r[3] += this.k[r[2] & 63];

        while (j <= 40) {
          // mix r[0]
          r[0] += this.k[j];
          r[0] += r[3] & r[2];
          r[0] += ~r[3] & r[1];
          r[0] = rotl16(r[0], 1);
          j += 1; // mix r[1]

          r[1] += this.k[j];
          r[1] += r[0] & r[3];
          r[1] += ~r[0] & r[2];
          r[1] = rotl16(r[1], 2);
          j += 1; // mix r[2]

          r[2] += this.k[j];
          r[2] += r[1] & r[0];
          r[2] += ~r[1] & r[3];
          r[2] = rotl16(r[2], 3);
          j += 1; // mix r[3]

          r[3] += this.k[j];
          r[3] += r[2] & r[1];
          r[3] += ~r[2] & r[0];
          r[3] = rotl16(r[3], 5);
          j += 1;
        }

        r[0] += this.k[r[3] & 63];
        r[1] += this.k[r[0] & 63];
        r[2] += this.k[r[1] & 63];
        r[3] += this.k[r[2] & 63];

        while (j <= 60) {
          // mix r[0]
          r[0] += this.k[j];
          r[0] += r[3] & r[2];
          r[0] += ~r[3] & r[1];
          r[0] = rotl16(r[0], 1);
          j += 1; // mix r[1]

          r[1] += this.k[j];
          r[1] += r[0] & r[3];
          r[1] += ~r[0] & r[2];
          r[1] = rotl16(r[1], 2);
          j += 1; // mix r[2]

          r[2] += this.k[j];
          r[2] += r[1] & r[0];
          r[2] += ~r[1] & r[3];
          r[2] = rotl16(r[2], 3);
          j += 1; // mix r[3]

          r[3] += this.k[j];
          r[3] += r[2] & r[1];
          r[3] += ~r[2] & r[0];
          r[3] = rotl16(r[3], 5);
          j += 1;
        }

        writeU16$1(output, r[0], opos + 0);
        writeU16$1(output, r[1], opos + 2);
        writeU16$1(output, r[2], opos + 4);
        writeU16$1(output, r[3], opos + 6);
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        var r = this.r;
        r[0] = readU16$1(input, ipos + 0);
        r[1] = readU16$1(input, ipos + 2);
        r[2] = readU16$1(input, ipos + 4);
        r[3] = readU16$1(input, ipos + 6);
        var j = 63;

        while (j >= 44) {
          // unmix r[3]
          r[3] = rotl16(r[3], 16 - 5);
          r[3] -= this.k[j];
          r[3] -= r[2] & r[1];
          r[3] -= ~r[2] & r[0];
          j -= 1; // unmix r[2]

          r[2] = rotl16(r[2], 16 - 3);
          r[2] -= this.k[j];
          r[2] -= r[1] & r[0];
          r[2] -= ~r[1] & r[3];
          j -= 1; // unmix r[1]

          r[1] = rotl16(r[1], 16 - 2);
          r[1] -= this.k[j];
          r[1] -= r[0] & r[3];
          r[1] -= ~r[0] & r[2];
          j -= 1; // unmix r[0]

          r[0] = rotl16(r[0], 16 - 1);
          r[0] -= this.k[j];
          r[0] -= r[3] & r[2];
          r[0] -= ~r[3] & r[1];
          j -= 1;
        }

        r[3] -= this.k[r[2] & 63];
        r[2] -= this.k[r[1] & 63];
        r[1] -= this.k[r[0] & 63];
        r[0] -= this.k[r[3] & 63];

        while (j >= 20) {
          // unmix r[3]
          r[3] = rotl16(r[3], 16 - 5);
          r[3] -= this.k[j];
          r[3] -= r[2] & r[1];
          r[3] -= ~r[2] & r[0];
          j -= 1; // unmix r[2]

          r[2] = rotl16(r[2], 16 - 3);
          r[2] -= this.k[j];
          r[2] -= r[1] & r[0];
          r[2] -= ~r[1] & r[3];
          j -= 1; // unmix r[1]

          r[1] = rotl16(r[1], 16 - 2);
          r[1] -= this.k[j];
          r[1] -= r[0] & r[3];
          r[1] -= ~r[0] & r[2];
          j -= 1; // unmix r[0]

          r[0] = rotl16(r[0], 16 - 1);
          r[0] -= this.k[j];
          r[0] -= r[3] & r[2];
          r[0] -= ~r[3] & r[1];
          j -= 1;
        }

        r[3] -= this.k[r[2] & 63];
        r[2] -= this.k[r[1] & 63];
        r[1] -= this.k[r[0] & 63];
        r[0] -= this.k[r[3] & 63];

        while (j >= 0) {
          // unmix r[3]
          r[3] = rotl16(r[3], 16 - 5);
          r[3] -= this.k[j];
          r[3] -= r[2] & r[1];
          r[3] -= ~r[2] & r[0];
          j -= 1; // unmix r[2]

          r[2] = rotl16(r[2], 16 - 3);
          r[2] -= this.k[j];
          r[2] -= r[1] & r[0];
          r[2] -= ~r[1] & r[3];
          j -= 1; // unmix r[1]

          r[1] = rotl16(r[1], 16 - 2);
          r[1] -= this.k[j];
          r[1] -= r[0] & r[3];
          r[1] -= ~r[0] & r[2];
          j -= 1; // unmix r[0]

          r[0] = rotl16(r[0], 16 - 1);
          r[0] -= this.k[j];
          r[0] -= r[3] & r[2];
          r[0] -= ~r[3] & r[1];
          j -= 1;
        }

        writeU16$1(output, r[0], opos + 0);
        writeU16$1(output, r[1], opos + 2);
        writeU16$1(output, r[2], opos + 4);
        writeU16$1(output, r[3], opos + 6);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 64; i++) {
          this.k[i] = 0;
        }

        for (var _i4 = 0; _i4 < 4; _i4++) {
          this.r[_i4] = 0;
        }

        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 8;
      }
    }]);

    return ARC2;
  }();
  /*
   * Helpers
   */


  function rotl16(x, b) {
    return x >>> 16 - b | x << b;
  }

  function readU16$1(data, pos) {
    return data[pos++] + data[pos] * 0x100;
  }

  function writeU16$1(data, value, pos) {
    data[pos++] = value;
    data[pos++] = value >>> 8;
    return pos;
  }
  /*
   * Expose
   */


  var arc2 = ARC2;

  /*
   * Constants
   */


  var SIGMA$2 = new Uint32Array([0xa09e667f, 0x3bcc908b, 0xb67ae858, 0x4caa73b2, 0xc6ef372f, 0xe94f82be, 0x54ff53a5, 0xf1d36f1c, 0x10e527fa, 0xde682d1d, 0xb05688c2, 0xb3e6c1fd]);
  var S1$1 = new Uint32Array([0x70707000, 0x82828200, 0x2c2c2c00, 0xececec00, 0xb3b3b300, 0x27272700, 0xc0c0c000, 0xe5e5e500, 0xe4e4e400, 0x85858500, 0x57575700, 0x35353500, 0xeaeaea00, 0x0c0c0c00, 0xaeaeae00, 0x41414100, 0x23232300, 0xefefef00, 0x6b6b6b00, 0x93939300, 0x45454500, 0x19191900, 0xa5a5a500, 0x21212100, 0xededed00, 0x0e0e0e00, 0x4f4f4f00, 0x4e4e4e00, 0x1d1d1d00, 0x65656500, 0x92929200, 0xbdbdbd00, 0x86868600, 0xb8b8b800, 0xafafaf00, 0x8f8f8f00, 0x7c7c7c00, 0xebebeb00, 0x1f1f1f00, 0xcecece00, 0x3e3e3e00, 0x30303000, 0xdcdcdc00, 0x5f5f5f00, 0x5e5e5e00, 0xc5c5c500, 0x0b0b0b00, 0x1a1a1a00, 0xa6a6a600, 0xe1e1e100, 0x39393900, 0xcacaca00, 0xd5d5d500, 0x47474700, 0x5d5d5d00, 0x3d3d3d00, 0xd9d9d900, 0x01010100, 0x5a5a5a00, 0xd6d6d600, 0x51515100, 0x56565600, 0x6c6c6c00, 0x4d4d4d00, 0x8b8b8b00, 0x0d0d0d00, 0x9a9a9a00, 0x66666600, 0xfbfbfb00, 0xcccccc00, 0xb0b0b000, 0x2d2d2d00, 0x74747400, 0x12121200, 0x2b2b2b00, 0x20202000, 0xf0f0f000, 0xb1b1b100, 0x84848400, 0x99999900, 0xdfdfdf00, 0x4c4c4c00, 0xcbcbcb00, 0xc2c2c200, 0x34343400, 0x7e7e7e00, 0x76767600, 0x05050500, 0x6d6d6d00, 0xb7b7b700, 0xa9a9a900, 0x31313100, 0xd1d1d100, 0x17171700, 0x04040400, 0xd7d7d700, 0x14141400, 0x58585800, 0x3a3a3a00, 0x61616100, 0xdedede00, 0x1b1b1b00, 0x11111100, 0x1c1c1c00, 0x32323200, 0x0f0f0f00, 0x9c9c9c00, 0x16161600, 0x53535300, 0x18181800, 0xf2f2f200, 0x22222200, 0xfefefe00, 0x44444400, 0xcfcfcf00, 0xb2b2b200, 0xc3c3c300, 0xb5b5b500, 0x7a7a7a00, 0x91919100, 0x24242400, 0x08080800, 0xe8e8e800, 0xa8a8a800, 0x60606000, 0xfcfcfc00, 0x69696900, 0x50505000, 0xaaaaaa00, 0xd0d0d000, 0xa0a0a000, 0x7d7d7d00, 0xa1a1a100, 0x89898900, 0x62626200, 0x97979700, 0x54545400, 0x5b5b5b00, 0x1e1e1e00, 0x95959500, 0xe0e0e000, 0xffffff00, 0x64646400, 0xd2d2d200, 0x10101000, 0xc4c4c400, 0x00000000, 0x48484800, 0xa3a3a300, 0xf7f7f700, 0x75757500, 0xdbdbdb00, 0x8a8a8a00, 0x03030300, 0xe6e6e600, 0xdadada00, 0x09090900, 0x3f3f3f00, 0xdddddd00, 0x94949400, 0x87878700, 0x5c5c5c00, 0x83838300, 0x02020200, 0xcdcdcd00, 0x4a4a4a00, 0x90909000, 0x33333300, 0x73737300, 0x67676700, 0xf6f6f600, 0xf3f3f300, 0x9d9d9d00, 0x7f7f7f00, 0xbfbfbf00, 0xe2e2e200, 0x52525200, 0x9b9b9b00, 0xd8d8d800, 0x26262600, 0xc8c8c800, 0x37373700, 0xc6c6c600, 0x3b3b3b00, 0x81818100, 0x96969600, 0x6f6f6f00, 0x4b4b4b00, 0x13131300, 0xbebebe00, 0x63636300, 0x2e2e2e00, 0xe9e9e900, 0x79797900, 0xa7a7a700, 0x8c8c8c00, 0x9f9f9f00, 0x6e6e6e00, 0xbcbcbc00, 0x8e8e8e00, 0x29292900, 0xf5f5f500, 0xf9f9f900, 0xb6b6b600, 0x2f2f2f00, 0xfdfdfd00, 0xb4b4b400, 0x59595900, 0x78787800, 0x98989800, 0x06060600, 0x6a6a6a00, 0xe7e7e700, 0x46464600, 0x71717100, 0xbababa00, 0xd4d4d400, 0x25252500, 0xababab00, 0x42424200, 0x88888800, 0xa2a2a200, 0x8d8d8d00, 0xfafafa00, 0x72727200, 0x07070700, 0xb9b9b900, 0x55555500, 0xf8f8f800, 0xeeeeee00, 0xacacac00, 0x0a0a0a00, 0x36363600, 0x49494900, 0x2a2a2a00, 0x68686800, 0x3c3c3c00, 0x38383800, 0xf1f1f100, 0xa4a4a400, 0x40404000, 0x28282800, 0xd3d3d300, 0x7b7b7b00, 0xbbbbbb00, 0xc9c9c900, 0x43434300, 0xc1c1c100, 0x15151500, 0xe3e3e300, 0xadadad00, 0xf4f4f400, 0x77777700, 0xc7c7c700, 0x80808000, 0x9e9e9e00]);
  var S2$1 = new Uint32Array([0x00e0e0e0, 0x00050505, 0x00585858, 0x00d9d9d9, 0x00676767, 0x004e4e4e, 0x00818181, 0x00cbcbcb, 0x00c9c9c9, 0x000b0b0b, 0x00aeaeae, 0x006a6a6a, 0x00d5d5d5, 0x00181818, 0x005d5d5d, 0x00828282, 0x00464646, 0x00dfdfdf, 0x00d6d6d6, 0x00272727, 0x008a8a8a, 0x00323232, 0x004b4b4b, 0x00424242, 0x00dbdbdb, 0x001c1c1c, 0x009e9e9e, 0x009c9c9c, 0x003a3a3a, 0x00cacaca, 0x00252525, 0x007b7b7b, 0x000d0d0d, 0x00717171, 0x005f5f5f, 0x001f1f1f, 0x00f8f8f8, 0x00d7d7d7, 0x003e3e3e, 0x009d9d9d, 0x007c7c7c, 0x00606060, 0x00b9b9b9, 0x00bebebe, 0x00bcbcbc, 0x008b8b8b, 0x00161616, 0x00343434, 0x004d4d4d, 0x00c3c3c3, 0x00727272, 0x00959595, 0x00ababab, 0x008e8e8e, 0x00bababa, 0x007a7a7a, 0x00b3b3b3, 0x00020202, 0x00b4b4b4, 0x00adadad, 0x00a2a2a2, 0x00acacac, 0x00d8d8d8, 0x009a9a9a, 0x00171717, 0x001a1a1a, 0x00353535, 0x00cccccc, 0x00f7f7f7, 0x00999999, 0x00616161, 0x005a5a5a, 0x00e8e8e8, 0x00242424, 0x00565656, 0x00404040, 0x00e1e1e1, 0x00636363, 0x00090909, 0x00333333, 0x00bfbfbf, 0x00989898, 0x00979797, 0x00858585, 0x00686868, 0x00fcfcfc, 0x00ececec, 0x000a0a0a, 0x00dadada, 0x006f6f6f, 0x00535353, 0x00626262, 0x00a3a3a3, 0x002e2e2e, 0x00080808, 0x00afafaf, 0x00282828, 0x00b0b0b0, 0x00747474, 0x00c2c2c2, 0x00bdbdbd, 0x00363636, 0x00222222, 0x00383838, 0x00646464, 0x001e1e1e, 0x00393939, 0x002c2c2c, 0x00a6a6a6, 0x00303030, 0x00e5e5e5, 0x00444444, 0x00fdfdfd, 0x00888888, 0x009f9f9f, 0x00656565, 0x00878787, 0x006b6b6b, 0x00f4f4f4, 0x00232323, 0x00484848, 0x00101010, 0x00d1d1d1, 0x00515151, 0x00c0c0c0, 0x00f9f9f9, 0x00d2d2d2, 0x00a0a0a0, 0x00555555, 0x00a1a1a1, 0x00414141, 0x00fafafa, 0x00434343, 0x00131313, 0x00c4c4c4, 0x002f2f2f, 0x00a8a8a8, 0x00b6b6b6, 0x003c3c3c, 0x002b2b2b, 0x00c1c1c1, 0x00ffffff, 0x00c8c8c8, 0x00a5a5a5, 0x00202020, 0x00898989, 0x00000000, 0x00909090, 0x00474747, 0x00efefef, 0x00eaeaea, 0x00b7b7b7, 0x00151515, 0x00060606, 0x00cdcdcd, 0x00b5b5b5, 0x00121212, 0x007e7e7e, 0x00bbbbbb, 0x00292929, 0x000f0f0f, 0x00b8b8b8, 0x00070707, 0x00040404, 0x009b9b9b, 0x00949494, 0x00212121, 0x00666666, 0x00e6e6e6, 0x00cecece, 0x00ededed, 0x00e7e7e7, 0x003b3b3b, 0x00fefefe, 0x007f7f7f, 0x00c5c5c5, 0x00a4a4a4, 0x00373737, 0x00b1b1b1, 0x004c4c4c, 0x00919191, 0x006e6e6e, 0x008d8d8d, 0x00767676, 0x00030303, 0x002d2d2d, 0x00dedede, 0x00969696, 0x00262626, 0x007d7d7d, 0x00c6c6c6, 0x005c5c5c, 0x00d3d3d3, 0x00f2f2f2, 0x004f4f4f, 0x00191919, 0x003f3f3f, 0x00dcdcdc, 0x00797979, 0x001d1d1d, 0x00525252, 0x00ebebeb, 0x00f3f3f3, 0x006d6d6d, 0x005e5e5e, 0x00fbfbfb, 0x00696969, 0x00b2b2b2, 0x00f0f0f0, 0x00313131, 0x000c0c0c, 0x00d4d4d4, 0x00cfcfcf, 0x008c8c8c, 0x00e2e2e2, 0x00757575, 0x00a9a9a9, 0x004a4a4a, 0x00575757, 0x00848484, 0x00111111, 0x00454545, 0x001b1b1b, 0x00f5f5f5, 0x00e4e4e4, 0x000e0e0e, 0x00737373, 0x00aaaaaa, 0x00f1f1f1, 0x00dddddd, 0x00595959, 0x00141414, 0x006c6c6c, 0x00929292, 0x00545454, 0x00d0d0d0, 0x00787878, 0x00707070, 0x00e3e3e3, 0x00494949, 0x00808080, 0x00505050, 0x00a7a7a7, 0x00f6f6f6, 0x00777777, 0x00939393, 0x00868686, 0x00838383, 0x002a2a2a, 0x00c7c7c7, 0x005b5b5b, 0x00e9e9e9, 0x00eeeeee, 0x008f8f8f, 0x00010101, 0x003d3d3d]);
  var S3$1 = new Uint32Array([0x38003838, 0x41004141, 0x16001616, 0x76007676, 0xd900d9d9, 0x93009393, 0x60006060, 0xf200f2f2, 0x72007272, 0xc200c2c2, 0xab00abab, 0x9a009a9a, 0x75007575, 0x06000606, 0x57005757, 0xa000a0a0, 0x91009191, 0xf700f7f7, 0xb500b5b5, 0xc900c9c9, 0xa200a2a2, 0x8c008c8c, 0xd200d2d2, 0x90009090, 0xf600f6f6, 0x07000707, 0xa700a7a7, 0x27002727, 0x8e008e8e, 0xb200b2b2, 0x49004949, 0xde00dede, 0x43004343, 0x5c005c5c, 0xd700d7d7, 0xc700c7c7, 0x3e003e3e, 0xf500f5f5, 0x8f008f8f, 0x67006767, 0x1f001f1f, 0x18001818, 0x6e006e6e, 0xaf00afaf, 0x2f002f2f, 0xe200e2e2, 0x85008585, 0x0d000d0d, 0x53005353, 0xf000f0f0, 0x9c009c9c, 0x65006565, 0xea00eaea, 0xa300a3a3, 0xae00aeae, 0x9e009e9e, 0xec00ecec, 0x80008080, 0x2d002d2d, 0x6b006b6b, 0xa800a8a8, 0x2b002b2b, 0x36003636, 0xa600a6a6, 0xc500c5c5, 0x86008686, 0x4d004d4d, 0x33003333, 0xfd00fdfd, 0x66006666, 0x58005858, 0x96009696, 0x3a003a3a, 0x09000909, 0x95009595, 0x10001010, 0x78007878, 0xd800d8d8, 0x42004242, 0xcc00cccc, 0xef00efef, 0x26002626, 0xe500e5e5, 0x61006161, 0x1a001a1a, 0x3f003f3f, 0x3b003b3b, 0x82008282, 0xb600b6b6, 0xdb00dbdb, 0xd400d4d4, 0x98009898, 0xe800e8e8, 0x8b008b8b, 0x02000202, 0xeb00ebeb, 0x0a000a0a, 0x2c002c2c, 0x1d001d1d, 0xb000b0b0, 0x6f006f6f, 0x8d008d8d, 0x88008888, 0x0e000e0e, 0x19001919, 0x87008787, 0x4e004e4e, 0x0b000b0b, 0xa900a9a9, 0x0c000c0c, 0x79007979, 0x11001111, 0x7f007f7f, 0x22002222, 0xe700e7e7, 0x59005959, 0xe100e1e1, 0xda00dada, 0x3d003d3d, 0xc800c8c8, 0x12001212, 0x04000404, 0x74007474, 0x54005454, 0x30003030, 0x7e007e7e, 0xb400b4b4, 0x28002828, 0x55005555, 0x68006868, 0x50005050, 0xbe00bebe, 0xd000d0d0, 0xc400c4c4, 0x31003131, 0xcb00cbcb, 0x2a002a2a, 0xad00adad, 0x0f000f0f, 0xca00caca, 0x70007070, 0xff00ffff, 0x32003232, 0x69006969, 0x08000808, 0x62006262, 0x00000000, 0x24002424, 0xd100d1d1, 0xfb00fbfb, 0xba00baba, 0xed00eded, 0x45004545, 0x81008181, 0x73007373, 0x6d006d6d, 0x84008484, 0x9f009f9f, 0xee00eeee, 0x4a004a4a, 0xc300c3c3, 0x2e002e2e, 0xc100c1c1, 0x01000101, 0xe600e6e6, 0x25002525, 0x48004848, 0x99009999, 0xb900b9b9, 0xb300b3b3, 0x7b007b7b, 0xf900f9f9, 0xce00cece, 0xbf00bfbf, 0xdf00dfdf, 0x71007171, 0x29002929, 0xcd00cdcd, 0x6c006c6c, 0x13001313, 0x64006464, 0x9b009b9b, 0x63006363, 0x9d009d9d, 0xc000c0c0, 0x4b004b4b, 0xb700b7b7, 0xa500a5a5, 0x89008989, 0x5f005f5f, 0xb100b1b1, 0x17001717, 0xf400f4f4, 0xbc00bcbc, 0xd300d3d3, 0x46004646, 0xcf00cfcf, 0x37003737, 0x5e005e5e, 0x47004747, 0x94009494, 0xfa00fafa, 0xfc00fcfc, 0x5b005b5b, 0x97009797, 0xfe00fefe, 0x5a005a5a, 0xac00acac, 0x3c003c3c, 0x4c004c4c, 0x03000303, 0x35003535, 0xf300f3f3, 0x23002323, 0xb800b8b8, 0x5d005d5d, 0x6a006a6a, 0x92009292, 0xd500d5d5, 0x21002121, 0x44004444, 0x51005151, 0xc600c6c6, 0x7d007d7d, 0x39003939, 0x83008383, 0xdc00dcdc, 0xaa00aaaa, 0x7c007c7c, 0x77007777, 0x56005656, 0x05000505, 0x1b001b1b, 0xa400a4a4, 0x15001515, 0x34003434, 0x1e001e1e, 0x1c001c1c, 0xf800f8f8, 0x52005252, 0x20002020, 0x14001414, 0xe900e9e9, 0xbd00bdbd, 0xdd00dddd, 0xe400e4e4, 0xa100a1a1, 0xe000e0e0, 0x8a008a8a, 0xf100f1f1, 0xd600d6d6, 0x7a007a7a, 0xbb00bbbb, 0xe300e3e3, 0x40004040, 0x4f004f4f]);
  var S4 = new Uint32Array([0x70700070, 0x2c2c002c, 0xb3b300b3, 0xc0c000c0, 0xe4e400e4, 0x57570057, 0xeaea00ea, 0xaeae00ae, 0x23230023, 0x6b6b006b, 0x45450045, 0xa5a500a5, 0xeded00ed, 0x4f4f004f, 0x1d1d001d, 0x92920092, 0x86860086, 0xafaf00af, 0x7c7c007c, 0x1f1f001f, 0x3e3e003e, 0xdcdc00dc, 0x5e5e005e, 0x0b0b000b, 0xa6a600a6, 0x39390039, 0xd5d500d5, 0x5d5d005d, 0xd9d900d9, 0x5a5a005a, 0x51510051, 0x6c6c006c, 0x8b8b008b, 0x9a9a009a, 0xfbfb00fb, 0xb0b000b0, 0x74740074, 0x2b2b002b, 0xf0f000f0, 0x84840084, 0xdfdf00df, 0xcbcb00cb, 0x34340034, 0x76760076, 0x6d6d006d, 0xa9a900a9, 0xd1d100d1, 0x04040004, 0x14140014, 0x3a3a003a, 0xdede00de, 0x11110011, 0x32320032, 0x9c9c009c, 0x53530053, 0xf2f200f2, 0xfefe00fe, 0xcfcf00cf, 0xc3c300c3, 0x7a7a007a, 0x24240024, 0xe8e800e8, 0x60600060, 0x69690069, 0xaaaa00aa, 0xa0a000a0, 0xa1a100a1, 0x62620062, 0x54540054, 0x1e1e001e, 0xe0e000e0, 0x64640064, 0x10100010, 0x00000000, 0xa3a300a3, 0x75750075, 0x8a8a008a, 0xe6e600e6, 0x09090009, 0xdddd00dd, 0x87870087, 0x83830083, 0xcdcd00cd, 0x90900090, 0x73730073, 0xf6f600f6, 0x9d9d009d, 0xbfbf00bf, 0x52520052, 0xd8d800d8, 0xc8c800c8, 0xc6c600c6, 0x81810081, 0x6f6f006f, 0x13130013, 0x63630063, 0xe9e900e9, 0xa7a700a7, 0x9f9f009f, 0xbcbc00bc, 0x29290029, 0xf9f900f9, 0x2f2f002f, 0xb4b400b4, 0x78780078, 0x06060006, 0xe7e700e7, 0x71710071, 0xd4d400d4, 0xabab00ab, 0x88880088, 0x8d8d008d, 0x72720072, 0xb9b900b9, 0xf8f800f8, 0xacac00ac, 0x36360036, 0x2a2a002a, 0x3c3c003c, 0xf1f100f1, 0x40400040, 0xd3d300d3, 0xbbbb00bb, 0x43430043, 0x15150015, 0xadad00ad, 0x77770077, 0x80800080, 0x82820082, 0xecec00ec, 0x27270027, 0xe5e500e5, 0x85850085, 0x35350035, 0x0c0c000c, 0x41410041, 0xefef00ef, 0x93930093, 0x19190019, 0x21210021, 0x0e0e000e, 0x4e4e004e, 0x65650065, 0xbdbd00bd, 0xb8b800b8, 0x8f8f008f, 0xebeb00eb, 0xcece00ce, 0x30300030, 0x5f5f005f, 0xc5c500c5, 0x1a1a001a, 0xe1e100e1, 0xcaca00ca, 0x47470047, 0x3d3d003d, 0x01010001, 0xd6d600d6, 0x56560056, 0x4d4d004d, 0x0d0d000d, 0x66660066, 0xcccc00cc, 0x2d2d002d, 0x12120012, 0x20200020, 0xb1b100b1, 0x99990099, 0x4c4c004c, 0xc2c200c2, 0x7e7e007e, 0x05050005, 0xb7b700b7, 0x31310031, 0x17170017, 0xd7d700d7, 0x58580058, 0x61610061, 0x1b1b001b, 0x1c1c001c, 0x0f0f000f, 0x16160016, 0x18180018, 0x22220022, 0x44440044, 0xb2b200b2, 0xb5b500b5, 0x91910091, 0x08080008, 0xa8a800a8, 0xfcfc00fc, 0x50500050, 0xd0d000d0, 0x7d7d007d, 0x89890089, 0x97970097, 0x5b5b005b, 0x95950095, 0xffff00ff, 0xd2d200d2, 0xc4c400c4, 0x48480048, 0xf7f700f7, 0xdbdb00db, 0x03030003, 0xdada00da, 0x3f3f003f, 0x94940094, 0x5c5c005c, 0x02020002, 0x4a4a004a, 0x33330033, 0x67670067, 0xf3f300f3, 0x7f7f007f, 0xe2e200e2, 0x9b9b009b, 0x26260026, 0x37370037, 0x3b3b003b, 0x96960096, 0x4b4b004b, 0xbebe00be, 0x2e2e002e, 0x79790079, 0x8c8c008c, 0x6e6e006e, 0x8e8e008e, 0xf5f500f5, 0xb6b600b6, 0xfdfd00fd, 0x59590059, 0x98980098, 0x6a6a006a, 0x46460046, 0xbaba00ba, 0x25250025, 0x42420042, 0xa2a200a2, 0xfafa00fa, 0x07070007, 0x55550055, 0xeeee00ee, 0x0a0a000a, 0x49490049, 0x68680068, 0x38380038, 0xa4a400a4, 0x28280028, 0x7b7b007b, 0xc9c900c9, 0xc1c100c1, 0xe3e300e3, 0xf4f400f4, 0xc7c700c7, 0x9e9e009e]);
  /**
   * Camellia128
   */

  var Camellia128 = /*#__PURE__*/function () {
    function Camellia128() {
      _classCallCheck__default['default'](this, Camellia128);

      this.key = new Uint32Array(52);
      this.block = new Uint32Array(4);
    }

    _createClass__default['default'](Camellia128, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length === 16);
        this.keySchedule(key);
        return this;
      }
    }, {
      key: "keySchedule",
      value: function keySchedule(key) {
        var s = this.block;
        var k = this.key;
        s[0] = readU32$8(key, 0);
        s[1] = readU32$8(key, 4);
        s[2] = readU32$8(key, 8);
        s[3] = readU32$8(key, 12);
        set4(k, 0, 1, 2, 3, s, 0, 1, 2, 3);
        feis(s, 0, 1, 2, 3, SIGMA$2[0], SIGMA$2[1]);
        feis(s, 2, 3, 0, 1, SIGMA$2[2], SIGMA$2[3]);
        xor4(s, 0, 1, 2, 3, k, 0, 1, 2, 3);
        feis(s, 0, 1, 2, 3, SIGMA$2[4], SIGMA$2[5]);
        feis(s, 2, 3, 0, 1, SIGMA$2[6], SIGMA$2[7]);
        set4(k, 4, 5, 6, 7, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 15); // KA << 15

        set4(k, 12, 13, 14, 15, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 15); // KA << 30

        set4(k, 16, 17, 18, 19, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 15); // KA << 45

        set2(k, 24, 25, s, 0, 1);
        rotl(s, 0, 1, 2, 3, 15); // KA << 60

        set4(k, 28, 29, 30, 31, s, 0, 1, 2, 3);
        rotl(s, 1, 2, 3, 0, 2); // KA << 94

        set4(k, 40, 41, 42, 43, s, 1, 2, 3, 0);
        rotl(s, 1, 2, 3, 0, 17); // KA << 111

        set4(k, 48, 49, 50, 51, s, 1, 2, 3, 0);
        set4(s, 0, 1, 2, 3, k, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 15); // KL << 15

        set4(k, 8, 9, 10, 11, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 30); // KL << 45

        set4(k, 20, 21, 22, 23, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 15); // KL << 60

        set2(k, 26, 27, s, 2, 3);
        rotl(s, 0, 1, 2, 3, 17); // KL << 77

        set4(k, 32, 33, 34, 35, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 17); // KL << 94

        set4(k, 36, 37, 38, 39, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 17); // KL << 111

        set4(k, 44, 45, 46, 47, s, 0, 1, 2, 3);
        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        var r = this.block;
        var k = this.key;
        r[0] = readU32$8(input, ipos + 0);
        r[1] = readU32$8(input, ipos + 4);
        r[2] = readU32$8(input, ipos + 8);
        r[3] = readU32$8(input, ipos + 12);
        xor4(r, 0, 1, 2, 3, k, 0, 1, 2, 3);
        feis(r, 0, 1, 2, 3, k[4], k[5]);
        feis(r, 2, 3, 0, 1, k[6], k[7]);
        feis(r, 0, 1, 2, 3, k[8], k[9]);
        feis(r, 2, 3, 0, 1, k[10], k[11]);
        feis(r, 0, 1, 2, 3, k[12], k[13]);
        feis(r, 2, 3, 0, 1, k[14], k[15]);
        var t = r[0] & k[16];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[19];
        r[0] ^= r[1] | k[17];
        t = r[2] & k[18];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[20], k[21]);
        feis(r, 2, 3, 0, 1, k[22], k[23]);
        feis(r, 0, 1, 2, 3, k[24], k[25]);
        feis(r, 2, 3, 0, 1, k[26], k[27]);
        feis(r, 0, 1, 2, 3, k[28], k[29]);
        feis(r, 2, 3, 0, 1, k[30], k[31]);
        t = r[0] & k[32];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[35];
        r[0] ^= r[1] | k[33];
        t = r[2] & k[34];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[36], k[37]);
        feis(r, 2, 3, 0, 1, k[38], k[39]);
        feis(r, 0, 1, 2, 3, k[40], k[41]);
        feis(r, 2, 3, 0, 1, k[42], k[43]);
        feis(r, 0, 1, 2, 3, k[44], k[45]);
        feis(r, 2, 3, 0, 1, k[46], k[47]);
        xor4(r, 2, 3, 0, 1, k, 48, 49, 50, 51);
        writeU32$7(output, r[2], opos + 0);
        writeU32$7(output, r[3], opos + 4);
        writeU32$7(output, r[0], opos + 8);
        writeU32$7(output, r[1], opos + 12);
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        var r = this.block;
        var k = this.key;
        r[0] = readU32$8(input, ipos + 0);
        r[1] = readU32$8(input, ipos + 4);
        r[2] = readU32$8(input, ipos + 8);
        r[3] = readU32$8(input, ipos + 12);
        xor4(r, 3, 2, 1, 0, k, 51, 50, 49, 48);
        feis(r, 0, 1, 2, 3, k[46], k[47]);
        feis(r, 2, 3, 0, 1, k[44], k[45]);
        feis(r, 0, 1, 2, 3, k[42], k[43]);
        feis(r, 2, 3, 0, 1, k[40], k[41]);
        feis(r, 0, 1, 2, 3, k[38], k[39]);
        feis(r, 2, 3, 0, 1, k[36], k[37]);
        var t = r[0] & k[34];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[33];
        r[0] ^= r[1] | k[35];
        t = r[2] & k[32];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[30], k[31]);
        feis(r, 2, 3, 0, 1, k[28], k[29]);
        feis(r, 0, 1, 2, 3, k[26], k[27]);
        feis(r, 2, 3, 0, 1, k[24], k[25]);
        feis(r, 0, 1, 2, 3, k[22], k[23]);
        feis(r, 2, 3, 0, 1, k[20], k[21]);
        t = r[0] & k[18];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[17];
        r[0] ^= r[1] | k[19];
        t = r[2] & k[16];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[14], k[15]);
        feis(r, 2, 3, 0, 1, k[12], k[13]);
        feis(r, 0, 1, 2, 3, k[10], k[11]);
        feis(r, 2, 3, 0, 1, k[8], k[9]);
        feis(r, 0, 1, 2, 3, k[6], k[7]);
        feis(r, 2, 3, 0, 1, k[4], k[5]);
        xor4(r, 1, 0, 3, 2, k, 3, 2, 1, 0);
        writeU32$7(output, r[2], opos + 0);
        writeU32$7(output, r[3], opos + 4);
        writeU32$7(output, r[0], opos + 8);
        writeU32$7(output, r[1], opos + 12);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 52; i++) {
          this.key[i] = 0;
        }

        for (var _i = 0; _i < 4; _i++) {
          this.block[_i] = 0;
        }

        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 16;
      }
    }]);

    return Camellia128;
  }();
  /**
   * Camellia256
   */


  var Camellia256 = /*#__PURE__*/function () {
    function Camellia256() {
      _classCallCheck__default['default'](this, Camellia256);

      this.key = new Uint32Array(68);
      this.block = new Uint32Array(4);
    }

    _createClass__default['default'](Camellia256, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length === 24 || key.length === 32);
        this.keySchedule(key);
        return this;
      }
    }, {
      key: "keySchedule",
      value: function keySchedule(key) {
        var s = this.block;
        var k = this.key;
        k[0] = readU32$8(key, 0);
        k[1] = readU32$8(key, 4);
        k[2] = readU32$8(key, 8);
        k[3] = readU32$8(key, 12);
        k[8] = readU32$8(key, 16);
        k[9] = readU32$8(key, 20);

        if (key.length === 24) {
          k[10] = ~k[8];
          k[11] = ~k[9];
        } else {
          k[10] = readU32$8(key, 24);
          k[11] = readU32$8(key, 28);
        }

        s[0] = k[8] ^ k[0];
        s[1] = k[9] ^ k[1];
        s[2] = k[10] ^ k[2];
        s[3] = k[11] ^ k[3];
        feis(s, 0, 1, 2, 3, SIGMA$2[0], SIGMA$2[1]);
        feis(s, 2, 3, 0, 1, SIGMA$2[2], SIGMA$2[3]);
        xor4(s, 0, 1, 2, 3, k, 0, 1, 2, 3);
        feis(s, 0, 1, 2, 3, SIGMA$2[4], SIGMA$2[5]);
        feis(s, 2, 3, 0, 1, SIGMA$2[6], SIGMA$2[7]);
        set4(k, 12, 13, 14, 15, s, 0, 1, 2, 3);
        xor4(s, 0, 1, 2, 3, k, 8, 9, 10, 11);
        feis(s, 0, 1, 2, 3, SIGMA$2[8], SIGMA$2[9]);
        feis(s, 2, 3, 0, 1, SIGMA$2[10], SIGMA$2[11]);
        set4(k, 4, 5, 6, 7, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 30); // KB << 30

        set4(k, 20, 21, 22, 23, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 30); // KB << 60

        set4(k, 40, 41, 42, 43, s, 0, 1, 2, 3);
        rotl(s, 1, 2, 3, 0, 19); // KB << 111

        set4(k, 64, 65, 66, 67, s, 1, 2, 3, 0);
        set4(s, 0, 1, 2, 3, k, 8, 9, 10, 11);
        rotl(s, 0, 1, 2, 3, 15); // KR << 15

        set4(k, 8, 9, 10, 11, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 15); // KR << 30

        set4(k, 16, 17, 18, 19, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 30); // KR << 60

        set4(k, 36, 37, 38, 39, s, 0, 1, 2, 3);
        rotl(s, 1, 2, 3, 0, 2); // KR << 94

        set4(k, 52, 53, 54, 55, s, 1, 2, 3, 0);
        set4(s, 0, 1, 2, 3, k, 12, 13, 14, 15);
        rotl(s, 0, 1, 2, 3, 15); // KA << 15

        set4(k, 12, 13, 14, 15, s, 0, 1, 2, 3);
        rotl(s, 0, 1, 2, 3, 30); // KA << 45

        set4(k, 28, 29, 30, 31, s, 0, 1, 2, 3); // KA << 77

        set4(k, 48, 49, 50, 51, s, 1, 2, 3, 0);
        rotl(s, 1, 2, 3, 0, 17); // KA << 94

        set4(k, 56, 57, 58, 59, s, 1, 2, 3, 0);
        set4(s, 0, 1, 2, 3, k, 0, 1, 2, 3);
        rotl(s, 1, 2, 3, 0, 13); // KL << 45

        set4(k, 24, 25, 26, 27, s, 1, 2, 3, 0);
        rotl(s, 1, 2, 3, 0, 15); // KL << 60

        set4(k, 32, 33, 34, 35, s, 1, 2, 3, 0);
        rotl(s, 1, 2, 3, 0, 17); // KL << 77

        set4(k, 44, 45, 46, 47, s, 1, 2, 3, 0);
        rotl(s, 2, 3, 0, 1, 2); // KL << 111

        set4(k, 60, 61, 62, 63, s, 2, 3, 0, 1);
        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        var r = this.block;
        var k = this.key;
        r[0] = readU32$8(input, ipos + 0);
        r[1] = readU32$8(input, ipos + 4);
        r[2] = readU32$8(input, ipos + 8);
        r[3] = readU32$8(input, ipos + 12);
        xor4(r, 0, 1, 2, 3, k, 0, 1, 2, 3);
        feis(r, 0, 1, 2, 3, k[4], k[5]);
        feis(r, 2, 3, 0, 1, k[6], k[7]);
        feis(r, 0, 1, 2, 3, k[8], k[9]);
        feis(r, 2, 3, 0, 1, k[10], k[11]);
        feis(r, 0, 1, 2, 3, k[12], k[13]);
        feis(r, 2, 3, 0, 1, k[14], k[15]);
        var t = r[0] & k[16];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[19];
        r[0] ^= r[1] | k[17];
        t = r[2] & k[18];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[20], k[21]);
        feis(r, 2, 3, 0, 1, k[22], k[23]);
        feis(r, 0, 1, 2, 3, k[24], k[25]);
        feis(r, 2, 3, 0, 1, k[26], k[27]);
        feis(r, 0, 1, 2, 3, k[28], k[29]);
        feis(r, 2, 3, 0, 1, k[30], k[31]);
        t = r[0] & k[32];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[35];
        r[0] ^= r[1] | k[33];
        t = r[2] & k[34];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[36], k[37]);
        feis(r, 2, 3, 0, 1, k[38], k[39]);
        feis(r, 0, 1, 2, 3, k[40], k[41]);
        feis(r, 2, 3, 0, 1, k[42], k[43]);
        feis(r, 0, 1, 2, 3, k[44], k[45]);
        feis(r, 2, 3, 0, 1, k[46], k[47]);
        t = r[0] & k[48];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[51];
        r[0] ^= r[1] | k[49];
        t = r[2] & k[50];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[52], k[53]);
        feis(r, 2, 3, 0, 1, k[54], k[55]);
        feis(r, 0, 1, 2, 3, k[56], k[57]);
        feis(r, 2, 3, 0, 1, k[58], k[59]);
        feis(r, 0, 1, 2, 3, k[60], k[61]);
        feis(r, 2, 3, 0, 1, k[62], k[63]);
        xor4(r, 2, 3, 0, 1, k, 64, 65, 66, 67);
        writeU32$7(output, r[2], opos + 0);
        writeU32$7(output, r[3], opos + 4);
        writeU32$7(output, r[0], opos + 8);
        writeU32$7(output, r[1], opos + 12);
        return this;
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        var r = this.block;
        var k = this.key;
        r[0] = readU32$8(input, ipos + 0);
        r[1] = readU32$8(input, ipos + 4);
        r[2] = readU32$8(input, ipos + 8);
        r[3] = readU32$8(input, ipos + 12);
        xor4(r, 3, 2, 1, 0, k, 67, 66, 65, 64);
        feis(r, 0, 1, 2, 3, k[62], k[63]);
        feis(r, 2, 3, 0, 1, k[60], k[61]);
        feis(r, 0, 1, 2, 3, k[58], k[59]);
        feis(r, 2, 3, 0, 1, k[56], k[57]);
        feis(r, 0, 1, 2, 3, k[54], k[55]);
        feis(r, 2, 3, 0, 1, k[52], k[53]);
        var t = r[0] & k[50];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[49];
        r[0] ^= r[1] | k[51];
        t = r[2] & k[48];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[46], k[47]);
        feis(r, 2, 3, 0, 1, k[44], k[45]);
        feis(r, 0, 1, 2, 3, k[42], k[43]);
        feis(r, 2, 3, 0, 1, k[40], k[41]);
        feis(r, 0, 1, 2, 3, k[38], k[39]);
        feis(r, 2, 3, 0, 1, k[36], k[37]);
        t = r[0] & k[34];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[33];
        r[0] ^= r[1] | k[35];
        t = r[2] & k[32];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[30], k[31]);
        feis(r, 2, 3, 0, 1, k[28], k[29]);
        feis(r, 0, 1, 2, 3, k[26], k[27]);
        feis(r, 2, 3, 0, 1, k[24], k[25]);
        feis(r, 0, 1, 2, 3, k[22], k[23]);
        feis(r, 2, 3, 0, 1, k[20], k[21]);
        t = r[0] & k[18];
        r[1] ^= t << 1 | t >>> 32 - 1;
        r[2] ^= r[3] | k[17];
        r[0] ^= r[1] | k[19];
        t = r[2] & k[16];
        r[3] ^= t << 1 | t >>> 32 - 1;
        feis(r, 0, 1, 2, 3, k[14], k[15]);
        feis(r, 2, 3, 0, 1, k[12], k[13]);
        feis(r, 0, 1, 2, 3, k[10], k[11]);
        feis(r, 2, 3, 0, 1, k[8], k[9]);
        feis(r, 0, 1, 2, 3, k[6], k[7]);
        feis(r, 2, 3, 0, 1, k[4], k[5]);
        xor4(r, 1, 0, 3, 2, k, 3, 2, 1, 0);
        writeU32$7(output, r[2], opos + 0);
        writeU32$7(output, r[3], opos + 4);
        writeU32$7(output, r[0], opos + 8);
        writeU32$7(output, r[1], opos + 12);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 68; i++) {
          this.key[i] = 0;
        }

        for (var _i2 = 0; _i2 < 4; _i2++) {
          this.block[_i2] = 0;
        }

        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 16;
      }
    }]);

    return Camellia256;
  }();
  /**
   * Camellia
   */


  var Camellia = /*#__PURE__*/function () {
    function Camellia(bits) {
      _classCallCheck__default['default'](this, Camellia);

      assert_1$1(bits >>> 0 === bits);
      this.bits = bits;
      this.ctx = null;

      switch (bits) {
        case 128:
          this.ctx = new Camellia128();
          break;

        case 192:
        case 256:
          this.ctx = new Camellia256();
          break;

        default:
          throw new Error('Invalid key size.');
      }
    }

    _createClass__default['default'](Camellia, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length === this.bits >>> 3);
        this.ctx.init(key);
        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        this.ctx.encrypt(output, opos, input, ipos);
        return this;
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        this.ctx.decrypt(output, opos, input, ipos);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.ctx.destroy();
        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return this.ctx.blockSize;
      }
    }]);

    return Camellia;
  }();
  /*
   * Helpers
   */


  function feis(r, i0, i1, i2, i3, k0, k1) {
    var t;
    k0 ^= r[i0];
    k1 ^= r[i1];
    t = S4[k0 >>> 0 & 0xff] ^ S3$1[k0 >>> 8 & 0xff] ^ S2$1[k0 >>> 16 & 0xff] ^ S1$1[k0 >>> 24 & 0xff];
    r[i3] ^= t >>> 8 | t << 32 - 8;
    t ^= S1$1[k1 >>> 0 & 0xff] ^ S4[k1 >>> 8 & 0xff] ^ S3$1[k1 >>> 16 & 0xff] ^ S2$1[k1 >>> 24 & 0xff];
    r[i2] ^= t;
    r[i3] ^= t;
  }

  function rotl(r, i0, i1, i2, i3, n) {
    var t = r[i0] >>> 32 - n;
    r[i0] = r[i0] << n | r[i1] >>> 32 - n;
    r[i1] = r[i1] << n | r[i2] >>> 32 - n;
    r[i2] = r[i2] << n | r[i3] >>> 32 - n;
    r[i3] = r[i3] << n | t;
  }

  function set2(x, x0, x1, y, y0, y1) {
    x[x0] = y[y0];
    x[x1] = y[y1];
  }

  function set4(x, x0, x1, x2, x3, y, y0, y1, y2, y3) {
    x[x0] = y[y0];
    x[x1] = y[y1];
    x[x2] = y[y2];
    x[x3] = y[y3];
  }

  function xor4(x, x0, x1, x2, x3, y, y0, y1, y2, y3) {
    x[x0] ^= y[y0];
    x[x1] ^= y[y1];
    x[x2] ^= y[y2];
    x[x3] ^= y[y3];
  }

  function readU32$8(data, pos) {
    return data[pos++] * 0x1000000 + data[pos++] * 0x10000 + data[pos++] * 0x100 + data[pos];
  }

  function writeU32$7(data, value, pos) {
    data[pos++] = value >>> 24;
    data[pos++] = value >>> 16;
    data[pos++] = value >>> 8;
    data[pos++] = value >>> 0;
    return pos;
  }
  /*
   * Expose
   */


  var camellia = Camellia;

  function _createForOfIteratorHelper$3(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

  function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /*
   * Constants
   */


  var S = [new Uint32Array([0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a, 0x1e213f2f, 0x9c004dd3, 0x6003e540, 0xcf9fc949, 0xbfd4af27, 0x88bbbdb5, 0xe2034090, 0x98d09675, 0x6e63a0e0, 0x15c361d2, 0xc2e7661d, 0x22d4ff8e, 0x28683b6f, 0xc07fd059, 0xff2379c8, 0x775f50e2, 0x43c340d3, 0xdf2f8656, 0x887ca41a, 0xa2d2bd2d, 0xa1c9e0d6, 0x346c4819, 0x61b76d87, 0x22540f2f, 0x2abe32e1, 0xaa54166b, 0x22568e3a, 0xa2d341d0, 0x66db40c8, 0xa784392f, 0x004dff2f, 0x2db9d2de, 0x97943fac, 0x4a97c1d8, 0x527644b7, 0xb5f437a7, 0xb82cbaef, 0xd751d159, 0x6ff7f0ed, 0x5a097a1f, 0x827b68d0, 0x90ecf52e, 0x22b0c054, 0xbc8e5935, 0x4b6d2f7f, 0x50bb64a2, 0xd2664910, 0xbee5812d, 0xb7332290, 0xe93b159f, 0xb48ee411, 0x4bff345d, 0xfd45c240, 0xad31973f, 0xc4f6d02e, 0x55fc8165, 0xd5b1caad, 0xa1ac2dae, 0xa2d4b76d, 0xc19b0c50, 0x882240f2, 0x0c6e4f38, 0xa4e4bfd7, 0x4f5ba272, 0x564c1d2f, 0xc59c5319, 0xb949e354, 0xb04669fe, 0xb1b6ab8a, 0xc71358dd, 0x6385c545, 0x110f935d, 0x57538ad5, 0x6a390493, 0xe63d37e0, 0x2a54f6b3, 0x3a787d5f, 0x6276a0b5, 0x19a6fcdf, 0x7a42206a, 0x29f9d4d5, 0xf61b1891, 0xbb72275e, 0xaa508167, 0x38901091, 0xc6b505eb, 0x84c7cb8c, 0x2ad75a0f, 0x874a1427, 0xa2d1936b, 0x2ad286af, 0xaa56d291, 0xd7894360, 0x425c750d, 0x93b39e26, 0x187184c9, 0x6c00b32d, 0x73e2bb14, 0xa0bebc3c, 0x54623779, 0x64459eab, 0x3f328b82, 0x7718cf82, 0x59a2cea6, 0x04ee002e, 0x89fe78e6, 0x3fab0950, 0x325ff6c2, 0x81383f05, 0x6963c5c8, 0x76cb5ad6, 0xd49974c9, 0xca180dcf, 0x380782d5, 0xc7fa5cf6, 0x8ac31511, 0x35e79e13, 0x47da91d0, 0xf40f9086, 0xa7e2419e, 0x31366241, 0x051ef495, 0xaa573b04, 0x4a805d8d, 0x548300d0, 0x00322a3c, 0xbf64cddf, 0xba57a68e, 0x75c6372b, 0x50afd341, 0xa7c13275, 0x915a0bf5, 0x6b54bfab, 0x2b0b1426, 0xab4cc9d7, 0x449ccd82, 0xf7fbf265, 0xab85c5f3, 0x1b55db94, 0xaad4e324, 0xcfa4bd3f, 0x2deaa3e2, 0x9e204d02, 0xc8bd25ac, 0xeadf55b3, 0xd5bd9e98, 0xe31231b2, 0x2ad5ad6c, 0x954329de, 0xadbe4528, 0xd8710f69, 0xaa51c90f, 0xaa786bf6, 0x22513f1e, 0xaa51a79b, 0x2ad344cc, 0x7b5a41f0, 0xd37cfbad, 0x1b069505, 0x41ece491, 0xb4c332e6, 0x032268d4, 0xc9600acc, 0xce387e6d, 0xbf6bb16c, 0x6a70fb78, 0x0d03d9c9, 0xd4df39de, 0xe01063da, 0x4736f464, 0x5ad328d8, 0xb347cc96, 0x75bb0fc3, 0x98511bfb, 0x4ffbcc35, 0xb58bcf6a, 0xe11f0abc, 0xbfc5fe4a, 0xa70aec10, 0xac39570a, 0x3f04442f, 0x6188b153, 0xe0397a2e, 0x5727cb79, 0x9ceb418f, 0x1cacd68d, 0x2ad37c96, 0x0175cb9d, 0xc69dff09, 0xc75b65f0, 0xd9db40d8, 0xec0e7779, 0x4744ead4, 0xb11c3274, 0xdd24cb9e, 0x7e1c54bd, 0xf01144f9, 0xd2240eb1, 0x9675b3fd, 0xa3ac3755, 0xd47c27af, 0x51c85f4d, 0x56907596, 0xa5bb15e6, 0x580304f0, 0xca042cf1, 0x011a37ea, 0x8dbfaadb, 0x35ba3e4a, 0x3526ffa0, 0xc37b4d09, 0xbc306ed9, 0x98a52666, 0x5648f725, 0xff5e569d, 0x0ced63d0, 0x7c63b2cf, 0x700b45e1, 0xd5ea50f1, 0x85a92872, 0xaf1fbda7, 0xd4234870, 0xa7870bf3, 0x2d3b4d79, 0x42e04198, 0x0cd0ede7, 0x26470db8, 0xf881814c, 0x474d6ad7, 0x7c0c5e5c, 0xd1231959, 0x381b7298, 0xf5d2f4db, 0xab838653, 0x6e2f1e23, 0x83719c9e, 0xbd91e046, 0x9a56456e, 0xdc39200c, 0x20c8c571, 0x962bda1c, 0xe1e696ff, 0xb141ab08, 0x7cca89b9, 0x1a69e783, 0x02cc4843, 0xa2f7c579, 0x429ef47d, 0x427b169c, 0x5ac9f049, 0xdd8f0f00, 0x5c8165bf]), new Uint32Array([0x1f201094, 0xef0ba75b, 0x69e3cf7e, 0x393f4380, 0xfe61cf7a, 0xeec5207a, 0x55889c94, 0x72fc0651, 0xada7ef79, 0x4e1d7235, 0xd55a63ce, 0xde0436ba, 0x99c430ef, 0x5f0c0794, 0x18dcdb7d, 0xa1d6eff3, 0xa0b52f7b, 0x59e83605, 0xee15b094, 0xe9ffd909, 0xdc440086, 0xef944459, 0xba83ccb3, 0xe0c3cdfb, 0xd1da4181, 0x3b092ab1, 0xf997f1c1, 0xa5e6cf7b, 0x01420ddb, 0xe4e7ef5b, 0x25a1ff41, 0xe180f806, 0x1fc41080, 0x179bee7a, 0xd37ac6a9, 0xfe5830a4, 0x98de8b7f, 0x77e83f4e, 0x79929269, 0x24fa9f7b, 0xe113c85b, 0xacc40083, 0xd7503525, 0xf7ea615f, 0x62143154, 0x0d554b63, 0x5d681121, 0xc866c359, 0x3d63cf73, 0xcee234c0, 0xd4d87e87, 0x5c672b21, 0x071f6181, 0x39f7627f, 0x361e3084, 0xe4eb573b, 0x602f64a4, 0xd63acd9c, 0x1bbc4635, 0x9e81032d, 0x2701f50c, 0x99847ab4, 0xa0e3df79, 0xba6cf38c, 0x10843094, 0x2537a95e, 0xf46f6ffe, 0xa1ff3b1f, 0x208cfb6a, 0x8f458c74, 0xd9e0a227, 0x4ec73a34, 0xfc884f69, 0x3e4de8df, 0xef0e0088, 0x3559648d, 0x8a45388c, 0x1d804366, 0x721d9bfd, 0xa58684bb, 0xe8256333, 0x844e8212, 0x128d8098, 0xfed33fb4, 0xce280ae1, 0x27e19ba5, 0xd5a6c252, 0xe49754bd, 0xc5d655dd, 0xeb667064, 0x77840b4d, 0xa1b6a801, 0x84db26a9, 0xe0b56714, 0x21f043b7, 0xe5d05860, 0x54f03084, 0x066ff472, 0xa31aa153, 0xdadc4755, 0xb5625dbf, 0x68561be6, 0x83ca6b94, 0x2d6ed23b, 0xeccf01db, 0xa6d3d0ba, 0xb6803d5c, 0xaf77a709, 0x33b4a34c, 0x397bc8d6, 0x5ee22b95, 0x5f0e5304, 0x81ed6f61, 0x20e74364, 0xb45e1378, 0xde18639b, 0x881ca122, 0xb96726d1, 0x8049a7e8, 0x22b7da7b, 0x5e552d25, 0x5272d237, 0x79d2951c, 0xc60d894c, 0x488cb402, 0x1ba4fe5b, 0xa4b09f6b, 0x1ca815cf, 0xa20c3005, 0x8871df63, 0xb9de2fcb, 0x0cc6c9e9, 0x0beeff53, 0xe3214517, 0xb4542835, 0x9f63293c, 0xee41e729, 0x6e1d2d7c, 0x50045286, 0x1e6685f3, 0xf33401c6, 0x30a22c95, 0x31a70850, 0x60930f13, 0x73f98417, 0xa1269859, 0xec645c44, 0x52c877a9, 0xcdff33a6, 0xa02b1741, 0x7cbad9a2, 0x2180036f, 0x50d99c08, 0xcb3f4861, 0xc26bd765, 0x64a3f6ab, 0x80342676, 0x25a75e7b, 0xe4e6d1fc, 0x20c710e6, 0xcdf0b680, 0x17844d3b, 0x31eef84d, 0x7e0824e4, 0x2ccb49eb, 0x846a3bae, 0x8ff77888, 0xee5d60f6, 0x7af75673, 0x2fdd5cdb, 0xa11631c1, 0x30f66f43, 0xb3faec54, 0x157fd7fa, 0xef8579cc, 0xd152de58, 0xdb2ffd5e, 0x8f32ce19, 0x306af97a, 0x02f03ef8, 0x99319ad5, 0xc242fa0f, 0xa7e3ebb0, 0xc68e4906, 0xb8da230c, 0x80823028, 0xdcdef3c8, 0xd35fb171, 0x088a1bc8, 0xbec0c560, 0x61a3c9e8, 0xbca8f54d, 0xc72feffa, 0x22822e99, 0x82c570b4, 0xd8d94e89, 0x8b1c34bc, 0x301e16e6, 0x273be979, 0xb0ffeaa6, 0x61d9b8c6, 0x00b24869, 0xb7ffce3f, 0x08dc283b, 0x43daf65a, 0xf7e19798, 0x7619b72f, 0x8f1c9ba4, 0xdc8637a0, 0x16a7d3b1, 0x9fc393b7, 0xa7136eeb, 0xc6bcc63e, 0x1a513742, 0xef6828bc, 0x520365d6, 0x2d6a77ab, 0x3527ed4b, 0x821fd216, 0x095c6e2e, 0xdb92f2fb, 0x5eea29cb, 0x145892f5, 0x91584f7f, 0x5483697b, 0x2667a8cc, 0x85196048, 0x8c4bacea, 0x833860d4, 0x0d23e0f9, 0x6c387e8a, 0x0ae6d249, 0xb284600c, 0xd835731d, 0xdcb1c647, 0xac4c56ea, 0x3ebd81b3, 0x230eabb0, 0x6438bc87, 0xf0b5b1fa, 0x8f5ea2b3, 0xfc184642, 0x0a036b7a, 0x4fb089bd, 0x649da589, 0xa345415e, 0x5c038323, 0x3e5d3bb9, 0x43d79572, 0x7e6dd07c, 0x06dfdf1e, 0x6c6cc4ef, 0x7160a539, 0x73bfbe70, 0x83877605, 0x4523ecf1]), new Uint32Array([0x8defc240, 0x25fa5d9f, 0xeb903dbf, 0xe810c907, 0x47607fff, 0x369fe44b, 0x8c1fc644, 0xaececa90, 0xbeb1f9bf, 0xeefbcaea, 0xe8cf1950, 0x51df07ae, 0x920e8806, 0xf0ad0548, 0xe13c8d83, 0x927010d5, 0x11107d9f, 0x07647db9, 0xb2e3e4d4, 0x3d4f285e, 0xb9afa820, 0xfade82e0, 0xa067268b, 0x8272792e, 0x553fb2c0, 0x489ae22b, 0xd4ef9794, 0x125e3fbc, 0x21fffcee, 0x825b1bfd, 0x9255c5ed, 0x1257a240, 0x4e1a8302, 0xbae07fff, 0x528246e7, 0x8e57140e, 0x3373f7bf, 0x8c9f8188, 0xa6fc4ee8, 0xc982b5a5, 0xa8c01db7, 0x579fc264, 0x67094f31, 0xf2bd3f5f, 0x40fff7c1, 0x1fb78dfc, 0x8e6bd2c1, 0x437be59b, 0x99b03dbf, 0xb5dbc64b, 0x638dc0e6, 0x55819d99, 0xa197c81c, 0x4a012d6e, 0xc5884a28, 0xccc36f71, 0xb843c213, 0x6c0743f1, 0x8309893c, 0x0feddd5f, 0x2f7fe850, 0xd7c07f7e, 0x02507fbf, 0x5afb9a04, 0xa747d2d0, 0x1651192e, 0xaf70bf3e, 0x58c31380, 0x5f98302e, 0x727cc3c4, 0x0a0fb402, 0x0f7fef82, 0x8c96fdad, 0x5d2c2aae, 0x8ee99a49, 0x50da88b8, 0x8427f4a0, 0x1eac5790, 0x796fb449, 0x8252dc15, 0xefbd7d9b, 0xa672597d, 0xada840d8, 0x45f54504, 0xfa5d7403, 0xe83ec305, 0x4f91751a, 0x925669c2, 0x23efe941, 0xa903f12e, 0x60270df2, 0x0276e4b6, 0x94fd6574, 0x927985b2, 0x8276dbcb, 0x02778176, 0xf8af918d, 0x4e48f79e, 0x8f616ddf, 0xe29d840e, 0x842f7d83, 0x340ce5c8, 0x96bbb682, 0x93b4b148, 0xef303cab, 0x984faf28, 0x779faf9b, 0x92dc560d, 0x224d1e20, 0x8437aa88, 0x7d29dc96, 0x2756d3dc, 0x8b907cee, 0xb51fd240, 0xe7c07ce3, 0xe566b4a1, 0xc3e9615e, 0x3cf8209d, 0x6094d1e3, 0xcd9ca341, 0x5c76460e, 0x00ea983b, 0xd4d67881, 0xfd47572c, 0xf76cedd9, 0xbda8229c, 0x127dadaa, 0x438a074e, 0x1f97c090, 0x081bdb8a, 0x93a07ebe, 0xb938ca15, 0x97b03cff, 0x3dc2c0f8, 0x8d1ab2ec, 0x64380e51, 0x68cc7bfb, 0xd90f2788, 0x12490181, 0x5de5ffd4, 0xdd7ef86a, 0x76a2e214, 0xb9a40368, 0x925d958f, 0x4b39fffa, 0xba39aee9, 0xa4ffd30b, 0xfaf7933b, 0x6d498623, 0x193cbcfa, 0x27627545, 0x825cf47a, 0x61bd8ba0, 0xd11e42d1, 0xcead04f4, 0x127ea392, 0x10428db7, 0x8272a972, 0x9270c4a8, 0x127de50b, 0x285ba1c8, 0x3c62f44f, 0x35c0eaa5, 0xe805d231, 0x428929fb, 0xb4fcdf82, 0x4fb66a53, 0x0e7dc15b, 0x1f081fab, 0x108618ae, 0xfcfd086d, 0xf9ff2889, 0x694bcc11, 0x236a5cae, 0x12deca4d, 0x2c3f8cc5, 0xd2d02dfe, 0xf8ef5896, 0xe4cf52da, 0x95155b67, 0x494a488c, 0xb9b6a80c, 0x5c8f82bc, 0x89d36b45, 0x3a609437, 0xec00c9a9, 0x44715253, 0x0a874b49, 0xd773bc40, 0x7c34671c, 0x02717ef6, 0x4feb5536, 0xa2d02fff, 0xd2bf60c4, 0xd43f03c0, 0x50b4ef6d, 0x07478cd1, 0x006e1888, 0xa2e53f55, 0xb9e6d4bc, 0xa2048016, 0x97573833, 0xd7207d67, 0xde0f8f3d, 0x72f87b33, 0xabcc4f33, 0x7688c55d, 0x7b00a6b0, 0x947b0001, 0x570075d2, 0xf9bb88f8, 0x8942019e, 0x4264a5ff, 0x856302e0, 0x72dbd92b, 0xee971b69, 0x6ea22fde, 0x5f08ae2b, 0xaf7a616d, 0xe5c98767, 0xcf1febd2, 0x61efc8c2, 0xf1ac2571, 0xcc8239c2, 0x67214cb8, 0xb1e583d1, 0xb7dc3e62, 0x7f10bdce, 0xf90a5c38, 0x0ff0443d, 0x606e6dc6, 0x60543a49, 0x5727c148, 0x2be98a1d, 0x8ab41738, 0x20e1be24, 0xaf96da0f, 0x68458425, 0x99833be5, 0x600d457d, 0x282f9350, 0x8334b362, 0xd91d1120, 0x2b6d8da0, 0x642b1e31, 0x9c305a00, 0x52bce688, 0x1b03588a, 0xf7baefd5, 0x4142ed9c, 0xa4315c11, 0x83323ec5, 0xdfef4636, 0xa133c501, 0xe9d3531c, 0xee353783]), new Uint32Array([0x9db30420, 0x1fb6e9de, 0xa7be7bef, 0xd273a298, 0x4a4f7bdb, 0x64ad8c57, 0x85510443, 0xfa020ed1, 0x7e287aff, 0xe60fb663, 0x095f35a1, 0x79ebf120, 0xfd059d43, 0x6497b7b1, 0xf3641f63, 0x241e4adf, 0x28147f5f, 0x4fa2b8cd, 0xc9430040, 0x0cc32220, 0xfdd30b30, 0xc0a5374f, 0x1d2d00d9, 0x24147b15, 0xee4d111a, 0x0fca5167, 0x71ff904c, 0x2d195ffe, 0x1a05645f, 0x0c13fefe, 0x081b08ca, 0x05170121, 0x80530100, 0xe83e5efe, 0xac9af4f8, 0x7fe72701, 0xd2b8ee5f, 0x06df4261, 0xbb9e9b8a, 0x7293ea25, 0xce84ffdf, 0xf5718801, 0x3dd64b04, 0xa26f263b, 0x7ed48400, 0x547eebe6, 0x446d4ca0, 0x6cf3d6f5, 0x2649abdf, 0xaea0c7f5, 0x36338cc1, 0x503f7e93, 0xd3772061, 0x11b638e1, 0x72500e03, 0xf80eb2bb, 0xabe0502e, 0xec8d77de, 0x57971e81, 0xe14f6746, 0xc9335400, 0x6920318f, 0x081dbb99, 0xffc304a5, 0x4d351805, 0x7f3d5ce3, 0xa6c866c6, 0x5d5bcca9, 0xdaec6fea, 0x9f926f91, 0x9f46222f, 0x3991467d, 0xa5bf6d8e, 0x1143c44f, 0x43958302, 0xd0214eeb, 0x022083b8, 0x3fb6180c, 0x18f8931e, 0x281658e6, 0x26486e3e, 0x8bd78a70, 0x7477e4c1, 0xb506e07c, 0xf32d0a25, 0x79098b02, 0xe4eabb81, 0x28123b23, 0x69dead38, 0x1574ca16, 0xdf871b62, 0x211c40b7, 0xa51a9ef9, 0x0014377b, 0x041e8ac8, 0x09114003, 0xbd59e4d2, 0xe3d156d5, 0x4fe876d5, 0x2f91a340, 0x557be8de, 0x00eae4a7, 0x0ce5c2ec, 0x4db4bba6, 0xe756bdff, 0xdd3369ac, 0xec17b035, 0x06572327, 0x99afc8b0, 0x56c8c391, 0x6b65811c, 0x5e146119, 0x6e85cb75, 0xbe07c002, 0xc2325577, 0x893ff4ec, 0x5bbfc92d, 0xd0ec3b25, 0xb7801ab7, 0x8d6d3b24, 0x20c763ef, 0xc366a5fc, 0x9c382880, 0x0ace3205, 0xaac9548a, 0xeca1d7c7, 0x041afa32, 0x1d16625a, 0x6701902c, 0x9b757a54, 0x31d477f7, 0x9126b031, 0x36cc6fdb, 0xc70b8b46, 0xd9e66a48, 0x56e55a79, 0x026a4ceb, 0x52437eff, 0x2f8f76b4, 0x0df980a5, 0x8674cde3, 0xedda04eb, 0x17a9be04, 0x2c18f4df, 0xb7747f9d, 0xab2af7b4, 0xefc34d20, 0x2e096b7c, 0x1741a254, 0xe5b6a035, 0x213d42f6, 0x2c1c7c26, 0x61c2f50f, 0x6552daf9, 0xd2c231f8, 0x25130f69, 0xd8167fa2, 0x0418f2c8, 0x001a96a6, 0x0d1526ab, 0x63315c21, 0x5e0a72ec, 0x49bafefd, 0x187908d9, 0x8d0dbd86, 0x311170a7, 0x3e9b640c, 0xcc3e10d7, 0xd5cad3b6, 0x0caec388, 0xf73001e1, 0x6c728aff, 0x71eae2a1, 0x1f9af36e, 0xcfcbd12f, 0xc1de8417, 0xac07be6b, 0xcb44a1d8, 0x8b9b0f56, 0x013988c3, 0xb1c52fca, 0xb4be31cd, 0xd8782806, 0x12a3a4e2, 0x6f7de532, 0x58fd7eb6, 0xd01ee900, 0x24adffc2, 0xf4990fc5, 0x9711aac5, 0x001d7b95, 0x82e5e7d2, 0x109873f6, 0x00613096, 0xc32d9521, 0xada121ff, 0x29908415, 0x7fbb977f, 0xaf9eb3db, 0x29c9ed2a, 0x5ce2a465, 0xa730f32c, 0xd0aa3fe8, 0x8a5cc091, 0xd49e2ce7, 0x0ce454a9, 0xd60acd86, 0x015f1919, 0x77079103, 0xdea03af6, 0x78a8565e, 0xdee356df, 0x21f05cbe, 0x8b75e387, 0xb3c50651, 0xb8a5c3ef, 0xd8eeb6d2, 0xe523be77, 0xc2154529, 0x2f69efdf, 0xafe67afb, 0xf470c4b2, 0xf3e0eb5b, 0xd6cc9876, 0x39e4460c, 0x1fda8538, 0x1987832f, 0xca007367, 0xa99144f8, 0x296b299e, 0x492fc295, 0x9266beab, 0xb5676e69, 0x9bd3ddda, 0xdf7e052f, 0xdb25701c, 0x1b5e51ee, 0xf65324e6, 0x6afce36c, 0x0316cc04, 0x8644213e, 0xb7dc59d0, 0x7965291f, 0xccd6fd43, 0x41823979, 0x932bcdf6, 0xb657c34d, 0x4edfd282, 0x7ae5290c, 0x3cb9536b, 0x851e20fe, 0x9833557e, 0x13ecf0b0, 0xd3ffb372, 0x3f85c5c1, 0x0aef7ed2]), new Uint32Array([0x7ec90c04, 0x2c6e74b9, 0x9b0e66df, 0xa6337911, 0xb86a7fff, 0x1dd358f5, 0x44dd9d44, 0x1731167f, 0x08fbf1fa, 0xe7f511cc, 0xd2051b00, 0x735aba00, 0x2ab722d8, 0x386381cb, 0xacf6243a, 0x69befd7a, 0xe6a2e77f, 0xf0c720cd, 0xc4494816, 0xccf5c180, 0x38851640, 0x15b0a848, 0xe68b18cb, 0x4caadeff, 0x5f480a01, 0x0412b2aa, 0x259814fc, 0x41d0efe2, 0x4e40b48d, 0x248eb6fb, 0x8dba1cfe, 0x41a99b02, 0x1a550a04, 0xba8f65cb, 0x7251f4e7, 0x95a51725, 0xc106ecd7, 0x97a5980a, 0xc539b9aa, 0x4d79fe6a, 0xf2f3f763, 0x68af8040, 0xed0c9e56, 0x11b4958b, 0xe1eb5a88, 0x8709e6b0, 0xd7e07156, 0x4e29fea7, 0x6366e52d, 0x02d1c000, 0xc4ac8e05, 0x9377f571, 0x0c05372a, 0x578535f2, 0x2261be02, 0xd642a0c9, 0xdf13a280, 0x74b55bd2, 0x682199c0, 0xd421e5ec, 0x53fb3ce8, 0xc8adedb3, 0x28a87fc9, 0x3d959981, 0x5c1ff900, 0xfe38d399, 0x0c4eff0b, 0x062407ea, 0xaa2f4fb1, 0x4fb96976, 0x90c79505, 0xb0a8a774, 0xef55a1ff, 0xe59ca2c2, 0xa6b62d27, 0xe66a4263, 0xdf65001f, 0x0ec50966, 0xdfdd55bc, 0x29de0655, 0x911e739a, 0x17af8975, 0x32c7911c, 0x89f89468, 0x0d01e980, 0x524755f4, 0x03b63cc9, 0x0cc844b2, 0xbcf3f0aa, 0x87ac36e9, 0xe53a7426, 0x01b3d82b, 0x1a9e7449, 0x64ee2d7e, 0xcddbb1da, 0x01c94910, 0xb868bf80, 0x0d26f3fd, 0x9342ede7, 0x04a5c284, 0x636737b6, 0x50f5b616, 0xf24766e3, 0x8eca36c1, 0x136e05db, 0xfef18391, 0xfb887a37, 0xd6e7f7d4, 0xc7fb7dc9, 0x3063fcdf, 0xb6f589de, 0xec2941da, 0x26e46695, 0xb7566419, 0xf654efc5, 0xd08d58b7, 0x48925401, 0xc1bacb7f, 0xe5ff550f, 0xb6083049, 0x5bb5d0e8, 0x87d72e5a, 0xab6a6ee1, 0x223a66ce, 0xc62bf3cd, 0x9e0885f9, 0x68cb3e47, 0x086c010f, 0xa21de820, 0xd18b69de, 0xf3f65777, 0xfa02c3f6, 0x407edac3, 0xcbb3d550, 0x1793084d, 0xb0d70eba, 0x0ab378d5, 0xd951fb0c, 0xded7da56, 0x4124bbe4, 0x94ca0b56, 0x0f5755d1, 0xe0e1e56e, 0x6184b5be, 0x580a249f, 0x94f74bc0, 0xe327888e, 0x9f7b5561, 0xc3dc0280, 0x05687715, 0x646c6bd7, 0x44904db3, 0x66b4f0a3, 0xc0f1648a, 0x697ed5af, 0x49e92ff6, 0x309e374f, 0x2cb6356a, 0x85808573, 0x4991f840, 0x76f0ae02, 0x083be84d, 0x28421c9a, 0x44489406, 0x736e4cb8, 0xc1092910, 0x8bc95fc6, 0x7d869cf4, 0x134f616f, 0x2e77118d, 0xb31b2be1, 0xaa90b472, 0x3ca5d717, 0x7d161bba, 0x9cad9010, 0xaf462ba2, 0x9fe459d2, 0x45d34559, 0xd9f2da13, 0xdbc65487, 0xf3e4f94e, 0x176d486f, 0x097c13ea, 0x631da5c7, 0x445f7382, 0x175683f4, 0xcdc66a97, 0x70be0288, 0xb3cdcf72, 0x6e5dd2f3, 0x20936079, 0x459b80a5, 0xbe60e2db, 0xa9c23101, 0xeba5315c, 0x224e42f2, 0x1c5c1572, 0xf6721b2c, 0x1ad2fff3, 0x8c25404e, 0x324ed72f, 0x4067b7fd, 0x0523138e, 0x5ca3bc78, 0xdc0fd66e, 0x75922283, 0x784d6b17, 0x58ebb16e, 0x44094f85, 0x3f481d87, 0xfcfeae7b, 0x77b5ff76, 0x8c2302bf, 0xaaf47556, 0x5f46b02a, 0x2b092801, 0x3d38f5f7, 0x0ca81f36, 0x52af4a8a, 0x66d5e7c0, 0xdf3b0874, 0x95055110, 0x1b5ad7a8, 0xf61ed5ad, 0x6cf6e479, 0x20758184, 0xd0cefa65, 0x88f7be58, 0x4a046826, 0x0ff6f8f3, 0xa09c7f70, 0x5346aba0, 0x5ce96c28, 0xe176eda3, 0x6bac307f, 0x376829d2, 0x85360fa9, 0x17e3fe2a, 0x24b79767, 0xf5a96b20, 0xd6cd2595, 0x68ff1ebf, 0x7555442c, 0xf19f06be, 0xf9e0659a, 0xeeb9491d, 0x34010718, 0xbb30cab8, 0xe822fe15, 0x88570983, 0x750e6249, 0xda627e55, 0x5e76ffa8, 0xb1534546, 0x6d47de08, 0xefe9e7d4]), new Uint32Array([0xf6fa8f9d, 0x2cac6ce1, 0x4ca34867, 0xe2337f7c, 0x95db08e7, 0x016843b4, 0xeced5cbc, 0x325553ac, 0xbf9f0960, 0xdfa1e2ed, 0x83f0579d, 0x63ed86b9, 0x1ab6a6b8, 0xde5ebe39, 0xf38ff732, 0x8989b138, 0x33f14961, 0xc01937bd, 0xf506c6da, 0xe4625e7e, 0xa308ea99, 0x4e23e33c, 0x79cbd7cc, 0x48a14367, 0xa3149619, 0xfec94bd5, 0xa114174a, 0xeaa01866, 0xa084db2d, 0x09a8486f, 0xa888614a, 0x2900af98, 0x01665991, 0xe1992863, 0xc8f30c60, 0x2e78ef3c, 0xd0d51932, 0xcf0fec14, 0xf7ca07d2, 0xd0a82072, 0xfd41197e, 0x9305a6b0, 0xe86be3da, 0x74bed3cd, 0x372da53c, 0x4c7f4448, 0xdab5d440, 0x6dba0ec3, 0x083919a7, 0x9fbaeed9, 0x49dbcfb0, 0x4e670c53, 0x5c3d9c01, 0x64bdb941, 0x2c0e636a, 0xba7dd9cd, 0xea6f7388, 0xe70bc762, 0x35f29adb, 0x5c4cdd8d, 0xf0d48d8c, 0xb88153e2, 0x08a19866, 0x1ae2eac8, 0x284caf89, 0xaa928223, 0x9334be53, 0x3b3a21bf, 0x16434be3, 0x9aea3906, 0xefe8c36e, 0xf890cdd9, 0x80226dae, 0xc340a4a3, 0xdf7e9c09, 0xa694a807, 0x5b7c5ecc, 0x221db3a6, 0x9a69a02f, 0x68818a54, 0xceb2296f, 0x53c0843a, 0xfe893655, 0x25bfe68a, 0xb4628abc, 0xcf222ebf, 0x25ac6f48, 0xa9a99387, 0x53bddb65, 0xe76ffbe7, 0xe967fd78, 0x0ba93563, 0x8e342bc1, 0xe8a11be9, 0x4980740d, 0xc8087dfc, 0x8de4bf99, 0xa11101a0, 0x7fd37975, 0xda5a26c0, 0xe81f994f, 0x9528cd89, 0xfd339fed, 0xb87834bf, 0x5f04456d, 0x22258698, 0xc9c4c83b, 0x2dc156be, 0x4f628daa, 0x57f55ec5, 0xe2220abe, 0xd2916ebf, 0x4ec75b95, 0x24f2c3c0, 0x42d15d99, 0xcd0d7fa0, 0x7b6e27ff, 0xa8dc8af0, 0x7345c106, 0xf41e232f, 0x35162386, 0xe6ea8926, 0x3333b094, 0x157ec6f2, 0x372b74af, 0x692573e4, 0xe9a9d848, 0xf3160289, 0x3a62ef1d, 0xa787e238, 0xf3a5f676, 0x74364853, 0x20951063, 0x4576698d, 0xb6fad407, 0x592af950, 0x36f73523, 0x4cfb6e87, 0x7da4cec0, 0x6c152daa, 0xcb0396a8, 0xc50dfe5d, 0xfcd707ab, 0x0921c42f, 0x89dff0bb, 0x5fe2be78, 0x448f4f33, 0x754613c9, 0x2b05d08d, 0x48b9d585, 0xdc049441, 0xc8098f9b, 0x7dede786, 0xc39a3373, 0x42410005, 0x6a091751, 0x0ef3c8a6, 0x890072d6, 0x28207682, 0xa9a9f7be, 0xbf32679d, 0xd45b5b75, 0xb353fd00, 0xcbb0e358, 0x830f220a, 0x1f8fb214, 0xd372cf08, 0xcc3c4a13, 0x8cf63166, 0x061c87be, 0x88c98f88, 0x6062e397, 0x47cf8e7a, 0xb6c85283, 0x3cc2acfb, 0x3fc06976, 0x4e8f0252, 0x64d8314d, 0xda3870e3, 0x1e665459, 0xc10908f0, 0x513021a5, 0x6c5b68b7, 0x822f8aa0, 0x3007cd3e, 0x74719eef, 0xdc872681, 0x073340d4, 0x7e432fd9, 0x0c5ec241, 0x8809286c, 0xf592d891, 0x08a930f6, 0x957ef305, 0xb7fbffbd, 0xc266e96f, 0x6fe4ac98, 0xb173ecc0, 0xbc60b42a, 0x953498da, 0xfba1ae12, 0x2d4bd736, 0x0f25faab, 0xa4f3fceb, 0xe2969123, 0x257f0c3d, 0x9348af49, 0x361400bc, 0xe8816f4a, 0x3814f200, 0xa3f94043, 0x9c7a54c2, 0xbc704f57, 0xda41e7f9, 0xc25ad33a, 0x54f4a084, 0xb17f5505, 0x59357cbe, 0xedbd15c8, 0x7f97c5ab, 0xba5ac7b5, 0xb6f6deaf, 0x3a479c3a, 0x5302da25, 0x653d7e6a, 0x54268d49, 0x51a477ea, 0x5017d55b, 0xd7d25d88, 0x44136c76, 0x0404a8c8, 0xb8e5a121, 0xb81a928a, 0x60ed5869, 0x97c55b96, 0xeaec991b, 0x29935913, 0x01fdb7f1, 0x088e8dfa, 0x9ab6f6f5, 0x3b4cbf9f, 0x4a5de3ab, 0xe6051d35, 0xa0e1d855, 0xd36b4cf1, 0xf544edeb, 0xb0e93524, 0xbebb8fbd, 0xa2d762cf, 0x49c92f54, 0x38b5f331, 0x7128a454, 0x48392905, 0xa65b1db8, 0x851c97bd, 0xd675cf2f]), new Uint32Array([0x85e04019, 0x332bf567, 0x662dbfff, 0xcfc65693, 0x2a8d7f6f, 0xab9bc912, 0xde6008a1, 0x2028da1f, 0x0227bce7, 0x4d642916, 0x18fac300, 0x50f18b82, 0x2cb2cb11, 0xb232e75c, 0x4b3695f2, 0xb28707de, 0xa05fbcf6, 0xcd4181e9, 0xe150210c, 0xe24ef1bd, 0xb168c381, 0xfde4e789, 0x5c79b0d8, 0x1e8bfd43, 0x4d495001, 0x38be4341, 0x913cee1d, 0x92a79c3f, 0x089766be, 0xbaeeadf4, 0x1286becf, 0xb6eacb19, 0x2660c200, 0x7565bde4, 0x64241f7a, 0x8248dca9, 0xc3b3ad66, 0x28136086, 0x0bd8dfa8, 0x356d1cf2, 0x107789be, 0xb3b2e9ce, 0x0502aa8f, 0x0bc0351e, 0x166bf52a, 0xeb12ff82, 0xe3486911, 0xd34d7516, 0x4e7b3aff, 0x5f43671b, 0x9cf6e037, 0x4981ac83, 0x334266ce, 0x8c9341b7, 0xd0d854c0, 0xcb3a6c88, 0x47bc2829, 0x4725ba37, 0xa66ad22b, 0x7ad61f1e, 0x0c5cbafa, 0x4437f107, 0xb6e79962, 0x42d2d816, 0x0a961288, 0xe1a5c06e, 0x13749e67, 0x72fc081a, 0xb1d139f7, 0xf9583745, 0xcf19df58, 0xbec3f756, 0xc06eba30, 0x07211b24, 0x45c28829, 0xc95e317f, 0xbc8ec511, 0x38bc46e9, 0xc6e6fa14, 0xbae8584a, 0xad4ebc46, 0x468f508b, 0x7829435f, 0xf124183b, 0x821dba9f, 0xaff60ff4, 0xea2c4e6d, 0x16e39264, 0x92544a8b, 0x009b4fc3, 0xaba68ced, 0x9ac96f78, 0x06a5b79a, 0xb2856e6e, 0x1aec3ca9, 0xbe838688, 0x0e0804e9, 0x55f1be56, 0xe7e5363b, 0xb3a1f25d, 0xf7debb85, 0x61fe033c, 0x16746233, 0x3c034c28, 0xda6d0c74, 0x79aac56c, 0x3ce4e1ad, 0x51f0c802, 0x98f8f35a, 0x1626a49f, 0xeed82b29, 0x1d382fe3, 0x0c4fb99a, 0xbb325778, 0x3ec6d97b, 0x6e77a6a9, 0xcb658b5c, 0xd45230c7, 0x2bd1408b, 0x60c03eb7, 0xb9068d78, 0xa33754f4, 0xf430c87d, 0xc8a71302, 0xb96d8c32, 0xebd4e7be, 0xbe8b9d2d, 0x7979fb06, 0xe7225308, 0x8b75cf77, 0x11ef8da4, 0xe083c858, 0x8d6b786f, 0x5a6317a6, 0xfa5cf7a0, 0x5dda0033, 0xf28ebfb0, 0xf5b9c310, 0xa0eac280, 0x08b9767a, 0xa3d9d2b0, 0x79d34217, 0x021a718d, 0x9ac6336a, 0x2711fd60, 0x438050e3, 0x069908a8, 0x3d7fedc4, 0x826d2bef, 0x4eeb8476, 0x488dcf25, 0x36c9d566, 0x28e74e41, 0xc2610aca, 0x3d49a9cf, 0xbae3b9df, 0xb65f8de6, 0x92aeaf64, 0x3ac7d5e6, 0x9ea80509, 0xf22b017d, 0xa4173f70, 0xdd1e16c3, 0x15e0d7f9, 0x50b1b887, 0x2b9f4fd5, 0x625aba82, 0x6a017962, 0x2ec01b9c, 0x15488aa9, 0xd716e740, 0x40055a2c, 0x93d29a22, 0xe32dbf9a, 0x058745b9, 0x3453dc1e, 0xd699296e, 0x496cff6f, 0x1c9f4986, 0xdfe2ed07, 0xb87242d1, 0x19de7eae, 0x053e561a, 0x15ad6f8c, 0x66626c1c, 0x7154c24c, 0xea082b2a, 0x93eb2939, 0x17dcb0f0, 0x58d4f2ae, 0x9ea294fb, 0x52cf564c, 0x9883fe66, 0x2ec40581, 0x763953c3, 0x01d6692e, 0xd3a0c108, 0xa1e7160e, 0xe4f2dfa6, 0x693ed285, 0x74904698, 0x4c2b0edd, 0x4f757656, 0x5d393378, 0xa132234f, 0x3d321c5d, 0xc3f5e194, 0x4b269301, 0xc79f022f, 0x3c997e7e, 0x5e4f9504, 0x3ffafbbd, 0x76f7ad0e, 0x296693f4, 0x3d1fce6f, 0xc61e45be, 0xd3b5ab34, 0xf72bf9b7, 0x1b0434c0, 0x4e72b567, 0x5592a33d, 0xb5229301, 0xcfd2a87f, 0x60aeb767, 0x1814386b, 0x30bcc33d, 0x38a0c07d, 0xfd1606f2, 0xc363519b, 0x589dd390, 0x5479f8e6, 0x1cb8d647, 0x97fd61a9, 0xea7759f4, 0x2d57539d, 0x569a58cf, 0xe84e63ad, 0x462e1b78, 0x6580f87e, 0xf3817914, 0x91da55f4, 0x40a230f3, 0xd1988f35, 0xb6e318d2, 0x3ffa50bc, 0x3d40f021, 0xc3c0bdae, 0x4958c24c, 0x518f36b2, 0x84b1d370, 0x0fedce83, 0x878ddada, 0xf2a279c7, 0x94e01be8, 0x90716f4b, 0x954b8aa3]), new Uint32Array([0xe216300d, 0xbbddfffc, 0xa7ebdabd, 0x35648095, 0x7789f8b7, 0xe6c1121b, 0x0e241600, 0x052ce8b5, 0x11a9cfb0, 0xe5952f11, 0xece7990a, 0x9386d174, 0x2a42931c, 0x76e38111, 0xb12def3a, 0x37ddddfc, 0xde9adeb1, 0x0a0cc32c, 0xbe197029, 0x84a00940, 0xbb243a0f, 0xb4d137cf, 0xb44e79f0, 0x049eedfd, 0x0b15a15d, 0x480d3168, 0x8bbbde5a, 0x669ded42, 0xc7ece831, 0x3f8f95e7, 0x72df191b, 0x7580330d, 0x94074251, 0x5c7dcdfa, 0xabbe6d63, 0xaa402164, 0xb301d40a, 0x02e7d1ca, 0x53571dae, 0x7a3182a2, 0x12a8ddec, 0xfdaa335d, 0x176f43e8, 0x71fb46d4, 0x38129022, 0xce949ad4, 0xb84769ad, 0x965bd862, 0x82f3d055, 0x66fb9767, 0x15b80b4e, 0x1d5b47a0, 0x4cfde06f, 0xc28ec4b8, 0x57e8726e, 0x647a78fc, 0x99865d44, 0x608bd593, 0x6c200e03, 0x39dc5ff6, 0x5d0b00a3, 0xae63aff2, 0x7e8bd632, 0x70108c0c, 0xbbd35049, 0x2998df04, 0x980cf42a, 0x9b6df491, 0x9e7edd53, 0x06918548, 0x58cb7e07, 0x3b74ef2e, 0x522fffb1, 0xd24708cc, 0x1c7e27cd, 0xa4eb215b, 0x3cf1d2e2, 0x19b47a38, 0x424f7618, 0x35856039, 0x9d17dee7, 0x27eb35e6, 0xc9aff67b, 0x36baf5b8, 0x09c467cd, 0xc18910b1, 0xe11dbf7b, 0x06cd1af8, 0x7170c608, 0x2d5e3354, 0xd4de495a, 0x64c6d006, 0xbcc0c62c, 0x3dd00db3, 0x708f8f34, 0x77d51b42, 0x264f620f, 0x24b8d2bf, 0x15c1b79e, 0x46a52564, 0xf8d7e54e, 0x3e378160, 0x7895cda5, 0x859c15a5, 0xe6459788, 0xc37bc75f, 0xdb07ba0c, 0x0676a3ab, 0x7f229b1e, 0x31842e7b, 0x24259fd7, 0xf8bef472, 0x835ffcb8, 0x6df4c1f2, 0x96f5b195, 0xfd0af0fc, 0xb0fe134c, 0xe2506d3d, 0x4f9b12ea, 0xf215f225, 0xa223736f, 0x9fb4c428, 0x25d04979, 0x34c713f8, 0xc4618187, 0xea7a6e98, 0x7cd16efc, 0x1436876c, 0xf1544107, 0xbedeee14, 0x56e9af27, 0xa04aa441, 0x3cf7c899, 0x92ecbae6, 0xdd67016d, 0x151682eb, 0xa842eedf, 0xfdba60b4, 0xf1907b75, 0x20e3030f, 0x24d8c29e, 0xe139673b, 0xefa63fb8, 0x71873054, 0xb6f2cf3b, 0x9f326442, 0xcb15a4cc, 0xb01a4504, 0xf1e47d8d, 0x844a1be5, 0xbae7dfdc, 0x42cbda70, 0xcd7dae0a, 0x57e85b7a, 0xd53f5af6, 0x20cf4d8c, 0xcea4d428, 0x79d130a4, 0x3486ebfb, 0x33d3cddc, 0x77853b53, 0x37effcb5, 0xc5068778, 0xe580b3e6, 0x4e68b8f4, 0xc5c8b37e, 0x0d809ea2, 0x398feb7c, 0x132a4f94, 0x43b7950e, 0x2fee7d1c, 0x223613bd, 0xdd06caa2, 0x37df932b, 0xc4248289, 0xacf3ebc3, 0x5715f6b7, 0xef3478dd, 0xf267616f, 0xc148cbe4, 0x9052815e, 0x5e410fab, 0xb48a2465, 0x2eda7fa4, 0xe87b40e4, 0xe98ea084, 0x5889e9e1, 0xefd390fc, 0xdd07d35b, 0xdb485694, 0x38d7e5b2, 0x57720101, 0x730edebc, 0x5b643113, 0x94917e4f, 0x503c2fba, 0x646f1282, 0x7523d24a, 0xe0779695, 0xf9c17a8f, 0x7a5b2121, 0xd187b896, 0x29263a4d, 0xba510cdf, 0x81f47c9f, 0xad1163ed, 0xea7b5965, 0x1a00726e, 0x11403092, 0x00da6d77, 0x4a0cdd61, 0xad1f4603, 0x605bdfb0, 0x9eedc364, 0x22ebe6a8, 0xcee7d28a, 0xa0e736a0, 0x5564a6b9, 0x10853209, 0xc7eb8f37, 0x2de705ca, 0x8951570f, 0xdf09822b, 0xbd691a6c, 0xaa12e4f2, 0x87451c0f, 0xe0f6a27a, 0x3ada4819, 0x4cf1764f, 0x0d771c2b, 0x67cdb156, 0x350d8384, 0x5938fa0f, 0x42399ef3, 0x36997b07, 0x0e84093d, 0x4aa93e61, 0x8360d87b, 0x1fa98b0c, 0x1149382c, 0xe97625a5, 0x0614d1b7, 0x0e25244b, 0x0c768347, 0x589e8d82, 0x0d2059d1, 0xa466bb1e, 0xf8da0a82, 0x04f19130, 0xba6e4ec0, 0x99265164, 0x1ee7230d, 0x50b2ad80, 0xeaee6801, 0x8db2a283, 0xea8bf59e])];
  var schedule = [{
    a: [new Uint8Array([4, 0, 0xd, 0xf, 0xc, 0xe, 0x8]), new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa]), new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]), new Uint8Array([7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb])],
    b: [new Uint8Array([16 + 8, 16 + 9, 16 + 7, 16 + 6, 16 + 2]), new Uint8Array([16 + 0xa, 16 + 0xb, 16 + 5, 16 + 4, 16 + 6]), new Uint8Array([16 + 0xc, 16 + 0xd, 16 + 3, 16 + 2, 16 + 9]), new Uint8Array([16 + 0xe, 16 + 0xf, 16 + 1, 16 + 0, 16 + 0xc])]
  }, {
    a: [new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]), new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]), new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]), new Uint8Array([3, 7, 0xa, 9, 0xb, 8, 16 + 3])],
    b: [new Uint8Array([3, 2, 0xc, 0xd, 8]), new Uint8Array([1, 0, 0xe, 0xf, 0xd]), new Uint8Array([7, 6, 8, 9, 3]), new Uint8Array([5, 4, 0xa, 0xb, 7])]
  }, {
    a: [new Uint8Array([4, 0, 0xd, 0xf, 0xc, 0xe, 8]), new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa]), new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]), new Uint8Array([7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb])],
    b: [new Uint8Array([16 + 3, 16 + 2, 16 + 0xc, 16 + 0xd, 16 + 9]), new Uint8Array([16 + 1, 16 + 0, 16 + 0xe, 16 + 0xf, 16 + 0xc]), new Uint8Array([16 + 7, 16 + 6, 16 + 8, 16 + 9, 16 + 2]), new Uint8Array([16 + 5, 16 + 4, 16 + 0xa, 16 + 0xb, 16 + 6])]
  }, {
    a: [new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]), new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]), new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]), new Uint8Array([3, 7, 0xa, 9, 0xb, 8, 16 + 3])],
    b: [new Uint8Array([8, 9, 7, 6, 3]), new Uint8Array([0xa, 0xb, 5, 4, 7]), new Uint8Array([0xc, 0xd, 3, 2, 8]), new Uint8Array([0xe, 0xf, 1, 0, 0xd])]
  }];
  var X = new Uint8Array([6, 7, 4, 5]);
  /**
   * CAST5
   */

  var CAST5 = /*#__PURE__*/function () {
    function CAST5() {
      _classCallCheck__default['default'](this, CAST5);

      this.masking = new Uint32Array(16);
      this.rotate = new Uint8Array(16);
    }

    _createClass__default['default'](CAST5, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length === 16);
        this.keySchedule(key);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 16; i++) {
          this.masking[i] = 0;
        }

        for (var _i = 0; _i < 16; _i++) {
          this.rotate[_i] = 0;
        }

        return this;
      }
    }, {
      key: "keySchedule",
      value: function keySchedule(input) {
        var t = new Uint32Array(8);
        var k = new Uint32Array(32);

        for (var i = 0; i < 4; i++) {
          t[i] = readU32$9(input, i * 4);
        }

        var ki = 0;
        var w;

        for (var half = 0; half < 2; half++) {
          var _iterator = _createForOfIteratorHelper$3(schedule),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var round = _step.value;

              for (var j = 0; j < 4; j++) {
                var a = round.a[j];
                w = t[a[1]] ^ S[4][t[a[2] >>> 2] >>> 24 - 8 * (a[2] & 3) & 0xff] ^ S[5][t[a[3] >>> 2] >>> 24 - 8 * (a[3] & 3) & 0xff] ^ S[6][t[a[4] >>> 2] >>> 24 - 8 * (a[4] & 3) & 0xff] ^ S[7][t[a[5] >>> 2] >>> 24 - 8 * (a[5] & 3) & 0xff];
                w ^= S[X[j]][t[a[6] >>> 2] >>> 24 - 8 * (a[6] & 3) & 0xff];
                t[a[0]] = w;
              }

              for (var _j = 0; _j < 4; _j++) {
                var b = round.b[_j];
                w = S[4][t[b[0] >>> 2] >>> 24 - 8 * (b[0] & 3) & 0xff] ^ S[5][t[b[1] >>> 2] >>> 24 - 8 * (b[1] & 3) & 0xff] ^ S[6][t[b[2] >>> 2] >>> 24 - 8 * (b[2] & 3) & 0xff] ^ S[7][t[b[3] >>> 2] >>> 24 - 8 * (b[3] & 3) & 0xff];
                w ^= S[4 + _j][t[b[4] >>> 2] >>> 24 - 8 * (b[4] & 3) & 0xff];
                k[ki] = w;
                ki += 1;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        for (var _i2 = 0; _i2 < 16; _i2++) {
          this.masking[_i2] = k[_i2];
          this.rotate[_i2] = k[16 + _i2] & 0x1f;
        }

        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        var l = readU32$9(input, ipos);
        var r = readU32$9(input, ipos + 4);
        var _ref = [r, l ^ f1(r, this.masking[0], this.rotate[0])];
        l = _ref[0];
        r = _ref[1];
        var _ref2 = [r, l ^ f2(r, this.masking[1], this.rotate[1])];
        l = _ref2[0];
        r = _ref2[1];
        var _ref3 = [r, l ^ f3(r, this.masking[2], this.rotate[2])];
        l = _ref3[0];
        r = _ref3[1];
        var _ref4 = [r, l ^ f1(r, this.masking[3], this.rotate[3])];
        l = _ref4[0];
        r = _ref4[1];
        var _ref5 = [r, l ^ f2(r, this.masking[4], this.rotate[4])];
        l = _ref5[0];
        r = _ref5[1];
        var _ref6 = [r, l ^ f3(r, this.masking[5], this.rotate[5])];
        l = _ref6[0];
        r = _ref6[1];
        var _ref7 = [r, l ^ f1(r, this.masking[6], this.rotate[6])];
        l = _ref7[0];
        r = _ref7[1];
        var _ref8 = [r, l ^ f2(r, this.masking[7], this.rotate[7])];
        l = _ref8[0];
        r = _ref8[1];
        var _ref9 = [r, l ^ f3(r, this.masking[8], this.rotate[8])];
        l = _ref9[0];
        r = _ref9[1];
        var _ref10 = [r, l ^ f1(r, this.masking[9], this.rotate[9])];
        l = _ref10[0];
        r = _ref10[1];
        var _ref11 = [r, l ^ f2(r, this.masking[10], this.rotate[10])];
        l = _ref11[0];
        r = _ref11[1];
        var _ref12 = [r, l ^ f3(r, this.masking[11], this.rotate[11])];
        l = _ref12[0];
        r = _ref12[1];
        var _ref13 = [r, l ^ f1(r, this.masking[12], this.rotate[12])];
        l = _ref13[0];
        r = _ref13[1];
        var _ref14 = [r, l ^ f2(r, this.masking[13], this.rotate[13])];
        l = _ref14[0];
        r = _ref14[1];
        var _ref15 = [r, l ^ f3(r, this.masking[14], this.rotate[14])];
        l = _ref15[0];
        r = _ref15[1];
        var _ref16 = [r, l ^ f1(r, this.masking[15], this.rotate[15])];
        l = _ref16[0];
        r = _ref16[1];
        writeU32$8(output, r, opos);
        writeU32$8(output, l, opos + 4);
        return this;
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        var l = readU32$9(input, ipos);
        var r = readU32$9(input, ipos + 4);
        var _ref17 = [r, l ^ f1(r, this.masking[15], this.rotate[15])];
        l = _ref17[0];
        r = _ref17[1];
        var _ref18 = [r, l ^ f3(r, this.masking[14], this.rotate[14])];
        l = _ref18[0];
        r = _ref18[1];
        var _ref19 = [r, l ^ f2(r, this.masking[13], this.rotate[13])];
        l = _ref19[0];
        r = _ref19[1];
        var _ref20 = [r, l ^ f1(r, this.masking[12], this.rotate[12])];
        l = _ref20[0];
        r = _ref20[1];
        var _ref21 = [r, l ^ f3(r, this.masking[11], this.rotate[11])];
        l = _ref21[0];
        r = _ref21[1];
        var _ref22 = [r, l ^ f2(r, this.masking[10], this.rotate[10])];
        l = _ref22[0];
        r = _ref22[1];
        var _ref23 = [r, l ^ f1(r, this.masking[9], this.rotate[9])];
        l = _ref23[0];
        r = _ref23[1];
        var _ref24 = [r, l ^ f3(r, this.masking[8], this.rotate[8])];
        l = _ref24[0];
        r = _ref24[1];
        var _ref25 = [r, l ^ f2(r, this.masking[7], this.rotate[7])];
        l = _ref25[0];
        r = _ref25[1];
        var _ref26 = [r, l ^ f1(r, this.masking[6], this.rotate[6])];
        l = _ref26[0];
        r = _ref26[1];
        var _ref27 = [r, l ^ f3(r, this.masking[5], this.rotate[5])];
        l = _ref27[0];
        r = _ref27[1];
        var _ref28 = [r, l ^ f2(r, this.masking[4], this.rotate[4])];
        l = _ref28[0];
        r = _ref28[1];
        var _ref29 = [r, l ^ f1(r, this.masking[3], this.rotate[3])];
        l = _ref29[0];
        r = _ref29[1];
        var _ref30 = [r, l ^ f3(r, this.masking[2], this.rotate[2])];
        l = _ref30[0];
        r = _ref30[1];
        var _ref31 = [r, l ^ f2(r, this.masking[1], this.rotate[1])];
        l = _ref31[0];
        r = _ref31[1];
        var _ref32 = [r, l ^ f1(r, this.masking[0], this.rotate[0])];
        l = _ref32[0];
        r = _ref32[1];
        writeU32$8(output, r, opos);
        writeU32$8(output, l, opos + 4);
        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 8;
      }
    }]);

    return CAST5;
  }();
  /*
   * Helpers
   */


  function f1(d, m, r) {
    var t = m + d;
    var I = t << r | t >>> 32 - r;
    return (S[0][I >>> 24 & 0xff] ^ S[1][I >>> 16 & 0xff]) - S[2][I >>> 8 & 0xff] + S[3][I >>> 0 & 0xff];
  }

  function f2(d, m, r) {
    var t = m ^ d;
    var I = t << r | t >>> 32 - r;
    return S[0][I >>> 24 & 0xff] - S[1][I >>> 16 & 0xff] + S[2][I >>> 8 & 0xff] ^ S[3][I >>> 0 & 0xff];
  }

  function f3(d, m, r) {
    var t = m - d;
    var I = t << r | t >>> 32 - r;
    return (S[0][I >>> 24 & 0xff] + S[1][I >>> 16 & 0xff] ^ S[2][I >>> 8 & 0xff]) - S[3][I >>> 0 & 0xff];
  }

  function readU32$9(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function writeU32$8(dst, num, off) {
    dst[off++] = num >>> 24;
    dst[off++] = num >>> 16;
    dst[off++] = num >>> 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var cast5 = CAST5;

  /*
   * Constants
   */


  var PC2 = new Uint8Array([// inL => outL
  0x0e, 0x0b, 0x11, 0x04, 0x1b, 0x17, 0x19, 0x00, 0x0d, 0x16, 0x07, 0x12, 0x05, 0x09, 0x10, 0x18, 0x02, 0x14, 0x0c, 0x15, 0x01, 0x08, 0x0f, 0x1a, // inR => outR
  0x0f, 0x04, 0x19, 0x13, 0x09, 0x01, 0x1a, 0x10, 0x05, 0x0b, 0x17, 0x08, 0x0c, 0x07, 0x11, 0x00, 0x16, 0x03, 0x0a, 0x0e, 0x06, 0x14, 0x1b, 0x18]);
  var S$1 = new Uint8Array([0x0e, 0x00, 0x04, 0x0f, 0x0d, 0x07, 0x01, 0x04, 0x02, 0x0e, 0x0f, 0x02, 0x0b, 0x0d, 0x08, 0x01, 0x03, 0x0a, 0x0a, 0x06, 0x06, 0x0c, 0x0c, 0x0b, 0x05, 0x09, 0x09, 0x05, 0x00, 0x03, 0x07, 0x08, 0x04, 0x0f, 0x01, 0x0c, 0x0e, 0x08, 0x08, 0x02, 0x0d, 0x04, 0x06, 0x09, 0x02, 0x01, 0x0b, 0x07, 0x0f, 0x05, 0x0c, 0x0b, 0x09, 0x03, 0x07, 0x0e, 0x03, 0x0a, 0x0a, 0x00, 0x05, 0x06, 0x00, 0x0d, 0x0f, 0x03, 0x01, 0x0d, 0x08, 0x04, 0x0e, 0x07, 0x06, 0x0f, 0x0b, 0x02, 0x03, 0x08, 0x04, 0x0e, 0x09, 0x0c, 0x07, 0x00, 0x02, 0x01, 0x0d, 0x0a, 0x0c, 0x06, 0x00, 0x09, 0x05, 0x0b, 0x0a, 0x05, 0x00, 0x0d, 0x0e, 0x08, 0x07, 0x0a, 0x0b, 0x01, 0x0a, 0x03, 0x04, 0x0f, 0x0d, 0x04, 0x01, 0x02, 0x05, 0x0b, 0x08, 0x06, 0x0c, 0x07, 0x06, 0x0c, 0x09, 0x00, 0x03, 0x05, 0x02, 0x0e, 0x0f, 0x09, 0x0a, 0x0d, 0x00, 0x07, 0x09, 0x00, 0x0e, 0x09, 0x06, 0x03, 0x03, 0x04, 0x0f, 0x06, 0x05, 0x0a, 0x01, 0x02, 0x0d, 0x08, 0x0c, 0x05, 0x07, 0x0e, 0x0b, 0x0c, 0x04, 0x0b, 0x02, 0x0f, 0x08, 0x01, 0x0d, 0x01, 0x06, 0x0a, 0x04, 0x0d, 0x09, 0x00, 0x08, 0x06, 0x0f, 0x09, 0x03, 0x08, 0x00, 0x07, 0x0b, 0x04, 0x01, 0x0f, 0x02, 0x0e, 0x0c, 0x03, 0x05, 0x0b, 0x0a, 0x05, 0x0e, 0x02, 0x07, 0x0c, 0x07, 0x0d, 0x0d, 0x08, 0x0e, 0x0b, 0x03, 0x05, 0x00, 0x06, 0x06, 0x0f, 0x09, 0x00, 0x0a, 0x03, 0x01, 0x04, 0x02, 0x07, 0x08, 0x02, 0x05, 0x0c, 0x0b, 0x01, 0x0c, 0x0a, 0x04, 0x0e, 0x0f, 0x09, 0x0a, 0x03, 0x06, 0x0f, 0x09, 0x00, 0x00, 0x06, 0x0c, 0x0a, 0x0b, 0x01, 0x07, 0x0d, 0x0d, 0x08, 0x0f, 0x09, 0x01, 0x04, 0x03, 0x05, 0x0e, 0x0b, 0x05, 0x0c, 0x02, 0x07, 0x08, 0x02, 0x04, 0x0e, 0x02, 0x0e, 0x0c, 0x0b, 0x04, 0x02, 0x01, 0x0c, 0x07, 0x04, 0x0a, 0x07, 0x0b, 0x0d, 0x06, 0x01, 0x08, 0x05, 0x05, 0x00, 0x03, 0x0f, 0x0f, 0x0a, 0x0d, 0x03, 0x00, 0x09, 0x0e, 0x08, 0x09, 0x06, 0x04, 0x0b, 0x02, 0x08, 0x01, 0x0c, 0x0b, 0x07, 0x0a, 0x01, 0x0d, 0x0e, 0x07, 0x02, 0x08, 0x0d, 0x0f, 0x06, 0x09, 0x0f, 0x0c, 0x00, 0x05, 0x09, 0x06, 0x0a, 0x03, 0x04, 0x00, 0x05, 0x0e, 0x03, 0x0c, 0x0a, 0x01, 0x0f, 0x0a, 0x04, 0x0f, 0x02, 0x09, 0x07, 0x02, 0x0c, 0x06, 0x09, 0x08, 0x05, 0x00, 0x06, 0x0d, 0x01, 0x03, 0x0d, 0x04, 0x0e, 0x0e, 0x00, 0x07, 0x0b, 0x05, 0x03, 0x0b, 0x08, 0x09, 0x04, 0x0e, 0x03, 0x0f, 0x02, 0x05, 0x0c, 0x02, 0x09, 0x08, 0x05, 0x0c, 0x0f, 0x03, 0x0a, 0x07, 0x0b, 0x00, 0x0e, 0x04, 0x01, 0x0a, 0x07, 0x01, 0x06, 0x0d, 0x00, 0x0b, 0x08, 0x06, 0x0d, 0x04, 0x0d, 0x0b, 0x00, 0x02, 0x0b, 0x0e, 0x07, 0x0f, 0x04, 0x00, 0x09, 0x08, 0x01, 0x0d, 0x0a, 0x03, 0x0e, 0x0c, 0x03, 0x09, 0x05, 0x07, 0x0c, 0x05, 0x02, 0x0a, 0x0f, 0x06, 0x08, 0x01, 0x06, 0x01, 0x06, 0x04, 0x0b, 0x0b, 0x0d, 0x0d, 0x08, 0x0c, 0x01, 0x03, 0x04, 0x07, 0x0a, 0x0e, 0x07, 0x0a, 0x09, 0x0f, 0x05, 0x06, 0x00, 0x08, 0x0f, 0x00, 0x0e, 0x05, 0x02, 0x09, 0x03, 0x02, 0x0c, 0x0d, 0x01, 0x02, 0x0f, 0x08, 0x0d, 0x04, 0x08, 0x06, 0x0a, 0x0f, 0x03, 0x0b, 0x07, 0x01, 0x04, 0x0a, 0x0c, 0x09, 0x05, 0x03, 0x06, 0x0e, 0x0b, 0x05, 0x00, 0x00, 0x0e, 0x0c, 0x09, 0x07, 0x02, 0x07, 0x02, 0x0b, 0x01, 0x04, 0x0e, 0x01, 0x07, 0x09, 0x04, 0x0c, 0x0a, 0x0e, 0x08, 0x02, 0x0d, 0x00, 0x0f, 0x06, 0x0c, 0x0a, 0x09, 0x0d, 0x00, 0x0f, 0x03, 0x03, 0x05, 0x05, 0x06, 0x08, 0x0b]);
  var PERMUTE = new Uint8Array([0x10, 0x19, 0x0c, 0x0b, 0x03, 0x14, 0x04, 0x0f, 0x1f, 0x11, 0x09, 0x06, 0x1b, 0x0e, 0x01, 0x16, 0x1e, 0x18, 0x08, 0x12, 0x00, 0x05, 0x1d, 0x17, 0x0d, 0x13, 0x02, 0x1a, 0x0a, 0x15, 0x1c, 0x07]);
  var SHIFT = new Uint8Array([0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01]);
  /**
   * DES
   */

  var DES = /*#__PURE__*/function () {
    function DES() {
      _classCallCheck__default['default'](this, DES);

      this.block = new Uint32Array(2);
      this.keys = new Uint32Array(32);
    }

    _createClass__default['default'](DES, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length === 8);
        return this.derive(key);
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        return this.crypt(output, opos, input, ipos, true);
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        return this.crypt(output, opos, input, ipos, false);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 2; i++) {
          this.block[i] = 0;
        }

        for (var _i = 0; _i < 32; _i++) {
          this.keys[_i] = 0;
        }

        return this;
      }
    }, {
      key: "derive",
      value: function derive(key) {
        var kL = readU32$a(key, 0);
        var kR = readU32$a(key, 4);
        pc1(kL, kR, this.block, 0);
        kL = this.block[0];
        kR = this.block[1];

        for (var i = 0; i < 32; i += 2) {
          var shift = SHIFT[i >>> 1];
          kL = r28shl(kL, shift);
          kR = r28shl(kR, shift);
          pc2(kL, kR, this.keys, i);
        }

        return this;
      }
    }, {
      key: "crypt",
      value: function crypt(output, opos, input, ipos, encrypt) {
        var l = readU32$a(input, ipos);
        var r = readU32$a(input, ipos + 4); // Initial Permutation

        ip(l, r, this.block, 0);
        l = this.block[0];
        r = this.block[1];
        if (encrypt) this.encipher(l, r, this.block, 0);else this.decipher(l, r, this.block, 0);
        l = this.block[0];
        r = this.block[1];
        writeU32$9(output, l, opos);
        writeU32$9(output, r, opos + 4);
        return this;
      }
    }, {
      key: "encipher",
      value: function encipher(lStart, rStart, out, off) {
        var l = lStart;
        var r = rStart; // Apply f() x16 times

        for (var i = 0; i < 32; i += 2) {
          var keyL = this.keys[i];
          var keyR = this.keys[i + 1]; // f(r, k)

          expand(r, this.block, 0);
          keyL ^= this.block[0];
          keyR ^= this.block[1];
          var s = substitute$1(keyL, keyR);
          var f = permute(s);
          var t = r;
          r = (l ^ f) >>> 0;
          l = t;
        } // Reverse Initial Permutation


        rip(r, l, out, off);
        return this;
      }
    }, {
      key: "decipher",
      value: function decipher(lStart, rStart, out, off) {
        var l = rStart;
        var r = lStart; // Apply f() x16 times

        for (var i = 32 - 2; i >= 0; i -= 2) {
          var keyL = this.keys[i];
          var keyR = this.keys[i + 1]; // f(r, k)

          expand(l, this.block, 0);
          keyL ^= this.block[0];
          keyR ^= this.block[1];
          var s = substitute$1(keyL, keyR);
          var f = permute(s);
          var t = l;
          l = (r ^ f) >>> 0;
          r = t;
        } // Reverse Initial Permutation


        rip(l, r, out, off);
        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 8;
      }
    }]);

    return DES;
  }();
  /**
   * EDE
   */


  var EDE = /*#__PURE__*/function () {
    function EDE() {
      _classCallCheck__default['default'](this, EDE);

      this.x = new DES();
      this.y = new DES();
    }

    _createClass__default['default'](EDE, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length === 16);
        var k1 = key.slice(0, 8);
        var k2 = key.slice(8, 16);
        this.x.init(k1);
        this.y.init(k2);
        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        this.x.encrypt(output, opos, input, ipos);
        this.y.decrypt(output, opos, output, opos);
        this.x.encrypt(output, opos, output, opos);
        return this;
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        this.x.decrypt(output, opos, input, ipos);
        this.y.encrypt(output, opos, output, opos);
        this.x.decrypt(output, opos, output, opos);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.x.destroy();
        this.y.destroy();
        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 8;
      }
    }]);

    return EDE;
  }();
  /**
   * EDE3
   */


  var EDE3 = /*#__PURE__*/function () {
    function EDE3() {
      _classCallCheck__default['default'](this, EDE3);

      this.x = new DES();
      this.y = new DES();
      this.z = new DES();
    }

    _createClass__default['default'](EDE3, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length === 24);
        var k1 = key.slice(0, 8);
        var k2 = key.slice(8, 16);
        var k3 = key.slice(16, 24);
        this.x.init(k1);
        this.y.init(k2);
        this.z.init(k3);
        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        this.x.encrypt(output, opos, input, ipos);
        this.y.decrypt(output, opos, output, opos);
        this.z.encrypt(output, opos, output, opos);
        return this;
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        this.z.decrypt(output, opos, input, ipos);
        this.y.encrypt(output, opos, output, opos);
        this.x.decrypt(output, opos, output, opos);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.x.destroy();
        this.y.destroy();
        this.z.destroy();
        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 8;
      }
    }]);

    return EDE3;
  }();
  /*
   * Helpers
   */


  function ip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    for (var i = 6; i >= 0; i -= 2) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >>> j + i & 1;
      }

      for (var _j = 0; _j <= 24; _j += 8) {
        outL <<= 1;
        outL |= inL >>> _j + i & 1;
      }
    }

    for (var _i2 = 6; _i2 >= 0; _i2 -= 2) {
      for (var _j2 = 1; _j2 <= 25; _j2 += 8) {
        outR <<= 1;
        outR |= inR >>> _j2 + _i2 & 1;
      }

      for (var _j3 = 1; _j3 <= 25; _j3 += 8) {
        outR <<= 1;
        outR |= inL >>> _j3 + _i2 & 1;
      }
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  }

  function rip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    for (var i = 0; i < 4; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        outL <<= 1;
        outL |= inR >>> j + i & 1;
        outL <<= 1;
        outL |= inL >>> j + i & 1;
      }
    }

    for (var _i3 = 4; _i3 < 8; _i3++) {
      for (var _j4 = 24; _j4 >= 0; _j4 -= 8) {
        outR <<= 1;
        outR |= inR >>> _j4 + _i3 & 1;
        outR <<= 1;
        outR |= inL >>> _j4 + _i3 & 1;
      }
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  }

  function pc1(inL, inR, out, off) {
    var outL = 0;
    var outR = 0; // 7, 15, 23, 31, 39, 47, 55, 63
    // 6, 14, 22, 30, 39, 47, 55, 63
    // 5, 13, 21, 29, 39, 47, 55, 63
    // 4, 12, 20, 28

    for (var i = 7; i >= 5; i--) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i & 1;
      }

      for (var _j5 = 0; _j5 <= 24; _j5 += 8) {
        outL <<= 1;
        outL |= inL >> _j5 + i & 1;
      }
    }

    for (var _j6 = 0; _j6 <= 24; _j6 += 8) {
      outL <<= 1;
      outL |= inR >> _j6 + 4 & 1;
    } // 1, 9, 17, 25, 33, 41, 49, 57
    // 2, 10, 18, 26, 34, 42, 50, 58
    // 3, 11, 19, 27, 35, 43, 51, 59
    // 36, 44, 52, 60


    for (var _i4 = 1; _i4 <= 3; _i4++) {
      for (var _j7 = 0; _j7 <= 24; _j7 += 8) {
        outR <<= 1;
        outR |= inR >> _j7 + _i4 & 1;
      }

      for (var _j8 = 0; _j8 <= 24; _j8 += 8) {
        outR <<= 1;
        outR |= inL >> _j8 + _i4 & 1;
      }
    }

    for (var _j9 = 0; _j9 <= 24; _j9 += 8) {
      outR <<= 1;
      outR |= inL >> _j9 + 4 & 1;
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  }

  function r28shl(x, b) {
    return x << b & 0xfffffff | x >>> 28 - b;
  }

  function pc2(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    var i = 0;

    for (; i < 24; i++) {
      outL <<= 1;
      outL |= inL >>> PC2[i] & 1;
    }

    for (; i < 48; i++) {
      outR <<= 1;
      outR |= inR >>> PC2[i] & 1;
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  }

  function expand(r, out, off) {
    var outL = 0;
    var outR = 0;
    outL = (r & 1) << 5 | r >>> 27;

    for (var i = 23; i >= 15; i -= 4) {
      outL <<= 6;
      outL |= r >>> i & 0x3f;
    }

    for (var _i5 = 11; _i5 >= 3; _i5 -= 4) {
      outR |= r >>> _i5 & 0x3f;
      outR <<= 6;
    }

    outR |= (r & 0x1f) << 1 | r >>> 31;
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  }

  function substitute$1(inL, inR) {
    var s = 0;

    for (var i = 0; i < 4; i++) {
      var b = inL >>> 18 - i * 6 & 0x3f;
      s = s << 4 | S$1[i * 0x40 + b];
    }

    for (var _i6 = 0; _i6 < 4; _i6++) {
      var _b = inR >>> 18 - _i6 * 6 & 0x3f;

      s = s << 4 | S$1[4 * 0x40 + _i6 * 0x40 + _b];
    }

    return s >>> 0;
  }

  function permute(s) {
    var f = 0;

    for (var i = 0; i < 32; i++) {
      f <<= 1;
      f |= s >>> PERMUTE[i] & 1;
    }

    return f >>> 0;
  }

  function readU32$a(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function writeU32$9(dst, num, off) {
    dst[off++] = num >>> 24;
    dst[off++] = num >>> 16;
    dst[off++] = num >>> 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var DES_1 = DES;
  var EDE_1 = EDE;
  var EDE3_1 = EDE3;
  var des = {
    DES: DES_1,
    EDE: EDE_1,
    EDE3: EDE3_1
  };

  /*
   * Constants
   */


  var ZERO16$1 = Buffer.alloc(16, 0x00);
  /**
   * IDEA
   */

  var IDEA = /*#__PURE__*/function () {
    function IDEA() {
      _classCallCheck__default['default'](this, IDEA);

      this.key = ZERO16$1;
      this.encryptKey = null;
      this.decryptKey = null;
    }

    _createClass__default['default'](IDEA, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length === 16);
        this.destroy();
        this.key = Buffer.from(key);
        return this;
      }
    }, {
      key: "getEncryptKey",
      value: function getEncryptKey() {
        if (!this.encryptKey) this.encryptKey = this.expandKey(this.key);
        return this.encryptKey;
      }
    }, {
      key: "getDecryptKey",
      value: function getDecryptKey() {
        if (!this.decryptKey) this.decryptKey = this.invertKey(this.getEncryptKey());
        return this.decryptKey;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        var key = this.getEncryptKey();
        return this.crypt(output, opos, input, ipos, key);
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        var key = this.getDecryptKey();
        return this.crypt(output, opos, input, ipos, key);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 16; i++) {
          this.key[i] = 0;
        }

        if (this.encryptKey) {
          for (var _i = 0; _i < 52; _i++) {
            this.encryptKey[_i] = 0;
          }
        }

        if (this.decryptKey) {
          for (var _i2 = 0; _i2 < 52; _i2++) {
            this.decryptKey[_i2] = 0;
          }
        }

        this.key = ZERO16$1;
        this.encryptKey = null;
        this.decryptKey = null;
        return this;
      }
    }, {
      key: "expandKey",
      value: function expandKey(key) {
        var K = new Uint16Array(52);
        var p = 0;
        var j = 0;
        var i = 0;

        for (; j < 8; j++) {
          K[j] = readU16$2(key, j * 2);
        }

        for (; j < 52; j++) {
          i += 1;
          K[p + (i + 7)] = K[p + (i + 0 & 7)] << 9 | K[p + (i + 1 & 7)] >>> 7;
          p += i & 8;
          i &= 7;
        }

        return K;
      }
    }, {
      key: "invertKey",
      value: function invertKey(K) {
        var D = new Uint16Array(52);
        var t1, t2, t3;
        var di = 52 - 1;
        var ki = 0;
        t1 = invm(K[ki++]);
        t2 = -K[ki++];
        t3 = -K[ki++];
        D[di--] = invm(K[ki++]);
        D[di--] = t3;
        D[di--] = t2;
        D[di--] = t1;

        for (var i = 0; i < 8 - 1; i++) {
          t1 = K[ki++];
          D[di--] = K[ki++];
          D[di--] = t1;
          t1 = invm(K[ki++]);
          t2 = -K[ki++];
          t3 = -K[ki++];
          D[di--] = invm(K[ki++]);
          D[di--] = t2;
          D[di--] = t3;
          D[di--] = t1;
        }

        t1 = K[ki++];
        D[di--] = K[ki++];
        D[di--] = t1;
        t1 = invm(K[ki++]);
        t2 = -K[ki++];
        t3 = -K[ki++];
        D[di--] = invm(K[ki++]);
        D[di--] = t3;
        D[di--] = t2;
        D[di--] = t1;
        return D;
      }
    }, {
      key: "crypt",
      value: function crypt(output, opos, input, ipos, key) {
        var x1 = readU16$2(input, ipos + 0);
        var x2 = readU16$2(input, ipos + 2);
        var x3 = readU16$2(input, ipos + 4);
        var x4 = readU16$2(input, ipos + 6);
        var s2 = 0;
        var s3 = 0;
        var p = 0;

        for (var i = 8 - 1; i >= 0; i--) {
          x1 = mul(x1, key[p++]);
          x2 += key[p++];
          x3 += key[p++];
          x4 = mul(x4, key[p++]);
          s3 = x3;
          x3 ^= x1;
          x3 = mul(x3, key[p++]);
          s2 = x2;
          x2 ^= x4;
          x2 += x3;
          x2 = mul(x2, key[p++]);
          x3 += x2;
          x1 ^= x2;
          x4 ^= x3;
          x2 ^= s3;
          x3 ^= s2;
        }

        x1 = mul(x1, key[p++]);
        x3 += key[p++];
        x2 += key[p++];
        x4 = mul(x4, key[p++]);
        writeU16$2(output, x1, opos + 0);
        writeU16$2(output, x3, opos + 2);
        writeU16$2(output, x2, opos + 4);
        writeU16$2(output, x4, opos + 6);
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 8;
      }
    }]);

    return IDEA;
  }();
  /*
   * Helpers
   */


  function invm(x) {
    x &= 0xffff;
    if (x <= 1) return x;
    var t1 = 0x10001 / x & 0xffff;
    var y = 0x10001 % x;
    if (y === 1) return 1 - t1 & 0xffff;
    var t0 = 1;
    var q = 0;

    while (y !== 1) {
      q = x / y & 0xffff;
      x %= y;
      t0 += q * t1;
      t0 &= 0xffff;
      if (x === 1) return t0;
      q = y / x & 0xffff;
      y %= x;
      t1 += q * t0;
      t1 &= 0xffff;
    }

    return 1 - t1 & 0xffff;
  }

  function mul(x, y) {
    x &= 0xffff;
    y &= 0xffff;
    if (y === 0) return 1 - x & 0xffff;
    if (x === 0) return 1 - y & 0xffff;
    var t32 = x * y >>> 0;
    x = t32 & 0xffff;
    y = t32 >>> 16;
    if (x < y) return x - y + 1 & 0xffff;
    return x - y & 0xffff;
  }

  function readU16$2(data, pos) {
    return data[pos++] * 0x100 + data[pos];
  }

  function writeU16$2(data, value, pos) {
    data[pos++] = value >>> 8;
    data[pos++] = value;
    return pos;
  }
  /*
   * Expose
   */


  var idea = IDEA;

  /*
   * Constants
   */


  var PHI = 0x9e3779b9;
  /**
   * Serpent
   */

  var Serpent = /*#__PURE__*/function () {
    function Serpent(bits) {
      _classCallCheck__default['default'](this, Serpent);

      assert_1$1(bits >>> 0 === bits);
      assert_1$1(bits === 128 || bits === 192 || bits === 256);
      this.bits = bits;
      this.subkeys = new Uint32Array(132);
      this.block = new Uint32Array(4);
    }

    _createClass__default['default'](Serpent, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(key.length * 8 === this.bits);
        this.keySchedule(key);
        return this;
      }
    }, {
      key: "keySchedule",
      value: function keySchedule(key) {
        var s = this.subkeys;
        var k = new Uint32Array(16);
        var j = 0;

        for (var i = 0; i < key.length; i += 4) {
          k[j++] = readU32$b(key, i);
        }

        if (j < 8) k[j++] = 1;

        while (j < 16) {
          k[j++] = 0;
        }

        for (var _i = 8; _i < 16; _i++) {
          var x = k[_i - 8] ^ k[_i - 5] ^ k[_i - 3] ^ k[_i - 1] ^ PHI ^ _i - 8;
          k[_i] = x << 11 | x >>> 21;
          s[_i - 8] = k[_i];
        }

        for (var _i2 = 8; _i2 < 132; _i2++) {
          var _x = s[_i2 - 8] ^ s[_i2 - 5] ^ s[_i2 - 3] ^ s[_i2 - 1] ^ PHI ^ _i2;

          s[_i2] = _x << 11 | _x >>> 21;
        }

        sb3(s, 0, 1, 2, 3);
        sb2(s, 4, 5, 6, 7);
        sb1(s, 8, 9, 10, 11);
        sb0(s, 12, 13, 14, 15);
        sb7(s, 16, 17, 18, 19);
        sb6(s, 20, 21, 22, 23);
        sb5(s, 24, 25, 26, 27);
        sb4(s, 28, 29, 30, 31);
        sb3(s, 32, 33, 34, 35);
        sb2(s, 36, 37, 38, 39);
        sb1(s, 40, 41, 42, 43);
        sb0(s, 44, 45, 46, 47);
        sb7(s, 48, 49, 50, 51);
        sb6(s, 52, 53, 54, 55);
        sb5(s, 56, 57, 58, 59);
        sb4(s, 60, 61, 62, 63);
        sb3(s, 64, 65, 66, 67);
        sb2(s, 68, 69, 70, 71);
        sb1(s, 72, 73, 74, 75);
        sb0(s, 76, 77, 78, 79);
        sb7(s, 80, 81, 82, 83);
        sb6(s, 84, 85, 86, 87);
        sb5(s, 88, 89, 90, 91);
        sb4(s, 92, 93, 94, 95);
        sb3(s, 96, 97, 98, 99);
        sb2(s, 100, 101, 102, 103);
        sb1(s, 104, 105, 106, 107);
        sb0(s, 108, 109, 110, 111);
        sb7(s, 112, 113, 114, 115);
        sb6(s, 116, 117, 118, 119);
        sb5(s, 120, 121, 122, 123);
        sb4(s, 124, 125, 126, 127);
        sb3(s, 128, 129, 130, 131);
        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        var sk = this.subkeys;
        var r = this.block;
        r[0] = readU32$b(input, ipos + 0);
        r[1] = readU32$b(input, ipos + 4);
        r[2] = readU32$b(input, ipos + 8);
        r[3] = readU32$b(input, ipos + 12);
        xor4$1(r, sk, 0, 1, 2, 3);
        sb0(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 4, 5, 6, 7);
        sb1(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 8, 9, 10, 11);
        sb2(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 12, 13, 14, 15);
        sb3(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 16, 17, 18, 19);
        sb4(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 20, 21, 22, 23);
        sb5(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 24, 25, 26, 27);
        sb6(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 28, 29, 30, 31);
        sb7(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 32, 33, 34, 35);
        sb0(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 36, 37, 38, 39);
        sb1(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 40, 41, 42, 43);
        sb2(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 44, 45, 46, 47);
        sb3(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 48, 49, 50, 51);
        sb4(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 52, 53, 54, 55);
        sb5(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 56, 57, 58, 59);
        sb6(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 60, 61, 62, 63);
        sb7(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 64, 65, 66, 67);
        sb0(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 68, 69, 70, 71);
        sb1(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 72, 73, 74, 75);
        sb2(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 76, 77, 78, 79);
        sb3(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 80, 81, 82, 83);
        sb4(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 84, 85, 86, 87);
        sb5(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 88, 89, 90, 91);
        sb6(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 92, 93, 94, 95);
        sb7(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 96, 97, 98, 99);
        sb0(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 100, 101, 102, 103);
        sb1(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 104, 105, 106, 107);
        sb2(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 108, 109, 110, 111);
        sb3(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 112, 113, 114, 115);
        sb4(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 116, 117, 118, 119);
        sb5(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 120, 121, 122, 123);
        sb6(r, 0, 1, 2, 3);
        linear(r, 0, 1, 2, 3);
        xor4$1(r, sk, 124, 125, 126, 127);
        sb7(r, 0, 1, 2, 3);
        r[0] ^= sk[128];
        r[1] ^= sk[129];
        r[2] ^= sk[130];
        r[3] ^= sk[131];
        writeU32$a(output, r[0], opos + 0);
        writeU32$a(output, r[1], opos + 4);
        writeU32$a(output, r[2], opos + 8);
        writeU32$a(output, r[3], opos + 12);
        return this;
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        var sk = this.subkeys;
        var r = this.block;
        r[0] = readU32$b(input, ipos + 0);
        r[1] = readU32$b(input, ipos + 4);
        r[2] = readU32$b(input, ipos + 8);
        r[3] = readU32$b(input, ipos + 12);
        r[0] ^= sk[128];
        r[1] ^= sk[129];
        r[2] ^= sk[130];
        r[3] ^= sk[131];
        sb7inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 124, 125, 126, 127);
        linearinv(r, 0, 1, 2, 3);
        sb6inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 120, 121, 122, 123);
        linearinv(r, 0, 1, 2, 3);
        sb5inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 116, 117, 118, 119);
        linearinv(r, 0, 1, 2, 3);
        sb4inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 112, 113, 114, 115);
        linearinv(r, 0, 1, 2, 3);
        sb3inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 108, 109, 110, 111);
        linearinv(r, 0, 1, 2, 3);
        sb2inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 104, 105, 106, 107);
        linearinv(r, 0, 1, 2, 3);
        sb1inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 100, 101, 102, 103);
        linearinv(r, 0, 1, 2, 3);
        sb0inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 96, 97, 98, 99);
        linearinv(r, 0, 1, 2, 3);
        sb7inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 92, 93, 94, 95);
        linearinv(r, 0, 1, 2, 3);
        sb6inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 88, 89, 90, 91);
        linearinv(r, 0, 1, 2, 3);
        sb5inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 84, 85, 86, 87);
        linearinv(r, 0, 1, 2, 3);
        sb4inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 80, 81, 82, 83);
        linearinv(r, 0, 1, 2, 3);
        sb3inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 76, 77, 78, 79);
        linearinv(r, 0, 1, 2, 3);
        sb2inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 72, 73, 74, 75);
        linearinv(r, 0, 1, 2, 3);
        sb1inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 68, 69, 70, 71);
        linearinv(r, 0, 1, 2, 3);
        sb0inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 64, 65, 66, 67);
        linearinv(r, 0, 1, 2, 3);
        sb7inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 60, 61, 62, 63);
        linearinv(r, 0, 1, 2, 3);
        sb6inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 56, 57, 58, 59);
        linearinv(r, 0, 1, 2, 3);
        sb5inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 52, 53, 54, 55);
        linearinv(r, 0, 1, 2, 3);
        sb4inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 48, 49, 50, 51);
        linearinv(r, 0, 1, 2, 3);
        sb3inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 44, 45, 46, 47);
        linearinv(r, 0, 1, 2, 3);
        sb2inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 40, 41, 42, 43);
        linearinv(r, 0, 1, 2, 3);
        sb1inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 36, 37, 38, 39);
        linearinv(r, 0, 1, 2, 3);
        sb0inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 32, 33, 34, 35);
        linearinv(r, 0, 1, 2, 3);
        sb7inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 28, 29, 30, 31);
        linearinv(r, 0, 1, 2, 3);
        sb6inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 24, 25, 26, 27);
        linearinv(r, 0, 1, 2, 3);
        sb5inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 20, 21, 22, 23);
        linearinv(r, 0, 1, 2, 3);
        sb4inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 16, 17, 18, 19);
        linearinv(r, 0, 1, 2, 3);
        sb3inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 12, 13, 14, 15);
        linearinv(r, 0, 1, 2, 3);
        sb2inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 8, 9, 10, 11);
        linearinv(r, 0, 1, 2, 3);
        sb1inv(r, 0, 1, 2, 3);
        xor4$1(r, sk, 4, 5, 6, 7);
        linearinv(r, 0, 1, 2, 3);
        sb0inv(r, 0, 1, 2, 3);
        r[0] ^= sk[0];
        r[1] ^= sk[1];
        r[2] ^= sk[2];
        r[3] ^= sk[3];
        writeU32$a(output, r[0], opos + 0);
        writeU32$a(output, r[1], opos + 4);
        writeU32$a(output, r[2], opos + 8);
        writeU32$a(output, r[3], opos + 12);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        for (var i = 0; i < 132; i++) {
          this.subkeys[i] = 0;
        }

        for (var _i3 = 0; _i3 < 4; _i3++) {
          this.block[_i3] = 0;
        }

        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return 16;
      }
    }]);

    return Serpent;
  }();
  /*
   * Helpers
   */


  function xor4$1(r, s, s1, s2, s3, s4) {
    r[0] ^= s[s1];
    r[1] ^= s[s2];
    r[2] ^= s[s3];
    r[3] ^= s[s4];
  }

  function linear(v, v0, v1, v2, v3) {
    var t0 = v[v0] << 13 | v[v0] >>> 32 - 13;
    var t2 = v[v2] << 3 | v[v2] >>> 32 - 3;
    var t1 = v[v1] ^ t0 ^ t2;
    var t3 = v[v3] ^ t2 ^ t0 << 3;
    v[v1] = t1 << 1 | t1 >>> 32 - 1;
    v[v3] = t3 << 7 | t3 >>> 32 - 7;
    t0 ^= v[v1] ^ v[v3];
    t2 ^= v[v3] ^ v[v1] << 7;
    v[v0] = t0 << 5 | t0 >>> 32 - 5;
    v[v2] = t2 << 22 | t2 >>> 32 - 22;
  }

  function linearinv(v, v0, v1, v2, v3) {
    var t2 = v[v2] >>> 22 | v[v2] << 32 - 22;
    var t0 = v[v0] >>> 5 | v[v0] << 32 - 5;
    t2 ^= v[v3] ^ v[v1] << 7;
    t0 ^= v[v1] ^ v[v3];
    var t3 = v[v3] >>> 7 | v[v3] << 32 - 7;
    var t1 = v[v1] >>> 1 | v[v1] << 32 - 1;
    v[v3] = t3 ^ t2 ^ t0 << 3;
    v[v1] = t1 ^ t0 ^ t2;
    v[v2] = t2 >>> 3 | t2 << 32 - 3;
    v[v0] = t0 >>> 13 | t0 << 32 - 13;
  }

  function sb0(r, r0, r1, r2, r3) {
    var t0 = r[r0] ^ r[r3];
    var t1 = r[r2] ^ t0;
    var t2 = r[r1] ^ t1;
    r[r3] = r[r0] & r[r3] ^ t2;
    var t3 = r[r0] ^ r[r1] & t0;
    r[r2] = t2 ^ (r[r2] | t3);
    var t4 = r[r3] & (t1 ^ t3);
    r[r1] = ~t1 ^ t4;
    r[r0] = t4 ^ ~t3;
  }

  function sb0inv(r, r0, r1, r2, r3) {
    var t0 = ~r[r0];
    var t1 = r[r0] ^ r[r1];
    var t2 = r[r3] ^ (t0 | t1);
    var t3 = r[r2] ^ t2;
    r[r2] = t1 ^ t3;
    var t4 = t0 ^ r[r3] & t1;
    r[r1] = t2 ^ r[r2] & t4;
    r[r3] = r[r0] & t2 ^ (t3 | r[r1]);
    r[r0] = r[r3] ^ (t3 ^ t4);
  }

  function sb1(r, r0, r1, r2, r3) {
    var t0 = r[r1] ^ ~r[r0];
    var t1 = r[r2] ^ (r[r0] | t0);
    r[r2] = r[r3] ^ t1;
    var t2 = r[r1] ^ (r[r3] | t0);
    var t3 = t0 ^ r[r2];
    r[r3] = t3 ^ t1 & t2;
    var t4 = t1 ^ t2;
    r[r1] = r[r3] ^ t4;
    r[r0] = t1 ^ t3 & t4;
  }

  function sb1inv(r, r0, r1, r2, r3) {
    var t0 = r[r1] ^ r[r3];
    var t1 = r[r0] ^ r[r1] & t0;
    var t2 = t0 ^ t1;
    r[r3] = r[r2] ^ t2;
    var t3 = r[r1] ^ t0 & t1;
    var t4 = r[r3] | t3;
    r[r1] = t1 ^ t4;
    var t5 = ~r[r1];
    var t6 = r[r3] ^ t3;
    r[r0] = t5 ^ t6;
    r[r2] = t2 ^ (t5 | t6);
  }

  function sb2(r, r0, r1, r2, r3) {
    var v0 = r[r0];
    var v3 = r[r3];
    var t0 = ~v0;
    var t1 = r[r1] ^ v3;
    var t2 = r[r2] & t0;
    r[r0] = t1 ^ t2;
    var t3 = r[r2] ^ t0;
    var t4 = r[r2] ^ r[r0];
    var t5 = r[r1] & t4;
    r[r3] = t3 ^ t5;
    r[r2] = v0 ^ (v3 | t5) & (r[r0] | t3);
    r[r1] = t1 ^ r[r3] ^ (r[r2] ^ (v3 | t0));
  }

  function sb2inv(r, r0, r1, r2, r3) {
    var v0 = r[r0];
    var v3 = r[r3];
    var t0 = r[r1] ^ v3;
    var t1 = ~t0;
    var t2 = v0 ^ r[r2];
    var t3 = r[r2] ^ t0;
    var t4 = r[r1] & t3;
    r[r0] = t2 ^ t4;
    var t5 = v0 | t1;
    var t6 = v3 ^ t5;
    var t7 = t2 | t6;
    r[r3] = t0 ^ t7;
    var t8 = ~t3;
    var t9 = r[r0] | r[r3];
    r[r1] = t8 ^ t9;
    r[r2] = v3 & t8 ^ (t2 ^ t9);
  }

  function sb3(r, r0, r1, r2, r3) {
    var v1 = r[r1];
    var v3 = r[r3];
    var t0 = r[r0] ^ r[r1];
    var t1 = r[r0] & r[r2];
    var t2 = r[r0] | r[r3];
    var t3 = r[r2] ^ r[r3];
    var t4 = t0 & t2;
    var t5 = t1 | t4;
    r[r2] = t3 ^ t5;
    var t6 = r[r1] ^ t2;
    var t7 = t5 ^ t6;
    var t8 = t3 & t7;
    r[r0] = t0 ^ t8;
    var t9 = r[r2] & r[r0];
    r[r1] = t7 ^ t9;
    r[r3] = (v1 | v3) ^ (t3 ^ t9);
  }

  function sb3inv(r, r0, r1, r2, r3) {
    var t0 = r[r0] | r[r1];
    var t1 = r[r1] ^ r[r2];
    var t2 = r[r1] & t1;
    var t3 = r[r0] ^ t2;
    var t4 = r[r2] ^ t3;
    var t5 = r[r3] | t3;
    r[r0] = t1 ^ t5;
    var t6 = t1 | t5;
    var t7 = r[r3] ^ t6;
    r[r2] = t4 ^ t7;
    var t8 = t0 ^ t7;
    var t9 = r[r0] & t8;
    r[r3] = t3 ^ t9;
    r[r1] = r[r3] ^ (r[r0] ^ t8);
  }

  function sb4(r, r0, r1, r2, r3) {
    var v0 = r[r0];
    var t0 = v0 ^ r[r3];
    var t1 = r[r3] & t0;
    var t2 = r[r2] ^ t1;
    var t3 = r[r1] | t2;
    r[r3] = t0 ^ t3;
    var t4 = ~r[r1];
    var t5 = t0 | t4;
    r[r0] = t2 ^ t5;
    var t6 = v0 & r[r0];
    var t7 = t0 ^ t4;
    var t8 = t3 & t7;
    r[r2] = t6 ^ t8;
    r[r1] = v0 ^ t2 ^ t7 & r[r2];
  }

  function sb4inv(r, r0, r1, r2, r3) {
    var v3 = r[r3];
    var t0 = r[r2] | v3;
    var t1 = r[r0] & t0;
    var t2 = r[r1] ^ t1;
    var t3 = r[r0] & t2;
    var t4 = r[r2] ^ t3;
    r[r1] = v3 ^ t4;
    var t5 = ~r[r0];
    var t6 = t4 & r[r1];
    r[r3] = t2 ^ t6;
    var t7 = r[r1] | t5;
    var t8 = v3 ^ t7;
    r[r0] = r[r3] ^ t8;
    r[r2] = t2 & t8 ^ (r[r1] ^ t5);
  }

  function sb5(r, r0, r1, r2, r3) {
    var v1 = r[r1];
    var t0 = ~r[r0];
    var t1 = r[r0] ^ v1;
    var t2 = r[r0] ^ r[r3];
    var t3 = r[r2] ^ t0;
    var t4 = t1 | t2;
    r[r0] = t3 ^ t4;
    var t5 = r[r3] & r[r0];
    var t6 = t1 ^ r[r0];
    r[r1] = t5 ^ t6;
    var t7 = t0 | r[r0];
    var t8 = t1 | t5;
    var t9 = t2 ^ t7;
    r[r2] = t8 ^ t9;
    r[r3] = v1 ^ t5 ^ r[r1] & t9;
  }

  function sb5inv(r, r0, r1, r2, r3) {
    var v0 = r[r0];
    var v1 = r[r1];
    var v3 = r[r3];
    var t0 = ~r[r2];
    var t1 = v1 & t0;
    var t2 = v3 ^ t1;
    var t3 = v0 & t2;
    var t4 = v1 ^ t0;
    r[r3] = t3 ^ t4;
    var t5 = v1 | r[r3];
    var t6 = v0 & t5;
    r[r1] = t2 ^ t6;
    var t7 = v0 | v3;
    var t8 = t0 ^ t5;
    r[r0] = t7 ^ t8;
    r[r2] = v1 & t7 ^ (t3 | v0 ^ r[r2]);
  }

  function sb6(r, r0, r1, r2, r3) {
    var t0 = ~r[r0];
    var t1 = r[r0] ^ r[r3];
    var t2 = r[r1] ^ t1;
    var t3 = t0 | t1;
    var t4 = r[r2] ^ t3;
    r[r1] = r[r1] ^ t4;
    var t5 = t1 | r[r1];
    var t6 = r[r3] ^ t5;
    var t7 = t4 & t6;
    r[r2] = t2 ^ t7;
    var t8 = t4 ^ t6;
    r[r0] = r[r2] ^ t8;
    r[r3] = ~t4 ^ t2 & t8;
  }

  function sb6inv(r, r0, r1, r2, r3) {
    var v1 = r[r1];
    var v3 = r[r3];
    var t0 = ~r[r0];
    var t1 = r[r0] ^ v1;
    var t2 = r[r2] ^ t1;
    var t3 = r[r2] | t0;
    var t4 = v3 ^ t3;
    r[r1] = t2 ^ t4;
    var t5 = t2 & t4;
    var t6 = t1 ^ t5;
    var t7 = v1 | t6;
    r[r3] = t4 ^ t7;
    var t8 = v1 | r[r3];
    r[r0] = t6 ^ t8;
    r[r2] = v3 & t0 ^ (t2 ^ t8);
  }

  function sb7(r, r0, r1, r2, r3) {
    var t0 = r[r1] ^ r[r2];
    var t1 = r[r2] & t0;
    var t2 = r[r3] ^ t1;
    var t3 = r[r0] ^ t2;
    var t4 = r[r3] | t0;
    var t5 = t3 & t4;
    r[r1] = r[r1] ^ t5;
    var t6 = t2 | r[r1];
    var t7 = r[r0] & t3;
    r[r3] = t0 ^ t7;
    var t8 = t3 ^ t6;
    var t9 = r[r3] & t8;
    r[r2] = t2 ^ t9;
    r[r0] = ~t8 ^ r[r3] & r[r2];
  }

  function sb7inv(r, r0, r1, r2, r3) {
    var v0 = r[r0];
    var v3 = r[r3];
    var t0 = r[r2] | v0 & r[r1];
    var t1 = v3 & (v0 | r[r1]);
    r[r3] = t0 ^ t1;
    var t2 = ~v3;
    var t3 = r[r1] ^ t1;
    var t4 = t3 | r[r3] ^ t2;
    r[r1] = v0 ^ t4;
    r[r0] = r[r2] ^ t3 ^ (v3 | r[r1]);
    r[r2] = t0 ^ r[r1] ^ (r[r0] ^ v0 & r[r3]);
  }

  function readU32$b(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off++] * 0x1000000;
  }

  function writeU32$a(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var serpent = Serpent;

  /*
   * Constants
   */


  var BLOCK_SIZE = 16;
  var MDS_POLY = 0x169; // x^8 + x^6 + x^5 + x^3 + 1

  var RS_POLY = 0x14d; // x^8 + x^6 + x^3 + x^2 + 1

  var RS = [new Uint8Array([0x01, 0xa4, 0x55, 0x87, 0x5a, 0x58, 0xdb, 0x9e]), new Uint8Array([0xa4, 0x56, 0x82, 0xf3, 0x1e, 0xc6, 0x68, 0xe5]), new Uint8Array([0x02, 0xa1, 0xfc, 0xc1, 0x47, 0xae, 0x3d, 0x19]), new Uint8Array([0xa4, 0x55, 0x87, 0x5a, 0x58, 0xdb, 0x9e, 0x03])];
  var S0$1 = new Uint8Array([0xa9, 0x67, 0xb3, 0xe8, 0x04, 0xfd, 0xa3, 0x76, 0x9a, 0x92, 0x80, 0x78, 0xe4, 0xdd, 0xd1, 0x38, 0x0d, 0xc6, 0x35, 0x98, 0x18, 0xf7, 0xec, 0x6c, 0x43, 0x75, 0x37, 0x26, 0xfa, 0x13, 0x94, 0x48, 0xf2, 0xd0, 0x8b, 0x30, 0x84, 0x54, 0xdf, 0x23, 0x19, 0x5b, 0x3d, 0x59, 0xf3, 0xae, 0xa2, 0x82, 0x63, 0x01, 0x83, 0x2e, 0xd9, 0x51, 0x9b, 0x7c, 0xa6, 0xeb, 0xa5, 0xbe, 0x16, 0x0c, 0xe3, 0x61, 0xc0, 0x8c, 0x3a, 0xf5, 0x73, 0x2c, 0x25, 0x0b, 0xbb, 0x4e, 0x89, 0x6b, 0x53, 0x6a, 0xb4, 0xf1, 0xe1, 0xe6, 0xbd, 0x45, 0xe2, 0xf4, 0xb6, 0x66, 0xcc, 0x95, 0x03, 0x56, 0xd4, 0x1c, 0x1e, 0xd7, 0xfb, 0xc3, 0x8e, 0xb5, 0xe9, 0xcf, 0xbf, 0xba, 0xea, 0x77, 0x39, 0xaf, 0x33, 0xc9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xad, 0x24, 0xcd, 0xf9, 0xd8, 0xe5, 0xc5, 0xb9, 0x4d, 0x44, 0x08, 0x86, 0xe7, 0xa1, 0x1d, 0xaa, 0xed, 0x06, 0x70, 0xb2, 0xd2, 0x41, 0x7b, 0xa0, 0x11, 0x31, 0xc2, 0x27, 0x90, 0x20, 0xf6, 0x60, 0xff, 0x96, 0x5c, 0xb1, 0xab, 0x9e, 0x9c, 0x52, 0x1b, 0x5f, 0x93, 0x0a, 0xef, 0x91, 0x85, 0x49, 0xee, 0x2d, 0x4f, 0x8f, 0x3b, 0x47, 0x87, 0x6d, 0x46, 0xd6, 0x3e, 0x69, 0x64, 0x2a, 0xce, 0xcb, 0x2f, 0xfc, 0x97, 0x05, 0x7a, 0xac, 0x7f, 0xd5, 0x1a, 0x4b, 0x0e, 0xa7, 0x5a, 0x28, 0x14, 0x3f, 0x29, 0x88, 0x3c, 0x4c, 0x02, 0xb8, 0xda, 0xb0, 0x17, 0x55, 0x1f, 0x8a, 0x7d, 0x57, 0xc7, 0x8d, 0x74, 0xb7, 0xc4, 0x9f, 0x72, 0x7e, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6e, 0x50, 0xde, 0x68, 0x65, 0xbc, 0xdb, 0xf8, 0xc8, 0xa8, 0x2b, 0x40, 0xdc, 0xfe, 0x32, 0xa4, 0xca, 0x10, 0x21, 0xf0, 0xd3, 0x5d, 0x0f, 0x00, 0x6f, 0x9d, 0x36, 0x42, 0x4a, 0x5e, 0xc1, 0xe0]);
  var S1$2 = new Uint8Array([0x75, 0xf3, 0xc6, 0xf4, 0xdb, 0x7b, 0xfb, 0xc8, 0x4a, 0xd3, 0xe6, 0x6b, 0x45, 0x7d, 0xe8, 0x4b, 0xd6, 0x32, 0xd8, 0xfd, 0x37, 0x71, 0xf1, 0xe1, 0x30, 0x0f, 0xf8, 0x1b, 0x87, 0xfa, 0x06, 0x3f, 0x5e, 0xba, 0xae, 0x5b, 0x8a, 0x00, 0xbc, 0x9d, 0x6d, 0xc1, 0xb1, 0x0e, 0x80, 0x5d, 0xd2, 0xd5, 0xa0, 0x84, 0x07, 0x14, 0xb5, 0x90, 0x2c, 0xa3, 0xb2, 0x73, 0x4c, 0x54, 0x92, 0x74, 0x36, 0x51, 0x38, 0xb0, 0xbd, 0x5a, 0xfc, 0x60, 0x62, 0x96, 0x6c, 0x42, 0xf7, 0x10, 0x7c, 0x28, 0x27, 0x8c, 0x13, 0x95, 0x9c, 0xc7, 0x24, 0x46, 0x3b, 0x70, 0xca, 0xe3, 0x85, 0xcb, 0x11, 0xd0, 0x93, 0xb8, 0xa6, 0x83, 0x20, 0xff, 0x9f, 0x77, 0xc3, 0xcc, 0x03, 0x6f, 0x08, 0xbf, 0x40, 0xe7, 0x2b, 0xe2, 0x79, 0x0c, 0xaa, 0x82, 0x41, 0x3a, 0xea, 0xb9, 0xe4, 0x9a, 0xa4, 0x97, 0x7e, 0xda, 0x7a, 0x17, 0x66, 0x94, 0xa1, 0x1d, 0x3d, 0xf0, 0xde, 0xb3, 0x0b, 0x72, 0xa7, 0x1c, 0xef, 0xd1, 0x53, 0x3e, 0x8f, 0x33, 0x26, 0x5f, 0xec, 0x76, 0x2a, 0x49, 0x81, 0x88, 0xee, 0x21, 0xc4, 0x1a, 0xeb, 0xd9, 0xc5, 0x39, 0x99, 0xcd, 0xad, 0x31, 0x8b, 0x01, 0x18, 0x23, 0xdd, 0x1f, 0x4e, 0x2d, 0xf9, 0x48, 0x4f, 0xf2, 0x65, 0x8e, 0x78, 0x5c, 0x58, 0x19, 0x8d, 0xe5, 0x98, 0x57, 0x67, 0x7f, 0x05, 0x64, 0xaf, 0x63, 0xb6, 0xfe, 0xf5, 0xb7, 0x3c, 0xa5, 0xce, 0xe9, 0x68, 0x44, 0xe0, 0x4d, 0x43, 0x69, 0x29, 0x2e, 0xac, 0x15, 0x59, 0xa8, 0x0a, 0x9e, 0x6e, 0x47, 0xdf, 0x34, 0x35, 0x6a, 0xcf, 0xdc, 0x22, 0xc9, 0xc0, 0x9b, 0x89, 0xd4, 0xed, 0xab, 0x12, 0xa2, 0x0d, 0x52, 0xbb, 0x02, 0x2f, 0xa9, 0xd7, 0x61, 0x1e, 0xb4, 0x50, 0x04, 0xf6, 0xc2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xbe, 0x91]);
  /**
   * Twofish
   */

  var Twofish = /*#__PURE__*/function () {
    function Twofish() {
      var bits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 256;

      _classCallCheck__default['default'](this, Twofish);

      assert_1$1(bits >>> 0 === bits);
      assert_1$1(bits === 128 || bits === 192 || bits === 256);
      this.bits = bits;
      this.S = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.k = new Uint32Array(40);
    }

    _createClass__default['default'](Twofish, [{
      key: "init",
      value: function init(key) {
        assert_1$1(Buffer.isBuffer(key));
        var keylen = key.length;
        if (keylen !== 16 && keylen !== 24 && keylen !== 32) throw new Error('Invalid key size.');
        if (keylen !== this.bits >>> 3) throw new Error('Invalid key size.'); // k is the number of 64 bit words in key.

        var k = keylen >>> 3; // Create the S[..] words.

        var W = new Uint8Array(4 * 4);

        for (var i = 0; i < k; i++) {
          for (var j = 0; j < 4; j++) {
            for (var _k = 0; _k < 8; _k++) {
              W[4 * i + j] ^= gfMul(key[8 * i + _k], RS[j][_k], RS_POLY);
            }
          }
        } // Calculate subkeys.


        var tmp = new Uint8Array(4);

        for (var _i = 0; _i < 20; _i++) {
          for (var _j = 0; _j < 4; _j++) {
            tmp[_j] = 2 * _i;
          }

          var A = h(tmp, key, 0);

          for (var _j2 = 0; _j2 < 4; _j2++) {
            tmp[_j2] = 2 * _i + 1;
          }

          var B = rol32(h(tmp, key, 1), 8);
          this.k[2 * _i + 0] = A + B;
          this.k[2 * _i + 1] = rol32(2 * B + A, 9);
        } // Calculate sboxes.


        switch (k) {
          case 2:
            for (var _i2 = 0; _i2 < 256; _i2++) {
              this.S[0][_i2] = mdsMul(S1$2[S0$1[S0$1[_i2] ^ W[0]] ^ W[4]], 0);
              this.S[1][_i2] = mdsMul(S0$1[S0$1[S1$2[_i2] ^ W[1]] ^ W[5]], 1);
              this.S[2][_i2] = mdsMul(S1$2[S1$2[S0$1[_i2] ^ W[2]] ^ W[6]], 2);
              this.S[3][_i2] = mdsMul(S0$1[S1$2[S1$2[_i2] ^ W[3]] ^ W[7]], 3);
            }

            break;

          case 3:
            for (var _i3 = 0; _i3 < 256; _i3++) {
              this.S[0][_i3] = mdsMul(S1$2[S0$1[S0$1[S1$2[_i3] ^ W[0]] ^ W[4]] ^ W[8]], 0);
              this.S[1][_i3] = mdsMul(S0$1[S0$1[S1$2[S1$2[_i3] ^ W[1]] ^ W[5]] ^ W[9]], 1);
              this.S[2][_i3] = mdsMul(S1$2[S1$2[S0$1[S0$1[_i3] ^ W[2]] ^ W[6]] ^ W[10]], 2);
              this.S[3][_i3] = mdsMul(S0$1[S1$2[S1$2[S0$1[_i3] ^ W[3]] ^ W[7]] ^ W[11]], 3);
            }

            break;

          case 4:
            for (var _i4 = 0; _i4 < 256; _i4++) {
              this.S[0][_i4] = mdsMul(S1$2[S0$1[S0$1[S1$2[S1$2[_i4] ^ W[0]] ^ W[4]] ^ W[8]] ^ W[12]], 0);
              this.S[1][_i4] = mdsMul(S0$1[S0$1[S1$2[S1$2[S0$1[_i4] ^ W[1]] ^ W[5]] ^ W[9]] ^ W[13]], 1);
              this.S[2][_i4] = mdsMul(S1$2[S1$2[S0$1[S0$1[S0$1[_i4] ^ W[2]] ^ W[6]] ^ W[10]] ^ W[14]], 2);
              this.S[3][_i4] = mdsMul(S0$1[S1$2[S1$2[S0$1[S1$2[_i4] ^ W[3]] ^ W[7]] ^ W[11]] ^ W[15]], 3);
            }

            break;

          default:
            throw new Error('unreachable');
        }

        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos, input, ipos) {
        var k = this.k;
        var S0 = this.S[0];
        var S1 = this.S[1];
        var S2 = this.S[2];
        var S3 = this.S[3]; // Load input.

        var ia = readU32$c(input, ipos + 0);
        var ib = readU32$c(input, ipos + 4);
        var ic = readU32$c(input, ipos + 8);
        var id = readU32$c(input, ipos + 12);
        var t1, t2; // Pre-whitening.

        ia ^= this.k[0];
        ib ^= this.k[1];
        ic ^= this.k[2];
        id ^= this.k[3];

        for (var i = 0; i < 8; i++) {
          var p = 8 + i * 4;
          t2 = S1[ib >>> 0 & 0xff] ^ S2[ib >>> 8 & 0xff] ^ S3[ib >>> 16 & 0xff] ^ S0[ib >>> 24 & 0xff];
          t1 = S0[ia >>> 0 & 0xff] ^ S1[ia >>> 8 & 0xff] ^ S2[ia >>> 16 & 0xff] ^ S3[ia >>> 24 & 0xff];
          t1 += t2;
          ic = ror32(ic ^ t1 + k[p + 0], 1);
          id = rol32(id, 1) ^ t2 + t1 + k[p + 1];
          t2 = S1[id >>> 0 & 0xff] ^ S2[id >>> 8 & 0xff] ^ S3[id >>> 16 & 0xff] ^ S0[id >>> 24 & 0xff];
          t1 = S0[ic >>> 0 & 0xff] ^ S1[ic >>> 8 & 0xff] ^ S2[ic >>> 16 & 0xff] ^ S3[ic >>> 24 & 0xff];
          t1 += t2;
          ia = ror32(ia ^ t1 + k[p + 2], 1);
          ib = rol32(ib, 1) ^ t2 + t1 + k[p + 3];
        } // Output with "undo last swap".


        var ta = ic ^ this.k[4];
        var tb = id ^ this.k[5];
        var tc = ia ^ this.k[6];
        var td = ib ^ this.k[7];
        writeU32$b(output, ta, opos + 0);
        writeU32$b(output, tb, opos + 4);
        writeU32$b(output, tc, opos + 8);
        writeU32$b(output, td, opos + 12);
        return this;
      }
    }, {
      key: "decrypt",
      value: function decrypt(output, opos, input, ipos) {
        var k = this.k;
        var S0 = this.S[0];
        var S1 = this.S[1];
        var S2 = this.S[2];
        var S3 = this.S[3]; // Load input.

        var ta = readU32$c(input, ipos + 0);
        var tb = readU32$c(input, ipos + 4);
        var tc = readU32$c(input, ipos + 8);
        var td = readU32$c(input, ipos + 12); // Undo undo final swap.

        var ia = tc ^ this.k[6];
        var ib = td ^ this.k[7];
        var ic = ta ^ this.k[4];
        var id = tb ^ this.k[5];
        var t1, t2;

        for (var i = 8; i > 0; i--) {
          var p = 4 + i * 4;
          t2 = S1[id >>> 0 & 0xff] ^ S2[id >>> 8 & 0xff] ^ S3[id >>> 16 & 0xff] ^ S0[id >>> 24 & 0xff];
          t1 = S0[ic >>> 0 & 0xff] ^ S1[ic >>> 8 & 0xff] ^ S2[ic >>> 16 & 0xff] ^ S3[ic >>> 24 & 0xff];
          t1 += t2;
          ia = rol32(ia, 1) ^ t1 + k[p + 2];
          ib = ror32(ib ^ t2 + t1 + k[p + 3], 1);
          t2 = S1[ib >>> 0 & 0xff] ^ S2[ib >>> 8 & 0xff] ^ S3[ib >>> 16 & 0xff] ^ S0[ib >>> 24 & 0xff];
          t1 = S0[ia >>> 0 & 0xff] ^ S1[ia >>> 8 & 0xff] ^ S2[ia >>> 16 & 0xff] ^ S3[ia >>> 24 & 0xff];
          t1 += t2;
          ic = rol32(ic, 1) ^ t1 + k[p + 0];
          id = ror32(id ^ t2 + t1 + k[p + 1], 1);
        } // Undo pre-whitening.


        ia ^= this.k[0];
        ib ^= this.k[1];
        ic ^= this.k[2];
        id ^= this.k[3];
        writeU32$b(output, ia, opos + 0);
        writeU32$b(output, ib, opos + 4);
        writeU32$b(output, ic, opos + 8);
        writeU32$b(output, id, opos + 12);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        cleanse$1(this.S[0]);
        cleanse$1(this.S[1]);
        cleanse$1(this.S[2]);
        cleanse$1(this.S[3]);
        cleanse$1(this.k);
        return this;
      }
    }, {
      key: "blockSize",
      get: function get() {
        return BLOCK_SIZE;
      }
    }]);

    return Twofish;
  }();
  /*
   * Helpers
   */


  function gfMul(a, b, p) {
    var B = new Uint32Array([0, b & 0xff]);
    var P = new Uint32Array([0, p >>> 0]);
    var res = 0;

    for (var i = 0; i < 7; i++) {
      res ^= B[a & 1];
      a >>>= 1;
      B[1] = P[B[1] >>> 7] ^ B[1] << 1;
    }

    res ^= B[a & 1];
    return res & 0xff;
  }

  function mdsMul(v, col) {
    var x = v & 0xff;
    var y = gfMul(v, 0x5b, MDS_POLY);
    var z = gfMul(v, 0xef, MDS_POLY);

    switch (col) {
      case 0:
        return x | y << 8 | z << 16 | z << 24;

      case 1:
        return z | z << 8 | y << 16 | x << 24;

      case 2:
        return y | z << 8 | x << 16 | z << 24;

      case 3:
        return y | x << 8 | z << 16 | y << 24;
    }

    throw new Error('unreachable');
  }

  function h(v, key, off) {
    var y = new Uint8Array(4);

    for (var i = 0; i < 4; i++) {
      y[i] = v[i];
    }

    var k = key.length >>> 3;

    switch (k) {
      case 4:
        y[0] = S1$2[y[0]] ^ key[4 * (6 + off) + 0];
        y[1] = S0$1[y[1]] ^ key[4 * (6 + off) + 1];
        y[2] = S0$1[y[2]] ^ key[4 * (6 + off) + 2];
        y[3] = S1$2[y[3]] ^ key[4 * (6 + off) + 3];
      // fallthrough

      case 3:
        y[0] = S1$2[y[0]] ^ key[4 * (4 + off) + 0];
        y[1] = S1$2[y[1]] ^ key[4 * (4 + off) + 1];
        y[2] = S0$1[y[2]] ^ key[4 * (4 + off) + 2];
        y[3] = S0$1[y[3]] ^ key[4 * (4 + off) + 3];
      // fallthrough

      case 2:
        y[0] = S1$2[S0$1[S0$1[y[0]] ^ key[4 * (2 + off) + 0]] ^ key[4 * (0 + off) + 0]];
        y[1] = S0$1[S0$1[S1$2[y[1]] ^ key[4 * (2 + off) + 1]] ^ key[4 * (0 + off) + 1]];
        y[2] = S1$2[S1$2[S0$1[y[2]] ^ key[4 * (2 + off) + 2]] ^ key[4 * (0 + off) + 2]];
        y[3] = S0$1[S1$2[S1$2[y[3]] ^ key[4 * (2 + off) + 3]] ^ key[4 * (0 + off) + 3]];
        break;

      default:
        throw new Error('Invalid key size.');
    }

    var mult = 0;

    for (var _i5 = 0; _i5 < 4; _i5++) {
      mult ^= mdsMul(y[_i5], _i5);
    }

    return mult >>> 0;
  }

  function rol32(x, y) {
    return x << (y & 31) | x >>> 32 - (y & 31);
  }

  function ror32(x, y) {
    return x >>> (y & 31) | x << 32 - (y & 31);
  }

  function cleanse$1(arr) {
    for (var i = 0; i < arr.length; i++) {
      arr[i] = 0;
    }
  }

  function readU32$c(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off++] * 0x1000000;
  }

  function writeU32$b(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var twofish = Twofish;

  function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var DES$1 = des.DES,
      EDE$1 = des.EDE,
      EDE3$1 = des.EDE3;
  /**
   * CipherBase
   */

  var CipherBase = /*#__PURE__*/function () {
    function CipherBase(name, encrypt) {
      _classCallCheck__default['default'](this, CipherBase);

      assert_1$1(typeof name === 'string');
      assert_1$1(typeof encrypt === 'boolean');
      this.encrypt = encrypt;
      this.ctx = null;

      this._init(name);
    }

    _createClass__default['default'](CipherBase, [{
      key: "_init",
      value: function _init(name) {
        var _parseName = parseName(name),
            _parseName2 = _slicedToArray__default['default'](_parseName, 2),
            algo = _parseName2[0],
            mode = _parseName2[1];

        var Mode = modes.get(mode, this.encrypt);

        switch (algo) {
          case 'AES-128':
          case 'AES-192':
          case 'AES-256':
            {
              var bits = algo.slice(-3) | 0;
              this.ctx = new Mode(new aes(bits));
              break;
            }

          case 'ARC2':
            {
              this.ctx = new Mode(new arc2());
              break;
            }

          case 'ARC2-GUTMANN':
            {
              this.ctx = new Mode(new arc2(-1, 0));
              break;
            }

          case 'ARC2-40':
            {
              this.ctx = new Mode(new arc2(40));
              break;
            }

          case 'ARC2-64':
            {
              this.ctx = new Mode(new arc2(64));
              break;
            }

          case 'ARC2-128':
            {
              this.ctx = new Mode(new arc2(128));
              break;
            }

          case 'ARC2-128-GUTMANN':
            {
              this.ctx = new Mode(new arc2(128, 1024));
              break;
            }

          case 'BF':
          case 'BLOWFISH':
            {
              this.ctx = new Mode(new blowfish());
              break;
            }

          case 'CAMELLIA-128':
          case 'CAMELLIA-192':
          case 'CAMELLIA-256':
            {
              var _bits = algo.slice(-3) | 0;

              this.ctx = new Mode(new camellia(_bits));
              break;
            }

          case 'CAST5':
            {
              this.ctx = new Mode(new cast5());
              break;
            }

          case 'DES':
            {
              this.ctx = new Mode(new DES$1());
              break;
            }

          case 'DES-EDE':
            {
              this.ctx = new Mode(new EDE$1());
              break;
            }

          case 'DES-EDE3':
            {
              this.ctx = new Mode(new EDE3$1());
              break;
            }

          case 'IDEA':
            {
              this.ctx = new Mode(new idea());
              break;
            }

          case 'SERPENT-128':
          case 'SERPENT-192':
          case 'SERPENT-256':
            {
              var _bits2 = algo.slice(-3) | 0;

              this.ctx = new Mode(new serpent(_bits2));
              break;
            }

          case 'TWOFISH-128':
          case 'TWOFISH-192':
          case 'TWOFISH-256':
            {
              var _bits3 = algo.slice(-3) | 0;

              this.ctx = new Mode(new twofish(_bits3));
              break;
            }

          default:
            {
              throw new Error("Unsupported cipher: ".concat(name, "."));
            }
        }
      }
    }, {
      key: "init",
      value: function init(key, iv) {
        this.ctx.init(key, iv);
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        return this.ctx.update(data);
      }
    }, {
      key: "crypt",
      value: function crypt(output, input) {
        return this.ctx.crypt(output, input);
      }
    }, {
      key: "final",
      value: function final() {
        return this.ctx.final();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.ctx.destroy();
        return this;
      }
    }, {
      key: "setAutoPadding",
      value: function setAutoPadding(padding) {
        this.ctx.setAutoPadding(padding);
        return this;
      }
    }, {
      key: "setAAD",
      value: function setAAD(data) {
        this.ctx.setAAD(data);
        return this;
      }
    }, {
      key: "setCCM",
      value: function setCCM(msgLen, tagLen, aad) {
        this.ctx.setCCM(msgLen, tagLen, aad);
        return this;
      }
    }, {
      key: "getAuthTag",
      value: function getAuthTag() {
        return this.ctx.getAuthTag();
      }
    }, {
      key: "setAuthTag",
      value: function setAuthTag(tag) {
        this.ctx.setAuthTag(tag);
        return this;
      }
    }]);

    return CipherBase;
  }();
  /**
   * Cipher
   * @extends CipherBase
   */


  var Cipher = /*#__PURE__*/function (_CipherBase) {
    _inherits__default['default'](Cipher, _CipherBase);

    var _super = _createSuper$d(Cipher);

    function Cipher(name) {
      _classCallCheck__default['default'](this, Cipher);

      return _super.call(this, name, true);
    }

    return Cipher;
  }(CipherBase);
  /**
   * Decipher
   * @extends CipherBase
   */


  var Decipher = /*#__PURE__*/function (_CipherBase2) {
    _inherits__default['default'](Decipher, _CipherBase2);

    var _super2 = _createSuper$d(Decipher);

    function Decipher(name) {
      _classCallCheck__default['default'](this, Decipher);

      return _super2.call(this, name, false);
    }

    return Decipher;
  }(CipherBase);
  /*
   * API
   */


  function encrypt(name, key, iv, data) {
    var ctx = new Cipher(name);
    ctx.init(key, iv);
    return Buffer.concat([ctx.update(data), ctx.final()]);
  }

  function decrypt(name, key, iv, data) {
    var ctx = new Decipher(name);
    ctx.init(key, iv);
    return Buffer.concat([ctx.update(data), ctx.final()]);
  }
  /*
   * Helpers
   */


  var modeNames = {
    __proto__: null,
    ECB: true,
    CBC: true,
    CTS: true,
    XTS: true,
    CTR: true,
    CFB: true,
    OFB: true,
    GCM: true,
    CCM: true,
    EAX: true
  };

  function parseName(name) {
    assert_1$1(typeof name === 'string');
    if (name.substring(0, 3) === 'RC2') name = 'A' + name;
    if (name.length < 5) return [name, 'RAW'];
    var mode = name.substring(name.length - 3);
    if (name[name.length - 4] !== '-' || !modeNames[mode]) return [name, 'RAW'];
    var algo = name.substring(0, name.length - 4);
    return [algo, mode];
  }
  /*
   * Expose
   */


  var native_1$5 = 0;
  var Cipher_1 = Cipher;
  var Decipher_1 = Decipher;
  var encrypt_1 = encrypt;
  var decrypt_1 = decrypt;
  var cipher = {
    native: native_1$5,
    Cipher: Cipher_1,
    Decipher: Decipher_1,
    encrypt: encrypt_1,
    decrypt: decrypt_1
  };

  var cipherBrowser = cipher;

  /**
   * A maybe-secure memzero.
   * @param {Buffer} data
   */


  function cleanse$2(data) {
    assert_1$1(Buffer.isBuffer(data));
    randomBrowser.randomFill(data, 0, data.length);
  }
  /*
   * Static
   */


  cleanse$2.native = 0;
  /*
   * Expose
   */

  var cleanse_1 = cleanse$2;

  var cleanseBrowser = cleanse_1;

  /*
   * Constants
   */


  var FINALIZED$4 = 0x80000000;
  var ROUND_CONST = new Uint32Array([0x00000001, 0x00000000, 0x00008082, 0x00000000, 0x0000808a, 0x80000000, 0x80008000, 0x80000000, 0x0000808b, 0x00000000, 0x80000001, 0x00000000, 0x80008081, 0x80000000, 0x00008009, 0x80000000, 0x0000008a, 0x00000000, 0x00000088, 0x00000000, 0x80008009, 0x00000000, 0x8000000a, 0x00000000, 0x8000808b, 0x00000000, 0x0000008b, 0x80000000, 0x00008089, 0x80000000, 0x00008003, 0x80000000, 0x00008002, 0x80000000, 0x00000080, 0x80000000, 0x0000800a, 0x00000000, 0x8000000a, 0x80000000, 0x80008081, 0x80000000, 0x00008080, 0x80000000, 0x80000001, 0x00000000, 0x80008008, 0x80000000]);
  /**
   * Keccak
   */

  var Keccak = /*#__PURE__*/function () {
    function Keccak() {
      _classCallCheck__default['default'](this, Keccak);

      this.state = new Uint32Array(50);
      this.block = Buffer.alloc(200);
      this.bs = 136;
      this.pos = FINALIZED$4;
    }

    _createClass__default['default'](Keccak, [{
      key: "init",
      value: function init(bits) {
        if (bits == null) bits = 256;
        assert_1$1(bits >>> 0 === bits);
        assert_1$1(bits >= 128);
        assert_1$1(bits <= 512);
        var rate = 1600 - bits * 2;
        assert_1$1(rate >= 0 && (rate & 63) === 0);
        this.bs = rate >>> 3;
        this.pos = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));
        assert_1$1(!(this.pos & FINALIZED$4), 'Context is not initialized.');
        var len = data.length;
        var pos = this.pos;
        var off = 0;
        this.pos = (this.pos + len) % this.bs;

        if (pos > 0) {
          var want = this.bs - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < this.bs) return this;

          this._transform(this.block, 0);
        }

        while (len >= this.bs) {
          this._transform(data, off);

          off += this.bs;
          len -= this.bs;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
        return this;
      }
    }, {
      key: "final",
      value: function final(pad, len) {
        if (pad == null) pad = 0x01;
        if (len == null || len === 0) len = 100 - (this.bs >>> 1);
        assert_1$1((pad & 0xff) === pad);
        assert_1$1(len >>> 0 === len);
        assert_1$1(!(this.pos & FINALIZED$4), 'Context is not initialized.');
        this.block.fill(0, this.pos, this.bs);
        this.block[this.pos] |= pad;
        this.block[this.bs - 1] |= 0x80;

        this._transform(this.block, 0);

        this.pos = FINALIZED$4;
        assert_1$1(len <= this.bs);
        var out = Buffer.alloc(len);

        for (var i = 0; i < len; i++) {
          out[i] = this.state[i >>> 2] >>> 8 * (i & 3);
        }

        for (var _i = 0; _i < 50; _i++) {
          this.state[_i] = 0;
        }

        for (var _i2 = 0; _i2 < this.bs; _i2++) {
          this.block[_i2] = 0;
        }

        return out;
      }
    }, {
      key: "_transform",
      value: function _transform(block, off) {
        var count = this.bs >>> 2;
        var s = this.state;

        for (var i = 0; i < count; i++) {
          s[i] ^= readU32$d(block, off + i * 4);
        }

        for (var n = 0; n < 48; n += 2) {
          var c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          var c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          var c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          var c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          var c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          var c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          var c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          var c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          var c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          var c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          var h0 = c8 ^ (c2 << 1 | c3 >>> 31);
          var l0 = c9 ^ (c3 << 1 | c2 >>> 31);
          var h1 = c0 ^ (c4 << 1 | c5 >>> 31);
          var l1 = c1 ^ (c5 << 1 | c4 >>> 31);
          var h2 = c2 ^ (c6 << 1 | c7 >>> 31);
          var l2 = c3 ^ (c7 << 1 | c6 >>> 31);
          var h3 = c4 ^ (c8 << 1 | c9 >>> 31);
          var l3 = c5 ^ (c9 << 1 | c8 >>> 31);
          var h4 = c6 ^ (c0 << 1 | c1 >>> 31);
          var l4 = c7 ^ (c1 << 1 | c0 >>> 31);
          s[0] ^= h0;
          s[1] ^= l0;
          s[10] ^= h0;
          s[11] ^= l0;
          s[20] ^= h0;
          s[21] ^= l0;
          s[30] ^= h0;
          s[31] ^= l0;
          s[40] ^= h0;
          s[41] ^= l0;
          s[2] ^= h1;
          s[3] ^= l1;
          s[12] ^= h1;
          s[13] ^= l1;
          s[22] ^= h1;
          s[23] ^= l1;
          s[32] ^= h1;
          s[33] ^= l1;
          s[42] ^= h1;
          s[43] ^= l1;
          s[4] ^= h2;
          s[5] ^= l2;
          s[14] ^= h2;
          s[15] ^= l2;
          s[24] ^= h2;
          s[25] ^= l2;
          s[34] ^= h2;
          s[35] ^= l2;
          s[44] ^= h2;
          s[45] ^= l2;
          s[6] ^= h3;
          s[7] ^= l3;
          s[16] ^= h3;
          s[17] ^= l3;
          s[26] ^= h3;
          s[27] ^= l3;
          s[36] ^= h3;
          s[37] ^= l3;
          s[46] ^= h3;
          s[47] ^= l3;
          s[8] ^= h4;
          s[9] ^= l4;
          s[18] ^= h4;
          s[19] ^= l4;
          s[28] ^= h4;
          s[29] ^= l4;
          s[38] ^= h4;
          s[39] ^= l4;
          s[48] ^= h4;
          s[49] ^= l4;
          var b0 = s[0];
          var b1 = s[1];
          var b32 = s[11] << 4 | s[10] >>> 28;
          var b33 = s[10] << 4 | s[11] >>> 28;
          var b14 = s[20] << 3 | s[21] >>> 29;
          var b15 = s[21] << 3 | s[20] >>> 29;
          var b46 = s[31] << 9 | s[30] >>> 23;
          var b47 = s[30] << 9 | s[31] >>> 23;
          var b28 = s[40] << 18 | s[41] >>> 14;
          var b29 = s[41] << 18 | s[40] >>> 14;
          var b20 = s[2] << 1 | s[3] >>> 31;
          var b21 = s[3] << 1 | s[2] >>> 31;
          var b2 = s[13] << 12 | s[12] >>> 20;
          var b3 = s[12] << 12 | s[13] >>> 20;
          var b34 = s[22] << 10 | s[23] >>> 22;
          var b35 = s[23] << 10 | s[22] >>> 22;
          var b16 = s[33] << 13 | s[32] >>> 19;
          var b17 = s[32] << 13 | s[33] >>> 19;
          var b48 = s[42] << 2 | s[43] >>> 30;
          var b49 = s[43] << 2 | s[42] >>> 30;
          var b40 = s[5] << 30 | s[4] >>> 2;
          var b41 = s[4] << 30 | s[5] >>> 2;
          var b22 = s[14] << 6 | s[15] >>> 26;
          var b23 = s[15] << 6 | s[14] >>> 26;
          var b4 = s[25] << 11 | s[24] >>> 21;
          var b5 = s[24] << 11 | s[25] >>> 21;
          var b36 = s[34] << 15 | s[35] >>> 17;
          var b37 = s[35] << 15 | s[34] >>> 17;
          var b18 = s[45] << 29 | s[44] >>> 3;
          var b19 = s[44] << 29 | s[45] >>> 3;
          var b10 = s[6] << 28 | s[7] >>> 4;
          var b11 = s[7] << 28 | s[6] >>> 4;
          var b42 = s[17] << 23 | s[16] >>> 9;
          var b43 = s[16] << 23 | s[17] >>> 9;
          var b24 = s[26] << 25 | s[27] >>> 7;
          var b25 = s[27] << 25 | s[26] >>> 7;
          var b6 = s[36] << 21 | s[37] >>> 11;
          var b7 = s[37] << 21 | s[36] >>> 11;
          var b38 = s[47] << 24 | s[46] >>> 8;
          var b39 = s[46] << 24 | s[47] >>> 8;
          var b30 = s[8] << 27 | s[9] >>> 5;
          var b31 = s[9] << 27 | s[8] >>> 5;
          var b12 = s[18] << 20 | s[19] >>> 12;
          var b13 = s[19] << 20 | s[18] >>> 12;
          var b44 = s[29] << 7 | s[28] >>> 25;
          var b45 = s[28] << 7 | s[29] >>> 25;
          var b26 = s[38] << 8 | s[39] >>> 24;
          var b27 = s[39] << 8 | s[38] >>> 24;
          var b8 = s[48] << 14 | s[49] >>> 18;
          var b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= ROUND_CONST[n + 0];
          s[1] ^= ROUND_CONST[n + 1];
        }
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new Keccak();
      }
    }, {
      key: "hmac",
      value: function hmac$1(bits, pad, len) {
        if (bits == null) bits = 256;
        assert_1$1(bits >>> 0 === bits);
        var rate = 1600 - bits * 2;
        assert_1$1(rate >= 0 && (rate & 63) === 0);
        return new hmac(Keccak, rate >>> 3, [bits], [pad, len]);
      }
    }, {
      key: "digest",
      value: function digest(data, bits, pad, len) {
        return Keccak.ctx.init(bits).update(data).final(pad, len);
      }
    }, {
      key: "root",
      value: function root(left, right, bits, pad, len) {
        if (bits == null) bits = 256;
        if (len == null) len = 0;
        if (len === 0) len = bits >>> 3;
        assert_1$1(bits >>> 0 === bits);
        assert_1$1((bits & 7) === 0);
        assert_1$1(len >>> 0 === len);
        assert_1$1(Buffer.isBuffer(left) && left.length === len);
        assert_1$1(Buffer.isBuffer(right) && right.length === len);
        return Keccak.ctx.init(bits).update(left).update(right).final(pad, len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, bits, pad, len) {
        var ctx = Keccak.ctx;
        ctx.init(bits);
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final(pad, len);
      }
    }, {
      key: "mac",
      value: function mac(data, key, bits, pad, len) {
        return Keccak.hmac(bits, pad, len).init(key).update(data).final();
      }
    }]);

    return Keccak;
  }();
  /*
   * Static
   */


  Keccak.native = 0;
  Keccak.id = 'KECCAK256';
  Keccak.size = 32;
  Keccak.bits = 256;
  Keccak.blockSize = 136;
  Keccak.zero = Buffer.alloc(32, 0x00);
  Keccak.ctx = new Keccak();
  /*
   * Helpers
   */

  function readU32$d(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }
  /*
   * Expose
   */


  var keccak = Keccak;

  var keccakBrowser = keccak;

  function _createForOfIteratorHelper$4(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

  function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /*
   * Constants
   */


  var EMPTY$1 = Buffer.alloc(0);
  var ZEROES = Buffer.alloc(200, 0x00);
  /*
   * CSHAKE
   */

  var CSHAKE = /*#__PURE__*/function (_Keccak) {
    _inherits__default['default'](CSHAKE, _Keccak);

    var _super = _createSuper$e(CSHAKE);

    function CSHAKE() {
      var _this;

      _classCallCheck__default['default'](this, CSHAKE);

      _this = _super.call(this);
      _this.pad = 0x04;
      _this.rate = 1088;
      return _this;
    }

    _createClass__default['default'](CSHAKE, [{
      key: "init",
      value: function init(bits, name, pers) {
        if (bits == null) bits = 256;
        if (name == null) name = EMPTY$1;
        if (pers == null) pers = EMPTY$1;
        assert_1$1(bits >>> 0 === bits);
        assert_1$1(bits === 128 || bits === 256);
        assert_1$1(Buffer.isBuffer(name));
        assert_1$1(Buffer.isBuffer(pers));

        _get__default['default'](_getPrototypeOf__default['default'](CSHAKE.prototype), "init", this).call(this, bits);

        if (name.length === 0 && pers.length === 0) {
          this.pad = 0x1f;
        } else {
          var rate = 1600 - bits * 2;
          var size = rate / 8;
          this.bytePad([name, pers], size);
          this.rate = rate;
          this.pad = 0x04;
        }

        return this;
      }
    }, {
      key: "final",
      value: function final(len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE.prototype), "final", this).call(this, this.pad, len);
      }
    }, {
      key: "bytePad",
      value: function bytePad(items, w) {
        assert_1$1(Array.isArray(items));
        assert_1$1(w >>> 0 === w);
        assert_1$1(w > 0);
        var z = this.leftEncode(w);

        var _iterator = _createForOfIteratorHelper$4(items),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var x = _step.value;
            z += this.encodeString(x);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var left = w - z % w;
        if (left === w) return z;
        z += this.zeroPad(left);
        return z;
      }
    }, {
      key: "encodeString",
      value: function encodeString(s) {
        assert_1$1(Buffer.isBuffer(s));
        var n = this.leftEncode(s.length * 8);
        this.update(s);
        return n + s.length;
      }
    }, {
      key: "zeroPad",
      value: function zeroPad(size) {
        assert_1$1(size >>> 0 === size);
        assert_1$1(size <= 200);
        var buf = ZEROES.slice(0, size);
        this.update(buf);
        return buf.length;
      }
    }, {
      key: "leftEncode",
      value: function leftEncode(x) {
        assert_1$1(x >>> 0 === x);
        assert_1$1(x >= 0 && x < 22040);
        var v = x;
        var n = 0;

        while (v && n < 4) {
          n += 1;
          v >>>= 8;
        }

        if (n === 0) n = 1;
        var buf = Buffer.alloc(n + 1);

        for (var i = 1; i <= n; i++) {
          buf[i] = x >>> 8 * (n - i);
        }

        buf[0] = n;
        this.update(buf);
        return buf.length;
      }
    }, {
      key: "rightEncode",
      value: function rightEncode(x) {
        assert_1$1(x >>> 0 === x);
        assert_1$1(x >= 0 && x < 22040);
        var v = x;
        var n = 0;

        while (v && n < 4) {
          n += 1;
          v >>>= 8;
        }

        if (n === 0) n = 1;
        var buf = Buffer.alloc(n + 1);

        for (var i = 1; i <= n; i++) {
          buf[i - 1] = x >>> 8 * (n - i);
        }

        buf[n] = n;
        this.update(buf);
        return buf.length;
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new CSHAKE();
      }
    }, {
      key: "hmac",
      value: function hmac$1(bits, name, pers, len) {
        if (bits == null) bits = 256;
        assert_1$1(bits >>> 0 === bits);
        assert_1$1(bits === 128 || bits === 256);
        var rate = 1600 - bits * 2;
        return new hmac(CSHAKE, rate / 8, [bits, name, pers], [len]);
      }
    }, {
      key: "digest",
      value: function digest(data, bits, name, pers, len) {
        return CSHAKE.ctx.init(bits, name, pers).update(data).final(len);
      }
    }, {
      key: "root",
      value: function root(left, right, bits, name, pers, len) {
        if (bits == null) bits = 256;
        if (len == null) len = 0;

        if (len === 0) {
          assert_1$1(bits >>> 0 === bits);
          len = bits >>> 3;
        }

        assert_1$1(len >>> 0 === len);
        assert_1$1(Buffer.isBuffer(left) && left.length === len);
        assert_1$1(Buffer.isBuffer(right) && right.length === len);
        var ctx = CSHAKE.ctx;
        ctx.init(bits, name, pers);
        ctx.update(left);
        ctx.update(right);
        return ctx.final(len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, bits, name, pers, len) {
        var ctx = CSHAKE.ctx;
        ctx.init(bits, name, pers);
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final(len);
      }
    }, {
      key: "mac",
      value: function mac(data, key, bits, name, pers, len) {
        return CSHAKE.hmac(bits, name, pers, len).init(key).update(data).final();
      }
    }]);

    return CSHAKE;
  }(keccakBrowser);
  /*
   * Static
   */


  CSHAKE.native = keccakBrowser.native;
  CSHAKE.id = 'CSHAKE256';
  CSHAKE.size = 32;
  CSHAKE.bits = 256;
  CSHAKE.blockSize = 136;
  CSHAKE.zero = Buffer.alloc(32, 0x00);
  CSHAKE.ctx = new CSHAKE();
  /*
   * Expose
   */

  var cshake = CSHAKE;

  function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * CSHAKE128
   */


  var CSHAKE128 = /*#__PURE__*/function (_CSHAKE) {
    _inherits__default['default'](CSHAKE128, _CSHAKE);

    var _super = _createSuper$f(CSHAKE128);

    function CSHAKE128() {
      _classCallCheck__default['default'](this, CSHAKE128);

      return _super.call(this);
    }

    _createClass__default['default'](CSHAKE128, [{
      key: "init",
      value: function init(name, pers) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE128.prototype), "init", this).call(this, 128, name, pers);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new CSHAKE128();
      }
    }, {
      key: "hmac",
      value: function hmac(name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE128), "hmac", this).call(this, 128, name, pers, len);
      }
    }, {
      key: "digest",
      value: function digest(data, name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE128), "digest", this).call(this, data, 128, name, pers, len);
      }
    }, {
      key: "root",
      value: function root(left, right, name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE128), "root", this).call(this, left, right, 128, name, pers, len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE128), "multi", this).call(this, x, y, z, 128, name, pers, len);
      }
    }, {
      key: "mac",
      value: function mac(data, key, name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE128), "mac", this).call(this, data, key, 128, name, pers, len);
      }
    }]);

    return CSHAKE128;
  }(cshake);
  /*
   * Static
   */


  CSHAKE128.native = cshake.native;
  CSHAKE128.id = 'CSHAKE128';
  CSHAKE128.size = 16;
  CSHAKE128.bits = 128;
  CSHAKE128.blockSize = 168;
  CSHAKE128.zero = Buffer.alloc(16, 0x00);
  CSHAKE128.ctx = new CSHAKE128();
  /*
   * Expose
   */

  var cshake128 = CSHAKE128;

  function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * CSHAKE256
   */


  var CSHAKE256 = /*#__PURE__*/function (_CSHAKE) {
    _inherits__default['default'](CSHAKE256, _CSHAKE);

    var _super = _createSuper$g(CSHAKE256);

    function CSHAKE256() {
      _classCallCheck__default['default'](this, CSHAKE256);

      return _super.call(this);
    }

    _createClass__default['default'](CSHAKE256, [{
      key: "init",
      value: function init(name, pers) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE256.prototype), "init", this).call(this, 256, name, pers);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new CSHAKE256();
      }
    }, {
      key: "hmac",
      value: function hmac(name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE256), "hmac", this).call(this, 256, name, pers, len);
      }
    }, {
      key: "digest",
      value: function digest(data, name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE256), "digest", this).call(this, data, 256, name, pers, len);
      }
    }, {
      key: "root",
      value: function root(left, right, name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE256), "root", this).call(this, left, right, 256, name, pers, len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE256), "multi", this).call(this, x, y, z, 256, name, pers, len);
      }
    }, {
      key: "mac",
      value: function mac(data, key, name, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](CSHAKE256), "mac", this).call(this, data, key, 256, name, pers, len);
      }
    }]);

    return CSHAKE256;
  }(cshake);
  /*
   * Static
   */


  CSHAKE256.native = cshake.native;
  CSHAKE256.id = 'CSHAKE256';
  CSHAKE256.size = 32;
  CSHAKE256.bits = 256;
  CSHAKE256.blockSize = 136;
  CSHAKE256.zero = Buffer.alloc(32, 0x00);
  CSHAKE256.ctx = new CSHAKE256();
  /*
   * Expose
   */

  var cshake256 = CSHAKE256;

  /*
   * Constants
   */


  var MAX_GENERATE_LENGTH = 65536;
  var RESEED_INTERVAL = 0x1000000000000;
  /**
   * CtrDRBG
   */

  var CtrDRBG = /*#__PURE__*/function () {
    function CtrDRBG(bits, derivation, entropy, nonce, pers) {
      _classCallCheck__default['default'](this, CtrDRBG);

      assert_1$1(bits >>> 0 === bits);
      assert_1$1(typeof derivation === 'boolean');
      this.bits = bits;
      this.ctr = new CTR$1(bits);
      this.keySize = bits >>> 3;
      this.blkSize = 16;
      this.entSize = this.keySize + this.blkSize;
      this.slab = Buffer.alloc(this.entSize);
      this.K = this.slab.slice(0, this.keySize);
      this.V = this.slab.slice(this.keySize);
      this.derivation = derivation;
      this.rounds = 0;
      if (entropy) this.init(entropy, nonce, pers);
    }

    _createClass__default['default'](CtrDRBG, [{
      key: "init",
      value: function init(entropy, nonce, pers) {
        if (nonce == null) nonce = Buffer.alloc(0);
        if (pers == null) pers = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(entropy));
        assert_1$1(Buffer.isBuffer(nonce));
        assert_1$1(Buffer.isBuffer(pers));
        var seed;

        if (this.derivation) {
          seed = this.derive(entropy, nonce, pers);
        } else {
          if (entropy.length + nonce.length > this.entSize) throw new Error('Entropy is too long.');
          if (pers.length > this.entSize) throw new Error('Personalization string is too long.');
          seed = Buffer.alloc(this.entSize, 0x00);
          entropy.copy(seed, 0);
          nonce.copy(seed, entropy.length);

          for (var i = 0; i < pers.length; i++) {
            seed[i] ^= pers[i];
          }
        }

        this.slab.fill(0);
        this.ctr.init(this.K, this.V);
        this.update(seed);
        this.rounds = 1;
        return this;
      }
    }, {
      key: "reseed",
      value: function reseed(entropy, add) {
        if (add == null) add = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(entropy));
        assert_1$1(Buffer.isBuffer(add));
        if (this.rounds === 0) throw new Error('DRBG not initialized.');
        var seed;

        if (this.derivation) {
          seed = this.derive(entropy, add);
        } else {
          if (add.length > this.entSize) throw new Error('Additional data is too long.');
          seed = Buffer.alloc(this.entSize, 0x00);
          entropy.copy(seed, 0);

          for (var i = 0; i < add.length; i++) {
            seed[i] ^= add[i];
          }
        }

        this.update(seed);
        this.rounds = 1;
        return this;
      }
    }, {
      key: "generate",
      value: function generate(len, add) {
        assert_1$1(len >>> 0 === len);
        assert_1$1(add == null || Buffer.isBuffer(add));
        if (this.rounds === 0) throw new Error('DRBG not initialized.');
        if (this.rounds > RESEED_INTERVAL) throw new Error('Reseed is required.');
        if (len > MAX_GENERATE_LENGTH) throw new Error('Requested length is too long.');

        if (add && add.length > 0) {
          if (this.derivation) add = this.derive(add);
          this.update(add);
        }

        var blocks = Math.ceil(len / this.blkSize);
        var out = Buffer.alloc(blocks * this.blkSize);

        for (var i = 0; i < blocks; i++) {
          this.ctr.encrypt(out, i * this.blkSize);
        }

        this.update(add);
        this.rounds += 1;
        return out.slice(0, len);
      }
    }, {
      key: "randomBytes",
      value: function randomBytes(size) {
        return this.generate(size);
      }
      /*
       * Helpers
       */

    }, {
      key: "update",
      value: function update(seed) {
        if (seed == null) seed = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(seed));
        if (seed.length > this.entSize) throw new Error('Seed is too long.');
        this.slab.fill(0);

        for (var i = 0; i < this.entSize; i += this.blkSize) {
          this.ctr.encrypt(this.slab, i);
        }

        for (var _i = 0; _i < seed.length; _i++) {
          this.slab[_i] ^= seed[_i];
        }

        this.ctr.init(this.K, this.V);
        return this;
      }
    }, {
      key: "serialize",
      value: function serialize() {
        var N = this.entSize;
        var L = 0;

        for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {
          input[_key] = arguments[_key];
        }

        for (var _i2 = 0, _input = input; _i2 < _input.length; _i2++) {
          var item = _input[_i2];
          L += item.length;
        }

        var size = this.blkSize + 4 + 4 + L + 1;
        if (size % this.blkSize) size += this.blkSize - size % this.blkSize;
        assert_1$1(size % this.blkSize === 0); // S = IV || (L || N || input || 0x80 || 0x00...)

        var S = Buffer.alloc(size, 0x00);
        var pos = this.blkSize;
        pos = writeU32$c(S, L, pos);
        pos = writeU32$c(S, N, pos);

        for (var _i3 = 0, _input2 = input; _i3 < _input2.length; _i3++) {
          var _item = _input2[_i3];
          pos += _item.copy(S, pos);
        }

        S[pos++] = 0x80;
        assert_1$1(pos === this.blkSize + 4 + 4 + L + 1);
        return S;
      }
    }, {
      key: "derive",
      value: function derive() {
        var S = this.serialize.apply(this, arguments);
        var N = S.length / this.blkSize;
        var K = Buffer.alloc(this.keySize);
        var blocks = Math.ceil(this.entSize / this.blkSize);
        var slab = Buffer.alloc(blocks * this.blkSize);
        var out = Buffer.alloc(blocks * this.blkSize);
        var chain = Buffer.alloc(this.blkSize);

        for (var i = 0; i < K.length; i++) {
          K[i] = i;
        }

        var ctx = new aes(this.bits).init(K);

        for (var _i4 = 0; _i4 < blocks; _i4++) {
          chain.fill(0);
          writeU32$c(S, _i4, 0); // chain = BCC(K, IV || S)

          for (var j = 0; j < N; j++) {
            for (var _k = 0; _k < chain.length; _k++) {
              chain[_k] ^= S[j * this.blkSize + _k];
            }

            ctx.encrypt(chain, 0, chain, 0);
          }

          chain.copy(slab, _i4 * this.blkSize);
        }

        var k = slab.slice(0, this.keySize);
        var x = slab.slice(this.keySize, this.entSize);
        ctx.init(k);

        for (var _i5 = 0; _i5 < blocks; _i5++) {
          ctx.encrypt(x, 0, x, 0);
          x.copy(out, _i5 * this.blkSize);
        }

        return out.slice(0, this.entSize);
      }
    }]);

    return CtrDRBG;
  }();
  /*
   * Static
   */


  CtrDRBG.native = 0;
  /*
   * CTR
   */

  var CTR$1 = /*#__PURE__*/function () {
    function CTR(bits) {
      _classCallCheck__default['default'](this, CTR);

      this.ctx = new aes(bits);
      this.ctr = Buffer.alloc(16);
    }

    _createClass__default['default'](CTR, [{
      key: "init",
      value: function init(key, iv) {
        this.ctx.init(key);
        iv.copy(this.ctr, 0);
        return this;
      }
    }, {
      key: "increment",
      value: function increment() {
        for (var i = this.ctr.length - 1; i >= 0; i--) {
          this.ctr[i] += 1;
          if (this.ctr[i] !== 0x00) break;
        }
      }
    }, {
      key: "encrypt",
      value: function encrypt(output, opos) {
        this.increment();
        this.ctx.encrypt(output, opos, this.ctr, 0);
        return this;
      }
    }]);

    return CTR;
  }();
  /*
   * Helpers
   */


  function writeU32$c(dst, num, off) {
    dst[off++] = num >>> 24;
    dst[off++] = num >>> 16;
    dst[off++] = num >>> 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var ctrDrbg = CtrDRBG;

  var ctrDrbgBrowser = ctrDrbg;

  /*
   * Constants
   */


  var RESEED_INTERVAL$1 = 0x1000000000000;
  var ZERO = Buffer.from([0x00]);
  var ONE = Buffer.from([0x01]);
  /**
   * HmacDRBG
   */

  var HmacDRBG = /*#__PURE__*/function () {
    function HmacDRBG(hash, entropy, nonce, pers) {
      _classCallCheck__default['default'](this, HmacDRBG);

      assert_1$1(hash && typeof hash.id === 'string');
      this.hash = hash;
      this.minEntropy = hash.id === 'SHA1' ? 10 : 24;
      this.K = Buffer.alloc(hash.size);
      this.V = Buffer.alloc(hash.size);
      this.rounds = 0;
      if (entropy) this.init(entropy, nonce, pers);
    }

    _createClass__default['default'](HmacDRBG, [{
      key: "init",
      value: function init(entropy, nonce, pers) {
        if (nonce == null) nonce = Buffer.alloc(0);
        if (pers == null) pers = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(entropy));
        assert_1$1(Buffer.isBuffer(nonce));
        assert_1$1(Buffer.isBuffer(pers));

        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0x00;
          this.V[i] = 0x01;
        }

        var seed = Buffer.concat([entropy, nonce, pers]);
        if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');
        this.update(seed);
        this.rounds = 1;
        return this;
      }
    }, {
      key: "reseed",
      value: function reseed(entropy, add) {
        if (add == null) add = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(entropy));
        assert_1$1(Buffer.isBuffer(add));
        if (this.rounds === 0) throw new Error('DRBG not initialized.');
        var seed = Buffer.concat([entropy, add]);
        if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');
        this.update(seed);
        this.rounds = 1;
        return this;
      }
    }, {
      key: "generate",
      value: function generate(len, add) {
        assert_1$1(len >>> 0 === len);
        assert_1$1(add == null || Buffer.isBuffer(add));
        if (this.rounds === 0) throw new Error('DRBG not initialized.');
        if (this.rounds > RESEED_INTERVAL$1) throw new Error('Reseed is required.');
        if (add && add.length > 0) this.update(add);
        var blocks = Math.ceil(len / this.hash.size);
        var out = Buffer.alloc(blocks * this.hash.size);

        for (var i = 0; i < blocks; i++) {
          this.V = this.mac(this.V);
          this.V.copy(out, i * this.hash.size);
        }

        this.update(add);
        this.rounds += 1;
        return out.slice(0, len);
      }
    }, {
      key: "randomBytes",
      value: function randomBytes(size) {
        return this.generate(size);
      }
      /*
       * Helpers
       */

    }, {
      key: "mac",
      value: function mac(data) {
        return this.hash.mac(data, this.K);
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return this.hash.hmac().init(this.K);
      }
    }, {
      key: "update",
      value: function update(seed) {
        assert_1$1(seed == null || Buffer.isBuffer(seed));
        var kmac = this.hmac();
        kmac.update(this.V);
        kmac.update(ZERO);
        if (seed) kmac.update(seed);
        this.K = kmac.final();
        this.V = this.mac(this.V);

        if (seed && seed.length > 0) {
          var _kmac = this.hmac();

          _kmac.update(this.V);

          _kmac.update(ONE);

          _kmac.update(seed);

          this.K = _kmac.final();
          this.V = this.mac(this.V);
        }

        return this;
      }
    }]);

    return HmacDRBG;
  }();
  /*
   * Static
   */


  HmacDRBG.native = 0;
  /*
   * Expose
   */

  var hmacDrbg = HmacDRBG;

  var hmacDrbgBrowser = hmacDrbg;

  /*
   * Constants
   */


  var FINALIZED$5 = -1;
  var DESC$1 = Buffer.alloc(8, 0x00);
  var PADDING$2 = Buffer.alloc(64, 0x00);
  PADDING$2[0] = 0x80;
  var K$1 = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
  /**
   * SHA256
   */

  var SHA256 = /*#__PURE__*/function () {
    function SHA256() {
      _classCallCheck__default['default'](this, SHA256);

      this.state = new Uint32Array(8);
      this.msg = new Uint32Array(64);
      this.block = Buffer.alloc(64);
      this.size = FINALIZED$5;
    }

    _createClass__default['default'](SHA256, [{
      key: "init",
      value: function init() {
        this.state[0] = 0x6a09e667;
        this.state[1] = 0xbb67ae85;
        this.state[2] = 0x3c6ef372;
        this.state[3] = 0xa54ff53a;
        this.state[4] = 0x510e527f;
        this.state[5] = 0x9b05688c;
        this.state[6] = 0x1f83d9ab;
        this.state[7] = 0x5be0cd19;
        this.size = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._update(data, data.length);

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return this._final(Buffer.alloc(32));
      }
    }, {
      key: "_update",
      value: function _update(data, len) {
        assert_1$1(this.size !== FINALIZED$5, 'Context is not initialized.');
        var pos = this.size & 63;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 64 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 64) return;

          this._transform(this.block, 0);
        }

        while (len >= 64) {
          this._transform(data, off);

          off += 64;
          len -= 64;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
    }, {
      key: "_final",
      value: function _final(out) {
        assert_1$1(this.size !== FINALIZED$5, 'Context is not initialized.');
        var pos = this.size & 63;
        var len = this.size * 8;
        writeU32$d(DESC$1, len * (1 / 0x100000000) >>> 0, 0);
        writeU32$d(DESC$1, len >>> 0, 4);

        this._update(PADDING$2, 1 + (119 - pos & 63));

        this._update(DESC$1, 8);

        for (var i = 0; i < 8; i++) {
          writeU32$d(out, this.state[i], i * 4);
          this.state[i] = 0;
        }

        for (var _i = 0; _i < 64; _i++) {
          this.msg[_i] = 0;
        }

        for (var _i2 = 0; _i2 < 64; _i2++) {
          this.block[_i2] = 0;
        }

        this.size = FINALIZED$5;
        return out;
      }
    }, {
      key: "_transform",
      value: function _transform(chunk, pos) {
        var W = this.msg;
        var a = this.state[0];
        var b = this.state[1];
        var c = this.state[2];
        var d = this.state[3];
        var e = this.state[4];
        var f = this.state[5];
        var g = this.state[6];
        var h = this.state[7];
        var i = 0;

        for (; i < 16; i++) {
          W[i] = readU32$e(chunk, pos + i * 4);
        }

        for (; i < 64; i++) {
          W[i] = sigma1(W[i - 2]) + W[i - 7] + sigma0(W[i - 15]) + W[i - 16];
        }

        for (i = 0; i < 64; i++) {
          var t1 = h + Sigma1(e) + Ch(e, f, g) + K$1[i] + W[i];
          var t2 = Sigma0(a) + Maj(a, b, c);
          h = g;
          g = f;
          f = e;
          e = d + t1 >>> 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }

        this.state[0] += a;
        this.state[1] += b;
        this.state[2] += c;
        this.state[3] += d;
        this.state[4] += e;
        this.state[5] += f;
        this.state[6] += g;
        this.state[7] += h;
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA256();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(SHA256, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return SHA256.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 32);
        assert_1$1(Buffer.isBuffer(right) && right.length === 32);
        return SHA256.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = SHA256.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return SHA256.hmac().init(key).update(data).final();
      }
    }]);

    return SHA256;
  }();
  /*
   * Static
   */


  SHA256.native = 0;
  SHA256.id = 'SHA256';
  SHA256.size = 32;
  SHA256.bits = 256;
  SHA256.blockSize = 64;
  SHA256.zero = Buffer.alloc(32, 0x00);
  SHA256.ctx = new SHA256();
  /*
   * Helpers
   */

  function Sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }

  function Sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }

  function sigma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }

  function sigma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }

  function Ch(x, y, z) {
    return z ^ x & (y ^ z);
  }

  function Maj(x, y, z) {
    return x & y | z & (x | y);
  }

  function readU32$e(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function writeU32$d(data, num, off) {
    data[off++] = num >>> 24;
    data[off++] = num >>> 16;
    data[off++] = num >>> 8;
    data[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var sha256 = SHA256;

  var sha256Browser = sha256;

  /*
   * Constants
   */


  var smallPrimes = new Uint8Array([3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]);
  var smallPrimesProduct = new bnBrowser('16294579238595022365', 10);
  var primeBitMaskLo = 0 | 1 << 2 | 1 << 3 | 1 << 5 | 1 << 7 | 1 << 11 | 1 << 13 | 1 << 17 | 1 << 19 | 1 << 23 | 1 << 29 | 1 << 31;
  var primeBitMaskHi = 0 | 1 << 37 - 32 | 1 << 41 - 32 | 1 << 43 - 32 | 1 << 47 - 32 | 1 << 53 - 32 | 1 << 59 - 32 | 1 << 61 - 32;
  var primesA = new bnBrowser(3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 37);
  var primesB = new bnBrowser(29 * 31 * 41 * 43 * 47 * 53);
  /*
   * Primality
   */

  function randomPrime(bits) {
    var reps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
    var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : randomBrowser;
    assert_1$1(bits >>> 0 === bits);
    assert_1$1(reps >>> 0 === reps);
    assert_1$1(rng != null);
    if (bits < 2) throw new Error('Prime must be at least 2 bits.');

    for (;;) {
      var p = bnBrowser.randomBits(rng, bits);
      p.setn(bits - 1, 1);
      p.setn(bits - 2, 1);
      p.setn(0, 1);
      var mod = p.mod(smallPrimesProduct);

      next: for (var delta = 0; delta < 1 << 20; delta += 2) {
        var m = mod.addn(delta);

        for (var i = 0; i < smallPrimes.length; i++) {
          var prime = smallPrimes[i];
          if (m.modrn(prime) === 0 && (bits > 6 || m.cmpn(prime) !== 0)) continue next;
        }

        p.iaddn(delta);
        break;
      }

      if (p.bitLength() !== bits) continue;
      if (!isProbablePrime(p, reps, rng)) continue;
      return p;
    }
  }

  function isProbablePrime(x, reps) {
    var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : randomBrowser;
    assert_1$1(x instanceof bnBrowser);
    if (x.sign() <= 0) return false;

    if (x.cmpn(64) < 0) {
      var w = x.word(0);
      if (w > 31) return (primeBitMaskHi & 1 << w - 32) !== 0;
      return (primeBitMaskLo & 1 << w) !== 0;
    }

    if (x.isEven()) return false;
    var ra = x.mod(primesA).toNumber();
    var rb = x.mod(primesB).toNumber();

    if (ra % 3 === 0 || ra % 5 === 0 || ra % 7 === 0 || ra % 11 === 0 || ra % 13 === 0 || ra % 17 === 0 || ra % 19 === 0 || ra % 23 === 0 || ra % 37 === 0 || rb % 29 === 0 || rb % 31 === 0 || rb % 41 === 0 || rb % 43 === 0 || rb % 47 === 0 || rb % 53 === 0) {
      return false;
    }

    return x.isPrime(rng, reps);
  }

  function isSafePrime(x, reps, rng) {
    // Safe Prime (2p + 1).
    if (!isProbablePrime(x, reps, rng)) return false; // Sophie Germain Prime (p).

    var p = x.subn(1).iushrn(1);
    if (!isProbablePrime(p, reps, rng)) return false;
    return true;
  }
  /*
   * Expose
   */


  var randomPrime_1 = randomPrime;
  var isProbablePrime_1 = isProbablePrime;
  var isSafePrime_1 = isSafePrime;
  var primes$1 = {
    randomPrime: randomPrime_1,
    isProbablePrime: isProbablePrime_1,
    isSafePrime: isSafePrime_1
  };

  /*
   * ASN1
   */


  function readSize(data, pos, strict) {
    assert$3(Buffer.isBuffer(data));
    assert$3(pos >>> 0 === pos);
    assert$3(typeof strict === 'boolean');
    if (pos >= data.length) throw new Error('Invalid size.');
    var field = data[pos];
    var bytes = field & 0x7f;
    pos += 1; // Definite form.

    if ((field & 0x80) === 0) {
      // Short form.
      return [bytes, pos];
    } // Indefinite form.


    if (strict && bytes === 0) throw new Error('Indefinite length.'); // Long form.

    var size = 0;

    for (var i = 0; i < bytes; i++) {
      assert$3(pos < data.length);
      var ch = data[pos];
      pos += 1;
      if (size >= 1 << 24) throw new Error('Length too large.');
      size *= 0x100;
      size += ch;
      if (strict && size === 0) throw new Error('Unexpected leading zeroes.');
    }

    if (strict && size < 0x80) throw new Error('Non-minimal length.');
    return [size, pos];
  }

  function readSeq(data, pos) {
    var strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    assert$3(Buffer.isBuffer(data));
    assert$3(pos >>> 0 === pos);
    assert$3(typeof strict === 'boolean');
    if (pos >= data.length || data[pos] !== 0x30) throw new Error('Invalid sequence tag.');
    pos += 1;
    var size;

    var _readSize = readSize(data, pos, strict);

    var _readSize2 = _slicedToArray__default['default'](_readSize, 2);

    size = _readSize2[0];
    pos = _readSize2[1];
    if (strict && pos + size !== data.length) throw new Error('Trailing bytes.');
    return pos;
  }

  function readInt(data, pos) {
    var strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    assert$3(Buffer.isBuffer(data));
    assert$3(pos >>> 0 === pos);
    assert$3(typeof strict === 'boolean');
    if (pos >= data.length || data[pos] !== 0x02) throw new Error('Invalid integer tag.');
    pos += 1;
    var size;

    var _readSize3 = readSize(data, pos, strict);

    var _readSize4 = _slicedToArray__default['default'](_readSize3, 2);

    size = _readSize4[0];
    pos = _readSize4[1];
    if (pos + size > data.length) throw new Error('Integer body out of bounds.');

    if (strict) {
      // Zero length integer.
      if (size === 0) throw new Error('Zero length integer.'); // No negatives.

      if (data[pos] & 0x80) throw new Error('Integers must be positive.'); // Allow zero only if it prefixes a high bit.

      if (size > 1) {
        if (data[pos] === 0x00 && (data[pos + 1] & 0x80) === 0x00) throw new Error('Unexpected leading zeroes.');
      }
    } // Eat leading zeroes.


    while (size > 0 && data[pos] === 0x00) {
      pos += 1;
      size -= 1;
    } // No reason to have an integer larger than this.


    if (size > 2048) throw new Error('Invalid integer size.');
    var num = bnBrowser.decode(data.slice(pos, pos + size));
    pos += size;
    return [num, pos];
  }

  function readVersion(data, pos, version) {
    var strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    assert$3(Buffer.isBuffer(data));
    assert$3(pos >>> 0 === pos);
    assert$3((version & 0xff) === version);
    assert$3(typeof strict === 'boolean');
    var num;

    var _readInt = readInt(data, pos, strict);

    var _readInt2 = _slicedToArray__default['default'](_readInt, 2);

    num = _readInt2[0];
    pos = _readInt2[1];
    if (num.cmpn(version) !== 0) throw new Error('Invalid version.');
    return pos;
  }

  function sizeSize(size) {
    assert$3(size >>> 0 === size);
    if (size <= 0x7f) // [size]
      return 1;
    if (size <= 0xff) // 0x81 [size]
      return 2;
    assert$3(size <= 0xffff);
    return 3; // 0x82 [size-hi] [size-lo]
  }

  function sizeSeq(size) {
    return 1 + sizeSize(size) + size;
  }

  function sizeInt(num) {
    assert$3(num instanceof bnBrowser); // 0x02 [size] [0x00?] [int]

    var bits = num.bitLength();
    var size = bits + 7 >>> 3;
    if (bits > 0 && (bits & 7) === 0) size += num.testn(bits - 1);
    if (bits === 0) size = 1;
    return 1 + sizeSize(size) + size;
  }

  function sizeVersion(version) {
    assert$3((version & 0xff) === version);
    return 3;
  }

  function writeSize(data, pos, size) {
    assert$3(Buffer.isBuffer(data));
    assert$3(pos >>> 0 === pos);
    assert$3(size >>> 0 === size);

    if (size <= 0x7f) {
      // [size]
      data[pos++] = size;
    } else if (size <= 0xff) {
      // 0x81 [size]
      data[pos++] = 0x81;
      data[pos++] = size;
    } else {
      // 0x82 [size-hi] [size-lo]
      assert$3(size <= 0xffff);
      data[pos++] = 0x82;
      data[pos++] = size >> 8;
      data[pos++] = size & 0xff;
    }

    assert$3(pos <= data.length);
    return pos;
  }

  function writeSeq(data, pos, size) {
    assert$3(Buffer.isBuffer(data));
    assert$3(pos >>> 0 === pos);
    data[pos++] = 0x30;
    return writeSize(data, pos, size);
  }

  function writeInt(data, pos, num) {
    assert$3(Buffer.isBuffer(data));
    assert$3(pos >>> 0 === pos);
    assert$3(num instanceof bnBrowser); // 0x02 [size] [0x00?] [int]

    var bits = num.bitLength();
    var size = bits + 7 >>> 3;
    var pad = 0;
    if (bits > 0 && (bits & 7) === 0) pad = num.testn(bits - 1);
    if (bits === 0) size = 1;
    data[pos++] = 0x02;
    pos = writeSize(data, pos, pad + size);
    if (pad) data[pos++] = 0x00;
    if (bits !== 0) num.encode().copy(data, pos);else data[pos] = 0x00;
    pos += size;
    assert$3(pos <= data.length);
    return pos;
  }

  function writeVersion(data, pos, version) {
    assert$3(Buffer.isBuffer(data));
    assert$3(pos >>> 0 === pos);
    assert$3((version & 0xff) === version);
    assert$3(pos + 3 <= data.length);
    data[pos++] = 0x02;
    data[pos++] = 0x01;
    data[pos++] = version;
    return pos;
  }
  /*
   * Expose
   */


  var readSize_1 = readSize;
  var readSeq_1 = readSeq;
  var readInt_1 = readInt;
  var readVersion_1 = readVersion;
  var sizeSize_1 = sizeSize;
  var sizeSeq_1 = sizeSeq;
  var sizeInt_1 = sizeInt;
  var sizeVersion_1 = sizeVersion;
  var writeSize_1 = writeSize;
  var writeSeq_1 = writeSeq;
  var writeInt_1 = writeInt;
  var writeVersion_1 = writeVersion;
  var asn1 = {
    readSize: readSize_1,
    readSeq: readSeq_1,
    readInt: readInt_1,
    readVersion: readVersion_1,
    sizeSize: sizeSize_1,
    sizeSeq: sizeSeq_1,
    sizeInt: sizeInt_1,
    sizeVersion: sizeVersion_1,
    writeSize: writeSize_1,
    writeSeq: writeSeq_1,
    writeInt: writeInt_1,
    writeVersion: writeVersion_1
  };

  function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var isProbablePrime$1 = primes$1.isProbablePrime;
  /*
   * Constants
   */

  var DEFAULT_BITS = 2048;
  var MIN_BITS = 512;
  var MAX_BITS = 10000;
  /**
   * DSAParams
   */

  var DSAParams = /*#__PURE__*/function () {
    function DSAParams() {
      _classCallCheck__default['default'](this, DSAParams);

      this.p = new bnBrowser(0);
      this.q = new bnBrowser(0);
      this.g = new bnBrowser(0);
    }

    _createClass__default['default'](DSAParams, [{
      key: "bits",
      value: function bits() {
        return this.p.bitLength();
      }
    }, {
      key: "size",
      value: function size() {
        return this.q.byteLength();
      }
    }, {
      key: "isSane",
      value: function isSane() {
        if (this.p.sign() < 0 || this.q.sign() < 0) return false;
        var pbits = this.p.bitLength();
        var qbits = this.q.bitLength();
        if (pbits < MIN_BITS || pbits > MAX_BITS) return false;
        if (qbits !== 160 && qbits !== 224 && qbits !== 256) return false;
        if (this.g.cmpn(2) < 0 || this.g.cmp(this.p.subn(1)) >= 0) return false;
        if (!this.p.isOdd()) return false;
        if (!this.q.isOdd()) return false;
        return true;
      }
    }, {
      key: "verify",
      value: function verify() {
        return this.g.powm(this.q, this.p).cmpn(1) === 0;
      }
    }, {
      key: "generate",
      value: function generate(L, N) {
        // [FIPS186] Page 31, Appendix A.1.
        //           Page 41, Appendix A.2.
        // [DSA] "Parameter generation".
        assert_1$1(L >>> 0 === L);
        assert_1$1(N >>> 0 === N);

        if (!(L === 1024 && N === 160) && !(L === 2048 && N === 224) && !(L === 2048 && N === 256) && !(L === 3072 && N === 256)) {
          throw new Error('Invalid parameter sizes.');
        }

        if (L < MIN_BITS || L > MAX_BITS || (N & 7) !== 0) throw new Error('Invalid parameter sizes.');
        var q = null;
        var p = null;

        outer: for (;;) {
          q = bnBrowser.randomBits(randomBrowser, N);
          q.setn(N - 1, 1);
          q.setn(0, 1);
          if (!isProbablePrime$1(q, 64)) continue;

          for (var i = 0; i < 4 * L; i++) {
            p = bnBrowser.randomBits(randomBrowser, L);
            p.setn(L - 1, 1);
            p.setn(0, 1);
            p.isub(p.mod(q).isubn(1));
            var bits = p.bitLength();
            if (bits < L || bits > MAX_BITS) continue;
            if (!isProbablePrime$1(p, 64)) continue;
            break outer;
          }
        }

        var h = new bnBrowser(2);
        var pm1 = p.subn(1);
        var e = pm1.div(q);

        for (;;) {
          var g = h.powm(e, p);

          if (g.cmpn(1) === 0) {
            h.iaddn(1);
            continue;
          }

          this.p = p;
          this.q = q;
          this.g = g;
          return this;
        }
      }
    }, {
      key: "toParams",
      value: function toParams() {
        var group = new DSAParams();
        group.p = this.p;
        group.q = this.q;
        group.g = this.g;
        return group;
      }
    }, {
      key: "encode",
      value: function encode() {
        var size = 0;
        size += asn1.sizeInt(this.p);
        size += asn1.sizeInt(this.q);
        size += asn1.sizeInt(this.g);
        var out = Buffer.alloc(asn1.sizeSeq(size));
        var pos = 0;
        pos = asn1.writeSeq(out, pos, size);
        pos = asn1.writeInt(out, pos, this.p);
        pos = asn1.writeInt(out, pos, this.q);
        pos = asn1.writeInt(out, pos, this.g);
        assert_1$1(pos === out.length);
        return out;
      }
    }, {
      key: "decode",
      value: function decode(data) {
        assert_1$1(Buffer.isBuffer(data));
        var pos = 0;
        pos = asn1.readSeq(data, pos);

        var _asn1$readInt = asn1.readInt(data, pos);

        var _asn1$readInt2 = _slicedToArray__default['default'](_asn1$readInt, 2);

        this.p = _asn1$readInt2[0];
        pos = _asn1$readInt2[1];

        var _asn1$readInt3 = asn1.readInt(data, pos);

        var _asn1$readInt4 = _slicedToArray__default['default'](_asn1$readInt3, 2);

        this.q = _asn1$readInt4[0];
        pos = _asn1$readInt4[1];

        var _asn1$readInt5 = asn1.readInt(data, pos);

        var _asn1$readInt6 = _slicedToArray__default['default'](_asn1$readInt5, 2);

        this.g = _asn1$readInt6[0];
        pos = _asn1$readInt6[1];
        if (pos !== data.length) throw new Error('Trailing bytes.');
        return this;
      }
    }], [{
      key: "generate",
      value: function generate(L, N) {
        return new DSAParams().generate(L, N);
      }
    }, {
      key: "decode",
      value: function decode(data) {
        return new DSAParams().decode(data);
      }
    }]);

    return DSAParams;
  }();
  /**
   * DSAPublicKey
   */


  var DSAPublicKey = /*#__PURE__*/function (_DSAParams) {
    _inherits__default['default'](DSAPublicKey, _DSAParams);

    var _super = _createSuper$h(DSAPublicKey);

    function DSAPublicKey() {
      var _this;

      _classCallCheck__default['default'](this, DSAPublicKey);

      _this = _super.call(this);
      _this.y = new bnBrowser(0);
      return _this;
    }

    _createClass__default['default'](DSAPublicKey, [{
      key: "isSane",
      value: function isSane() {
        if (!_get__default['default'](_getPrototypeOf__default['default'](DSAPublicKey.prototype), "isSane", this).call(this)) return false;
        if (this.y.cmpn(2) < 0 || this.y.cmp(this.p.subn(1)) >= 0) return false;
        return true;
      }
    }, {
      key: "verify",
      value: function verify() {
        if (!_get__default['default'](_getPrototypeOf__default['default'](DSAPublicKey.prototype), "verify", this).call(this)) return false;
        return this.y.powm(this.q, this.p).cmpn(1) === 0;
      }
    }, {
      key: "encode",
      value: function encode() {
        var size = 0;
        size += asn1.sizeInt(this.y);
        size += asn1.sizeInt(this.p);
        size += asn1.sizeInt(this.q);
        size += asn1.sizeInt(this.g);
        var out = Buffer.alloc(asn1.sizeSeq(size));
        var pos = 0;
        pos = asn1.writeSeq(out, pos, size);
        pos = asn1.writeInt(out, pos, this.y);
        pos = asn1.writeInt(out, pos, this.p);
        pos = asn1.writeInt(out, pos, this.q);
        pos = asn1.writeInt(out, pos, this.g);
        assert_1$1(pos === out.length);
        return out;
      }
    }, {
      key: "decode",
      value: function decode(data) {
        assert_1$1(Buffer.isBuffer(data));
        var pos = 0;
        pos = asn1.readSeq(data, pos);

        var _asn1$readInt7 = asn1.readInt(data, pos);

        var _asn1$readInt8 = _slicedToArray__default['default'](_asn1$readInt7, 2);

        this.y = _asn1$readInt8[0];
        pos = _asn1$readInt8[1];

        var _asn1$readInt9 = asn1.readInt(data, pos);

        var _asn1$readInt10 = _slicedToArray__default['default'](_asn1$readInt9, 2);

        this.p = _asn1$readInt10[0];
        pos = _asn1$readInt10[1];

        var _asn1$readInt11 = asn1.readInt(data, pos);

        var _asn1$readInt12 = _slicedToArray__default['default'](_asn1$readInt11, 2);

        this.q = _asn1$readInt12[0];
        pos = _asn1$readInt12[1];

        var _asn1$readInt13 = asn1.readInt(data, pos);

        var _asn1$readInt14 = _slicedToArray__default['default'](_asn1$readInt13, 2);

        this.g = _asn1$readInt14[0];
        pos = _asn1$readInt14[1];
        if (pos !== data.length) throw new Error('Trailing bytes.');
        return this;
      }
    }], [{
      key: "decode",
      value: function decode(data) {
        return new DSAPublicKey().decode(data);
      }
    }]);

    return DSAPublicKey;
  }(DSAParams);
  /**
   * DSAPrivateKey
   */


  var DSAPrivateKey = /*#__PURE__*/function (_DSAPublicKey) {
    _inherits__default['default'](DSAPrivateKey, _DSAPublicKey);

    var _super2 = _createSuper$h(DSAPrivateKey);

    function DSAPrivateKey() {
      var _this2;

      _classCallCheck__default['default'](this, DSAPrivateKey);

      _this2 = _super2.call(this);
      _this2.x = new bnBrowser(0);
      return _this2;
    }

    _createClass__default['default'](DSAPrivateKey, [{
      key: "isSane",
      value: function isSane() {
        if (!_get__default['default'](_getPrototypeOf__default['default'](DSAPrivateKey.prototype), "isSane", this).call(this)) return false;
        if (this.x.sign() <= 0 || this.x.cmp(this.q) >= 0) return false;
        return true;
      }
    }, {
      key: "isSaneCompute",
      value: function isSaneCompute() {
        var group = new DSAParams();
        group.p = this.p;
        group.q = this.q;
        group.g = this.g;
        if (!group.isSane()) return false;
        if (this.x.sign() <= 0 || this.x.cmp(this.q) >= 0) return false;
        return true;
      }
    }, {
      key: "verify",
      value: function verify() {
        if (!_get__default['default'](_getPrototypeOf__default['default'](DSAPrivateKey.prototype), "verify", this).call(this)) return false;
        var y = this.g.powm(this.x, this.p);
        return this.y.eq(y);
      }
    }, {
      key: "toPublic",
      value: function toPublic() {
        var pub = new DSAPublicKey();
        pub.p = this.p;
        pub.q = this.q;
        pub.g = this.g;
        pub.y = this.y;
        return pub;
      }
    }, {
      key: "encode",
      value: function encode() {
        var size = 0;
        size += asn1.sizeVersion(0);
        size += asn1.sizeInt(this.p);
        size += asn1.sizeInt(this.q);
        size += asn1.sizeInt(this.g);
        size += asn1.sizeInt(this.y);
        size += asn1.sizeInt(this.x);
        var out = Buffer.alloc(asn1.sizeSeq(size));
        var pos = 0;
        pos = asn1.writeSeq(out, pos, size);
        pos = asn1.writeVersion(out, pos, 0);
        pos = asn1.writeInt(out, pos, this.p);
        pos = asn1.writeInt(out, pos, this.q);
        pos = asn1.writeInt(out, pos, this.g);
        pos = asn1.writeInt(out, pos, this.y);
        pos = asn1.writeInt(out, pos, this.x);
        assert_1$1(pos === out.length);
        return out;
      }
    }, {
      key: "decode",
      value: function decode(data) {
        assert_1$1(Buffer.isBuffer(data));
        var pos = 0;
        pos = asn1.readSeq(data, pos);
        pos = asn1.readVersion(data, pos, 0);

        var _asn1$readInt15 = asn1.readInt(data, pos);

        var _asn1$readInt16 = _slicedToArray__default['default'](_asn1$readInt15, 2);

        this.p = _asn1$readInt16[0];
        pos = _asn1$readInt16[1];

        var _asn1$readInt17 = asn1.readInt(data, pos);

        var _asn1$readInt18 = _slicedToArray__default['default'](_asn1$readInt17, 2);

        this.q = _asn1$readInt18[0];
        pos = _asn1$readInt18[1];

        var _asn1$readInt19 = asn1.readInt(data, pos);

        var _asn1$readInt20 = _slicedToArray__default['default'](_asn1$readInt19, 2);

        this.g = _asn1$readInt20[0];
        pos = _asn1$readInt20[1];

        var _asn1$readInt21 = asn1.readInt(data, pos);

        var _asn1$readInt22 = _slicedToArray__default['default'](_asn1$readInt21, 2);

        this.y = _asn1$readInt22[0];
        pos = _asn1$readInt22[1];

        var _asn1$readInt23 = asn1.readInt(data, pos);

        var _asn1$readInt24 = _slicedToArray__default['default'](_asn1$readInt23, 2);

        this.x = _asn1$readInt24[0];
        pos = _asn1$readInt24[1];
        if (pos !== data.length) throw new Error('Trailing bytes.');
        return this;
      }
    }], [{
      key: "decode",
      value: function decode(data) {
        return new DSAPrivateKey().decode(data);
      }
    }]);

    return DSAPrivateKey;
  }(DSAPublicKey);
  /**
   * DSASignature
   */


  var DSASignature = /*#__PURE__*/function () {
    function DSASignature() {
      _classCallCheck__default['default'](this, DSASignature);

      this.r = new bnBrowser(0);
      this.s = new bnBrowser(0);
    }

    _createClass__default['default'](DSASignature, [{
      key: "encode",
      value: function encode() {
        var size = asn1.sizeInt(this.r) + asn1.sizeInt(this.s);
        var out = Buffer.alloc(asn1.sizeSeq(size));
        var pos = 0;
        pos = asn1.writeSeq(out, pos, size);
        pos = asn1.writeInt(out, pos, this.r);
        pos = asn1.writeInt(out, pos, this.s);
        assert_1$1(pos === out.length);
        return out;
      }
    }, {
      key: "decode",
      value: function decode(data) {
        assert_1$1(Buffer.isBuffer(data));
        var pos = 0;
        pos = asn1.readSeq(data, pos);

        var _asn1$readInt25 = asn1.readInt(data, pos);

        var _asn1$readInt26 = _slicedToArray__default['default'](_asn1$readInt25, 2);

        this.r = _asn1$readInt26[0];
        pos = _asn1$readInt26[1];

        var _asn1$readInt27 = asn1.readInt(data, pos);

        var _asn1$readInt28 = _slicedToArray__default['default'](_asn1$readInt27, 2);

        this.s = _asn1$readInt28[0];
        pos = _asn1$readInt28[1];
        if (pos !== data.length) throw new Error('Trailing bytes.');
        return this;
      }
    }, {
      key: "encodeRS",
      value: function encodeRS(size) {
        assert_1$1(size >> 0 === size);
        return Buffer.concat([this.r.encode('be', size), this.s.encode('be', size)]);
      }
    }, {
      key: "decodeRS",
      value: function decodeRS(data, size) {
        assert_1$1(Buffer.isBuffer(data));
        if (size == null) size = data.length >>> 1;
        assert_1$1(size >> 0 === size);
        assert_1$1(data.length === size * 2);
        this.r = bnBrowser.decode(data.slice(0, size));
        this.s = bnBrowser.decode(data.slice(size, size * 2));
        return this;
      }
    }], [{
      key: "decode",
      value: function decode(data) {
        return new DSASignature().decode(data);
      }
    }, {
      key: "decodeRS",
      value: function decodeRS(data, size) {
        return new DSASignature().decodeRS(data, size);
      }
    }]);

    return DSASignature;
  }();
  /**
   * Create params from key.
   * @param {Buffer} key
   * @returns {Buffer}
   */


  function paramsCreate(key) {
    assert_1$1(Buffer.isBuffer(key));
    var k;

    try {
      k = DSAPrivateKey.decode(key);
    } catch (e) {
      k = DSAPublicKey.decode(key);
    }

    var group = k.toParams();
    if (!group.isSane()) throw new Error('Invalid DSA key.');
    return group.encode();
  }
  /**
   * Generate params.
   * @param {Number} [bits=2048]
   * @returns {Buffer}
   */


  function paramsGenerate(bits) {
    if (bits == null) bits = DEFAULT_BITS;
    assert_1$1(bits >>> 0 === bits);
    if (bits < MIN_BITS || bits > MAX_BITS) throw new RangeError("\"bits\" ranges from ".concat(MIN_BITS, " to ").concat(MAX_BITS, ".")); // OpenSSL behavior.

    var L = bits;
    var N = bits < 2048 ? 160 : 256;
    return DSAParams.generate(L, N).encode();
  }
  /**
   * Generate params.
   * @param {Number} [bits=2048]
   * @returns {Buffer}
   */


  function paramsGenerateAsync(_x) {
    return _paramsGenerateAsync.apply(this, arguments);
  }
  /**
   * Get params prime size in bits.
   * @param {Buffer} params
   * @returns {Number}
   */


  function _paramsGenerateAsync() {
    _paramsGenerateAsync = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(bits) {
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", paramsGenerate(bits));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _paramsGenerateAsync.apply(this, arguments);
  }

  function paramsBits(params) {
    var group = DSAParams.decode(params);
    if (!group.isSane()) throw new Error('Invalid DSA params.');
    return group.bits();
  }
  /**
   * Get params scalar size in bits.
   * @param {Buffer} params
   * @returns {Number}
   */


  function paramsScalarBits(params) {
    var group = DSAParams.decode(params);
    if (!group.isSane()) throw new Error('Invalid DSA params.');
    return group.q.bitLength();
  }
  /**
   * Verify params.
   * @param {Buffer} params
   * @returns {Boolean}
   */


  function paramsVerify(params) {
    assert_1$1(Buffer.isBuffer(params));
    var group;

    try {
      group = DSAParams.decode(params);
    } catch (e) {
      return false;
    }

    if (!group.isSane()) return false;
    return group.verify();
  }
  /**
   * Import params from an object.
   * @param {Object} json
   * @returns {Buffer}
   */


  function paramsImport(json) {
    assert_1$1(json && _typeof__default['default'](json) === 'object');
    var group = new DSAParams();
    if (json.p != null) group.p = bnBrowser.decode(json.p);
    if (json.q != null) group.q = bnBrowser.decode(json.q);
    if (json.g != null) group.g = bnBrowser.decode(json.g);
    if (!group.isSane()) throw new Error('Invalid DSA parameters.');
    return group.encode();
  }
  /**
   * Export params to an object.
   * @param {Buffer} params
   * @returns {Object}
   */


  function paramsExport(params) {
    var group = DSAParams.decode(params);
    if (!group.isSane()) throw new Error('Invalid DSA parameters.');
    return {
      p: group.p.encode(),
      q: group.q.encode(),
      g: group.g.encode()
    };
  }
  /**
   * Generate private key from params.
   * @param {Buffer} params
   * @returns {Buffer}
   */


  function privateKeyCreate(params) {
    // [FIPS186] Page 46, Appendix B.1.
    // [DSA] "Per-user keys".
    var group = DSAParams.decode(params);
    if (!group.isSane()) throw new Error('Invalid DSA parameters.');
    var p = group.p,
        q = group.q,
        g = group.g;
    var x = bnBrowser.random(randomBrowser, 1, q);
    var y = g.powm(x, p);
    var key = new DSAPrivateKey();
    key.p = p;
    key.q = q;
    key.g = g;
    key.x = x;
    key.y = y;
    return key.encode();
  }
  /**
   * Generate private key.
   * @param {Number} [bits=2048]
   * @returns {Buffer}
   */


  function privateKeyGenerate(bits) {
    var params = paramsGenerate(bits);
    return privateKeyCreate(params);
  }
  /**
   * Generate private key.
   * @param {Number} [bits=2048]
   * @returns {Buffer}
   */


  function privateKeyGenerateAsync(_x2) {
    return _privateKeyGenerateAsync.apply(this, arguments);
  }
  /**
   * Get private key prime size in bits.
   * @param {Buffer} key
   * @returns {Number}
   */


  function _privateKeyGenerateAsync() {
    _privateKeyGenerateAsync = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(bits) {
      var params;
      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return paramsGenerateAsync(bits);

            case 2:
              params = _context2.sent;
              return _context2.abrupt("return", privateKeyCreate(params));

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _privateKeyGenerateAsync.apply(this, arguments);
  }

  function privateKeyBits(key) {
    var k = DSAPrivateKey.decode(key);
    if (!k.isSane()) throw new Error('Invalid DSA private key.');
    return k.bits();
  }
  /**
   * Get private key scalar size in bits.
   * @param {Buffer} key
   * @returns {Number}
   */


  function privateKeyScalarBits(key) {
    var k = DSAPrivateKey.decode(key);
    if (!k.isSane()) throw new Error('Invalid DSA private key.');
    return k.q.bitLength();
  }
  /**
   * Verify a private key.
   * @param {Buffer} key
   * @returns {Boolean}
   */


  function privateKeyVerify(key) {
    assert_1$1(Buffer.isBuffer(key));
    var k;

    try {
      k = DSAPrivateKey.decode(key);
    } catch (e) {
      return false;
    }

    if (!k.isSane()) return false;
    return k.verify();
  }
  /**
   * Import a private key from an object.
   * @param {Object} json
   * @returns {Buffer}
   */


  function privateKeyImport(json) {
    assert_1$1(json && _typeof__default['default'](json) === 'object');
    var k = new DSAPrivateKey();
    if (json.p != null) k.p = bnBrowser.decode(json.p);
    if (json.q != null) k.q = bnBrowser.decode(json.q);
    if (json.g != null) k.g = bnBrowser.decode(json.g);
    if (json.y != null) k.y = bnBrowser.decode(json.y);
    if (json.x != null) k.x = bnBrowser.decode(json.x);

    if (k.y.isZero()) {
      if (!k.isSaneCompute()) throw new Error('Invalid DSA private key.');
      k.y = k.g.powm(k.x, k.p);
    } else {
      if (!k.isSane()) throw new Error('Invalid DSA private key.');
    }

    return k.encode();
  }
  /**
   * Export a private key in OpenSSL ASN.1 format.
   * @param {Buffer} key
   * @returns {Buffer}
   */


  function privateKeyExport(key) {
    var k = DSAPrivateKey.decode(key);
    if (!k.isSane()) throw new Error('Invalid RSA private key.');
    return {
      p: k.p.encode(),
      q: k.q.encode(),
      g: k.g.encode(),
      y: k.y.encode(),
      x: k.x.encode()
    };
  }
  /**
   * Create a public key from a private key.
   * @param {Buffer} key
   * @returns {Buffer}
   */


  function publicKeyCreate(key) {
    var k = DSAPrivateKey.decode(key);
    if (!k.isSane()) throw new Error('Invalid DSA private key.');
    var p = k.toPublic();
    return p.encode();
  }
  /**
   * Get public key prime size in bits.
   * @param {Buffer} key
   * @returns {Number}
   */


  function publicKeyBits(key) {
    var k = DSAPublicKey.decode(key);
    if (!k.isSane()) throw new Error('Invalid DSA public key.');
    return k.bits();
  }
  /**
   * Get public key scalar size in bits.
   * @param {Buffer} key
   * @returns {Number}
   */


  function publicKeyScalarBits(key) {
    var k = DSAPublicKey.decode(key);
    if (!k.isSane()) throw new Error('Invalid DSA public key.');
    return k.q.bitLength();
  }
  /**
   * Verify a public key.
   * @param {Buffer} key
   * @returns {Boolean}
   */


  function publicKeyVerify(key) {
    var k;

    try {
      k = DSAPublicKey.decode(key);
    } catch (e) {
      return false;
    }

    if (!k.isSane()) return false;
    return k.verify();
  }
  /**
   * Import a public key to an object.
   * @param {Object} json
   * @returns {Buffer}
   */


  function publicKeyImport(json) {
    assert_1$1(json && _typeof__default['default'](json) === 'object');
    var k = new DSAPublicKey();
    if (json.p != null) k.p = bnBrowser.decode(json.p);
    if (json.q != null) k.q = bnBrowser.decode(json.q);
    if (json.g != null) k.g = bnBrowser.decode(json.g);
    if (json.y != null) k.y = bnBrowser.decode(json.y);
    if (!k.isSane()) throw new Error('Invalid DSA public key.');
    return k.encode();
  }
  /**
   * Export a public key to an object.
   * @param {Buffer} key
   * @returns {Object}
   */


  function publicKeyExport(key) {
    var k = DSAPublicKey.decode(key);
    if (!k.isSane()) throw new Error('Invalid DSA public key.');
    return {
      p: k.p.encode(),
      q: k.q.encode(),
      g: k.g.encode(),
      y: k.y.encode()
    };
  }
  /**
   * Convert DER signature to R/S.
   * @param {Buffer} sig
   * @param {Number} size
   * @returns {Buffer} R/S-formatted signature.
   */


  function signatureImport(sig, size) {
    var S = DSASignature.decode(sig);
    return S.encodeRS(size);
  }
  /**
   * Convert R/S signature to DER.
   * @param {Buffer} sig
   * @param {Number} size
   * @returns {Buffer} DER-formatted signature.
   */


  function signatureExport(sig, size) {
    var S = DSASignature.decodeRS(sig, size);
    return S.encode();
  }
  /**
   * Sign a message (R/S).
   * @param {Buffer} msg
   * @param {Buffer} key - Private key.
   * @returns {Buffer} R/S-formatted signature.
   */


  function sign(msg, key) {
    var k = DSAPrivateKey.decode(key);

    var S = _sign(msg, k);

    return S.encodeRS(k.size());
  }
  /**
   * Sign a message (DER).
   * @param {Buffer} msg
   * @param {Buffer} key - Private key.
   * @returns {Buffer} DER-formatted signature.
   */


  function signDER(msg, key) {
    var k = DSAPrivateKey.decode(key);

    var S = _sign(msg, k);

    return S.encode();
  }
  /**
   * Sign a message.
   * @private
   * @param {Buffer} msg
   * @param {Buffer} key
   * @returns {Signature}
   */


  function _sign(msg, key) {
    // DSA Signing.
    //
    // [FIPS186] Page 19, Section 4.6.
    // [DSA] "Signing".
    // [RFC6979] Page 9, Section 2.4.
    // [RFC6979] Page 10, Section 3.2.
    //
    // Assumptions:
    //
    //   - Let `m` be an integer reduced from bytes.
    //   - Let `x` be a secret non-zero scalar.
    //   - Let `k` be a random non-zero scalar.
    //   - r != 0, s != 0.
    //
    // Computation:
    //
    //   k = random integer in [1,q-1]
    //   r' = g^k mod p
    //   r = r' mod q
    //   s = (r * x + m) / k mod q
    //   S = (r, s)
    //
    // We can blind the scalar arithmetic
    // with a random integer `b` like so:
    //
    //   b = random integer in [1,q-1]
    //   s = (r * (x * b) + m * b) / (k * b) mod q
    //
    // Note that `k` must remain secret,
    // otherwise an attacker can compute:
    //
    //   x = (s * k - m) / r mod q
    //
    // This means that if two signatures
    // share the same `r` value, an attacker
    // can compute:
    //
    //   k = (m1 - m2) / (s1 - s2) mod q
    //   x = (s1 * k - m1) / r mod q
    //
    // Assuming:
    //
    //   s1 = (r * x + m1) / k mod q
    //   s2 = (r * x + m2) / k mod q
    //
    // To mitigate this, `k` can be generated
    // deterministically using the HMAC-DRBG
    // construction described in [RFC6979].
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(key instanceof DSAPrivateKey);
    if (!key.isSane()) throw new Error('Invalid DSA private key.');
    var p = key.p,
        q = key.q,
        g = key.g,
        x = key.x;
    var bytes = q.byteLength();
    var m = reduce(msg, q);
    var entropy = x.encode('be', bytes);
    var nonce = m.encode('be', bytes);
    var drbg = new hmacDrbgBrowser(sha256Browser, entropy, nonce);

    for (;;) {
      var k = truncate$1(drbg.generate(bytes), q);
      if (k.isZero() || k.cmp(q) >= 0) continue;
      var re = powBlind(g, k, p, q);
      var r = re.mod(q);
      if (r.isZero()) continue;
      var b = bnBrowser.random(randomBrowser, 1, q);
      var ki = k.mul(b).fermat(q);
      var bx = x.mul(b).imod(q);
      var bm = m.mul(b).imod(q);
      var sk = r.mul(bx).iadd(bm).imod(q);
      var s = sk.mul(ki).imod(q);
      if (s.isZero()) continue;
      var S = new DSASignature();
      S.r = r;
      S.s = s;
      return S;
    }
  }
  /**
   * Verify a signature (R/S).
   * @private
   * @param {Buffer} msg
   * @param {Buffer} sig - R/S-formatted.
   * @param {Buffer} key
   * @returns {Boolean}
   */


  function verify$1(msg, sig, key) {
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(sig));
    assert_1$1(Buffer.isBuffer(key));
    var k;

    try {
      k = DSAPublicKey.decode(key);
    } catch (e) {
      return false;
    }

    var S;

    try {
      S = DSASignature.decodeRS(sig, k.size());
    } catch (e) {
      return false;
    }

    try {
      return _verify(msg, S, k);
    } catch (e) {
      return false;
    }
  }
  /**
   * Verify a signature (DER).
   * @param {Buffer} msg
   * @param {Buffer} sig - DER-formatted.
   * @param {Buffer} key
   * @returns {Boolean}
   */


  function verifyDER(msg, sig, key) {
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(sig));
    assert_1$1(Buffer.isBuffer(key));
    var k;

    try {
      k = DSAPublicKey.decode(key);
    } catch (e) {
      return false;
    }

    var S;

    try {
      S = DSASignature.decode(sig);
    } catch (e) {
      return false;
    }

    try {
      return _verify(msg, S, k);
    } catch (e) {
      return false;
    }
  }
  /**
   * Verify a signature.
   * @private
   * @param {Buffer} msg
   * @param {Signature} S
   * @param {Buffer} key
   * @returns {Boolean}
   */


  function _verify(msg, S, key) {
    // DSA Verification.
    //
    // [FIPS186] Page 19, Section 4.7.
    // [DSA] "Verifying a signature".
    //
    // Assumptions:
    //
    //   - Let `m` be an integer reduced from bytes.
    //   - Let `r` and `s` be signature elements.
    //   - Let `y` be a valid group element.
    //   - r != 0, r < q.
    //   - s != 0, s < q.
    //
    // Computation:
    //
    //   u1 = m / s mod q
    //   u2 = r / s mod q
    //   r' = g^u1 * y^u2 mod p
    //   r == r' mod q
    var r = S.r,
        s = S.s;
    var p = key.p,
        q = key.q,
        g = key.g,
        y = key.y;
    if (!key.isSane()) return false;
    if (r.isZero() || r.cmp(q) >= 0) return false;
    if (s.isZero() || s.cmp(q) >= 0) return false;
    var m = reduce(msg, q);
    var si = s.invert(q);
    var u1 = m.mul(si).imod(q);
    var u2 = r.mul(si).imod(q);
    var e1 = g.powm(u1, p);
    var e2 = y.powm(u2, p);
    var re = e1.mul(e2).imod(p);
    return re.imod(q).eq(r);
  }
  /**
   * Perform a diffie-hellman.
   * @param {Buffer} pub
   * @param {Buffer} priv
   * @returns {Buffer}
   */


  function derive$2(pub, priv) {
    var k1 = DSAPublicKey.decode(pub);
    var k2 = DSAPrivateKey.decode(priv);
    if (!k1.isSane()) throw new Error('Invalid DSA public key.');
    if (!k2.isSane()) throw new Error('Invalid DSA private key.');
    var p = k2.p,
        q = k2.q,
        g = k2.g,
        x = k2.x;
    var y = k1.y;
    if (!k1.p.eq(p) || !k1.q.eq(q) || !k1.g.eq(g)) throw new Error('Incompatible DSA parameters.');
    if (!k1.verify()) throw new Error('Invalid DSA public key.');
    var e = powBlind(y, x, p, q);
    return e.encode('be', p.byteLength());
  }
  /*
   * Helpers
   */


  function truncate$1(msg, q) {
    // Byte array to integer conversion.
    //
    // [FIPS186] Page 68, Appendix C.2.
    //
    // Note that the FIPS186 behavior
    // differs from OpenSSL's behavior.
    // We replicate OpenSSL which takes
    // the left-most ceil(log2(n+1)) bits
    // modulo `q`.
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(q instanceof bnBrowser);
    var bits = q.bitLength();
    assert_1$1((bits & 7) === 0);
    var bytes = bits >>> 3;
    if (msg.length > bytes) msg = msg.slice(0, bytes);
    return bnBrowser.decode(msg);
  }

  function reduce(msg, q) {
    return truncate$1(msg, q).imod(q);
  }

  function powBlind(g, x, p, q) {
    // Idea: exponentiate by scalar with a
    // blinding factor, similar to how we
    // blind multiplications in EC. Note
    // that it would be safer if we had the
    // blinding factor pregenerated for each
    // key.
    //
    // Computation:
    //
    //   b = random integer in [1,q-1]
    //   k = (x - b) mod q
    //   e = g^k * g^b mod p
    //
    // In theory, we could also speed up
    // the calculation of `e` with a multi
    // exponentiation algorithm.
    assert_1$1(g instanceof bnBrowser);
    assert_1$1(x instanceof bnBrowser);
    assert_1$1(p instanceof bnBrowser);
    assert_1$1(q instanceof bnBrowser);
    var G = g.toRed(bnBrowser.mont(p));
    var b = bnBrowser.random(randomBrowser, 1, q);
    var k = x.sub(b).imod(q);
    var e1 = G.redPow(k);
    var e2 = G.redPow(b);
    var e = e1.redMul(e2);
    return e.fromRed();
  }
  /*
   * Expose
   */


  var native_1$6 = 0;
  var paramsCreate_1 = paramsCreate;
  var paramsGenerate_1 = paramsGenerate;
  var paramsGenerateAsync_1 = paramsGenerateAsync;
  var paramsBits_1 = paramsBits;
  var paramsScalarBits_1 = paramsScalarBits;
  var paramsVerify_1 = paramsVerify;
  var paramsImport_1 = paramsImport;
  var paramsExport_1 = paramsExport;
  var privateKeyCreate_1 = privateKeyCreate;
  var privateKeyGenerate_1 = privateKeyGenerate;
  var privateKeyGenerateAsync_1 = privateKeyGenerateAsync;
  var privateKeyBits_1 = privateKeyBits;
  var privateKeyScalarBits_1 = privateKeyScalarBits;
  var privateKeyVerify_1 = privateKeyVerify;
  var privateKeyImport_1 = privateKeyImport;
  var privateKeyExport_1 = privateKeyExport;
  var publicKeyCreate_1 = publicKeyCreate;
  var publicKeyBits_1 = publicKeyBits;
  var publicKeyScalarBits_1 = publicKeyScalarBits;
  var publicKeyVerify_1 = publicKeyVerify;
  var publicKeyImport_1 = publicKeyImport;
  var publicKeyExport_1 = publicKeyExport;
  var signatureImport_1 = signatureImport;
  var signatureExport_1 = signatureExport;
  var sign_1 = sign;
  var signDER_1 = signDER;
  var verify_1$1 = verify$1;
  var verifyDER_1 = verifyDER;
  var derive_1$2 = derive$2;
  var dsa = {
    native: native_1$6,
    paramsCreate: paramsCreate_1,
    paramsGenerate: paramsGenerate_1,
    paramsGenerateAsync: paramsGenerateAsync_1,
    paramsBits: paramsBits_1,
    paramsScalarBits: paramsScalarBits_1,
    paramsVerify: paramsVerify_1,
    paramsImport: paramsImport_1,
    paramsExport: paramsExport_1,
    privateKeyCreate: privateKeyCreate_1,
    privateKeyGenerate: privateKeyGenerate_1,
    privateKeyGenerateAsync: privateKeyGenerateAsync_1,
    privateKeyBits: privateKeyBits_1,
    privateKeyScalarBits: privateKeyScalarBits_1,
    privateKeyVerify: privateKeyVerify_1,
    privateKeyImport: privateKeyImport_1,
    privateKeyExport: privateKeyExport_1,
    publicKeyCreate: publicKeyCreate_1,
    publicKeyBits: publicKeyBits_1,
    publicKeyScalarBits: publicKeyScalarBits_1,
    publicKeyVerify: publicKeyVerify_1,
    publicKeyImport: publicKeyImport_1,
    publicKeyExport: publicKeyExport_1,
    signatureImport: signatureImport_1,
    signatureExport: signatureExport_1,
    sign: sign_1,
    signDER: signDER_1,
    verify: verify_1$1,
    verifyDER: verifyDER_1,
    derive: derive_1$2
  };

  var dsaBrowser = dsa;

  var padLeft$1 = util$1.padLeft;
  /*
   * DSAIES
   */

  function encrypt$1(kdf, msg, pub) {
    var priv = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    assert_1$1(kdf != null);
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(pub));
    assert_1$1(priv == null || Buffer.isBuffer(priv));

    if (priv == null) {
      var params = dsaBrowser.paramsCreate(pub);
      priv = dsaBrowser.privateKeyCreate(params);
    }

    var klen = dsaBrowser.publicKeyBits(pub) + 7 >>> 3;

    var _dsa$privateKeyExport = dsaBrowser.privateKeyExport(priv),
        y = _dsa$privateKeyExport.y;

    var secret = dsaBrowser.derive(pub, priv);
    var key = secretboxBrowser.derive(secret, kdf);
    var nonce = randomBrowser.randomBytes(24);
    var ourY = padLeft$1(y, klen);
    var sealed = secretboxBrowser.seal(msg, key, nonce);
    return Buffer.concat([ourY, nonce, sealed]);
  }

  function decrypt$1(kdf, msg, priv) {
    assert_1$1(kdf != null);
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(priv));
    var klen = dsaBrowser.privateKeyBits(priv) + 7 >>> 3;
    if (msg.length < klen + 24) throw new Error('Invalid ciphertext.');

    var _dsa$privateKeyExport2 = dsaBrowser.privateKeyExport(priv),
        p = _dsa$privateKeyExport2.p,
        q = _dsa$privateKeyExport2.q,
        g = _dsa$privateKeyExport2.g;

    var y = msg.slice(0, klen);
    var theirPub = dsaBrowser.publicKeyImport({
      p: p,
      q: q,
      g: g,
      y: y
    });
    var nonce = msg.slice(klen, klen + 24);
    var sealed = msg.slice(klen + 24);
    var secret = dsaBrowser.derive(theirPub, priv);
    var key = secretboxBrowser.derive(secret, kdf);
    return secretboxBrowser.open(sealed, key, nonce);
  }
  /*
   * Expose
   */


  var encrypt_1$1 = encrypt$1;
  var decrypt_1$1 = decrypt$1;
  var dsaies = {
    encrypt: encrypt_1$1,
    decrypt: decrypt_1$1
  };

  /*
   * EB2K
   */


  function derive$3(hash, pass, salt, keyLen, ivLen) {
    if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');
    if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
    if (salt == null) salt = Buffer.alloc(0);
    if (ivLen == null) ivLen = 0;
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(pass));
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(keyLen >>> 0 === keyLen);
    assert_1$1(ivLen >>> 0 === ivLen);
    if (salt.length > 8) salt = salt.slice(0, 8);
    if (salt.length !== 0 && salt.length !== 8) throw new RangeError('Salt must be at least 8 bytes.');
    var key = Buffer.alloc(keyLen);
    var iv = Buffer.alloc(ivLen);
    var prev = Buffer.alloc(0);
    var keyPos = 0;
    var ivPos = 0;

    while (keyPos < keyLen || ivPos < ivLen) {
      var prevPos = 0;
      prev = hash.multi(prev, pass, salt);

      if (keyPos < keyLen) {
        var need = Math.min(keyLen - keyPos, prev.length - prevPos);
        prev.copy(key, keyPos, prevPos, prevPos + need);
        keyPos += need;
        prevPos += need;
      }

      if (ivPos < ivLen) {
        var _need = Math.min(ivLen - ivPos, prev.length - prevPos);

        prev.copy(iv, ivPos, prevPos, prevPos + _need);
        ivPos += _need;
        prevPos += _need;
      }
    }

    return [key, iv];
  }
  /*
   * Expose
   */


  var native_1$7 = 0;
  var derive_1$3 = derive$3;
  var eb2k = {
    native: native_1$7,
    derive: derive_1$3
  };

  var eb2kBrowser = eb2k;

  /*
   * ECIES
   */


  function encrypt$2(curve, kdf, msg, pub) {
    var priv = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    assert_1$1(curve && typeof curve.id === 'string');
    if (priv == null) priv = curve.privateKeyGenerate();
    var ourPub = curve.publicKeyCreate(priv);
    var secret = curve.derive(pub, priv);
    var key = secretboxBrowser.derive(secret, kdf);
    var nonce = randomBrowser.randomBytes(24);
    var sealed = secretboxBrowser.seal(msg, key, nonce);
    return Buffer.concat([ourPub, nonce, sealed]);
  }

  function decrypt$2(curve, kdf, msg, priv) {
    assert_1$1(curve && typeof curve.id === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    var klen = curve.type === 'ecdsa' ? 1 + curve.size : curve.size;
    if (msg.length < klen + 24) throw new Error('Invalid ciphertext.');
    var theirPub = msg.slice(0, klen);
    var nonce = msg.slice(klen, klen + 24);
    var sealed = msg.slice(klen + 24);
    var secret = curve.derive(theirPub, priv);
    var key = secretboxBrowser.derive(secret, kdf);
    return secretboxBrowser.open(sealed, key, nonce);
  }
  /*
   * Expose
   */


  var encrypt_1$2 = encrypt$2;
  var decrypt_1$2 = decrypt$2;
  var ecies = {
    encrypt: encrypt_1$2,
    decrypt: decrypt_1$2
  };

  function _createForOfIteratorHelper$5(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

  function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /**
   * BatchRNG
   */


  var BatchRNG = /*#__PURE__*/function () {
    function BatchRNG(curve) {
      var encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (key) {
        return key;
      };

      _classCallCheck__default['default'](this, BatchRNG);

      this.curve = curve;
      this.encode = encode;
      this.hash = new sha256Browser();
      this.chacha = new chacha20Browser();
      this.key = Buffer.alloc(32, 0x00);
      this.iv = Buffer.alloc(8, 0x00);
      this.cache = [new bnBrowser(1), new bnBrowser(1)];
    }

    _createClass__default['default'](BatchRNG, [{
      key: "init",
      value: function init(batch) {
        assert_1$1(Array.isArray(batch));
        this.hash.init();

        var _iterator = _createForOfIteratorHelper$5(batch),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray__default['default'](_step.value, 3),
                msg = _step$value[0],
                sig = _step$value[1],
                key = _step$value[2];

            this.hash.update(sha256Browser.digest(msg));
            this.hash.update(sig);
            this.hash.update(this.encode(key));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.key = this.hash.final();
        this.cache[0] = new bnBrowser(1);
        this.cache[1] = new bnBrowser(1);
        return this;
      }
    }, {
      key: "encrypt",
      value: function encrypt(counter) {
        var size = this.curve.scalarSize * 2;
        var data = Buffer.alloc(size, 0x00);
        var left = data.slice(0, this.curve.scalarSize);
        var right = data.slice(this.curve.scalarSize);
        this.chacha.init(this.key, this.iv, counter);
        this.chacha.encrypt(data);
        return [this.curve.decodeScalar(left), this.curve.decodeScalar(right)];
      }
    }, {
      key: "refresh",
      value: function refresh(counter) {
        var overflow = 0;

        for (;;) {
          // First word is always zero.
          this.iv[4] = overflow;
          this.iv[5] = overflow >>> 8;
          this.iv[6] = overflow >>> 16;
          this.iv[7] = overflow >>> 24;
          overflow += 1;

          var _this$encrypt = this.encrypt(counter),
              _this$encrypt2 = _slicedToArray__default['default'](_this$encrypt, 2),
              s1 = _this$encrypt2[0],
              s2 = _this$encrypt2[1];

          if (s1.isZero() || s1.cmp(this.curve.n) >= 0) continue;
          if (s2.isZero() || s2.cmp(this.curve.n) >= 0) continue;
          this.cache[0] = s1;
          this.cache[1] = s2;
          break;
        }
      }
    }, {
      key: "generate",
      value: function generate(index) {
        assert_1$1(index >>> 0 === index);
        if (index & 1) this.refresh(index >>> 1);
        return this.cache[index & 1];
      }
    }]);

    return BatchRNG;
  }();
  /*
   * Expose
   */


  var batchRng = BatchRNG;

  function _createForOfIteratorHelper$6(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

  function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /*
   * EDDSA
   */


  var EDDSA = /*#__PURE__*/function () {
    function EDDSA(id, mid, eid, hash, pre) {
      _classCallCheck__default['default'](this, EDDSA);

      assert_1$1(typeof id === 'string');
      assert_1$1(!mid || typeof mid === 'string');
      assert_1$1(!eid || typeof eid === 'string');
      assert_1$1(hash);
      this.id = id;
      this.type = 'eddsa';
      this.mid = mid || null;
      this.eid = eid || null;
      this.hash = hash;
      this.native = 0;
      this._pre = pre || null;
      this._curve = null;
      this._mont = null;
      this._iso = null;
      this._rng = null;
    }

    _createClass__default['default'](EDDSA, [{
      key: "hashNonce",
      value: function hashNonce(prefix, msg, ph, ctx) {
        var hash = new Hash(this);
        hash.init(ph, ctx);
        hash.update(prefix);
        hash.update(msg);
        return hash.final();
      }
    }, {
      key: "hashChallenge",
      value: function hashChallenge(R, A, m, ph, ctx) {
        var hash = new Hash(this);
        hash.init(ph, ctx);
        hash.update(R);
        hash.update(A);
        hash.update(m);
        return hash.final();
      }
    }, {
      key: "privateKeyGenerate",
      value: function privateKeyGenerate() {
        return randomBrowser.randomBytes(this.curve.adjustedSize);
      }
    }, {
      key: "scalarGenerate",
      value: function scalarGenerate() {
        var scalar = randomBrowser.randomBytes(this.curve.scalarSize);
        return this.curve.clamp(scalar);
      }
    }, {
      key: "privateKeyExpand",
      value: function privateKeyExpand(secret) {
        assert_1$1(Buffer.isBuffer(secret));
        assert_1$1(secret.length === this.curve.adjustedSize);
        var hash = this.hash.digest(secret, this.curve.adjustedSize * 2);
        return this.curve.splitHash(hash);
      }
    }, {
      key: "privateKeyConvert",
      value: function privateKeyConvert(secret) {
        var _this$privateKeyExpan = this.privateKeyExpand(secret),
            _this$privateKeyExpan2 = _slicedToArray__default['default'](_this$privateKeyExpan, 1),
            key = _this$privateKeyExpan2[0];

        return key;
      }
    }, {
      key: "privateKeyVerify",
      value: function privateKeyVerify(secret) {
        assert_1$1(Buffer.isBuffer(secret));
        return secret.length === this.curve.adjustedSize;
      }
    }, {
      key: "scalarVerify",
      value: function scalarVerify(scalar) {
        assert_1$1(Buffer.isBuffer(scalar));
        return scalar.length === this.curve.scalarSize;
      }
    }, {
      key: "scalarIsZero",
      value: function scalarIsZero(scalar) {
        assert_1$1(Buffer.isBuffer(scalar));
        var k;

        try {
          k = this.curve.decodeScalar(scalar).imod(this.curve.n);
        } catch (e) {
          return false;
        }

        return k.isZero();
      }
    }, {
      key: "scalarClamp",
      value: function scalarClamp(scalar) {
        assert_1$1(Buffer.isBuffer(scalar));
        assert_1$1(scalar.length === this.curve.scalarSize);
        return this.curve.clamp(Buffer.from(scalar));
      }
    }, {
      key: "privateKeyExport",
      value: function privateKeyExport(secret) {
        var pub = this.publicKeyCreate(secret);

        var _this$publicKeyExport = this.publicKeyExport(pub),
            x = _this$publicKeyExport.x,
            y = _this$publicKeyExport.y;

        return {
          d: Buffer.from(secret),
          x: x,
          y: y
        };
      }
    }, {
      key: "privateKeyImport",
      value: function privateKeyImport(json) {
        assert_1$1(json && _typeof__default['default'](json) === 'object');
        assert_1$1(Buffer.isBuffer(json.d));
        if (json.d.length !== this.curve.adjustedSize) throw new Error('Invalid private key.');
        return Buffer.from(json.d);
      }
    }, {
      key: "scalarTweakAdd",
      value: function scalarTweakAdd(scalar, tweak) {
        var a = this.curve.decodeScalar(scalar);
        var t = this.curve.decodeScalar(tweak);
        var k = a.add(t).imod(this.curve.n);
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "scalarTweakMul",
      value: function scalarTweakMul(scalar, tweak) {
        var a = this.curve.decodeScalar(scalar);
        var t = this.curve.decodeScalar(tweak);
        var k = a.mul(t).imod(this.curve.n);
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "scalarReduce",
      value: function scalarReduce(scalar) {
        assert_1$1(Buffer.isBuffer(scalar));
        if (scalar.length > this.curve.scalarSize) scalar = scalar.slice(0, this.curve.scalarSize);
        var k = bnBrowser.decode(scalar, this.curve.endian).imod(this.curve.n);
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "scalarNegate",
      value: function scalarNegate(scalar) {
        var a = this.curve.decodeScalar(scalar).imod(this.curve.n);
        var k = a.neg().imod(this.curve.n);
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "scalarInvert",
      value: function scalarInvert(scalar) {
        var a = this.curve.decodeScalar(scalar).imod(this.curve.n);
        if (a.isZero()) return this.curve.encodeScalar(a);
        var k = a.invert(this.curve.n);
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "publicKeyCreate",
      value: function publicKeyCreate(secret) {
        var key = this.privateKeyConvert(secret);
        return this.publicKeyFromScalar(key);
      }
    }, {
      key: "publicKeyFromScalar",
      value: function publicKeyFromScalar(scalar) {
        var a = this.curve.decodeScalar(scalar).imod(this.curve.n);
        var A = this.curve.g.mulBlind(a);
        return A.encode();
      }
    }, {
      key: "publicKeyConvert",
      value: function publicKeyConvert(key) {
        if (!this.mont) throw new Error('No equivalent montgomery curve.');
        var A = this.curve.decodePoint(key);
        var P = this.mont.pointFromEdwards(A);
        return P.encode();
      }
    }, {
      key: "publicKeyFromUniform",
      value: function publicKeyFromUniform(bytes) {
        var u = this.curve.decodeUniform(bytes);
        var A = this.curve.pointFromUniform(u, this.iso);
        return A.encode();
      }
    }, {
      key: "publicKeyToUniform",
      value: function publicKeyToUniform(key) {
        var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : randomBrowser.randomInt();
        var A = this.curve.decodePoint(key);
        var u = this.curve.pointToUniform(A, hint, this.iso);
        return this.curve.encodeUniform(u, hint >>> 8);
      }
    }, {
      key: "publicKeyFromHash",
      value: function publicKeyFromHash(bytes) {
        var pake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var A = this.curve.pointFromHash(bytes, pake, this.iso);
        return A.encode();
      }
    }, {
      key: "publicKeyToHash",
      value: function publicKeyToHash(key) {
        var subgroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : randomBrowser.randomInt();
        var A = this.curve.decodePoint(key);
        return this.curve.pointToHash(A, subgroup, randomBrowser, this.iso);
      }
    }, {
      key: "publicKeyVerify",
      value: function publicKeyVerify(key) {
        assert_1$1(Buffer.isBuffer(key));

        try {
          this.curve.decodePoint(key);
        } catch (e) {
          return false;
        }

        return true;
      }
    }, {
      key: "publicKeyIsInfinity",
      value: function publicKeyIsInfinity(key) {
        assert_1$1(Buffer.isBuffer(key));
        var A;

        try {
          A = this.curve.decodePoint(key);
        } catch (e) {
          return false;
        }

        return A.isInfinity();
      }
    }, {
      key: "publicKeyIsSmall",
      value: function publicKeyIsSmall(key) {
        assert_1$1(Buffer.isBuffer(key));
        var A;

        try {
          A = this.curve.decodePoint(key);
        } catch (e) {
          return false;
        }

        return A.isSmall();
      }
    }, {
      key: "publicKeyHasTorsion",
      value: function publicKeyHasTorsion(key) {
        assert_1$1(Buffer.isBuffer(key));
        var A;

        try {
          A = this.curve.decodePoint(key);
        } catch (e) {
          return false;
        }

        return A.hasTorsion();
      }
    }, {
      key: "publicKeyExport",
      value: function publicKeyExport(key) {
        var _this$curve$decodePoi = this.curve.decodePoint(key),
            x = _this$curve$decodePoi.x,
            y = _this$curve$decodePoi.y;

        return {
          x: this.curve.encodeField(x.fromRed()),
          y: this.curve.encodeField(y.fromRed())
        };
      }
    }, {
      key: "publicKeyImport",
      value: function publicKeyImport(json) {
        assert_1$1(json && _typeof__default['default'](json) === 'object');
        var x = null;
        var y = null;
        var A;

        if (json.x != null) {
          x = bnBrowser.decode(json.x, this.curve.endian);
          if (x.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');
        }

        if (json.y != null) {
          y = bnBrowser.decode(json.y, this.curve.endian);
          if (y.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');
        }

        if (x && y) {
          A = this.curve.point(x, y);
          if (!A.validate()) throw new Error('Invalid point.');
        } else if (x) {
          A = this.curve.pointFromX(x, json.sign);
        } else if (y) {
          A = this.curve.pointFromY(y, json.sign);
        } else {
          throw new Error('Invalid point.');
        }

        return A.encode();
      }
    }, {
      key: "publicKeyTweakAdd",
      value: function publicKeyTweakAdd(key, tweak) {
        var t = this.curve.decodeScalar(tweak).imod(this.curve.n);
        var A = this.curve.decodePoint(key);
        var T = this.curve.g.mul(t);
        var P = T.add(A);
        return P.encode();
      }
    }, {
      key: "publicKeyTweakMul",
      value: function publicKeyTweakMul(key, tweak) {
        var t = this.curve.decodeScalar(tweak);
        var A = this.curve.decodePoint(key);
        var P = A.mul(t);
        return P.encode();
      }
    }, {
      key: "publicKeyCombine",
      value: function publicKeyCombine(keys) {
        assert_1$1(Array.isArray(keys));
        var P = this.curve.point();

        var _iterator = _createForOfIteratorHelper$6(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;
            var A = this.curve.decodePoint(key);
            P = P.add(A);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return P.encode();
      }
    }, {
      key: "publicKeyNegate",
      value: function publicKeyNegate(key) {
        var A = this.curve.decodePoint(key);
        var P = A.neg();
        return P.encode();
      }
    }, {
      key: "sign",
      value: function sign(msg, secret, ph, ctx) {
        var _this$privateKeyExpan3 = this.privateKeyExpand(secret),
            _this$privateKeyExpan4 = _slicedToArray__default['default'](_this$privateKeyExpan3, 2),
            key = _this$privateKeyExpan4[0],
            prefix = _this$privateKeyExpan4[1];

        return this.signWithScalar(msg, key, prefix, ph, ctx);
      }
    }, {
      key: "signWithScalar",
      value: function signWithScalar(msg, scalar, prefix, ph, ctx) {
        // EdDSA Signing.
        //
        // [EDDSA] Page 12, Section 4.
        // [RFC8032] Page 8, Section 3.3.
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `m` be a byte array of arbitrary size.
        //   - Let `a` be a secret scalar.
        //   - Let `w` be a secret byte array.
        //
        // Computation:
        //
        //   k = H(w, m) mod n
        //   R = G * k
        //   A = G * a
        //   e = H(R, A, m) mod n
        //   s = (k + e * a) mod n
        //   S = (R, s)
        //
        // Note that `k` must remain secret,
        // otherwise an attacker can compute:
        //
        //   a = (s - k) / e mod n
        //
        // The same is true of `w` as `k`
        // can be re-derived as `H(w, m)`.
        if (ctx == null) ctx = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(prefix));
        assert_1$1(prefix.length === this.curve.adjustedSize);
        var n = this.curve.n;
        var G = this.curve.g;
        var k = this.hashNonce(prefix, msg, ph, ctx);
        var Rraw = G.mulBlind(k).encode();
        var a = this.curve.decodeScalar(scalar);
        var Araw = G.mulBlind(a).encode();
        var e = this.hashChallenge(Rraw, Araw, msg, ph, ctx);
        var s = k.add(e.mul(a)).imod(n);
        return Buffer.concat([Rraw, this.curve.encodeAdjusted(s)]);
      }
    }, {
      key: "signTweakAdd",
      value: function signTweakAdd(msg, secret, tweak, ph, ctx) {
        var _this$privateKeyExpan5 = this.privateKeyExpand(secret),
            _this$privateKeyExpan6 = _slicedToArray__default['default'](_this$privateKeyExpan5, 2),
            key_ = _this$privateKeyExpan6[0],
            prefix_ = _this$privateKeyExpan6[1];

        var key = this.scalarTweakAdd(key_, tweak);
        var expanded = this.hash.multi(prefix_, tweak, null, this.curve.adjustedSize * 2);
        var prefix = expanded.slice(0, this.curve.adjustedSize);
        return this.signWithScalar(msg, key, prefix, ph, ctx);
      }
    }, {
      key: "signTweakMul",
      value: function signTweakMul(msg, secret, tweak, ph, ctx) {
        var _this$privateKeyExpan7 = this.privateKeyExpand(secret),
            _this$privateKeyExpan8 = _slicedToArray__default['default'](_this$privateKeyExpan7, 2),
            key_ = _this$privateKeyExpan8[0],
            prefix_ = _this$privateKeyExpan8[1];

        var key = this.scalarTweakMul(key_, tweak);
        var expanded = this.hash.multi(prefix_, tweak, null, this.curve.adjustedSize * 2);
        var prefix = expanded.slice(0, this.curve.adjustedSize);
        return this.signWithScalar(msg, key, prefix, ph, ctx);
      }
    }, {
      key: "verify",
      value: function verify(msg, sig, key, ph, ctx) {
        if (ctx == null) ctx = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(sig));
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(ph == null || typeof ph === 'boolean');
        assert_1$1(Buffer.isBuffer(ctx));
        if (sig.length !== this.curve.adjustedSize * 2) return false;
        if (key.length !== this.curve.adjustedSize) return false;

        try {
          return this._verify(msg, sig, key, ph, ctx);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "_verify",
      value: function _verify(msg, sig, key, ph, ctx) {
        // EdDSA Verification.
        //
        // [EDDSA] Page 15, Section 5.
        // [RFC8032] Page 8, Section 3.4.
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `m` be a byte array of arbitrary size.
        //   - Let `R` and `s` be signature elements.
        //   - Let `A` be a valid group element.
        //   - s < n.
        //
        // Computation:
        //
        //   e = H(R, A, m) mod n
        //   G * s == R + A * e
        //
        // Alternatively, we can compute:
        //
        //   R == G * s - A * e
        //
        // This allows us to make use of a
        // multi-exponentiation algorithm.
        var n = this.curve.n;
        var G = this.curve.g;
        var Rraw = sig.slice(0, this.curve.adjustedSize);
        var sraw = sig.slice(this.curve.adjustedSize);
        var R = this.curve.decodePoint(Rraw);
        var s = this.curve.decodeAdjusted(sraw);
        var A = this.curve.decodePoint(key);
        if (s.cmp(n) >= 0) return false;
        var e = this.hashChallenge(Rraw, key, msg, ph, ctx);
        return G.mulAdd(s, A.neg(), e).eq(R);
      }
    }, {
      key: "verifySingle",
      value: function verifySingle(msg, sig, key, ph, ctx) {
        if (ctx == null) ctx = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(sig));
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(ph == null || typeof ph === 'boolean');
        assert_1$1(Buffer.isBuffer(ctx));
        if (sig.length !== this.curve.adjustedSize * 2) return false;
        if (key.length !== this.curve.adjustedSize) return false;

        try {
          return this._verifySingle(msg, sig, key, ph, ctx);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "_verifySingle",
      value: function _verifySingle(msg, sig, key, ph, ctx) {
        // EdDSA Verification (with cofactor multiplication).
        //
        // [EDDSA] Page 15, Section 5.
        // [RFC8032] Page 8, Section 3.4.
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `m` be a byte array of arbitrary size.
        //   - Let `R` and `s` be signature elements.
        //   - Let `A` be a valid group element.
        //   - s < n.
        //
        // Computation:
        //
        //   e = H(R, A, m) mod n
        //   (G * s) * h == (R + A * e) * h
        //
        // Alternatively, we can compute:
        //
        //   R * h == G * (s * h) - (A * h) * e
        //
        // This allows us to make use of a
        // multi-exponentiation algorithm.
        var n = this.curve.n;
        var G = this.curve.g;
        var Rraw = sig.slice(0, this.curve.adjustedSize);
        var sraw = sig.slice(this.curve.adjustedSize);
        var R = this.curve.decodePoint(Rraw);
        var s = this.curve.decodeAdjusted(sraw);
        var A = this.curve.decodePoint(key);
        if (s.cmp(n) >= 0) return false;
        var e = this.hashChallenge(Rraw, key, msg, ph, ctx);
        var sh = this.curve.imulH(s);
        var Ah = A.mulH();
        var Rh = R.mulH();
        return G.mulAdd(sh, Ah.neg(), e).eq(Rh);
      }
    }, {
      key: "verifyBatch",
      value: function verifyBatch(batch, ph, ctx) {
        if (ctx == null) ctx = Buffer.alloc(0);
        assert_1$1(Array.isArray(batch));
        assert_1$1(ph == null || typeof ph === 'boolean');
        assert_1$1(Buffer.isBuffer(ctx));

        var _iterator2 = _createForOfIteratorHelper$6(batch),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            assert_1$1(Array.isArray(item) && item.length === 3);

            var _item = _slicedToArray__default['default'](item, 3),
                msg = _item[0],
                sig = _item[1],
                key = _item[2];

            assert_1$1(Buffer.isBuffer(msg));
            assert_1$1(Buffer.isBuffer(sig));
            assert_1$1(Buffer.isBuffer(key));
            if (sig.length !== this.curve.adjustedSize * 2) return false;
            if (key.length !== this.curve.adjustedSize) return false;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        try {
          return this._verifyBatch(batch, ph, ctx);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "_verifyBatch",
      value: function _verifyBatch(batch, ph, ctx) {
        // EdDSA Batch Verification.
        //
        // [EDDSA] Page 16, Section 5.
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `R` and `s` be signature elements.
        //   - Let `A` be a valid group element.
        //   - Let `i` be the batch item index.
        //   - s < n.
        //   - a1 = 1 mod n.
        //
        // Computation:
        //
        //   ei = H(Ri, Ai, mi) mod n
        //   ai = random integer in [1,n-1]
        //   lhs = (si * ai + ...) * h mod n
        //   rhs = (Ri * h) * ai + (Ai * h) * (ei * ai mod n) + ...
        //   G * -lhs + rhs == O
        var n = this.curve.n;
        var G = this.curve.g;
        var points = new Array(1 + batch.length * 2);
        var coeffs = new Array(1 + batch.length * 2);
        var sum = new bnBrowser(0);
        this.rng.init(batch);
        points[0] = G;
        coeffs[0] = sum;

        for (var i = 0; i < batch.length; i++) {
          var _batch$i = _slicedToArray__default['default'](batch[i], 3),
              msg = _batch$i[0],
              sig = _batch$i[1],
              key = _batch$i[2];

          var Rraw = sig.slice(0, this.curve.adjustedSize);
          var sraw = sig.slice(this.curve.adjustedSize);
          var R = this.curve.decodePoint(Rraw);
          var s = this.curve.decodeAdjusted(sraw);
          var A = this.curve.decodePoint(key);
          if (s.cmp(n) >= 0) return false;
          var e = this.hashChallenge(Rraw, key, msg, ph, ctx);
          var a = this.rng.generate(i);
          var ea = e.mul(a).imod(n);
          sum.iadd(s.mul(a)).imod(n);
          points[1 + i * 2 + 0] = R.mulH();
          coeffs[1 + i * 2 + 0] = a;
          points[1 + i * 2 + 1] = A.mulH();
          coeffs[1 + i * 2 + 1] = ea;
        }

        this.curve.imulH(sum.ineg());
        return this.curve.mulAll(points, coeffs).isInfinity();
      }
    }, {
      key: "derive",
      value: function derive(pub, secret) {
        var scalar = this.privateKeyConvert(secret);
        return this.deriveWithScalar(pub, scalar);
      }
    }, {
      key: "deriveWithScalar",
      value: function deriveWithScalar(pub, scalar) {
        var A = this.curve.decodePoint(pub);
        var a = this.curve.decodeClamped(scalar);
        var P = A.mulConst(a, randomBrowser);
        if (P.isInfinity()) throw new Error('Invalid point.');
        return P.encode();
      }
    }, {
      key: "curve",
      get: function get() {
        if (!this._curve) {
          this._curve = elliptic.curve(this.id, this._pre);

          this._curve.precompute(randomBrowser);

          this._pre = null;
        }

        return this._curve;
      }
    }, {
      key: "mont",
      get: function get() {
        if (this.mid && !this._mont) this._mont = elliptic.curve(this.mid);
        return this._mont;
      }
    }, {
      key: "iso",
      get: function get() {
        if (!this.eid) return this.mont;
        if (!this._iso) this._iso = elliptic.curve(this.eid);
        return this._iso;
      }
    }, {
      key: "rng",
      get: function get() {
        if (!this._rng) this._rng = new batchRng(this.curve);
        return this._rng;
      }
    }, {
      key: "size",
      get: function get() {
        return this.curve.adjustedSize;
      }
    }, {
      key: "bits",
      get: function get() {
        return this.curve.fieldBits;
      }
    }]);

    return EDDSA;
  }();
  /*
   * Hash
   */


  var Hash = /*#__PURE__*/function () {
    function Hash(eddsa) {
      _classCallCheck__default['default'](this, Hash);

      this.curve = eddsa.curve; // eslint-disable-next-line

      this.hash = new eddsa.hash();
    }

    _createClass__default['default'](Hash, [{
      key: "init",
      value: function init(ph, ctx) {
        assert_1$1(ph == null || typeof ph === 'boolean');
        assert_1$1(Buffer.isBuffer(ctx));
        if (ctx.length > 255) ctx = ctx.slice(0, 255);
        this.hash.init();

        if (this.curve.context || ph != null || ctx.length > 0) {
          if (this.curve.prefix) this.hash.update(this.curve.prefix);
          this.hash.update(byte(ph));
          this.hash.update(byte(ctx.length));
          this.hash.update(ctx);
        }

        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        this.hash.update(data);
        return this;
      }
    }, {
      key: "final",
      value: function final() {
        var hash = this.hash.final(this.curve.adjustedSize * 2);
        var num = bnBrowser.decode(hash, this.curve.endian);
        return num.imod(this.curve.n);
      }
    }]);

    return Hash;
  }();
  /*
   * Helpers
   */


  function byte(ch) {
    var buf = Buffer.alloc(1);
    buf[0] = ch & 0xff;
    return buf;
  }
  /*
   * Expose
   */


  var eddsa = EDDSA;

  /*
   * Expose
   */


  var ed25519$2 = new eddsa('ED25519', 'X25519', null, sha512Browser, pre);

  var ed25519Browser = ed25519$2;

  function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHAKE
   */


  var SHAKE = /*#__PURE__*/function (_Keccak) {
    _inherits__default['default'](SHAKE, _Keccak);

    var _super = _createSuper$i(SHAKE);

    /**
     * Create a SHAKE Context.
     * @constructor
     */
    function SHAKE() {
      _classCallCheck__default['default'](this, SHAKE);

      return _super.call(this);
    }

    _createClass__default['default'](SHAKE, [{
      key: "final",
      value: function final(len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE.prototype), "final", this).call(this, 0x1f, len);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHAKE();
      }
    }, {
      key: "hmac",
      value: function hmac(bits, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE), "hmac", this).call(this, bits, 0x1f, len);
      }
    }, {
      key: "digest",
      value: function digest(data, bits, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE), "digest", this).call(this, data, bits, 0x1f, len);
      }
    }, {
      key: "root",
      value: function root(left, right, bits, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE), "root", this).call(this, left, right, bits, 0x1f, len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, bits, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE), "multi", this).call(this, x, y, z, bits, 0x1f, len);
      }
    }, {
      key: "mac",
      value: function mac(data, key, bits, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE), "mac", this).call(this, data, key, bits, 0x1f, len);
      }
    }]);

    return SHAKE;
  }(keccakBrowser);
  /*
   * Static
   */


  SHAKE.native = keccakBrowser.native;
  SHAKE.id = 'SHAKE256';
  SHAKE.size = 32;
  SHAKE.bits = 256;
  SHAKE.blockSize = 136;
  SHAKE.zero = Buffer.alloc(32, 0x00);
  SHAKE.ctx = new SHAKE();
  /*
   * Expose
   */

  var shake = SHAKE;

  function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHAKE256
   */


  var SHAKE256 = /*#__PURE__*/function (_SHAKE) {
    _inherits__default['default'](SHAKE256, _SHAKE);

    var _super = _createSuper$j(SHAKE256);

    function SHAKE256() {
      _classCallCheck__default['default'](this, SHAKE256);

      return _super.call(this);
    }

    _createClass__default['default'](SHAKE256, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE256.prototype), "init", this).call(this, 256);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHAKE256();
      }
    }, {
      key: "hmac",
      value: function hmac(len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE256), "hmac", this).call(this, 256, len);
      }
    }, {
      key: "digest",
      value: function digest(data, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE256), "digest", this).call(this, data, 256, len);
      }
    }, {
      key: "root",
      value: function root(left, right, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE256), "root", this).call(this, left, right, 256, len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE256), "multi", this).call(this, x, y, z, 256, len);
      }
    }, {
      key: "mac",
      value: function mac(data, key, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE256), "mac", this).call(this, data, key, 256, len);
      }
    }]);

    return SHAKE256;
  }(shake);
  /*
   * Static
   */


  SHAKE256.native = shake.native;
  SHAKE256.id = 'SHAKE256';
  SHAKE256.size = 32;
  SHAKE256.bits = 256;
  SHAKE256.blockSize = 136;
  SHAKE256.zero = Buffer.alloc(32, 0x00);
  SHAKE256.ctx = new SHAKE256();
  /*
   * Expose
   */

  var shake256 = SHAKE256;

  /*
   * Expose
   */


  var ed448 = new eddsa('ED448', 'X448', 'MONT448', shake256);

  var ed448Browser = ed448;

  var custom$3 = 'inspect';
  var customBrowser$1 = {
    custom: custom$3
  };

  /*!
   * enforce.js - type enforcement for bcoin
   * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcoin
   */
  /*
   * Enforce
   */

  function enforce$2(value, name, type) {
    if (!value) {
      var err = new TypeError("'".concat(name, "' must be a(n) ").concat(type, "."));
      if (Error.captureStackTrace) Error.captureStackTrace(err, enforce$2);
      throw err;
    }
  }
  /*
   * Expose
   */


  var enforce_1 = enforce$2;

  /*!
   * error.js - encoding error for bcoin
   * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
   * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcoin
   */

  function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var EncodingError = /*#__PURE__*/function (_Error) {
    _inherits__default['default'](EncodingError, _Error);

    var _super = _createSuper$k(EncodingError);

    /**
     * Create an encoding error.
     * @constructor
     * @param {Number} offset
     * @param {String} reason
     */
    function EncodingError(offset, reason, start) {
      var _this;

      _classCallCheck__default['default'](this, EncodingError);

      _this = _super.call(this);
      _this.type = 'EncodingError';
      _this.name = 'EncodingError';
      _this.code = 'ERR_ENCODING';
      _this.message = "".concat(reason, " (offset=").concat(offset, ").");
      if (Error.captureStackTrace) Error.captureStackTrace(_assertThisInitialized__default['default'](_this), start || EncodingError);
      return _this;
    }

    return EncodingError;
  }( /*#__PURE__*/_wrapNativeSuper__default['default'](Error));
  /*
   * Expose
   */


  var error = EncodingError;

  /*
   * Constants
   */


  var HI = 1 / 0x100000000;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
  var F32_ARRAY = new Float32Array(1);
  var F328_ARRAY = new Uint8Array(F32_ARRAY.buffer);
  var F64_ARRAY = new Float64Array(1);
  var F648_ARRAY = new Uint8Array(F64_ARRAY.buffer);
  F32_ARRAY[0] = -1;
  var BIG_ENDIAN$2 = F328_ARRAY[3] === 0;
  /*
   * Read Unsigned LE
   */

  function readU(data, off, len) {
    switch (len) {
      case 8:
        return readU64(data, off);

      case 7:
        return readU56(data, off);

      case 6:
        return readU48(data, off);

      case 5:
        return readU40(data, off);

      case 4:
        return readU32$f(data, off);

      case 3:
        return readU24(data, off);

      case 2:
        return readU16$3(data, off);

      case 1:
        return readU8(data, off);

      default:
        throw new error(off, 'Invalid read length');
    }
  }

  function readU64(data, off) {
    var hi = readU32$f(data, off + 4);
    var lo = readU32$f(data, off);
    check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
    return hi * 0x100000000 + lo;
  }

  function readU56(data, off) {
    var hi = readU24(data, off + 4);
    var lo = readU32$f(data, off);
    check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
    return hi * 0x100000000 + lo;
  }

  function readU48(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off++] * 0x1000000 + data[off++] * 0x100000000 + data[off] * 0x10000000000;
  }

  function readU40(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off++] * 0x1000000 + data[off] * 0x100000000;
  }

  function readU32$f(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }

  function readU24(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off] * 0x10000;
  }

  function readU16$3(data, off) {
    return data[off++] + data[off] * 0x100;
  }

  function readU8(data, off) {
    return data[off];
  }
  /*
   * Read Unsigned BE
   */


  function readUBE(data, off, len) {
    switch (len) {
      case 8:
        return readU64BE(data, off);

      case 7:
        return readU56BE(data, off);

      case 6:
        return readU48BE(data, off);

      case 5:
        return readU40BE(data, off);

      case 4:
        return readU32BE(data, off);

      case 3:
        return readU24BE(data, off);

      case 2:
        return readU16BE(data, off);

      case 1:
        return readU8(data, off);

      default:
        throw new error(off, 'Invalid read length');
    }
  }

  function readU64BE(data, off) {
    var hi = readU32BE(data, off);
    var lo = readU32BE(data, off + 4);
    check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
    return hi * 0x100000000 + lo;
  }

  function readU56BE(data, off) {
    var hi = readU24BE(data, off);
    var lo = readU32BE(data, off + 3);
    check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');
    return hi * 0x100000000 + lo;
  }

  function readU48BE(data, off) {
    return data[off++] * 0x10000000000 + data[off++] * 0x100000000 + data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function readU40BE(data, off) {
    return data[off++] * 0x100000000 + data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function readU32BE(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function readU24BE(data, off) {
    return data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function readU16BE(data, off) {
    return data[off++] * 0x100 + data[off];
  }
  /*
   * Read Signed LE
   */


  function readI(data, off, len) {
    switch (len) {
      case 8:
        return readI64(data, off);

      case 7:
        return readI56(data, off);

      case 6:
        return readI48(data, off);

      case 5:
        return readI40(data, off);

      case 4:
        return readI32(data, off);

      case 3:
        return readI24(data, off);

      case 2:
        return readI16(data, off);

      case 1:
        return readI8(data, off);

      default:
        throw new error(off, 'Invalid read length');
    }
  }

  function readI64(data, off) {
    var hi = readI32(data, off + 4);
    var lo = readU32$f(data, off);
    check(isSafe(hi, lo), 'Number exceeds 2^53-1');
    return hi * 0x100000000 + lo;
  }

  function readI56(data, off) {
    var hi = readI24(data, off + 4);
    var lo = readU32$f(data, off);
    check(isSafe(hi, lo), 'Number exceeds 2^53-1');
    return hi * 0x100000000 + lo;
  }

  function readI48(data, off) {
    var val = data[off + 4] + data[off + 5] * 0x100;
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000 + (val | (val & 0x8000) * 0x1fffe) * 0x100000000;
  }

  function readI40(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off++] * 0x1000000 + (data[off] | (data[off] & 0x80) * 0x1fffffe) * 0x100000000;
  }

  function readI32(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + (data[off] << 24);
  }

  function readI24(data, off) {
    var val = data[off++] + data[off++] * 0x100 + data[off] * 0x10000;
    return val | (val & 0x800000) * 0x1fe;
  }

  function readI16(data, off) {
    var val = data[off++] + data[off] * 0x100;
    return val | (val & 0x8000) * 0x1fffe;
  }

  function readI8(data, off) {
    var val = data[off];
    return val | (val & 0x80) * 0x1fffffe;
  }
  /*
   * Read Signed BE
   */


  function readIBE(data, off, len) {
    switch (len) {
      case 8:
        return readI64BE(data, off);

      case 7:
        return readI56BE(data, off);

      case 6:
        return readI48BE(data, off);

      case 5:
        return readI40BE(data, off);

      case 4:
        return readI32BE(data, off);

      case 3:
        return readI24BE(data, off);

      case 2:
        return readI16BE(data, off);

      case 1:
        return readI8(data, off);

      default:
        throw new error(off, 'Invalid read length');
    }
  }

  function readI64BE(data, off) {
    var hi = readI32BE(data, off);
    var lo = readU32BE(data, off + 4);
    check(isSafe(hi, lo), 'Number exceeds 2^53-1');
    return hi * 0x100000000 + lo;
  }

  function readI56BE(data, off) {
    var hi = readI24BE(data, off);
    var lo = readU32BE(data, off + 3);
    check(isSafe(hi, lo), 'Number exceeds 2^53-1');
    return hi * 0x100000000 + lo;
  }

  function readI48BE(data, off) {
    var val = data[off++] * 0x100 + data[off++];
    return (val | (val & 0x8000) * 0x1fffe) * 0x100000000 + data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function readI40BE(data, off) {
    var val = data[off++];
    return (val | (val & 0x80) * 0x1fffffe) * 0x100000000 + data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function readI32BE(data, off) {
    return (data[off++] << 24) + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function readI24BE(data, off) {
    var val = data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
    return val | (val & 0x800000) * 0x1fe;
  }

  function readI16BE(data, off) {
    var val = data[off++] * 0x100 + data[off];
    return val | (val & 0x8000) * 0x1fffe;
  }
  /*
   * Read Float
   */


  function _readFloatBackwards(data, off) {
    F328_ARRAY[3] = data[off++];
    F328_ARRAY[2] = data[off++];
    F328_ARRAY[1] = data[off++];
    F328_ARRAY[0] = data[off];
    return F32_ARRAY[0];
  }

  function _readFloatForwards(data, off) {
    F328_ARRAY[0] = data[off++];
    F328_ARRAY[1] = data[off++];
    F328_ARRAY[2] = data[off++];
    F328_ARRAY[3] = data[off];
    return F32_ARRAY[0];
  }

  function _readDoubleBackwards(data, off) {
    F648_ARRAY[7] = data[off++];
    F648_ARRAY[6] = data[off++];
    F648_ARRAY[5] = data[off++];
    F648_ARRAY[4] = data[off++];
    F648_ARRAY[3] = data[off++];
    F648_ARRAY[2] = data[off++];
    F648_ARRAY[1] = data[off++];
    F648_ARRAY[0] = data[off];
    return F64_ARRAY[0];
  }

  function _readDoubleForwards(data, off) {
    F648_ARRAY[0] = data[off++];
    F648_ARRAY[1] = data[off++];
    F648_ARRAY[2] = data[off++];
    F648_ARRAY[3] = data[off++];
    F648_ARRAY[4] = data[off++];
    F648_ARRAY[5] = data[off++];
    F648_ARRAY[6] = data[off++];
    F648_ARRAY[7] = data[off];
    return F64_ARRAY[0];
  }

  var readFloat = BIG_ENDIAN$2 ? _readFloatBackwards : _readFloatForwards;
  var readFloatBE = BIG_ENDIAN$2 ? _readFloatForwards : _readFloatBackwards;
  var readDouble = BIG_ENDIAN$2 ? _readDoubleBackwards : _readDoubleForwards;
  var readDoubleBE = BIG_ENDIAN$2 ? _readDoubleForwards : _readDoubleBackwards;
  /*
   * Write Unsigned LE
   */

  function writeU(dst, num, off, len) {
    switch (len) {
      case 8:
        return writeU64$1(dst, num, off);

      case 7:
        return writeU56(dst, num, off);

      case 6:
        return writeU48(dst, num, off);

      case 5:
        return writeU40(dst, num, off);

      case 4:
        return writeU32$e(dst, num, off);

      case 3:
        return writeU24(dst, num, off);

      case 2:
        return writeU16$3(dst, num, off);

      case 1:
        return writeU8(dst, num, off);

      default:
        throw new error(off, 'Invalid write length');
    }
  }

  function writeU64$1(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    return write64(dst, num, off, false);
  }

  function writeU56(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    return write56(dst, num, off, false);
  }

  function writeU48(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    var hi = num * HI | 0;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    dst[off++] = hi;
    dst[off++] = hi >>> 8;
    return off;
  }

  function writeU40(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    var hi = num * HI | 0;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    dst[off++] = hi;
    return off;
  }

  function writeU32$e(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }

  function writeU24(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }

  function writeU16$3(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    dst[off++] = num;
    dst[off++] = num >>> 8;
    return off;
  }

  function writeU8(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    dst[off] = num;
    return off + 1;
  }
  /*
   * Write Unsigned BE
   */


  function writeUBE(dst, num, off, len) {
    switch (len) {
      case 8:
        return writeU64BE(dst, num, off);

      case 7:
        return writeU56BE(dst, num, off);

      case 6:
        return writeU48BE(dst, num, off);

      case 5:
        return writeU40BE(dst, num, off);

      case 4:
        return writeU32BE(dst, num, off);

      case 3:
        return writeU24BE(dst, num, off);

      case 2:
        return writeU16BE(dst, num, off);

      case 1:
        return writeU8(dst, num, off);

      default:
        throw new error(off, 'Invalid write length');
    }
  }

  function writeU64BE(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    return write64(dst, num, off, true);
  }

  function writeU56BE(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    return write56(dst, num, off, true);
  }

  function writeU48BE(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    var hi = num * HI | 0;
    dst[off++] = hi >>> 8;
    dst[off++] = hi;
    dst[off + 3] = num;
    num >>>= 8;
    dst[off + 2] = num;
    num >>>= 8;
    dst[off + 1] = num;
    num >>>= 8;
    dst[off] = num;
    return off + 4;
  }

  function writeU40BE(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    var hi = num * HI | 0;
    dst[off++] = hi;
    dst[off + 3] = num;
    num >>>= 8;
    dst[off + 2] = num;
    num >>>= 8;
    dst[off + 1] = num;
    num >>>= 8;
    dst[off] = num;
    return off + 4;
  }

  function writeU32BE(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    dst[off + 3] = num;
    num >>>= 8;
    dst[off + 2] = num;
    num >>>= 8;
    dst[off + 1] = num;
    num >>>= 8;
    dst[off] = num;
    return off + 4;
  }

  function writeU24BE(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    dst[off + 2] = num;
    num >>>= 8;
    dst[off + 1] = num;
    num >>>= 8;
    dst[off] = num;
    return off + 3;
  }

  function writeU16BE(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    dst[off++] = num >>> 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Write Signed LE
   */


  function writeI(dst, num, off, len) {
    switch (len) {
      case 8:
        return writeU64$1(dst, num, off);

      case 7:
        return writeU56(dst, num, off);

      case 6:
        return writeU48(dst, num, off);

      case 5:
        return writeU40(dst, num, off);

      case 4:
        return writeU24(dst, num, off);

      case 3:
        return writeU32$e(dst, num, off);

      case 2:
        return writeU16$3(dst, num, off);

      case 1:
        return writeU8(dst, num, off);

      default:
        throw new error(off, 'Invalid write length');
    }
  }

  function writeI64(dst, num, off) {
    return writeU64$1(dst, num, off);
  }

  function writeI56(dst, num, off) {
    return writeU56(dst, num, off);
  }

  function writeI48(dst, num, off) {
    return writeU48(dst, num, off);
  }

  function writeI40(dst, num, off) {
    return writeU40(dst, num, off);
  }

  function writeI32(dst, num, off) {
    return writeU32$e(dst, num, off);
  }

  function writeI24(dst, num, off) {
    return writeU24(dst, num, off);
  }

  function writeI16(dst, num, off) {
    return writeU16$3(dst, num, off);
  }

  function writeI8(dst, num, off) {
    return writeU8(dst, num, off);
  }
  /*
   * Write Signed BE
   */


  function writeIBE(dst, num, off, len) {
    switch (len) {
      case 8:
        return writeU64BE(dst, num, off);

      case 7:
        return writeU56BE(dst, num, off);

      case 6:
        return writeU48BE(dst, num, off);

      case 5:
        return writeU40BE(dst, num, off);

      case 4:
        return writeU32BE(dst, num, off);

      case 3:
        return writeU24BE(dst, num, off);

      case 2:
        return writeU16BE(dst, num, off);

      case 1:
        return writeU8(dst, num, off);

      default:
        throw new error(off, 'Invalid write length');
    }
  }

  function writeI64BE(dst, num, off) {
    return writeU64BE(dst, num, off);
  }

  function writeI56BE(dst, num, off) {
    return writeU56BE(dst, num, off);
  }

  function writeI48BE(dst, num, off) {
    return writeU48BE(dst, num, off);
  }

  function writeI40BE(dst, num, off) {
    return writeU40BE(dst, num, off);
  }

  function writeI32BE(dst, num, off) {
    return writeU32BE(dst, num, off);
  }

  function writeI24BE(dst, num, off) {
    return writeU24BE(dst, num, off);
  }

  function writeI16BE(dst, num, off) {
    return writeU16BE(dst, num, off);
  }

  function _writeDoubleForwards(dst, num, off) {
    enforce_1(isNumber(num), 'num', 'number');
    F64_ARRAY[0] = num;
    dst[off++] = F648_ARRAY[0];
    dst[off++] = F648_ARRAY[1];
    dst[off++] = F648_ARRAY[2];
    dst[off++] = F648_ARRAY[3];
    dst[off++] = F648_ARRAY[4];
    dst[off++] = F648_ARRAY[5];
    dst[off++] = F648_ARRAY[6];
    dst[off++] = F648_ARRAY[7];
    return off;
  }

  function _writeDoubleBackwards(dst, num, off) {
    enforce_1(isNumber(num), 'num', 'number');
    F64_ARRAY[0] = num;
    dst[off++] = F648_ARRAY[7];
    dst[off++] = F648_ARRAY[6];
    dst[off++] = F648_ARRAY[5];
    dst[off++] = F648_ARRAY[4];
    dst[off++] = F648_ARRAY[3];
    dst[off++] = F648_ARRAY[2];
    dst[off++] = F648_ARRAY[1];
    dst[off++] = F648_ARRAY[0];
    return off;
  }

  function _writeFloatForwards(dst, num, off) {
    enforce_1(isNumber(num), 'num', 'number');
    F32_ARRAY[0] = num;
    dst[off++] = F328_ARRAY[0];
    dst[off++] = F328_ARRAY[1];
    dst[off++] = F328_ARRAY[2];
    dst[off++] = F328_ARRAY[3];
    return off;
  }

  function _writeFloatBackwards(dst, num, off) {
    enforce_1(isNumber(num), 'num', 'number');
    F32_ARRAY[0] = num;
    dst[off++] = F328_ARRAY[3];
    dst[off++] = F328_ARRAY[2];
    dst[off++] = F328_ARRAY[1];
    dst[off++] = F328_ARRAY[0];
    return off;
  }

  var writeFloat$2 = BIG_ENDIAN$2 ? _writeFloatBackwards : _writeFloatForwards;
  var writeFloatBE = BIG_ENDIAN$2 ? _writeFloatForwards : _writeFloatBackwards;
  var writeDouble$2 = BIG_ENDIAN$2 ? _writeDoubleBackwards : _writeDoubleForwards;
  var writeDoubleBE = BIG_ENDIAN$2 ? _writeDoubleForwards : _writeDoubleBackwards;
  /*
   * Varints
   */

  function readVarint(data, off) {
    var value, size;
    checkRead(off < data.length, off);

    switch (data[off]) {
      case 0xff:
        size = 9;
        checkRead(off + size <= data.length, off);
        value = readU64(data, off + 1);
        check(value > 0xffffffff, off, 'Non-canonical varint');
        break;

      case 0xfe:
        size = 5;
        checkRead(off + size <= data.length, off);
        value = readU32$f(data, off + 1);
        check(value > 0xffff, off, 'Non-canonical varint');
        break;

      case 0xfd:
        size = 3;
        checkRead(off + size <= data.length, off);
        value = readU16$3(data, off + 1);
        check(value >= 0xfd, off, 'Non-canonical varint');
        break;

      default:
        size = 1;
        value = data[off];
        break;
    }

    return new Varint(size, value);
  }

  function writeVarint(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');

    if (num < 0xfd) {
      dst[off++] = num;
      return off;
    }

    if (num <= 0xffff) {
      dst[off++] = 0xfd;
      return writeU16$3(dst, num, off);
    }

    if (num <= 0xffffffff) {
      dst[off++] = 0xfe;
      return writeU32$e(dst, num, off);
    }

    dst[off++] = 0xff;
    return writeU64$1(dst, num, off);
  }

  function sizeVarint(num) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    if (num < 0xfd) return 1;
    if (num <= 0xffff) return 3;
    if (num <= 0xffffffff) return 5;
    return 9;
  }

  function readVarint2(data, off) {
    var num = 0;
    var size = 0;

    for (;;) {
      checkRead(off < data.length, off);
      var ch = data[off++];
      size += 1; // Number.MAX_SAFE_INTEGER >>> 7

      check(num <= 0x3fffffffffff - (ch & 0x7f), off, 'Number exceeds 2^53-1'); // num = (num << 7) | (ch & 0x7f);

      num = num * 0x80 + (ch & 0x7f);
      if ((ch & 0x80) === 0) break;
      check(num !== MAX_SAFE_INTEGER, off, 'Number exceeds 2^53-1');
      num += 1;
    }

    return new Varint(size, num);
  }

  function writeVarint2(dst, num, off) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    var tmp = [];
    var len = 0;

    for (;;) {
      tmp[len] = num & 0x7f | (len ? 0x80 : 0x00);
      if (num <= 0x7f) break; // num = (num >>> 7) - 1;

      num = (num - num % 0x80) / 0x80 - 1;
      len += 1;
    }

    checkRead(off + len + 1 <= dst.length, off);

    do {
      dst[off++] = tmp[len];
    } while (len--);

    return off;
  }

  function sizeVarint2(num) {
    enforce_1(Number.isSafeInteger(num), 'num', 'integer');
    var size = 0;

    for (;;) {
      size += 1;
      if (num <= 0x7f) break; // num = (num >>> 7) - 1;

      num = (num - num % 0x80) / 0x80 - 1;
    }

    return size;
  }
  /*
   * Bytes
   */


  function sliceBytes(data, off, size) {
    enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
    enforce_1(off >>> 0 === off, 'off', 'integer');
    enforce_1(size >>> 0 === size, 'size', 'integer');
    if (off + size > data.length) throw new error(off, 'Out of bounds read');
    return data.slice(off, off + size);
  }

  function readBytes(data, off, size) {
    enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
    enforce_1(off >>> 0 === off, 'off', 'integer');
    enforce_1(size >>> 0 === size, 'size', 'integer');
    if (off + size > data.length) throw new error(off, 'Out of bounds read');
    var buf = Buffer.allocUnsafeSlow(size);
    data.copy(buf, 0, off, off + size);
    return buf;
  }

  function writeBytes(data, value, off) {
    enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
    enforce_1(Buffer.isBuffer(value), 'value', 'buffer');
    enforce_1(off >>> 0 === off, 'off', 'integer');
    if (off + value.length > data.length) throw new error(off, 'Out of bounds write');
    return value.copy(data, off, 0, value.length);
  }

  function readString(data, off, size, enc) {
    if (enc == null) enc = 'binary';
    enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
    enforce_1(off >>> 0 === off, 'off', 'integer');
    enforce_1(size >>> 0 === size, 'size', 'integer');
    enforce_1(typeof enc === 'string', 'enc', 'string');
    if (off + size > data.length) throw new error(off, 'Out of bounds read');
    return data.toString(enc, off, off + size);
  }

  function writeString(data, str, off, enc) {
    if (enc == null) enc = 'binary';
    enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
    enforce_1(typeof str === 'string', 'str', 'string');
    enforce_1(off >>> 0 === off, 'off', 'integer');
    enforce_1(typeof enc === 'string', 'enc', 'string');
    if (str.length === 0) return 0;
    var size = Buffer.byteLength(str, enc);
    if (off + size > data.length) throw new error(off, 'Out of bounds write');
    return data.write(str, off, enc);
  }

  function realloc(data, size) {
    enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
    var buf = Buffer.allocUnsafeSlow(size);
    data.copy(buf, 0);
    return buf;
  }

  function copy$1(data) {
    enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
    return realloc(data, data.length);
  }

  function concat(a, b) {
    enforce_1(Buffer.isBuffer(a), 'a', 'buffer');
    enforce_1(Buffer.isBuffer(b), 'b', 'buffer');
    var size = a.length + b.length;
    var buf = Buffer.allocUnsafeSlow(size);
    a.copy(buf, 0);
    b.copy(buf, a.length);
    return buf;
  }
  /*
   * Size Helpers
   */


  function sizeVarBytes(data) {
    enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
    return sizeVarint(data.length) + data.length;
  }

  function sizeVarlen(len) {
    return sizeVarint(len) + len;
  }

  function sizeVarString(str, enc) {
    if (enc == null) enc = 'binary';
    enforce_1(typeof str === 'string', 'str', 'string');
    enforce_1(typeof enc === 'string', 'enc', 'string');
    if (str.length === 0) return 1;
    var len = Buffer.byteLength(str, enc);
    return sizeVarint(len) + len;
  }
  /*
   * Helpers
   */


  function isSafe(hi, lo) {
    if (hi < 0) {
      hi = ~hi;
      if (lo === 0) hi += 1;
    }

    return (hi & 0xffe00000) === 0;
  }

  function write64(dst, num, off, be) {
    var neg = false;

    if (num < 0) {
      num = -num;
      neg = true;
    }

    var hi = num * HI | 0;
    var lo = num | 0;

    if (neg) {
      if (lo === 0) {
        hi = ~hi + 1 | 0;
      } else {
        hi = ~hi;
        lo = ~lo + 1;
      }
    }

    if (be) {
      off = writeI32BE(dst, hi, off);
      off = writeI32BE(dst, lo, off);
    } else {
      off = writeI32(dst, lo, off);
      off = writeI32(dst, hi, off);
    }

    return off;
  }

  function write56(dst, num, off, be) {
    var neg = false;

    if (num < 0) {
      num = -num;
      neg = true;
    }

    var hi = num * HI | 0;
    var lo = num | 0;

    if (neg) {
      if (lo === 0) {
        hi = ~hi + 1 | 0;
      } else {
        hi = ~hi;
        lo = ~lo + 1;
      }
    }

    if (be) {
      off = writeI24BE(dst, hi, off);
      off = writeI32BE(dst, lo, off);
    } else {
      off = writeI32(dst, lo, off);
      off = writeI24(dst, hi, off);
    }

    return off;
  }

  var Varint = function Varint(size, value) {
    _classCallCheck__default['default'](this, Varint);

    this.size = size;
    this.value = value;
  };

  function isNumber(num) {
    return typeof num === 'number' && isFinite(num);
  }

  function checkRead(value, offset) {
    if (!value) throw new error(offset, 'Out of bounds read', checkRead);
  }

  function check(value, offset, reason) {
    if (!value) throw new error(offset, reason, check);
  }
  /*
   * Expose
   */


  var readU_1 = readU;
  var readU64_1 = readU64;
  var readU56_1 = readU56;
  var readU48_1 = readU48;
  var readU40_1 = readU40;
  var readU32_1 = readU32$f;
  var readU24_1 = readU24;
  var readU16_1 = readU16$3;
  var readU8_1 = readU8;
  var readUBE_1 = readUBE;
  var readU64BE_1 = readU64BE;
  var readU56BE_1 = readU56BE;
  var readU48BE_1 = readU48BE;
  var readU40BE_1 = readU40BE;
  var readU32BE_1 = readU32BE;
  var readU24BE_1 = readU24BE;
  var readU16BE_1 = readU16BE;
  var readI_1 = readI;
  var readI64_1 = readI64;
  var readI56_1 = readI56;
  var readI48_1 = readI48;
  var readI40_1 = readI40;
  var readI32_1 = readI32;
  var readI24_1 = readI24;
  var readI16_1 = readI16;
  var readI8_1 = readI8;
  var readIBE_1 = readIBE;
  var readI64BE_1 = readI64BE;
  var readI56BE_1 = readI56BE;
  var readI48BE_1 = readI48BE;
  var readI40BE_1 = readI40BE;
  var readI32BE_1 = readI32BE;
  var readI24BE_1 = readI24BE;
  var readI16BE_1 = readI16BE;
  var readFloat_1 = readFloat;
  var readFloatBE_1 = readFloatBE;
  var readDouble_1 = readDouble;
  var readDoubleBE_1 = readDoubleBE;
  var writeU_1 = writeU;
  var writeU64_1 = writeU64$1;
  var writeU56_1 = writeU56;
  var writeU48_1 = writeU48;
  var writeU40_1 = writeU40;
  var writeU32_1 = writeU32$e;
  var writeU24_1 = writeU24;
  var writeU16_1 = writeU16$3;
  var writeU8_1 = writeU8;
  var writeUBE_1 = writeUBE;
  var writeU64BE_1 = writeU64BE;
  var writeU56BE_1 = writeU56BE;
  var writeU48BE_1 = writeU48BE;
  var writeU40BE_1 = writeU40BE;
  var writeU32BE_1 = writeU32BE;
  var writeU24BE_1 = writeU24BE;
  var writeU16BE_1 = writeU16BE;
  var writeI_1 = writeI;
  var writeI64_1 = writeI64;
  var writeI56_1 = writeI56;
  var writeI48_1 = writeI48;
  var writeI40_1 = writeI40;
  var writeI32_1 = writeI32;
  var writeI24_1 = writeI24;
  var writeI16_1 = writeI16;
  var writeI8_1 = writeI8;
  var writeIBE_1 = writeIBE;
  var writeI64BE_1 = writeI64BE;
  var writeI56BE_1 = writeI56BE;
  var writeI48BE_1 = writeI48BE;
  var writeI40BE_1 = writeI40BE;
  var writeI32BE_1 = writeI32BE;
  var writeI24BE_1 = writeI24BE;
  var writeI16BE_1 = writeI16BE;
  var writeFloat_1 = writeFloat$2;
  var writeFloatBE_1 = writeFloatBE;
  var writeDouble_1 = writeDouble$2;
  var writeDoubleBE_1 = writeDoubleBE;
  var readVarint_1 = readVarint;
  var writeVarint_1 = writeVarint;
  var sizeVarint_1 = sizeVarint;
  var readVarint2_1 = readVarint2;
  var writeVarint2_1 = writeVarint2;
  var sizeVarint2_1 = sizeVarint2;
  var sliceBytes_1 = sliceBytes;
  var readBytes_1 = readBytes;
  var writeBytes_1 = writeBytes;
  var readString_1 = readString;
  var writeString_1 = writeString;
  var realloc_1 = realloc;
  var copy_1 = copy$1;
  var concat_1 = concat;
  var sizeVarBytes_1 = sizeVarBytes;
  var sizeVarlen_1 = sizeVarlen;
  var sizeVarString_1 = sizeVarString;
  var encoding = {
    readU: readU_1,
    readU64: readU64_1,
    readU56: readU56_1,
    readU48: readU48_1,
    readU40: readU40_1,
    readU32: readU32_1,
    readU24: readU24_1,
    readU16: readU16_1,
    readU8: readU8_1,
    readUBE: readUBE_1,
    readU64BE: readU64BE_1,
    readU56BE: readU56BE_1,
    readU48BE: readU48BE_1,
    readU40BE: readU40BE_1,
    readU32BE: readU32BE_1,
    readU24BE: readU24BE_1,
    readU16BE: readU16BE_1,
    readI: readI_1,
    readI64: readI64_1,
    readI56: readI56_1,
    readI48: readI48_1,
    readI40: readI40_1,
    readI32: readI32_1,
    readI24: readI24_1,
    readI16: readI16_1,
    readI8: readI8_1,
    readIBE: readIBE_1,
    readI64BE: readI64BE_1,
    readI56BE: readI56BE_1,
    readI48BE: readI48BE_1,
    readI40BE: readI40BE_1,
    readI32BE: readI32BE_1,
    readI24BE: readI24BE_1,
    readI16BE: readI16BE_1,
    readFloat: readFloat_1,
    readFloatBE: readFloatBE_1,
    readDouble: readDouble_1,
    readDoubleBE: readDoubleBE_1,
    writeU: writeU_1,
    writeU64: writeU64_1,
    writeU56: writeU56_1,
    writeU48: writeU48_1,
    writeU40: writeU40_1,
    writeU32: writeU32_1,
    writeU24: writeU24_1,
    writeU16: writeU16_1,
    writeU8: writeU8_1,
    writeUBE: writeUBE_1,
    writeU64BE: writeU64BE_1,
    writeU56BE: writeU56BE_1,
    writeU48BE: writeU48BE_1,
    writeU40BE: writeU40BE_1,
    writeU32BE: writeU32BE_1,
    writeU24BE: writeU24BE_1,
    writeU16BE: writeU16BE_1,
    writeI: writeI_1,
    writeI64: writeI64_1,
    writeI56: writeI56_1,
    writeI48: writeI48_1,
    writeI40: writeI40_1,
    writeI32: writeI32_1,
    writeI24: writeI24_1,
    writeI16: writeI16_1,
    writeI8: writeI8_1,
    writeIBE: writeIBE_1,
    writeI64BE: writeI64BE_1,
    writeI56BE: writeI56BE_1,
    writeI48BE: writeI48BE_1,
    writeI40BE: writeI40BE_1,
    writeI32BE: writeI32BE_1,
    writeI24BE: writeI24BE_1,
    writeI16BE: writeI16BE_1,
    writeFloat: writeFloat_1,
    writeFloatBE: writeFloatBE_1,
    writeDouble: writeDouble_1,
    writeDoubleBE: writeDoubleBE_1,
    readVarint: readVarint_1,
    writeVarint: writeVarint_1,
    sizeVarint: sizeVarint_1,
    readVarint2: readVarint2_1,
    writeVarint2: writeVarint2_1,
    sizeVarint2: sizeVarint2_1,
    sliceBytes: sliceBytes_1,
    readBytes: readBytes_1,
    writeBytes: writeBytes_1,
    readString: readString_1,
    writeString: writeString_1,
    realloc: realloc_1,
    copy: copy_1,
    concat: concat_1,
    sizeVarBytes: sizeVarBytes_1,
    sizeVarlen: sizeVarlen_1,
    sizeVarString: sizeVarString_1
  };

  /*
   * Constants
   */


  var EMPTY$2 = Buffer.alloc(0);
  /**
   * Buffer Reader
   */

  var BufferReader = /*#__PURE__*/function () {
    /**
     * Create a buffer reader.
     * @constructor
     * @param {Buffer} data
     * @param {Boolean?} zeroCopy - Do not reallocate buffers when
     * slicing. Note that this can lead to memory leaks if not used
     * carefully.
     */
    function BufferReader(data) {
      var zeroCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _classCallCheck__default['default'](this, BufferReader);

      enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
      enforce_1(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');
      this.data = data;
      this.offset = 0;
      this.zeroCopy = zeroCopy;
      this.stack = [];
    }
    /**
     * Assertion.
     * @param {Number} size
     */


    _createClass__default['default'](BufferReader, [{
      key: "check",
      value: function check(size) {
        if (this.offset + size > this.data.length) throw new error(this.offset, 'Out of bounds read', this.check);
      }
      /**
       * Get total size of passed-in Buffer.
       * @returns {Buffer}
       */

    }, {
      key: "getSize",
      value: function getSize() {
        return this.data.length;
      }
      /**
       * Calculate number of bytes left to read.
       * @returns {Number}
       */

    }, {
      key: "left",
      value: function left() {
        this.check(0);
        return this.data.length - this.offset;
      }
      /**
       * Seek to a position to read from by offset.
       * @param {Number} off - Offset (positive or negative).
       */

    }, {
      key: "seek",
      value: function seek(off) {
        enforce_1(Number.isSafeInteger(off), 'off', 'integer');
        if (this.offset + off < 0) throw new error(this.offset, 'Out of bounds read');
        this.check(off);
        this.offset += off;
        return this;
      }
      /**
       * Mark the current starting position.
       */

    }, {
      key: "start",
      value: function start() {
        this.stack.push(this.offset);
        return this.offset;
      }
      /**
       * Stop reading. Pop the start position off the stack
       * and calculate the size of the data read.
       * @returns {Number} Size.
       * @throws on empty stack.
       */

    }, {
      key: "end",
      value: function end() {
        if (this.stack.length === 0) throw new Error('Cannot end without a stack item.');
        var start = this.stack.pop();
        return this.offset - start;
      }
      /**
       * Stop reading. Pop the start position off the stack
       * and return the data read.
       * @param {Bolean?} zeroCopy - Do a fast buffer
       * slice instead of allocating a new buffer (warning:
       * may cause memory leaks if not used with care).
       * @returns {Buffer} Data read.
       * @throws on empty stack.
       */

    }, {
      key: "endData",
      value: function endData() {
        var zeroCopy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        enforce_1(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');
        if (this.stack.length === 0) throw new Error('Cannot end without a stack item.');
        var start = this.stack.pop();
        var end = this.offset;
        var size = end - start;
        var data = this.data;
        if (size === data.length) return data;
        if (this.zeroCopy || zeroCopy) return data.slice(start, end);
        var ret = Buffer.allocUnsafeSlow(size);
        data.copy(ret, 0, start, end);
        return ret;
      }
      /**
       * Destroy the reader. Remove references to the data.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this.data = EMPTY$2;
        this.offset = 0;
        this.stack.length = 0;
        return this;
      }
      /**
       * Read uint8.
       * @returns {Number}
       */

    }, {
      key: "readU8",
      value: function readU8() {
        this.check(1);
        var ret = this.data[this.offset];
        this.offset += 1;
        return ret;
      }
      /**
       * Read uint16le.
       * @returns {Number}
       */

    }, {
      key: "readU16",
      value: function readU16() {
        this.check(2);
        var ret = encoding.readU16(this.data, this.offset);
        this.offset += 2;
        return ret;
      }
      /**
       * Read uint16be.
       * @returns {Number}
       */

    }, {
      key: "readU16BE",
      value: function readU16BE() {
        this.check(2);
        var ret = encoding.readU16BE(this.data, this.offset);
        this.offset += 2;
        return ret;
      }
      /**
       * Read uint24le.
       * @returns {Number}
       */

    }, {
      key: "readU24",
      value: function readU24() {
        this.check(3);
        var ret = encoding.readU24(this.data, this.offset);
        this.offset += 3;
        return ret;
      }
      /**
       * Read uint24be.
       * @returns {Number}
       */

    }, {
      key: "readU24BE",
      value: function readU24BE() {
        this.check(3);
        var ret = encoding.readU24BE(this.data, this.offset);
        this.offset += 3;
        return ret;
      }
      /**
       * Read uint32le.
       * @returns {Number}
       */

    }, {
      key: "readU32",
      value: function readU32() {
        this.check(4);
        var ret = encoding.readU32(this.data, this.offset);
        this.offset += 4;
        return ret;
      }
      /**
       * Read uint32be.
       * @returns {Number}
       */

    }, {
      key: "readU32BE",
      value: function readU32BE() {
        this.check(4);
        var ret = encoding.readU32BE(this.data, this.offset);
        this.offset += 4;
        return ret;
      }
      /**
       * Read uint40le.
       * @returns {Number}
       */

    }, {
      key: "readU40",
      value: function readU40() {
        this.check(5);
        var ret = encoding.readU40(this.data, this.offset);
        this.offset += 5;
        return ret;
      }
      /**
       * Read uint40be.
       * @returns {Number}
       */

    }, {
      key: "readU40BE",
      value: function readU40BE() {
        this.check(5);
        var ret = encoding.readU40BE(this.data, this.offset);
        this.offset += 5;
        return ret;
      }
      /**
       * Read uint48le.
       * @returns {Number}
       */

    }, {
      key: "readU48",
      value: function readU48() {
        this.check(6);
        var ret = encoding.readU48(this.data, this.offset);
        this.offset += 6;
        return ret;
      }
      /**
       * Read uint48be.
       * @returns {Number}
       */

    }, {
      key: "readU48BE",
      value: function readU48BE() {
        this.check(6);
        var ret = encoding.readU48BE(this.data, this.offset);
        this.offset += 6;
        return ret;
      }
      /**
       * Read uint56le.
       * @returns {Number}
       */

    }, {
      key: "readU56",
      value: function readU56() {
        this.check(7);
        var ret = encoding.readU56(this.data, this.offset);
        this.offset += 7;
        return ret;
      }
      /**
       * Read uint56be.
       * @returns {Number}
       */

    }, {
      key: "readU56BE",
      value: function readU56BE() {
        this.check(7);
        var ret = encoding.readU56BE(this.data, this.offset);
        this.offset += 7;
        return ret;
      }
      /**
       * Read uint64le as a js number.
       * @returns {Number}
       * @throws on num > MAX_SAFE_INTEGER
       */

    }, {
      key: "readU64",
      value: function readU64() {
        this.check(8);
        var ret = encoding.readU64(this.data, this.offset);
        this.offset += 8;
        return ret;
      }
      /**
       * Read uint64be as a js number.
       * @returns {Number}
       * @throws on num > MAX_SAFE_INTEGER
       */

    }, {
      key: "readU64BE",
      value: function readU64BE() {
        this.check(8);
        var ret = encoding.readU64BE(this.data, this.offset);
        this.offset += 8;
        return ret;
      }
      /**
       * Read int8.
       * @returns {Number}
       */

    }, {
      key: "readI8",
      value: function readI8() {
        this.check(1);
        var ret = encoding.readI8(this.data, this.offset);
        this.offset += 1;
        return ret;
      }
      /**
       * Read int16le.
       * @returns {Number}
       */

    }, {
      key: "readI16",
      value: function readI16() {
        this.check(2);
        var ret = encoding.readI16(this.data, this.offset);
        this.offset += 2;
        return ret;
      }
      /**
       * Read int16be.
       * @returns {Number}
       */

    }, {
      key: "readI16BE",
      value: function readI16BE() {
        this.check(2);
        var ret = encoding.readI16BE(this.data, this.offset);
        this.offset += 2;
        return ret;
      }
      /**
       * Read int24le.
       * @returns {Number}
       */

    }, {
      key: "readI24",
      value: function readI24() {
        this.check(3);
        var ret = encoding.readI24(this.data, this.offset);
        this.offset += 3;
        return ret;
      }
      /**
       * Read int24be.
       * @returns {Number}
       */

    }, {
      key: "readI24BE",
      value: function readI24BE() {
        this.check(3);
        var ret = encoding.readI24BE(this.data, this.offset);
        this.offset += 3;
        return ret;
      }
      /**
       * Read int32le.
       * @returns {Number}
       */

    }, {
      key: "readI32",
      value: function readI32() {
        this.check(4);
        var ret = encoding.readI32(this.data, this.offset);
        this.offset += 4;
        return ret;
      }
      /**
       * Read int32be.
       * @returns {Number}
       */

    }, {
      key: "readI32BE",
      value: function readI32BE() {
        this.check(4);
        var ret = encoding.readI32BE(this.data, this.offset);
        this.offset += 4;
        return ret;
      }
      /**
       * Read int40le.
       * @returns {Number}
       */

    }, {
      key: "readI40",
      value: function readI40() {
        this.check(5);
        var ret = encoding.readI40(this.data, this.offset);
        this.offset += 5;
        return ret;
      }
      /**
       * Read int40be.
       * @returns {Number}
       */

    }, {
      key: "readI40BE",
      value: function readI40BE() {
        this.check(5);
        var ret = encoding.readI40BE(this.data, this.offset);
        this.offset += 5;
        return ret;
      }
      /**
       * Read int48le.
       * @returns {Number}
       */

    }, {
      key: "readI48",
      value: function readI48() {
        this.check(6);
        var ret = encoding.readI48(this.data, this.offset);
        this.offset += 6;
        return ret;
      }
      /**
       * Read int48be.
       * @returns {Number}
       */

    }, {
      key: "readI48BE",
      value: function readI48BE() {
        this.check(6);
        var ret = encoding.readI48BE(this.data, this.offset);
        this.offset += 6;
        return ret;
      }
      /**
       * Read int56le.
       * @returns {Number}
       */

    }, {
      key: "readI56",
      value: function readI56() {
        this.check(7);
        var ret = encoding.readI56(this.data, this.offset);
        this.offset += 7;
        return ret;
      }
      /**
       * Read int56be.
       * @returns {Number}
       */

    }, {
      key: "readI56BE",
      value: function readI56BE() {
        this.check(7);
        var ret = encoding.readI56BE(this.data, this.offset);
        this.offset += 7;
        return ret;
      }
      /**
       * Read int64le as a js number.
       * @returns {Number}
       * @throws on num > MAX_SAFE_INTEGER
       */

    }, {
      key: "readI64",
      value: function readI64() {
        this.check(8);
        var ret = encoding.readI64(this.data, this.offset);
        this.offset += 8;
        return ret;
      }
      /**
       * Read int64be as a js number.
       * @returns {Number}
       * @throws on num > MAX_SAFE_INTEGER
       */

    }, {
      key: "readI64BE",
      value: function readI64BE() {
        this.check(8);
        var ret = encoding.readI64BE(this.data, this.offset);
        this.offset += 8;
        return ret;
      }
      /**
       * Read float le.
       * @returns {Number}
       */

    }, {
      key: "readFloat",
      value: function readFloat() {
        this.check(4);
        var ret = encoding.readFloat(this.data, this.offset);
        this.offset += 4;
        return ret;
      }
      /**
       * Read float be.
       * @returns {Number}
       */

    }, {
      key: "readFloatBE",
      value: function readFloatBE() {
        this.check(4);
        var ret = encoding.readFloatBE(this.data, this.offset);
        this.offset += 4;
        return ret;
      }
      /**
       * Read double float le.
       * @returns {Number}
       */

    }, {
      key: "readDouble",
      value: function readDouble() {
        this.check(8);
        var ret = encoding.readDouble(this.data, this.offset);
        this.offset += 8;
        return ret;
      }
      /**
       * Read double float be.
       * @returns {Number}
       */

    }, {
      key: "readDoubleBE",
      value: function readDoubleBE() {
        this.check(8);
        var ret = encoding.readDoubleBE(this.data, this.offset);
        this.offset += 8;
        return ret;
      }
      /**
       * Read a varint.
       * @returns {Number}
       */

    }, {
      key: "readVarint",
      value: function readVarint() {
        var _encoding$readVarint = encoding.readVarint(this.data, this.offset),
            size = _encoding$readVarint.size,
            value = _encoding$readVarint.value;

        this.offset += size;
        return value;
      }
      /**
       * Read a varint (type 2).
       * @returns {Number}
       */

    }, {
      key: "readVarint2",
      value: function readVarint2() {
        var _encoding$readVarint2 = encoding.readVarint2(this.data, this.offset),
            size = _encoding$readVarint2.size,
            value = _encoding$readVarint2.value;

        this.offset += size;
        return value;
      }
      /**
       * Read N bytes (will do a fast slice if zero copy).
       * @param {Number} size
       * @param {Bolean?} zeroCopy - Do a fast buffer
       * slice instead of allocating a new buffer (warning:
       * may cause memory leaks if not used with care).
       * @returns {Buffer}
       */

    }, {
      key: "readBytes",
      value: function readBytes(size) {
        var zeroCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        enforce_1(size >>> 0 === size, 'size', 'integer');
        enforce_1(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');
        this.check(size);
        var ret;

        if (this.zeroCopy || zeroCopy) {
          ret = this.data.slice(this.offset, this.offset + size);
        } else {
          ret = Buffer.allocUnsafeSlow(size);
          this.data.copy(ret, 0, this.offset, this.offset + size);
        }

        this.offset += size;
        return ret;
      }
      /**
       * Read a varint number of bytes (will do a fast slice if zero copy).
       * @param {Bolean?} zeroCopy - Do a fast buffer
       * slice instead of allocating a new buffer (warning:
       * may cause memory leaks if not used with care).
       * @returns {Buffer}
       */

    }, {
      key: "readVarBytes",
      value: function readVarBytes() {
        var zeroCopy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return this.readBytes(this.readVarint(), zeroCopy);
      }
      /**
       * Slice N bytes and create a child reader.
       * @param {Number} size
       * @returns {BufferReader}
       */

    }, {
      key: "readChild",
      value: function readChild(size) {
        enforce_1(size >>> 0 === size, 'size', 'integer');
        this.check(size);
        var data = this.data.slice(0, this.offset + size);
        var br = new this.constructor(data);
        br.offset = this.offset;
        this.offset += size;
        return br;
      }
      /**
       * Read a string.
       * @param {Number} size
       * @param {String} enc - Any buffer-supported encoding.
       * @returns {String}
       */

    }, {
      key: "readString",
      value: function readString(size, enc) {
        if (enc == null) enc = 'binary';
        enforce_1(size >>> 0 === size, 'size', 'integer');
        enforce_1(typeof enc === 'string', 'enc', 'string');
        this.check(size);
        var ret = this.data.toString(enc, this.offset, this.offset + size);
        this.offset += size;
        return ret;
      }
      /**
       * Read a 32-byte hash.
       * @param {String} enc - `"hex"` or `null`.
       * @returns {Hash|Buffer}
       */

    }, {
      key: "readHash",
      value: function readHash(enc) {
        if (enc) return this.readString(32, enc);
        return this.readBytes(32);
      }
      /**
       * Read string of a varint length.
       * @param {String} enc - Any buffer-supported encoding.
       * @param {Number?} limit - Size limit.
       * @returns {String}
       */

    }, {
      key: "readVarString",
      value: function readVarString(enc) {
        var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        if (enc == null) enc = 'binary';
        enforce_1(typeof enc === 'string', 'enc', 'string');
        enforce_1(limit >>> 0 === limit, 'limit', 'integer');
        var size = this.readVarint();
        if (limit !== 0 && size > limit) throw new error(this.offset, 'String exceeds limit');
        return this.readString(size, enc);
      }
      /**
       * Read a null-terminated string.
       * @param {String} enc - Any buffer-supported encoding.
       * @returns {String}
       */

    }, {
      key: "readNullString",
      value: function readNullString(enc) {
        if (enc == null) enc = 'binary';
        enforce_1(typeof enc === 'string', 'enc', 'string');
        var i = this.offset;

        for (; i < this.data.length; i++) {
          if (this.data[i] === 0) break;
        }

        if (i === this.data.length) throw new error(this.offset, 'No NUL terminator');
        var ret = this.readString(i - this.offset, enc);
        this.offset = i + 1;
        return ret;
      }
      /**
       * Create a checksum from the last start position.
       * @param {Function} hash
       * @returns {Number} Checksum.
       */

    }, {
      key: "createChecksum",
      value: function createChecksum(hash) {
        if (!hash || typeof hash.digest !== 'function') enforce_1(typeof hash === 'function', 'hash', 'function');
        var start = 0;
        if (this.stack.length > 0) start = this.stack[this.stack.length - 1];
        var data = this.data.slice(start, this.offset);
        var raw = hash.digest ? hash.digest(data) : hash(data);
        return encoding.readU32(raw, 0);
      }
      /**
       * Verify a 4-byte checksum against a calculated checksum.
       * @param {Function} hash
       * @returns {Number} checksum
       * @throws on bad checksum
       */

    }, {
      key: "verifyChecksum",
      value: function verifyChecksum(hash) {
        var checksum = this.createChecksum(hash);
        var expect = this.readU32();
        if (checksum !== expect) throw new error(this.offset, 'Checksum mismatch');
        return checksum;
      }
    }]);

    return BufferReader;
  }();
  /*
   * Expose
   */


  var reader = BufferReader;

  function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _createForOfIteratorHelper$7(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

  function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /*
   * Constants
   */


  var SEEK = 0;
  var U8 = 1;
  var U16 = 2;
  var U16BE = 3;
  var U24 = 4;
  var U24BE = 5;
  var U32 = 6;
  var U32BE = 7;
  var U40 = 8;
  var U40BE = 9;
  var U48 = 10;
  var U48BE = 11;
  var U56 = 12;
  var U56BE = 13;
  var U64$1 = 14;
  var U64BE = 15;
  var I8 = 16;
  var I16 = 17;
  var I16BE = 18;
  var I24 = 19;
  var I24BE = 20;
  var I32 = 21;
  var I32BE = 22;
  var I40 = 23;
  var I40BE = 24;
  var I48 = 25;
  var I48BE = 26;
  var I56 = 27;
  var I56BE = 28;
  var I64 = 29;
  var I64BE = 30;
  var FL = 31;
  var FLBE = 32;
  var DBL = 33;
  var DBLBE = 34;
  var VARINT = 35;
  var VARINT2 = 36;
  var BYTES = 37;
  var STR = 38;
  var CHECKSUM = 39;
  var FILL = 40;
  /**
   * Buffer Writer
   */

  var BufferWriter = /*#__PURE__*/function () {
    /**
     * Create a buffer writer.
     * @constructor
     */
    function BufferWriter() {
      _classCallCheck__default['default'](this, BufferWriter);

      this.ops = [];
      this.offset = 0;
    }
    /**
     * Allocate and render the final buffer.
     * @returns {Buffer} Rendered buffer.
     */


    _createClass__default['default'](BufferWriter, [{
      key: "render",
      value: function render() {
        var data = Buffer.allocUnsafeSlow(this.offset);
        var off = 0;

        var _iterator = _createForOfIteratorHelper$7(this.ops),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var op = _step.value;

            switch (op.type) {
              case SEEK:
                off += op.value;
                break;

              case U8:
                off = encoding.writeU8(data, op.value, off);
                break;

              case U16:
                off = encoding.writeU16(data, op.value, off);
                break;

              case U16BE:
                off = encoding.writeU16BE(data, op.value, off);
                break;

              case U24:
                off = encoding.writeU24(data, op.value, off);
                break;

              case U24BE:
                off = encoding.writeU24BE(data, op.value, off);
                break;

              case U32:
                off = encoding.writeU32(data, op.value, off);
                break;

              case U32BE:
                off = encoding.writeU32BE(data, op.value, off);
                break;

              case U40:
                off = encoding.writeU40(data, op.value, off);
                break;

              case U40BE:
                off = encoding.writeU40BE(data, op.value, off);
                break;

              case U48:
                off = encoding.writeU48(data, op.value, off);
                break;

              case U48BE:
                off = encoding.writeU48BE(data, op.value, off);
                break;

              case U56:
                off = encoding.writeU56(data, op.value, off);
                break;

              case U56BE:
                off = encoding.writeU56BE(data, op.value, off);
                break;

              case U64$1:
                off = encoding.writeU64(data, op.value, off);
                break;

              case U64BE:
                off = encoding.writeU64BE(data, op.value, off);
                break;

              case I8:
                off = encoding.writeI8(data, op.value, off);
                break;

              case I16:
                off = encoding.writeI16(data, op.value, off);
                break;

              case I16BE:
                off = encoding.writeI16BE(data, op.value, off);
                break;

              case I24:
                off = encoding.writeI24(data, op.value, off);
                break;

              case I24BE:
                off = encoding.writeI24BE(data, op.value, off);
                break;

              case I32:
                off = encoding.writeI32(data, op.value, off);
                break;

              case I32BE:
                off = encoding.writeI32BE(data, op.value, off);
                break;

              case I40:
                off = encoding.writeI40(data, op.value, off);
                break;

              case I40BE:
                off = encoding.writeI40BE(data, op.value, off);
                break;

              case I48:
                off = encoding.writeI48(data, op.value, off);
                break;

              case I48BE:
                off = encoding.writeI48BE(data, op.value, off);
                break;

              case I56:
                off = encoding.writeI56(data, op.value, off);
                break;

              case I56BE:
                off = encoding.writeI56BE(data, op.value, off);
                break;

              case I64:
                off = encoding.writeI64(data, op.value, off);
                break;

              case I64BE:
                off = encoding.writeI64BE(data, op.value, off);
                break;

              case FL:
                off = encoding.writeFloat(data, op.value, off);
                break;

              case FLBE:
                off = encoding.writeFloatBE(data, op.value, off);
                break;

              case DBL:
                off = encoding.writeDouble(data, op.value, off);
                break;

              case DBLBE:
                off = encoding.writeDoubleBE(data, op.value, off);
                break;

              case VARINT:
                off = encoding.writeVarint(data, op.value, off);
                break;

              case VARINT2:
                off = encoding.writeVarint2(data, op.value, off);
                break;

              case BYTES:
                off += op.data.copy(data, off);
                break;

              case STR:
                off += data.write(op.value, off, op.enc);
                break;

              case CHECKSUM:
                off += op.func(data.slice(0, off)).copy(data, off, 0, 4);
                break;

              case FILL:
                data.fill(op.value, off, off + op.size);
                off += op.size;
                break;

              default:
                throw new Error('Invalid type.');
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (off !== data.length) throw new error(off, 'Out of bounds write');
        this.destroy();
        return data;
      }
      /**
       * Get size of data written so far.
       * @returns {Number}
       */

    }, {
      key: "getSize",
      value: function getSize() {
        return this.offset;
      }
      /**
       * Seek to relative offset.
       * @param {Number} offset
       */

    }, {
      key: "seek",
      value: function seek(off) {
        enforce_1(Number.isSafeInteger(off), 'off', 'integer');
        if (this.offset + off < 0) throw new error(this.offset, 'Out of bounds write');
        this.offset += off;
        this.ops.push(new NumberOp(SEEK, off));
        return this;
      }
      /**
       * Destroy the buffer writer. Remove references to `ops`.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this.ops.length = 0;
        this.offset = 0;
        return this;
      }
      /**
       * Write uint8.
       * @param {Number} value
       */

    }, {
      key: "writeU8",
      value: function writeU8(value) {
        this.offset += 1;
        this.ops.push(new NumberOp(U8, value));
        return this;
      }
      /**
       * Write uint16le.
       * @param {Number} value
       */

    }, {
      key: "writeU16",
      value: function writeU16(value) {
        this.offset += 2;
        this.ops.push(new NumberOp(U16, value));
        return this;
      }
      /**
       * Write uint16be.
       * @param {Number} value
       */

    }, {
      key: "writeU16BE",
      value: function writeU16BE(value) {
        this.offset += 2;
        this.ops.push(new NumberOp(U16BE, value));
        return this;
      }
      /**
       * Write uint24le.
       * @param {Number} value
       */

    }, {
      key: "writeU24",
      value: function writeU24(value) {
        this.offset += 3;
        this.ops.push(new NumberOp(U24, value));
        return this;
      }
      /**
       * Write uint24be.
       * @param {Number} value
       */

    }, {
      key: "writeU24BE",
      value: function writeU24BE(value) {
        this.offset += 3;
        this.ops.push(new NumberOp(U24BE, value));
        return this;
      }
      /**
       * Write uint32le.
       * @param {Number} value
       */

    }, {
      key: "writeU32",
      value: function writeU32(value) {
        this.offset += 4;
        this.ops.push(new NumberOp(U32, value));
        return this;
      }
      /**
       * Write uint32be.
       * @param {Number} value
       */

    }, {
      key: "writeU32BE",
      value: function writeU32BE(value) {
        this.offset += 4;
        this.ops.push(new NumberOp(U32BE, value));
        return this;
      }
      /**
       * Write uint40le.
       * @param {Number} value
       */

    }, {
      key: "writeU40",
      value: function writeU40(value) {
        this.offset += 5;
        this.ops.push(new NumberOp(U40, value));
        return this;
      }
      /**
       * Write uint40be.
       * @param {Number} value
       */

    }, {
      key: "writeU40BE",
      value: function writeU40BE(value) {
        this.offset += 5;
        this.ops.push(new NumberOp(U40BE, value));
        return this;
      }
      /**
       * Write uint48le.
       * @param {Number} value
       */

    }, {
      key: "writeU48",
      value: function writeU48(value) {
        this.offset += 6;
        this.ops.push(new NumberOp(U48, value));
        return this;
      }
      /**
       * Write uint48be.
       * @param {Number} value
       */

    }, {
      key: "writeU48BE",
      value: function writeU48BE(value) {
        this.offset += 6;
        this.ops.push(new NumberOp(U48BE, value));
        return this;
      }
      /**
       * Write uint56le.
       * @param {Number} value
       */

    }, {
      key: "writeU56",
      value: function writeU56(value) {
        this.offset += 7;
        this.ops.push(new NumberOp(U56, value));
        return this;
      }
      /**
       * Write uint56be.
       * @param {Number} value
       */

    }, {
      key: "writeU56BE",
      value: function writeU56BE(value) {
        this.offset += 7;
        this.ops.push(new NumberOp(U56BE, value));
        return this;
      }
      /**
       * Write uint64le.
       * @param {Number} value
       */

    }, {
      key: "writeU64",
      value: function writeU64(value) {
        this.offset += 8;
        this.ops.push(new NumberOp(U64$1, value));
        return this;
      }
      /**
       * Write uint64be.
       * @param {Number} value
       */

    }, {
      key: "writeU64BE",
      value: function writeU64BE(value) {
        this.offset += 8;
        this.ops.push(new NumberOp(U64BE, value));
        return this;
      }
      /**
       * Write int8.
       * @param {Number} value
       */

    }, {
      key: "writeI8",
      value: function writeI8(value) {
        this.offset += 1;
        this.ops.push(new NumberOp(I8, value));
        return this;
      }
      /**
       * Write int16le.
       * @param {Number} value
       */

    }, {
      key: "writeI16",
      value: function writeI16(value) {
        this.offset += 2;
        this.ops.push(new NumberOp(I16, value));
        return this;
      }
      /**
       * Write int16be.
       * @param {Number} value
       */

    }, {
      key: "writeI16BE",
      value: function writeI16BE(value) {
        this.offset += 2;
        this.ops.push(new NumberOp(I16BE, value));
        return this;
      }
      /**
       * Write int24le.
       * @param {Number} value
       */

    }, {
      key: "writeI24",
      value: function writeI24(value) {
        this.offset += 3;
        this.ops.push(new NumberOp(I24, value));
        return this;
      }
      /**
       * Write int24be.
       * @param {Number} value
       */

    }, {
      key: "writeI24BE",
      value: function writeI24BE(value) {
        this.offset += 3;
        this.ops.push(new NumberOp(I24BE, value));
        return this;
      }
      /**
       * Write int32le.
       * @param {Number} value
       */

    }, {
      key: "writeI32",
      value: function writeI32(value) {
        this.offset += 4;
        this.ops.push(new NumberOp(I32, value));
        return this;
      }
      /**
       * Write int32be.
       * @param {Number} value
       */

    }, {
      key: "writeI32BE",
      value: function writeI32BE(value) {
        this.offset += 4;
        this.ops.push(new NumberOp(I32BE, value));
        return this;
      }
      /**
       * Write int40le.
       * @param {Number} value
       */

    }, {
      key: "writeI40",
      value: function writeI40(value) {
        this.offset += 5;
        this.ops.push(new NumberOp(I40, value));
        return this;
      }
      /**
       * Write int40be.
       * @param {Number} value
       */

    }, {
      key: "writeI40BE",
      value: function writeI40BE(value) {
        this.offset += 5;
        this.ops.push(new NumberOp(I40BE, value));
        return this;
      }
      /**
       * Write int48le.
       * @param {Number} value
       */

    }, {
      key: "writeI48",
      value: function writeI48(value) {
        this.offset += 6;
        this.ops.push(new NumberOp(I48, value));
        return this;
      }
      /**
       * Write int48be.
       * @param {Number} value
       */

    }, {
      key: "writeI48BE",
      value: function writeI48BE(value) {
        this.offset += 6;
        this.ops.push(new NumberOp(I48BE, value));
        return this;
      }
      /**
       * Write int56le.
       * @param {Number} value
       */

    }, {
      key: "writeI56",
      value: function writeI56(value) {
        this.offset += 7;
        this.ops.push(new NumberOp(I56, value));
        return this;
      }
      /**
       * Write int56be.
       * @param {Number} value
       */

    }, {
      key: "writeI56BE",
      value: function writeI56BE(value) {
        this.offset += 7;
        this.ops.push(new NumberOp(I56BE, value));
        return this;
      }
      /**
       * Write int64le.
       * @param {Number} value
       */

    }, {
      key: "writeI64",
      value: function writeI64(value) {
        this.offset += 8;
        this.ops.push(new NumberOp(I64, value));
        return this;
      }
      /**
       * Write int64be.
       * @param {Number} value
       */

    }, {
      key: "writeI64BE",
      value: function writeI64BE(value) {
        this.offset += 8;
        this.ops.push(new NumberOp(I64BE, value));
        return this;
      }
      /**
       * Write float le.
       * @param {Number} value
       */

    }, {
      key: "writeFloat",
      value: function writeFloat(value) {
        this.offset += 4;
        this.ops.push(new NumberOp(FL, value));
        return this;
      }
      /**
       * Write float be.
       * @param {Number} value
       */

    }, {
      key: "writeFloatBE",
      value: function writeFloatBE(value) {
        this.offset += 4;
        this.ops.push(new NumberOp(FLBE, value));
        return this;
      }
      /**
       * Write double le.
       * @param {Number} value
       */

    }, {
      key: "writeDouble",
      value: function writeDouble(value) {
        this.offset += 8;
        this.ops.push(new NumberOp(DBL, value));
        return this;
      }
      /**
       * Write double be.
       * @param {Number} value
       */

    }, {
      key: "writeDoubleBE",
      value: function writeDoubleBE(value) {
        this.offset += 8;
        this.ops.push(new NumberOp(DBLBE, value));
        return this;
      }
      /**
       * Write a varint.
       * @param {Number} value
       */

    }, {
      key: "writeVarint",
      value: function writeVarint(value) {
        this.offset += encoding.sizeVarint(value);
        this.ops.push(new NumberOp(VARINT, value));
        return this;
      }
      /**
       * Write a varint (type 2).
       * @param {Number} value
       */

    }, {
      key: "writeVarint2",
      value: function writeVarint2(value) {
        this.offset += encoding.sizeVarint2(value);
        this.ops.push(new NumberOp(VARINT2, value));
        return this;
      }
      /**
       * Write bytes.
       * @param {Buffer} value
       */

    }, {
      key: "writeBytes",
      value: function writeBytes(value) {
        enforce_1(Buffer.isBuffer(value), 'value', 'buffer');
        if (value.length === 0) return this;
        this.offset += value.length;
        this.ops.push(new BufferOp(BYTES, value));
        return this;
      }
      /**
       * Write bytes with a varint length before them.
       * @param {Buffer} value
       */

    }, {
      key: "writeVarBytes",
      value: function writeVarBytes(value) {
        enforce_1(Buffer.isBuffer(value), 'value', 'buffer');
        this.offset += encoding.sizeVarint(value.length);
        this.ops.push(new NumberOp(VARINT, value.length));
        if (value.length === 0) return this;
        this.offset += value.length;
        this.ops.push(new BufferOp(BYTES, value));
        return this;
      }
      /**
       * Copy bytes.
       * @param {Buffer} value
       * @param {Number} start
       * @param {Number} end
       */

    }, {
      key: "copy",
      value: function copy(value, start, end) {
        enforce_1(Buffer.isBuffer(value), 'value', 'buffer');
        enforce_1(start >>> 0 === start, 'start', 'integer');
        enforce_1(end >>> 0 === end, 'end', 'integer');
        enforce_1(end >= start, 'start', 'integer');
        var buf = value.slice(start, end);
        this.writeBytes(buf);
        return this;
      }
      /**
       * Write string to buffer.
       * @param {String} value
       * @param {String?} enc - Any buffer-supported encoding.
       */

    }, {
      key: "writeString",
      value: function writeString(value, enc) {
        if (enc == null) enc = 'binary';
        enforce_1(typeof value === 'string', 'value', 'string');
        enforce_1(typeof enc === 'string', 'enc', 'string');
        if (value.length === 0) return this;
        this.offset += Buffer.byteLength(value, enc);
        this.ops.push(new StringOp(STR, value, enc));
        return this;
      }
      /**
       * Write a 32 byte hash.
       * @param {Hash} value
       */

    }, {
      key: "writeHash",
      value: function writeHash(value) {
        if (typeof value !== 'string') {
          enforce_1(Buffer.isBuffer(value), 'value', 'buffer');
          enforce_1(value.length === 32, 'value', '32-byte hash');
          this.writeBytes(value);
          return this;
        }

        enforce_1(value.length === 64, 'value', '32-byte hash');
        this.writeString(value, 'hex');
        return this;
      }
      /**
       * Write a string with a varint length before it.
       * @param {String}
       * @param {String?} enc - Any buffer-supported encoding.
       */

    }, {
      key: "writeVarString",
      value: function writeVarString(value, enc) {
        if (enc == null) enc = 'binary';
        enforce_1(typeof value === 'string', 'value', 'string');
        enforce_1(typeof enc === 'string', 'enc', 'string');

        if (value.length === 0) {
          this.ops.push(new NumberOp(VARINT, 0));
          return this;
        }

        var size = Buffer.byteLength(value, enc);
        this.offset += encoding.sizeVarint(size);
        this.offset += size;
        this.ops.push(new NumberOp(VARINT, size));
        this.ops.push(new StringOp(STR, value, enc));
        return this;
      }
      /**
       * Write a null-terminated string.
       * @param {String|Buffer}
       * @param {String?} enc - Any buffer-supported encoding.
       */

    }, {
      key: "writeNullString",
      value: function writeNullString(value, enc) {
        this.writeString(value, enc);
        this.writeU8(0);
        return this;
      }
      /**
       * Calculate and write a checksum for the data written so far.
       * @param {Function} hash
       */

    }, {
      key: "writeChecksum",
      value: function writeChecksum(hash) {
        if (hash && typeof hash.digest === 'function') hash = hash.digest.bind(hash);
        enforce_1(typeof hash === 'function', 'hash', 'function');
        this.offset += 4;
        this.ops.push(new FunctionOp(CHECKSUM, hash));
        return this;
      }
      /**
       * Fill N bytes with value.
       * @param {Number} value
       * @param {Number} size
       */

    }, {
      key: "fill",
      value: function fill(value, size) {
        enforce_1((value & 0xff) === value, 'value', 'byte');
        enforce_1(size >>> 0 === size, 'size', 'integer');
        if (size === 0) return this;
        this.offset += size;
        this.ops.push(new FillOp(FILL, value, size));
        return this;
      }
    }]);

    return BufferWriter;
  }();
  /*
   * Helpers
   */


  var WriteOp = function WriteOp(type) {
    _classCallCheck__default['default'](this, WriteOp);

    this.type = type;
  };

  var NumberOp = /*#__PURE__*/function (_WriteOp) {
    _inherits__default['default'](NumberOp, _WriteOp);

    var _super = _createSuper$l(NumberOp);

    function NumberOp(type, value) {
      var _this;

      _classCallCheck__default['default'](this, NumberOp);

      _this = _super.call(this, type);
      _this.value = value;
      return _this;
    }

    return NumberOp;
  }(WriteOp);

  var BufferOp = /*#__PURE__*/function (_WriteOp2) {
    _inherits__default['default'](BufferOp, _WriteOp2);

    var _super2 = _createSuper$l(BufferOp);

    function BufferOp(type, data) {
      var _this2;

      _classCallCheck__default['default'](this, BufferOp);

      _this2 = _super2.call(this, type);
      _this2.data = data;
      return _this2;
    }

    return BufferOp;
  }(WriteOp);

  var StringOp = /*#__PURE__*/function (_WriteOp3) {
    _inherits__default['default'](StringOp, _WriteOp3);

    var _super3 = _createSuper$l(StringOp);

    function StringOp(type, value, enc) {
      var _this3;

      _classCallCheck__default['default'](this, StringOp);

      _this3 = _super3.call(this, type);
      _this3.value = value;
      _this3.enc = enc;
      return _this3;
    }

    return StringOp;
  }(WriteOp);

  var FunctionOp = /*#__PURE__*/function (_WriteOp4) {
    _inherits__default['default'](FunctionOp, _WriteOp4);

    var _super4 = _createSuper$l(FunctionOp);

    function FunctionOp(type, func) {
      var _this4;

      _classCallCheck__default['default'](this, FunctionOp);

      _this4 = _super4.call(this, type);
      _this4.func = func;
      return _this4;
    }

    return FunctionOp;
  }(WriteOp);

  var FillOp = /*#__PURE__*/function (_WriteOp5) {
    _inherits__default['default'](FillOp, _WriteOp5);

    var _super5 = _createSuper$l(FillOp);

    function FillOp(type, value, size) {
      var _this5;

      _classCallCheck__default['default'](this, FillOp);

      _this5 = _super5.call(this, type);
      _this5.value = value;
      _this5.size = size;
      return _this5;
    }

    return FillOp;
  }(WriteOp);
  /*
   * Expose
   */


  var writer = BufferWriter;

  /*
   * Constants
   */


  var EMPTY$3 = Buffer.alloc(0);
  var POOL_SIZE = 100 << 10;
  var POOL = null;
  /**
   * Statically Allocated Writer
   */

  var StaticWriter = /*#__PURE__*/function () {
    /**
     * Statically allocated buffer writer.
     * @constructor
     * @param {Number|Buffer} options
     */
    function StaticWriter(options) {
      _classCallCheck__default['default'](this, StaticWriter);

      this.data = EMPTY$3;
      this.offset = 0;
      if (options != null) this.init(options);
    }
    /**
     * Assertion.
     * @param {Number} size
     */


    _createClass__default['default'](StaticWriter, [{
      key: "check",
      value: function check(size) {
        if (this.offset + size > this.data.length) throw new error(this.offset, 'Out of bounds write', this.check);
      }
      /**
       * Initialize options.
       * @param {Object} options
       */

    }, {
      key: "init",
      value: function init(options) {
        if (Buffer.isBuffer(options)) {
          this.data = options;
          this.offset = 0;
          return this;
        }

        enforce_1(options >>> 0 === options, 'size', 'integer');
        this.data = Buffer.allocUnsafeSlow(options);
        this.offset = 0;
        return this;
      }
      /**
       * Allocate writer from preallocated 100kb pool.
       * @param {Number} size
       * @returns {StaticWriter}
       */

    }, {
      key: "render",

      /**
       * Allocate and render the final buffer.
       * @returns {Buffer} Rendered buffer.
       */
      value: function render() {
        var data = this.data,
            offset = this.offset;
        if (offset !== data.length) throw new error(offset, 'Out of bounds write');
        this.destroy();
        return data;
      }
      /**
       * Slice the final buffer at written offset.
       * @returns {Buffer} Rendered buffer.
       */

    }, {
      key: "slice",
      value: function slice() {
        var data = this.data,
            offset = this.offset;
        if (offset > data.length) throw new error(offset, 'Out of bounds write');
        this.destroy();
        return data.slice(0, offset);
      }
      /**
       * Get size of data written so far.
       * @returns {Number}
       */

    }, {
      key: "getSize",
      value: function getSize() {
        return this.offset;
      }
      /**
       * Seek to relative offset.
       * @param {Number} off
       */

    }, {
      key: "seek",
      value: function seek(off) {
        enforce_1(Number.isSafeInteger(off), 'off', 'integer');
        if (this.offset + off < 0) throw new error(this.offset, 'Out of bounds write');
        this.check(off);
        this.offset += off;
        return this;
      }
      /**
       * Destroy the buffer writer.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this.data = EMPTY$3;
        this.offset = 0;
        return this;
      }
      /**
       * Write uint8.
       * @param {Number} value
       */

    }, {
      key: "writeU8",
      value: function writeU8(value) {
        this.check(1);
        this.offset = encoding.writeU8(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint16le.
       * @param {Number} value
       */

    }, {
      key: "writeU16",
      value: function writeU16(value) {
        this.check(2);
        this.offset = encoding.writeU16(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint16be.
       * @param {Number} value
       */

    }, {
      key: "writeU16BE",
      value: function writeU16BE(value) {
        this.check(2);
        this.offset = encoding.writeU16BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint24le.
       * @param {Number} value
       */

    }, {
      key: "writeU24",
      value: function writeU24(value) {
        this.check(3);
        this.offset = encoding.writeU24(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint24be.
       * @param {Number} value
       */

    }, {
      key: "writeU24BE",
      value: function writeU24BE(value) {
        this.check(3);
        this.offset = encoding.writeU24BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint32le.
       * @param {Number} value
       */

    }, {
      key: "writeU32",
      value: function writeU32(value) {
        this.check(4);
        this.offset = encoding.writeU32(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint32be.
       * @param {Number} value
       */

    }, {
      key: "writeU32BE",
      value: function writeU32BE(value) {
        this.check(4);
        this.offset = encoding.writeU32BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint40le.
       * @param {Number} value
       */

    }, {
      key: "writeU40",
      value: function writeU40(value) {
        this.check(5);
        this.offset = encoding.writeU40(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint40be.
       * @param {Number} value
       */

    }, {
      key: "writeU40BE",
      value: function writeU40BE(value) {
        this.check(5);
        this.offset = encoding.writeU40BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint48le.
       * @param {Number} value
       */

    }, {
      key: "writeU48",
      value: function writeU48(value) {
        this.check(6);
        this.offset = encoding.writeU48(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint48be.
       * @param {Number} value
       */

    }, {
      key: "writeU48BE",
      value: function writeU48BE(value) {
        this.check(6);
        this.offset = encoding.writeU48BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint56le.
       * @param {Number} value
       */

    }, {
      key: "writeU56",
      value: function writeU56(value) {
        this.check(7);
        this.offset = encoding.writeU56(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint56be.
       * @param {Number} value
       */

    }, {
      key: "writeU56BE",
      value: function writeU56BE(value) {
        this.check(7);
        this.offset = encoding.writeU56BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint64le.
       * @param {Number} value
       */

    }, {
      key: "writeU64",
      value: function writeU64(value) {
        this.check(8);
        this.offset = encoding.writeU64(this.data, value, this.offset);
        return this;
      }
      /**
       * Write uint64be.
       * @param {Number} value
       */

    }, {
      key: "writeU64BE",
      value: function writeU64BE(value) {
        this.check(8);
        this.offset = encoding.writeU64BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int8.
       * @param {Number} value
       */

    }, {
      key: "writeI8",
      value: function writeI8(value) {
        this.check(1);
        this.offset = encoding.writeI8(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int16le.
       * @param {Number} value
       */

    }, {
      key: "writeI16",
      value: function writeI16(value) {
        this.check(2);
        this.offset = encoding.writeI16(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int16be.
       * @param {Number} value
       */

    }, {
      key: "writeI16BE",
      value: function writeI16BE(value) {
        this.check(2);
        this.offset = encoding.writeI16BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int24le.
       * @param {Number} value
       */

    }, {
      key: "writeI24",
      value: function writeI24(value) {
        this.check(3);
        this.offset = encoding.writeI24(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int24be.
       * @param {Number} value
       */

    }, {
      key: "writeI24BE",
      value: function writeI24BE(value) {
        this.check(3);
        this.offset = encoding.writeI24BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int32le.
       * @param {Number} value
       */

    }, {
      key: "writeI32",
      value: function writeI32(value) {
        this.check(4);
        this.offset = encoding.writeI32(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int32be.
       * @param {Number} value
       */

    }, {
      key: "writeI32BE",
      value: function writeI32BE(value) {
        this.check(4);
        this.offset = encoding.writeI32BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int40le.
       * @param {Number} value
       */

    }, {
      key: "writeI40",
      value: function writeI40(value) {
        this.check(5);
        this.offset = encoding.writeI40(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int40be.
       * @param {Number} value
       */

    }, {
      key: "writeI40BE",
      value: function writeI40BE(value) {
        this.check(5);
        this.offset = encoding.writeI40BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int48le.
       * @param {Number} value
       */

    }, {
      key: "writeI48",
      value: function writeI48(value) {
        this.check(6);
        this.offset = encoding.writeI48(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int48be.
       * @param {Number} value
       */

    }, {
      key: "writeI48BE",
      value: function writeI48BE(value) {
        this.check(6);
        this.offset = encoding.writeI48BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int56le.
       * @param {Number} value
       */

    }, {
      key: "writeI56",
      value: function writeI56(value) {
        this.check(7);
        this.offset = encoding.writeI56(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int56be.
       * @param {Number} value
       */

    }, {
      key: "writeI56BE",
      value: function writeI56BE(value) {
        this.check(7);
        this.offset = encoding.writeI56BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int64le.
       * @param {Number} value
       */

    }, {
      key: "writeI64",
      value: function writeI64(value) {
        this.check(8);
        this.offset = encoding.writeI64(this.data, value, this.offset);
        return this;
      }
      /**
       * Write int64be.
       * @param {Number} value
       */

    }, {
      key: "writeI64BE",
      value: function writeI64BE(value) {
        this.check(8);
        this.offset = encoding.writeI64BE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write float le.
       * @param {Number} value
       */

    }, {
      key: "writeFloat",
      value: function writeFloat(value) {
        this.check(4);
        this.offset = encoding.writeFloat(this.data, value, this.offset);
        return this;
      }
      /**
       * Write float be.
       * @param {Number} value
       */

    }, {
      key: "writeFloatBE",
      value: function writeFloatBE(value) {
        this.check(4);
        this.offset = encoding.writeFloatBE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write double le.
       * @param {Number} value
       */

    }, {
      key: "writeDouble",
      value: function writeDouble(value) {
        this.check(8);
        this.offset = encoding.writeDouble(this.data, value, this.offset);
        return this;
      }
      /**
       * Write double be.
       * @param {Number} value
       */

    }, {
      key: "writeDoubleBE",
      value: function writeDoubleBE(value) {
        this.check(8);
        this.offset = encoding.writeDoubleBE(this.data, value, this.offset);
        return this;
      }
      /**
       * Write a varint.
       * @param {Number} value
       */

    }, {
      key: "writeVarint",
      value: function writeVarint(value) {
        this.offset = encoding.writeVarint(this.data, value, this.offset);
        return this;
      }
      /**
       * Write a varint (type 2).
       * @param {Number} value
       */

    }, {
      key: "writeVarint2",
      value: function writeVarint2(value) {
        this.offset = encoding.writeVarint2(this.data, value, this.offset);
        return this;
      }
      /**
       * Write bytes.
       * @param {Buffer} value
       */

    }, {
      key: "writeBytes",
      value: function writeBytes(value) {
        enforce_1(Buffer.isBuffer(value), 'value', 'buffer');
        this.check(value.length);
        this.offset += value.copy(this.data, this.offset);
        return this;
      }
      /**
       * Write bytes with a varint length before them.
       * @param {Buffer} value
       */

    }, {
      key: "writeVarBytes",
      value: function writeVarBytes(value) {
        enforce_1(Buffer.isBuffer(value), 'value', 'buffer');
        this.writeVarint(value.length);
        this.writeBytes(value);
        return this;
      }
      /**
       * Copy bytes.
       * @param {Buffer} value
       * @param {Number} start
       * @param {Number} end
       */

    }, {
      key: "copy",
      value: function copy(value, start, end) {
        enforce_1(Buffer.isBuffer(value), 'value', 'buffer');
        enforce_1(start >>> 0 === start, 'start', 'integer');
        enforce_1(end >>> 0 === end, 'end', 'integer');
        enforce_1(end >= start, 'start', 'integer');
        this.check(end - start);
        this.offset += value.copy(this.data, this.offset, start, end);
        return this;
      }
      /**
       * Write string to buffer.
       * @param {String} value
       * @param {String?} enc - Any buffer-supported encoding.
       */

    }, {
      key: "writeString",
      value: function writeString(value, enc) {
        if (enc == null) enc = 'binary';
        enforce_1(typeof value === 'string', 'value', 'string');
        enforce_1(typeof enc === 'string', 'enc', 'string');
        if (value.length === 0) return this;
        var size = Buffer.byteLength(value, enc);
        this.check(size);
        this.offset += this.data.write(value, this.offset, enc);
        return this;
      }
      /**
       * Write a 32 byte hash.
       * @param {Hash} value
       */

    }, {
      key: "writeHash",
      value: function writeHash(value) {
        if (typeof value !== 'string') {
          enforce_1(Buffer.isBuffer(value), 'value', 'buffer');
          enforce_1(value.length === 32, 'value', '32-byte hash');
          this.writeBytes(value);
          return this;
        }

        enforce_1(value.length === 64, 'value', '32-byte hash');
        this.check(32);
        this.offset += this.data.write(value, this.offset, 'hex');
        return this;
      }
      /**
       * Write a string with a varint length before it.
       * @param {String}
       * @param {String?} enc - Any buffer-supported encoding.
       */

    }, {
      key: "writeVarString",
      value: function writeVarString(value, enc) {
        if (enc == null) enc = 'binary';
        enforce_1(typeof value === 'string', 'value', 'string');
        enforce_1(typeof enc === 'string', 'enc', 'string');

        if (value.length === 0) {
          this.writeVarint(0);
          return this;
        }

        var size = Buffer.byteLength(value, enc);
        this.writeVarint(size);
        this.check(size);
        this.offset += this.data.write(value, this.offset, enc);
        return this;
      }
      /**
       * Write a null-terminated string.
       * @param {String|Buffer}
       * @param {String?} enc - Any buffer-supported encoding.
       */

    }, {
      key: "writeNullString",
      value: function writeNullString(value, enc) {
        this.writeString(value, enc);
        this.writeU8(0);
        return this;
      }
      /**
       * Calculate and write a checksum for the data written so far.
       * @param {Function} hash
       */

    }, {
      key: "writeChecksum",
      value: function writeChecksum(hash) {
        if (!hash || typeof hash.digest !== 'function') enforce_1(typeof hash === 'function', 'hash', 'function');
        this.check(4);
        var data = this.data.slice(0, this.offset);
        var raw = hash.digest ? hash.digest(data) : hash(data);
        raw.copy(this.data, this.offset, 0, 4);
        this.offset += 4;
        return this;
      }
      /**
       * Fill N bytes with value.
       * @param {Number} value
       * @param {Number} size
       */

    }, {
      key: "fill",
      value: function fill(value, size) {
        enforce_1((value & 0xff) === value, 'value', 'byte');
        enforce_1(size >>> 0 === size, 'size', 'integer');
        this.check(size);
        this.data.fill(value, this.offset, this.offset + size);
        this.offset += size;
        return this;
      }
    }], [{
      key: "pool",
      value: function pool(size) {
        enforce_1(size >>> 0 === size, 'size', 'integer');

        if (size <= POOL_SIZE) {
          if (!POOL) POOL = Buffer.allocUnsafeSlow(POOL_SIZE);
          var bw = new StaticWriter();
          bw.data = POOL.slice(0, size);
          return bw;
        }

        return new StaticWriter(size);
      }
    }]);

    return StaticWriter;
  }();
  /*
   * Expose
   */


  var staticwriter = StaticWriter;

  var custom$4 = customBrowser$1.custom;
  /**
   * Struct
   */

  var Struct = /*#__PURE__*/function () {
    function Struct() {
      _classCallCheck__default['default'](this, Struct);
    }

    _createClass__default['default'](Struct, [{
      key: "inject",
      value: function inject(obj) {
        enforce_1(obj instanceof this.constructor, 'obj', 'struct');
        return this.decode(obj.encode());
      }
    }, {
      key: "clone",
      value: function clone() {
        var copy = new this.constructor();
        return copy.inject(this);
      }
      /*
       * Bindable
       */

    }, {
      key: "getSize",
      value: function getSize(extra) {
        return -1;
      }
    }, {
      key: "write",
      value: function write(bw, extra) {
        return bw;
      }
    }, {
      key: "read",
      value: function read(br, extra) {
        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        return Object.prototype.toString.call(this);
      }
    }, {
      key: "fromString",
      value: function fromString(str, extra) {
        return this;
      }
    }, {
      key: "getJSON",
      value: function getJSON() {
        return this;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json, extra) {
        return this;
      }
    }, {
      key: "fromOptions",
      value: function fromOptions(options, extra) {
        return this;
      }
    }, {
      key: "from",
      value: function from(options, extra) {
        return this.fromOptions(options, extra);
      }
    }, {
      key: "format",
      value: function format() {
        return this.getJSON();
      }
      /*
       * API
       */

    }, {
      key: "encode",
      value: function encode(extra) {
        var size = this.getSize(extra);
        var bw = size === -1 ? new writer() : new staticwriter(size);
        this.write(bw, extra);
        return bw.render();
      }
    }, {
      key: "decode",
      value: function decode(data, extra) {
        var br = new reader(data);
        this.read(br, extra);
        return this;
      }
    }, {
      key: "toHex",
      value: function toHex(extra) {
        return this.encode(extra).toString('hex');
      }
    }, {
      key: "fromHex",
      value: function fromHex(str, extra) {
        enforce_1(typeof str === 'string', 'str', 'string');
        var size = str.length >>> 1;
        var data = Buffer.from(str, 'hex');
        if (data.length !== size) throw new Error('Invalid hex string.');
        return this.decode(data, extra);
      }
    }, {
      key: "toBase64",
      value: function toBase64(extra) {
        return this.encode(extra).toString('base64');
      }
    }, {
      key: "fromBase64",
      value: function fromBase64(str, extra) {
        enforce_1(typeof str === 'string', 'str', 'string');
        var data = Buffer.from(str, 'base64');
        if (str.length > size64(data.length)) throw new Error('Invalid base64 string.');
        return this.decode(data, extra);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.getJSON();
      }
    }, {
      key: custom$4,
      value: function value() {
        return this.format();
      }
      /*
       * Static API
       */

    }, {
      key: "toWriter",

      /*
       * Aliases
       */
      value: function toWriter(bw, extra) {
        return this.write(bw, extra);
      }
    }, {
      key: "fromReader",
      value: function fromReader(br, extra) {
        return this.read(br, extra);
      }
    }, {
      key: "toRaw",
      value: function toRaw(extra) {
        return this.encode(extra);
      }
    }, {
      key: "fromRaw",
      value: function fromRaw(data, extra) {
        return this.decode(data, extra);
      }
      /*
       * Static Aliases
       */

    }], [{
      key: "read",
      value: function read(br, extra) {
        return new this().read(br, extra);
      }
    }, {
      key: "decode",
      value: function decode(data, extra) {
        return new this().decode(data, extra);
      }
    }, {
      key: "fromHex",
      value: function fromHex(str, extra) {
        return new this().fromHex(str, extra);
      }
    }, {
      key: "fromBase64",
      value: function fromBase64(str, extra) {
        return new this().fromBase64(str, extra);
      }
    }, {
      key: "fromString",
      value: function fromString(str, extra) {
        return new this().fromString(str, extra);
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json, extra) {
        return new this().fromJSON(json, extra);
      }
    }, {
      key: "fromOptions",
      value: function fromOptions(options, extra) {
        return new this().fromOptions(options, extra);
      }
    }, {
      key: "from",
      value: function from(options, extra) {
        return new this().from(options, extra);
      }
    }, {
      key: "fromReader",
      value: function fromReader(br, extra) {
        return this.read(br, extra);
      }
    }, {
      key: "fromRaw",
      value: function fromRaw(data, extra) {
        return this.decode(data, extra);
      }
    }]);

    return Struct;
  }();
  /*
   * Helpers
   */


  function size64(size) {
    var expect = 4 * size / 3 + 3 & ~3;
    return expect >>> 0;
  }
  /*
   * Expose
   */


  var struct = Struct;

  var custom_1 = customBrowser$1;
  var encoding_1 = encoding;
  var EncodingError_1 = error;
  var BufferReader_1 = reader;
  var BufferWriter_1 = writer;
  var StaticWriter_1 = staticwriter;
  var Struct_1 = struct;

  var read$2 = function read(data, zeroCopy) {
    return new reader(data, zeroCopy);
  };

  var write$2 = function write(size) {
    return size != null ? new staticwriter(size) : new writer();
  };

  var pool$1 = function pool(size) {
    return staticwriter.pool(size);
  };

  function _read(func, size) {
    return function (data, off) {
      enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
      enforce_1(off >>> 0 === off, 'off', 'integer');
      if (off + size > data.length) throw new error(off, 'Out of bounds read');
      return func(data, off);
    };
  }

  function _readn(func) {
    return function (data, off, len) {
      enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
      enforce_1(off >>> 0 === off, 'off', 'integer');
      enforce_1(len >>> 0 === len, 'len', 'integer');
      if (off + len > data.length) throw new error(off, 'Out of bounds read');
      return func(data, off, len);
    };
  }

  function _readvar(func) {
    return function (data, off) {
      enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
      enforce_1(off >>> 0 === off, 'off', 'integer');
      return func(data, off);
    };
  }

  function _write(func, size) {
    return function (data, num, off) {
      enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
      enforce_1(off >>> 0 === off, 'off', 'integer');
      if (off + size > data.length) throw new error(off, 'Out of bounds write');
      return func(data, num, off);
    };
  }

  function _writen(func) {
    return function (data, num, off, len) {
      enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
      enforce_1(off >>> 0 === off, 'off', 'integer');
      enforce_1(len >>> 0 === len, 'len', 'integer');
      if (off + len > data.length) throw new error(off, 'Out of bounds write');
      return func(data, num, off, len);
    };
  }

  function _writecb(func, size) {
    return function (data, num, off) {
      enforce_1(Buffer.isBuffer(data), 'data', 'buffer');
      enforce_1(off >>> 0 === off, 'off', 'integer');
      if (off + size(num) > data.length) throw new error(off, 'Out of bounds write');
      return func(data, num, off);
    };
  }

  var readU$1 = _readn(encoding.readU);

  var readU64$1 = _read(encoding.readU64, 8);

  var readU56$1 = _read(encoding.readU56, 7);

  var readU48$1 = _read(encoding.readU48, 6);

  var readU40$1 = _read(encoding.readU40, 5);

  var readU32$g = _read(encoding.readU32, 4);

  var readU24$1 = _read(encoding.readU24, 3);

  var readU16$4 = _read(encoding.readU16, 2);

  var readU8$1 = _read(encoding.readU8, 1);

  var readUBE$1 = _readn(encoding.readUBE);

  var readU64BE$1 = _read(encoding.readU64BE, 8);

  var readU56BE$1 = _read(encoding.readU56BE, 7);

  var readU48BE$1 = _read(encoding.readU48BE, 6);

  var readU40BE$1 = _read(encoding.readU40BE, 5);

  var readU32BE$1 = _read(encoding.readU32BE, 4);

  var readU24BE$1 = _read(encoding.readU24BE, 3);

  var readU16BE$1 = _read(encoding.readU16BE, 2);

  var readI$1 = _readn(encoding.readI);

  var readI64$1 = _read(encoding.readI64, 8);

  var readI56$1 = _read(encoding.readI56, 7);

  var readI48$1 = _read(encoding.readI48, 6);

  var readI40$1 = _read(encoding.readI40, 5);

  var readI32$1 = _read(encoding.readI32, 4);

  var readI24$1 = _read(encoding.readI24, 3);

  var readI16$1 = _read(encoding.readI16, 2);

  var readI8$1 = _read(encoding.readI8, 1);

  var readIBE$1 = _readn(encoding.readIBE);

  var readI64BE$1 = _read(encoding.readI64BE, 8);

  var readI56BE$1 = _read(encoding.readI56BE, 7);

  var readI48BE$1 = _read(encoding.readI48BE, 6);

  var readI40BE$1 = _read(encoding.readI40BE, 5);

  var readI32BE$1 = _read(encoding.readI32BE, 4);

  var readI24BE$1 = _read(encoding.readI24BE, 3);

  var readI16BE$1 = _read(encoding.readI16BE, 2);

  var readFloat$1 = _read(encoding.readFloat, 4);

  var readFloatBE$1 = _read(encoding.readFloatBE, 4);

  var readDouble$1 = _read(encoding.readDouble, 8);

  var readDoubleBE$1 = _read(encoding.readDoubleBE, 8);

  var writeU$1 = _writen(encoding.writeU);

  var writeU64$2 = _write(encoding.writeU64, 8);

  var writeU56$1 = _write(encoding.writeU56, 7);

  var writeU48$1 = _write(encoding.writeU48, 6);

  var writeU40$1 = _write(encoding.writeU40, 5);

  var writeU32$f = _write(encoding.writeU32, 4);

  var writeU24$1 = _write(encoding.writeU24, 3);

  var writeU16$4 = _write(encoding.writeU16, 2);

  var writeU8$1 = _write(encoding.writeU8, 1);

  var writeUBE$1 = _writen(encoding.writeUBE);

  var writeU64BE$1 = _write(encoding.writeU64BE, 8);

  var writeU56BE$1 = _write(encoding.writeU56BE, 7);

  var writeU48BE$1 = _write(encoding.writeU48BE, 6);

  var writeU40BE$1 = _write(encoding.writeU40BE, 5);

  var writeU32BE$1 = _write(encoding.writeU32BE, 4);

  var writeU24BE$1 = _write(encoding.writeU24BE, 3);

  var writeU16BE$1 = _write(encoding.writeU16BE, 2);

  var writeI$1 = _writen(encoding.writeI);

  var writeI64$1 = _write(encoding.writeI64, 8);

  var writeI56$1 = _write(encoding.writeI56, 7);

  var writeI48$1 = _write(encoding.writeI48, 6);

  var writeI40$1 = _write(encoding.writeI40, 5);

  var writeI32$1 = _write(encoding.writeI32, 4);

  var writeI24$1 = _write(encoding.writeI24, 3);

  var writeI16$1 = _write(encoding.writeI16, 2);

  var writeI8$1 = _write(encoding.writeI8, 1);

  var writeIBE$1 = _writen(encoding.writeIBE);

  var writeI64BE$1 = _write(encoding.writeI64BE, 8);

  var writeI56BE$1 = _write(encoding.writeI56BE, 7);

  var writeI48BE$1 = _write(encoding.writeI48BE, 6);

  var writeI40BE$1 = _write(encoding.writeI40BE, 5);

  var writeI32BE$1 = _write(encoding.writeI32BE, 4);

  var writeI24BE$1 = _write(encoding.writeI24BE, 3);

  var writeI16BE$1 = _write(encoding.writeI16BE, 2);

  var writeFloat$3 = _write(encoding.writeFloat, 4);

  var writeFloatBE$1 = _write(encoding.writeFloatBE, 4);

  var writeDouble$3 = _write(encoding.writeDouble, 8);

  var writeDoubleBE$1 = _write(encoding.writeDoubleBE, 8);

  var readVarint$1 = _readvar(encoding.readVarint);

  var writeVarint$1 = _writecb(encoding.writeVarint, encoding.sizeVarint);

  var sizeVarint$1 = encoding.sizeVarint;

  var readVarint2$1 = _readvar(encoding.readVarint2);

  var writeVarint2$1 = _writecb(encoding.writeVarint2, encoding.sizeVarint2);

  var sizeVarint2$1 = encoding.sizeVarint2;
  var sliceBytes$1 = encoding.sliceBytes;
  var readBytes$1 = encoding.readBytes;
  var writeBytes$1 = encoding.writeBytes;
  var readString$1 = encoding.readString;
  var writeString$1 = encoding.writeString;
  var realloc$1 = encoding.realloc;
  var copy$2 = encoding.copy;
  var concat$1 = encoding.concat;
  var sizeVarBytes$1 = encoding.sizeVarBytes;
  var sizeVarlen$1 = encoding.sizeVarlen;
  var sizeVarString$1 = encoding.sizeVarString;
  var bufio = {
    custom: custom_1,
    encoding: encoding_1,
    EncodingError: EncodingError_1,
    BufferReader: BufferReader_1,
    BufferWriter: BufferWriter_1,
    StaticWriter: StaticWriter_1,
    Struct: Struct_1,
    read: read$2,
    write: write$2,
    pool: pool$1,
    readU: readU$1,
    readU64: readU64$1,
    readU56: readU56$1,
    readU48: readU48$1,
    readU40: readU40$1,
    readU32: readU32$g,
    readU24: readU24$1,
    readU16: readU16$4,
    readU8: readU8$1,
    readUBE: readUBE$1,
    readU64BE: readU64BE$1,
    readU56BE: readU56BE$1,
    readU48BE: readU48BE$1,
    readU40BE: readU40BE$1,
    readU32BE: readU32BE$1,
    readU24BE: readU24BE$1,
    readU16BE: readU16BE$1,
    readI: readI$1,
    readI64: readI64$1,
    readI56: readI56$1,
    readI48: readI48$1,
    readI40: readI40$1,
    readI32: readI32$1,
    readI24: readI24$1,
    readI16: readI16$1,
    readI8: readI8$1,
    readIBE: readIBE$1,
    readI64BE: readI64BE$1,
    readI56BE: readI56BE$1,
    readI48BE: readI48BE$1,
    readI40BE: readI40BE$1,
    readI32BE: readI32BE$1,
    readI24BE: readI24BE$1,
    readI16BE: readI16BE$1,
    readFloat: readFloat$1,
    readFloatBE: readFloatBE$1,
    readDouble: readDouble$1,
    readDoubleBE: readDoubleBE$1,
    writeU: writeU$1,
    writeU64: writeU64$2,
    writeU56: writeU56$1,
    writeU48: writeU48$1,
    writeU40: writeU40$1,
    writeU32: writeU32$f,
    writeU24: writeU24$1,
    writeU16: writeU16$4,
    writeU8: writeU8$1,
    writeUBE: writeUBE$1,
    writeU64BE: writeU64BE$1,
    writeU56BE: writeU56BE$1,
    writeU48BE: writeU48BE$1,
    writeU40BE: writeU40BE$1,
    writeU32BE: writeU32BE$1,
    writeU24BE: writeU24BE$1,
    writeU16BE: writeU16BE$1,
    writeI: writeI$1,
    writeI64: writeI64$1,
    writeI56: writeI56$1,
    writeI48: writeI48$1,
    writeI40: writeI40$1,
    writeI32: writeI32$1,
    writeI24: writeI24$1,
    writeI16: writeI16$1,
    writeI8: writeI8$1,
    writeIBE: writeIBE$1,
    writeI64BE: writeI64BE$1,
    writeI56BE: writeI56BE$1,
    writeI48BE: writeI48BE$1,
    writeI40BE: writeI40BE$1,
    writeI32BE: writeI32BE$1,
    writeI24BE: writeI24BE$1,
    writeI16BE: writeI16BE$1,
    writeFloat: writeFloat$3,
    writeFloatBE: writeFloatBE$1,
    writeDouble: writeDouble$3,
    writeDoubleBE: writeDoubleBE$1,
    readVarint: readVarint$1,
    writeVarint: writeVarint$1,
    sizeVarint: sizeVarint$1,
    readVarint2: readVarint2$1,
    writeVarint2: writeVarint2$1,
    sizeVarint2: sizeVarint2$1,
    sliceBytes: sliceBytes$1,
    readBytes: readBytes$1,
    writeBytes: writeBytes$1,
    readString: readString$1,
    writeString: writeString$1,
    realloc: realloc$1,
    copy: copy$2,
    concat: concat$1,
    sizeVarBytes: sizeVarBytes$1,
    sizeVarlen: sizeVarlen$1,
    sizeVarString: sizeVarString$1
  };

  /*!
   * objects.js - OIDs encoding for javascript
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on golang/go:
   *   Copyright (c) 2009, The Go Authors. All rights reserved.
   *   https://github.com/golang/go
   *
   * Resources:
   *   https://www.ietf.org/rfc/rfc2459.txt
   *   https://tools.ietf.org/html/rfc3279
   *   http://oid-info.com/get/1.2.840.10040.4
   *   http://oid-info.com/get/1.2.840.113549.1.1
   *   http://oid-info.com/get/1.2.840.10045.4.3
   *   https://tools.ietf.org/html/draft-jivsov-openpgp-sha3-01
   *   https://github.com/golang/go/blob/master/src/crypto/x509/x509.go
   *   https://github.com/golang/go/blob/master/src/crypto/x509/pkix/pkix.go
   *   https://tools.ietf.org/html/draft-josefsson-pkix-eddsa-01
   *   https://tools.ietf.org/html/rfc5480
   *   https://tools.ietf.org/html/draft-josefsson-pkix-newcurves-00
   *   https://tools.ietf.org/id/draft-ietf-curdle-pkix-06.html
   *   https://tools.ietf.org/html/rfc7693
   */

  var _attrsByVal, _keyAlgsByVal, _hashesByVal, _curvesByVal, _sigAlgsByVal, _sigToHash;

  var NONE = '0.0';
  var attrs = {
    COUNTRY: '2.5.4.6',
    ORGANIZATION: '2.5.4.10',
    ORGANIZATIONALUNIT: '2.5.4.11',
    COMMONNAME: '2.5.4.3',
    SERIALNUMBER: '2.5.4.5',
    LOCALITY: '2.5.4.7',
    PROVINCE: '2.5.4.8',
    STREETADDRESS: '2.5.4.9',
    POSTALCODE: '2.5.4.17'
  };
  var attrsByVal = (_attrsByVal = {}, _defineProperty__default['default'](_attrsByVal, attrs.COUNTRY, 'COUNTRY'), _defineProperty__default['default'](_attrsByVal, attrs.ORGANIZATION, 'ORGANIZATION'), _defineProperty__default['default'](_attrsByVal, attrs.ORGANIZATIONALUNIT, 'ORGANIZATIONALUNIT'), _defineProperty__default['default'](_attrsByVal, attrs.COMMONNAME, 'COMMONNAME'), _defineProperty__default['default'](_attrsByVal, attrs.SERIALNUMBER, 'SERIALNUMBER'), _defineProperty__default['default'](_attrsByVal, attrs.LOCALITY, 'LOCALITY'), _defineProperty__default['default'](_attrsByVal, attrs.PROVINCE, 'PROVINCE'), _defineProperty__default['default'](_attrsByVal, attrs.STREETADDRESS, 'STREETADDRESS'), _defineProperty__default['default'](_attrsByVal, attrs.POSTALCODE, 'POSTALCODE'), _attrsByVal);
  var keyAlgs = {
    DH: '1.2.840.113549.1.3.1',
    DSA: '1.2.840.10040.4.1',
    DSA_ALT: '1.2.840.10040.4.2',
    RSA: '1.2.840.113549.1.1.1',
    ECDSA: '1.2.840.10045.2.1',
    EDDSA: '1.3.6.1.4.1.11591.4.12.1'
  };
  var keyAlgsByVal = (_keyAlgsByVal = {}, _defineProperty__default['default'](_keyAlgsByVal, keyAlgs.DH, 'DH'), _defineProperty__default['default'](_keyAlgsByVal, keyAlgs.DSA, 'DSA'), _defineProperty__default['default'](_keyAlgsByVal, keyAlgs.DSA_ALT, 'DSA'), _defineProperty__default['default'](_keyAlgsByVal, keyAlgs.RSA, 'RSA'), _defineProperty__default['default'](_keyAlgsByVal, keyAlgs.ECDSA, 'ECDSA'), _defineProperty__default['default'](_keyAlgsByVal, keyAlgs.EDDSA, 'EDDSA'), _keyAlgsByVal);
  var hashes = {
    BLAKE2B160: '1.3.6.1.4.1.1722.12.2.1.5',
    BLAKE2B256: '1.3.6.1.4.1.1722.12.2.1.8',
    BLAKE2B384: '1.3.6.1.4.1.1722.12.2.1.12',
    BLAKE2B512: '1.3.6.1.4.1.1722.12.2.1.16',
    BLAKE2S128: '1.3.6.1.4.1.1722.12.2.2.4',
    BLAKE2S160: '1.3.6.1.4.1.1722.12.2.2.5',
    BLAKE2S224: '1.3.6.1.4.1.1722.12.2.2.7',
    BLAKE2S256: '1.3.6.1.4.1.1722.12.2.2.8',
    GOST94: '1.2.643.2.2.20',
    MD2: '1.2.840.113549.2.2',
    MD4: '1.2.840.113549.2.4',
    MD5: '1.2.840.113549.2.5',
    MDC2: '1.3.14.3.2.19',
    RIPEMD160: '1.0.10118.3.0.49',
    RIPEMD160_ALT: '1.3.36.3.2.1',
    SHA1: '1.3.14.3.2.26',
    SHA224: '2.16.840.1.101.3.4.2.4',
    SHA256: '2.16.840.1.101.3.4.2.1',
    SHA384: '2.16.840.1.101.3.4.2.2',
    SHA512: '2.16.840.1.101.3.4.2.3',
    SHA3_224: '2.16.840.1.101.3.4.2.7',
    SHA3_256: '2.16.840.1.101.3.4.2.8',
    SHA3_384: '2.16.840.1.101.3.4.2.9',
    SHA3_512: '2.16.840.1.101.3.4.2.10',
    SHAKE128: '2.16.840.1.101.3.4.2.11',
    SHAKE256: '2.16.840.1.101.3.4.2.12',
    SM3: '1.0.10118.3.0.65',
    WHIRLPOOL: '1.0.10118.3.0.55'
  };
  var hashesByVal = (_hashesByVal = {}, _defineProperty__default['default'](_hashesByVal, hashes.BLAKE2B160, 'BLAKE2B160'), _defineProperty__default['default'](_hashesByVal, hashes.BLAKE2B256, 'BLAKE2B256'), _defineProperty__default['default'](_hashesByVal, hashes.BLAKE2B384, 'BLAKE2B384'), _defineProperty__default['default'](_hashesByVal, hashes.BLAKE2B512, 'BLAKE2B512'), _defineProperty__default['default'](_hashesByVal, hashes.BLAKE2S128, 'BLAKE2S128'), _defineProperty__default['default'](_hashesByVal, hashes.BLAKE2S160, 'BLAKE2S160'), _defineProperty__default['default'](_hashesByVal, hashes.BLAKE2S224, 'BLAKE2S224'), _defineProperty__default['default'](_hashesByVal, hashes.BLAKE2S256, 'BLAKE2S256'), _defineProperty__default['default'](_hashesByVal, hashes.GOST94, 'GOST94'), _defineProperty__default['default'](_hashesByVal, hashes.MD2, 'MD2'), _defineProperty__default['default'](_hashesByVal, hashes.MD4, 'MD4'), _defineProperty__default['default'](_hashesByVal, hashes.MD5, 'MD5'), _defineProperty__default['default'](_hashesByVal, hashes.MDC2, 'MDC2'), _defineProperty__default['default'](_hashesByVal, hashes.RIPEMD160, 'RIPEMD160'), _defineProperty__default['default'](_hashesByVal, hashes.RIPEMD160_ALT, 'RIPEMD160'), _defineProperty__default['default'](_hashesByVal, hashes.SHA1, 'SHA1'), _defineProperty__default['default'](_hashesByVal, hashes.SHA224, 'SHA224'), _defineProperty__default['default'](_hashesByVal, hashes.SHA256, 'SHA256'), _defineProperty__default['default'](_hashesByVal, hashes.SHA384, 'SHA384'), _defineProperty__default['default'](_hashesByVal, hashes.SHA512, 'SHA512'), _defineProperty__default['default'](_hashesByVal, hashes.SHA3_224, 'SHA3_224'), _defineProperty__default['default'](_hashesByVal, hashes.SHA3_256, 'SHA3_256'), _defineProperty__default['default'](_hashesByVal, hashes.SHA3_384, 'SHA3_384'), _defineProperty__default['default'](_hashesByVal, hashes.SHA3_512, 'SHA3_512'), _defineProperty__default['default'](_hashesByVal, hashes.SHAKE128, 'SHAKE128'), _defineProperty__default['default'](_hashesByVal, hashes.SHAKE256, 'SHAKE256'), _defineProperty__default['default'](_hashesByVal, hashes.SM3, 'SM3'), _defineProperty__default['default'](_hashesByVal, hashes.WHIRLPOOL, 'WHIRLPOOL'), _hashesByVal);
  var curves$1 = {
    P192: '1.2.840.10045.3.1.1',
    P224: '1.3.132.0.33',
    P256: '1.2.840.10045.3.1.7',
    P384: '1.3.132.0.34',
    P521: '1.3.132.0.35',
    BRAINPOOLP256: '1.3.36.3.3.2.8.1.1.7',
    BRAINPOOLP384: '1.3.36.3.3.2.8.1.1.11',
    BRAINPOOLP512: '1.3.36.3.3.2.8.1.1.13',
    SECP192K1: '1.3.132.0.31',
    SECP224K1: '1.3.132.0.32',
    SECP256K1: '1.3.132.0.10',
    FRP256V1: '1.2.250.1.223.101.256.1',
    X25519: '1.3.101.110',
    X25519_ALT: '1.3.6.1.4.1.11591.7',
    ED25519: '1.3.101.112',
    X448: '1.3.101.111',
    X448_ALT: '1.3.6.1.4.1.11591.8',
    ED448: '1.3.101.113',
    // Non-standard, but officially registered:
    // See: https://github.com/weidai11/cryptopp/issues/67#issuecomment-162191213
    ED1174: '1.3.6.1.4.1.9509.5.2.6',
    ED41417: '1.3.6.1.4.1.9509.5.2.5',
    CURVE383187: '1.3.6.1.4.1.9509.5.1.4',
    M221: '1.3.6.1.4.1.9509.5.1.1',
    E222: '1.3.6.1.4.1.9509.5.2.1',
    M383: '1.3.6.1.4.1.9509.5.1.2',
    E382: '1.3.6.1.4.1.9509.5.2.2',
    M511: '1.3.6.1.4.1.9509.5.1.3',
    E521: '1.3.6.1.4.1.9509.5.2.4'
  };
  var curvesByVal = (_curvesByVal = {}, _defineProperty__default['default'](_curvesByVal, curves$1.P192, 'P192'), _defineProperty__default['default'](_curvesByVal, curves$1.P224, 'P224'), _defineProperty__default['default'](_curvesByVal, curves$1.P256, 'P256'), _defineProperty__default['default'](_curvesByVal, curves$1.P384, 'P384'), _defineProperty__default['default'](_curvesByVal, curves$1.P521, 'P521'), _defineProperty__default['default'](_curvesByVal, curves$1.BRAINPOOLP256, 'BRAINPOOLP256'), _defineProperty__default['default'](_curvesByVal, curves$1.BRAINPOOLP384, 'BRAINPOOLP384'), _defineProperty__default['default'](_curvesByVal, curves$1.BRAINPOOLP512, 'BRAINPOOLP512'), _defineProperty__default['default'](_curvesByVal, curves$1.SECP192K1, 'SECP192K1'), _defineProperty__default['default'](_curvesByVal, curves$1.SECP224K1, 'SECP224K1'), _defineProperty__default['default'](_curvesByVal, curves$1.SECP256K1, 'SECP256K1'), _defineProperty__default['default'](_curvesByVal, curves$1.FRP256V1, 'FRP256V1'), _defineProperty__default['default'](_curvesByVal, curves$1.X25519, 'X25519'), _defineProperty__default['default'](_curvesByVal, curves$1.X25519_ALT, 'X25519'), _defineProperty__default['default'](_curvesByVal, curves$1.ED25519, 'ED25519'), _defineProperty__default['default'](_curvesByVal, curves$1.X448, 'X448'), _defineProperty__default['default'](_curvesByVal, curves$1.X448_ALT, 'X448'), _defineProperty__default['default'](_curvesByVal, curves$1.ED448, 'ED448'), _defineProperty__default['default'](_curvesByVal, curves$1.ED1174, 'ED1174'), _defineProperty__default['default'](_curvesByVal, curves$1.ED41417, 'ED41417'), _defineProperty__default['default'](_curvesByVal, curves$1.CURVE383187, 'CURVE383187'), _defineProperty__default['default'](_curvesByVal, curves$1.M221, 'M221'), _defineProperty__default['default'](_curvesByVal, curves$1.E222, 'E222'), _defineProperty__default['default'](_curvesByVal, curves$1.M383, 'M383'), _defineProperty__default['default'](_curvesByVal, curves$1.E382, 'E382'), _defineProperty__default['default'](_curvesByVal, curves$1.M511, 'M511'), _defineProperty__default['default'](_curvesByVal, curves$1.E521, 'E521'), _curvesByVal);
  var sigAlgs = {
    DSASHA1: '1.2.840.10040.4.3',
    RSAMD2: '1.2.840.113549.1.1.2',
    RSAMD4: '1.2.840.113549.1.1.3',
    RSAMD5: '1.2.840.113549.1.1.4',
    RSASHA1: '1.2.840.113549.1.1.5',
    RSASHA1_MS: '1.3.14.3.2.29',
    RSAPSS: '1.2.840.113549.1.1.10',
    RSASHA256: '1.2.840.113549.1.1.11',
    RSASHA384: '1.2.840.113549.1.1.12',
    RSASHA512: '1.2.840.113549.1.1.13',
    RSASHA224: '1.2.840.113549.1.1.14',
    MGF1: '1.2.840.113549.1.1.8',
    RSASHA3_256: '2.16.840.1.101.3.4.2.8',
    RSASHA3_384: '2.16.840.1.101.3.4.2.9',
    RSASHA3_512: '2.16.840.1.101.3.4.2.10',
    ECDSASHA1: '1.2.840.10045.4.1',
    ECDSASHA224: '1.2.840.10045.4.3.1',
    ECDSASHA256: '1.2.840.10045.4.3.2',
    ECDSASHA384: '1.2.840.10045.4.3.3',
    ECDSASHA512: '1.2.840.10045.4.3.4',
    EDDSA: '1.3.6.1.4.1.11591.4.12.2'
  };
  var sigAlgsByVal = (_sigAlgsByVal = {}, _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.DSASHA1, 'DSASHA1'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSAMD2, 'RSAMD2'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSAMD4, 'RSAMD4'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSAMD5, 'RSAMD5'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSASHA1, 'RSASHA1'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSASHA1_MS, 'RSASHA1'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSAPSS, 'RSAPSS'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSASHA256, 'RSASHA256'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSASHA384, 'RSASHA384'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSASHA512, 'RSASHA512'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.MGF1, 'MGF1'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSASHA3_256, 'RSASHA3_256'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSASHA3_384, 'RSASHA3_384'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.RSASHA3_512, 'RSASHA3_512'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.ECDSASHA1, 'ECDSASHA1'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.ECDSASHA224, 'ECDSASHA224'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.ECDSASHA384, 'ECDSASHA384'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.ECDSASHA512, 'ECDSASHA512'), _defineProperty__default['default'](_sigAlgsByVal, sigAlgs.EDDSA, 'EDDSA'), _sigAlgsByVal);
  var sigToHash = (_sigToHash = {}, _defineProperty__default['default'](_sigToHash, sigAlgs.DSASHA1, hashes.SHA1), _defineProperty__default['default'](_sigToHash, sigAlgs.RSAMD2, hashes.MD2), _defineProperty__default['default'](_sigToHash, sigAlgs.RSAMD4, hashes.MD4), _defineProperty__default['default'](_sigToHash, sigAlgs.RSAMD5, hashes.MD5), _defineProperty__default['default'](_sigToHash, sigAlgs.RSASHA1, hashes.SHA1), _defineProperty__default['default'](_sigToHash, sigAlgs.RSASHA1_MS, hashes.SHA1), _defineProperty__default['default'](_sigToHash, sigAlgs.RSAPSS, null), _defineProperty__default['default'](_sigToHash, sigAlgs.RSASHA256, hashes.SHA256), _defineProperty__default['default'](_sigToHash, sigAlgs.RSASHA384, hashes.SHA384), _defineProperty__default['default'](_sigToHash, sigAlgs.RSASHA512, hashes.SHA512), _defineProperty__default['default'](_sigToHash, sigAlgs.MGF1, null), _defineProperty__default['default'](_sigToHash, sigAlgs.RSASHA3_256, hashes.SHA3_256), _defineProperty__default['default'](_sigToHash, sigAlgs.RSASHA3_384, hashes.SHA3_384), _defineProperty__default['default'](_sigToHash, sigAlgs.RSASHA3_512, hashes.SHA3_512), _defineProperty__default['default'](_sigToHash, sigAlgs.ECDSASHA1, hashes.SHA1), _defineProperty__default['default'](_sigToHash, sigAlgs.ECDSASHA224, hashes.SHA224), _defineProperty__default['default'](_sigToHash, sigAlgs.ECDSASHA384, hashes.SHA384), _defineProperty__default['default'](_sigToHash, sigAlgs.ECDSASHA512, hashes.SHA512), _defineProperty__default['default'](_sigToHash, sigAlgs.EDDSA, null), _sigToHash);
  /*
   * Expose
   */

  var NONE_1 = NONE;
  var attrs_1 = attrs;
  var attrsByVal_1 = attrsByVal;
  var keyAlgs_1 = keyAlgs;
  var keyAlgsByVal_1 = keyAlgsByVal;
  var hashes_1 = hashes;
  var hashesByVal_1 = hashesByVal;
  var curves_1$1 = curves$1;
  var curvesByVal_1 = curvesByVal;
  var sigAlgs_1 = sigAlgs;
  var sigAlgsByVal_1 = sigAlgsByVal;
  var sigToHash_1 = sigToHash;
  var objects = {
    NONE: NONE_1,
    attrs: attrs_1,
    attrsByVal: attrsByVal_1,
    keyAlgs: keyAlgs_1,
    keyAlgsByVal: keyAlgsByVal_1,
    hashes: hashes_1,
    hashesByVal: hashesByVal_1,
    curves: curves_1$1,
    curvesByVal: curvesByVal_1,
    sigAlgs: sigAlgs_1,
    sigAlgsByVal: sigAlgsByVal_1,
    sigToHash: sigToHash_1
  };

  function _createForOfIteratorHelper$8(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

  function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /*
   * Constants
   */


  var EMPTY$4 = Buffer.alloc(0);
  var ZERO$1 = Buffer.alloc(1, 0x00);
  var EMPTY_OID = new Uint32Array(2);
  var MIN_TIME = -62167219200; // 0000-01-01T00:00:00.000Z

  var MAX_TIME = 253402300799; // 9999-12-31T23:59:59.000Z

  var MIN_OFFSET = -43200; // UTC-12:00

  var MAX_OFFSET = 50400; // UTC+14:00
  // Missing types:
  //   EOC: 0
  //   OBJDESC: 7
  //   EXTERNAL: 8
  //   REAL: 9
  //   EMBED: 11
  //   ROID: 13
  //   VIDEOSTRING: 21
  //   GRAPHSTRING: 25
  //   ISO64STRING: 26
  //   UNISTRING: 28
  //   CHARSTRING: 29
  //   BMPSTRING: 30

  var types$2 = {
    BOOLEAN: 1,
    INTEGER: 2,
    BITSTRING: 3,
    OCTSTRING: 4,
    NULL: 5,
    OID: 6,
    ENUM: 10,
    UTF8STRING: 12,
    SEQUENCE: 16,
    SET: 17,
    NUMSTRING: 18,
    PRINTSTRING: 19,
    T61STRING: 20,
    IA5STRING: 22,
    UTCTIME: 23,
    GENTIME: 24,
    GENSTRING: 27
  };
  var typesByVal = {
    1: 'BOOLEAN',
    2: 'INTEGER',
    3: 'BITSTRING',
    4: 'OCTSTRING',
    5: 'NULL',
    6: 'OID',
    10: 'ENUM',
    12: 'UTF8STRING',
    16: 'SEQUENCE',
    17: 'SET',
    18: 'NUMSTRING',
    19: 'PRINTSTRING',
    20: 'T61STRING',
    22: 'IA5STRING',
    23: 'UTCTIME',
    24: 'GENTIME',
    27: 'GENSTRING'
  };
  var classes = {
    UNIVERSAL: 0,
    APPLICATION: 1,
    CONTEXT: 2,
    PRIVATE: 3
  };
  var classesByVal = {
    0: 'UNIVERSAL',
    1: 'APPLICATION',
    2: 'CONTEXT',
    3: 'PRIVATE'
  };
  var TARGET = 0xff;
  var OPTIONAL = 1 << 8;
  var MODE = 0xff << 9;
  var NORMAL = 0 << 9;
  var EXPLICIT = 1 << 9;
  var IMPLICIT = 2 << 9;
  /**
   * Node
   */

  var Node = /*#__PURE__*/function (_bio$Struct) {
    _inherits__default['default'](Node, _bio$Struct);

    var _super = _createSuper$m(Node);

    function Node() {
      var _this;

      _classCallCheck__default['default'](this, Node);

      _this = _super.call(this);
      _this.flags = 0;
      return _this;
    }

    _createClass__default['default'](Node, [{
      key: "explicit",
      value: function explicit(target) {
        assert_1$1(target >>> 0 === target);
        this.mode = EXPLICIT;
        this.target = target;
        return this;
      }
    }, {
      key: "implicit",
      value: function implicit(target) {
        assert_1$1(target >>> 0 === target);
        this.mode = IMPLICIT;
        this.target = target;
        return this;
      }
    }, {
      key: "optional",
      value: function optional() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        assert_1$1(typeof value === 'boolean');
        this.opt = value;
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return false;
      }
    }, {
      key: "getBodySize",
      value: function getBodySize(extra) {
        return 0;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw, extra) {
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br, extra) {
        return this;
      }
    }, {
      key: "encodeBody",
      value: function encodeBody(extra) {
        var size = this.getBodySize();
        var bw = bufio.write(size);
        this.writeBody(bw, extra);
        return bw.render();
      }
    }, {
      key: "decodeBody",
      value: function decodeBody(data, extra) {
        var br = bufio.read(data);
        return this.readBody(br, extra);
      }
    }, {
      key: "set",
      value: function set() {
        return this;
      }
    }, {
      key: "from",
      value: function from(options) {
        if (options == null) return this;

        for (var _len = arguments.length, extra = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          extra[_key - 1] = arguments[_key];
        }

        return this.set.apply(this, [options].concat(extra));
      }
    }, {
      key: "error",
      value: function error(str) {
        if (this.opt) return this;
        var err = new Error(str);
        if (Error.captureStackTrace) Error.captureStackTrace(err, this.error);
        throw err;
      }
    }, {
      key: "getSize",
      value: function getSize(extra) {
        if (this.opt && this.clean()) return 0;
        var body = this.getBodySize(extra);
        var size = 0;
        size += sizeHeader(body);
        size += body;
        if (this.mode === EXPLICIT) size += sizeHeader(size);
        return size;
      }
    }, {
      key: "write",
      value: function write(bw, extra) {
        if (this.opt && this.clean()) return bw;
        var body = this.getBodySize();

        switch (this.mode) {
          case EXPLICIT:
            {
              var size = sizeHeader(body) + body;
              writeHeader(bw, this.target, classes.CONTEXT, false, size); // fall through
            }

          case NORMAL:
            {
              var primitive = this.type !== types$2.SEQUENCE && this.type !== types$2.SET;
              writeHeader(bw, this.type, classes.UNIVERSAL, primitive, body);
              break;
            }

          case IMPLICIT:
            {
              var _primitive = this.type !== types$2.SEQUENCE && this.type !== types$2.SET;

              writeHeader(bw, this.target, classes.CONTEXT, _primitive, body);
              break;
            }

          default:
            {
              throw new assert_1$1.AssertionError('Invalid mode.');
            }
        }

        return this.writeBody(bw, extra);
      }
    }, {
      key: "read",
      value: function read(br, extra) {
        switch (this.mode) {
          case EXPLICIT:
            {
              var hdr = peekHeader(br, this.opt);
              if (!hdr) return this;
              if (hdr.cls !== classes.CONTEXT) return this.error("Unexpected class: ".concat(hdr.cls, "."));
              if (hdr.primitive) return this.error('Unexpected primitive flag.');
              if (hdr.type !== this.target) return this.error("Unexpected type: ".concat(hdr.type, "."));
              br.seek(hdr.len);
              br = br.readChild(hdr.size); // Fall through.
            }

          case NORMAL:
            {
              var _hdr = peekHeader(br, this.opt);

              if (!_hdr) return this;
              if (_hdr.cls !== classes.UNIVERSAL) return this.error("Unexpected class: ".concat(_hdr.cls, "."));
              var primitive = this.type !== types$2.SEQUENCE && this.type !== types$2.SET;
              if (_hdr.primitive !== primitive) return this.error('Unexpected primitive flag.');
              if (_hdr.type !== this.type) return this.error("Unexpected type: ".concat(_hdr.type, "."));

              if (this.isRaw) {
                var size = _hdr.len + _hdr.size;
                this.raw = br.readBytes(size);
                br.seek(-size);
              }

              br.seek(_hdr.len);
              var child = br.readChild(_hdr.size);
              return this.readBody(child, extra);
            }

          case IMPLICIT:
            {
              var _hdr2 = peekHeader(br, this.opt);

              if (!_hdr2) return this;
              if (_hdr2.cls !== classes.CONTEXT) return this.error("Unexpected class: ".concat(_hdr2.cls, "."));

              var _primitive2 = this.type !== types$2.SEQUENCE && this.type !== types$2.SET;

              if (_hdr2.primitive !== _primitive2) return this.error('Unexpected primitive flag.');
              if (_hdr2.type !== this.target) return this.error("Unexpected type: ".concat(_hdr2.type, "."));
              br.seek(_hdr2.len);

              var _child = br.readChild(_hdr2.size);

              return this.readBody(_child, extra);
            }

          default:
            {
              throw new assert_1$1.AssertionError('Invalid mode.');
            }
        }
      }
    }, {
      key: "fromArray",
      value: function fromArray(value) {
        return this;
      }
    }, {
      key: "fromNumber",
      value: function fromNumber(num) {
        return this;
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(num) {
        return this;
      }
    }, {
      key: "mode",
      get: function get() {
        return this.flags & MODE;
      },
      set: function set(value) {
        this.flags &= ~MODE;
        this.flags |= value;
      }
    }, {
      key: "opt",
      get: function get() {
        return (this.flags & OPTIONAL) !== 0;
      },
      set: function set(value) {
        if (value) this.flags |= OPTIONAL;else this.flags &= ~OPTIONAL;
      }
    }, {
      key: "target",
      get: function get() {
        return this.flags & TARGET;
      },
      set: function set(value) {
        this.flags &= ~TARGET;
        this.flags |= value;
      }
    }, {
      key: "isRaw",
      get: function get() {
        return false;
      }
    }], [{
      key: "decodeBody",
      value: function decodeBody(value) {
        return new this().decodeBody(value);
      }
    }, {
      key: "fromArray",
      value: function fromArray(value) {
        return new this().fromArray(value);
      }
    }, {
      key: "fromNumber",
      value: function fromNumber(num) {
        return new this().fromNumber(num);
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        return new this().fromPEM(str);
      }
    }]);

    return Node;
  }(bufio.Struct);
  /**
   * Sequence
   */


  var Sequence = /*#__PURE__*/function (_Node) {
    _inherits__default['default'](Sequence, _Node);

    var _super2 = _createSuper$m(Sequence);

    function Sequence() {
      var _this3;

      var _this2;

      _classCallCheck__default['default'](this, Sequence);

      _this2 = _super2.call(this);
      _this2.raw = null;

      (_this3 = _this2).from.apply(_this3, arguments);

      return _this2;
    }

    _createClass__default['default'](Sequence, [{
      key: "type",
      get: function get() {
        return types$2.SEQUENCE;
      }
    }]);

    return Sequence;
  }(Node);
  /**
   * Set
   */

  var Set$1 = /*#__PURE__*/function (_Node2) {
    _inherits__default['default'](Set, _Node2);

    var _super3 = _createSuper$m(Set);

    function Set() {
      var _this5;

      var _this4;

      _classCallCheck__default['default'](this, Set);

      _this4 = _super3.call(this);
      _this4.raw = null;

      (_this5 = _this4).from.apply(_this5, arguments);

      return _this4;
    }

    _createClass__default['default'](Set, [{
      key: "type",
      get: function get() {
        return types$2.SET;
      }
    }]);

    return Set;
  }(Node);
  /**
   * Any
   */

  var Any = /*#__PURE__*/function (_Node3) {
    _inherits__default['default'](Any, _Node3);

    var _super4 = _createSuper$m(Any);

    function Any() {
      var _this7;

      var _this6;

      _classCallCheck__default['default'](this, Any);

      _this6 = _super4.call(this);
      _this6.node = new Null();
      _this6.raw = null;

      (_this7 = _this6).from.apply(_this7, arguments);

      return _this6;
    }

    _createClass__default['default'](Any, [{
      key: "explicit",
      value: function explicit(target) {
        throw new Error('Cannot set explicit on any.');
      }
    }, {
      key: "implicit",
      value: function implicit(target) {
        throw new Error('Cannot set implicit on any.');
      }
    }, {
      key: "getSize",
      value: function getSize(extra) {
        this.node.flags = this.flags;
        return this.node.getSize(extra);
      }
    }, {
      key: "write",
      value: function write(bw, extra) {
        assert_1$1(bw);
        assert_1$1(this.mode === NORMAL);
        this.node.flags = this.flags;
        this.node.write(bw, extra);
        return bw;
      }
    }, {
      key: "read",
      value: function read(br, extra) {
        assert_1$1(br);
        assert_1$1(this.mode === NORMAL);
        var hdr = peekHeader(br, this.opt);

        if (!hdr) {
          this.node.flags = this.flags;
          return this;
        }

        var Node = typeToClass(hdr.type);
        this.node = new Node();
        this.node.flags = this.flags;
        this.node.read(br, extra);
        return this;
      }
    }, {
      key: "getBodySize",
      value: function getBodySize(extra) {
        this.node.flags = this.flags;
        return this.node.getBodySize(extra);
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw, extra) {
        this.node.flags = this.flags;
        this.node.writeBody(bw, extra);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br, extra) {
        this.node.flags = this.flags;
        this.node.readBody(br, extra);
        return this;
      }
    }, {
      key: "set",
      value: function set(node) {
        if (node == null) node = new Null();
        assert_1$1(node instanceof Node);
        this.node = node;
        this.node.flags = this.flags;
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.node.type === types$2.NULL;
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          node: this.node
        };
      }
    }, {
      key: "isRaw",
      get: function get() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return this.node.type;
      }
    }]);

    return Any;
  }(Node);
  /**
   * Choice
   */


  var Choice = /*#__PURE__*/function (_Node4) {
    _inherits__default['default'](Choice, _Node4);

    var _super5 = _createSuper$m(Choice);

    function Choice(node) {
      var _this9;

      var _this8;

      _classCallCheck__default['default'](this, Choice);

      _this8 = _super5.call(this);
      assert_1$1(node instanceof Node);
      _this8.node = node;

      for (var _len2 = arguments.length, options = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        options[_key2 - 1] = arguments[_key2];
      }

      (_this9 = _this8).from.apply(_this9, options);

      return _this8;
    }

    _createClass__default['default'](Choice, [{
      key: "choices",
      value: function choices() {
        throw new Error('Unimplemented.');
      }
    }, {
      key: "getSize",
      value: function getSize(extra) {
        return this.node.getSize(extra);
      }
    }, {
      key: "write",
      value: function write(bw, extra) {
        assert_1$1(bw);
        this.node.flags = this.flags;
        this.node.write(bw, extra);
        return bw;
      }
    }, {
      key: "read",
      value: function read(br, extra) {
        assert_1$1(br);
        var choices = this.choices();
        assert_1$1(Array.isArray(choices));
        assert_1$1(choices.length >= 1);
        var hdr = peekHeader(br, this.opt);
        if (!hdr) return this;
        if (choices.indexOf(hdr.type) === -1) throw new Error("Could not satisfy choice for: ".concat(hdr.type, "."));
        var Node = typeToClass(hdr.type);
        var el = new Node();
        el.flags = this.flags;
        this.node = el.read(br, extra);
        return this;
      }
    }, {
      key: "getBodySize",
      value: function getBodySize(extra) {
        return this.node.getBodySize(extra);
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw, extra) {
        this.node.writeBody(bw, extra);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br, extra) {
        this.node.readBody(br, extra);
        return this;
      }
    }, {
      key: "set",
      value: function set() {
        var _this$node;

        return (_this$node = this.node).set.apply(_this$node, arguments);
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.node.clean();
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          node: this.node
        };
      }
    }, {
      key: "type",
      get: function get() {
        return this.node.type;
      }
    }]);

    return Choice;
  }(Node);
  /**
   * String
   */


  var Str = /*#__PURE__*/function (_Node5) {
    _inherits__default['default'](String, _Node5);

    var _super6 = _createSuper$m(String);

    function String() {
      var _this11;

      var _this10;

      _classCallCheck__default['default'](this, String);

      _this10 = _super6.call(this);
      _this10.value = '';

      (_this11 = _this10).from.apply(_this11, arguments);

      return _this10;
    }

    _createClass__default['default'](String, [{
      key: "getBodySize",
      value: function getBodySize() {
        return Buffer.byteLength(this.value, this.encoding);
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        bw.writeString(this.value, this.encoding);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        var str = br.readString(br.left(), this.encoding);

        switch (this.type) {
          case types$2.NUMSTRING:
            {
              if (!isNumString(str)) throw new Error('Invalid num string.');
              break;
            }

          case types$2.PRINTSTRING:
            {
              if (!isPrintString(str)) throw new Error('Invalid print string.');
              break;
            }

          case types$2.IA5STRING:
            {
              if (!isIA5String(str)) throw new Error('Invalid print string.');
              break;
            }
        }

        this.value = str;
        return this;
      }
    }, {
      key: "set",
      value: function set(value) {
        if (value == null) value = '';
        assert_1$1(typeof value === 'string');
        this.value = value;
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.value.length === 0;
      }
    }, {
      key: "format",
      value: function format() {
        return "<".concat(this.constructor.name, ": ").concat(this.value, ">");
      }
    }, {
      key: "encoding",
      get: function get() {
        return 'binary';
      }
    }]);

    return String;
  }(Node);
  /**
   * Boolean
   */


  var Bool = /*#__PURE__*/function (_Node6) {
    _inherits__default['default'](Boolean, _Node6);

    var _super7 = _createSuper$m(Boolean);

    function Boolean() {
      var _this13;

      var _this12;

      _classCallCheck__default['default'](this, Boolean);

      _this12 = _super7.call(this);
      _this12.value = false;

      (_this13 = _this12).from.apply(_this13, arguments);

      return _this12;
    }

    _createClass__default['default'](Boolean, [{
      key: "getBodySize",
      value: function getBodySize() {
        return 1;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        bw.writeU8(this.value ? 0xff : 0x00);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        if (br.left() !== 1) throw new Error('Non-minimal boolean.');
        var value = br.readU8();
        if (value !== 0x00 && value !== 0xff) throw new Error('Invalid boolean.');
        this.value = value === 0xff;
        return this;
      }
    }, {
      key: "set",
      value: function set(value) {
        if (value == null) value = false;
        assert_1$1(typeof value === 'boolean');
        this.value = value;
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.value === false;
      }
    }, {
      key: "format",
      value: function format() {
        return "<".concat(this.constructor.name, ": ").concat(this.value, ">");
      }
    }, {
      key: "type",
      get: function get() {
        return types$2.BOOLEAN;
      }
    }]);

    return Boolean;
  }(Node);
  /**
   * Integer
   */


  var Integer = /*#__PURE__*/function (_Node7) {
    _inherits__default['default'](Integer, _Node7);

    var _super8 = _createSuper$m(Integer);

    function Integer() {
      var _this15;

      var _this14;

      _classCallCheck__default['default'](this, Integer);

      _this14 = _super8.call(this);
      _this14.value = ZERO$1;
      _this14.negative = false;

      (_this15 = _this14).from.apply(_this15, arguments);

      return _this14;
    }

    _createClass__default['default'](Integer, [{
      key: "getBodySize",
      value: function getBodySize() {
        var b = this.value;
        if (b.length === 0) return 1;
        var pad = 0;
        var size = 0;

        if (!this.negative && b[0] > 127) {
          pad = 1;
        } else if (this.negative) {
          if (b[0] > 128) {
            pad = 1;
          } else if (b[0] === 128) {
            pad = 0;

            for (var i = 1; i < b.length; i++) {
              pad |= b[i];
            }

            pad = pad ? 1 : 0;
          }
        }

        size += pad;
        size += b.length;
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        var b = this.value;

        if (b.length === 0) {
          bw.writeU8(0x00);
          return bw;
        }

        var pad = 0;
        var pb = 0;

        if (!this.negative && b[0] > 127) {
          pad = 1;
          pb = 0;
        } else if (this.negative) {
          pb = 0xff;

          if (b[0] > 128) {
            pad = 1;
          } else if (b[0] === 128) {
            pad = 0;

            for (var i = 1; i < b.length; i++) {
              pad |= b[i];
            }

            pb = pad !== 0 ? 0xff : 0;
            pad = pb & 1;
          }
        }

        if (pad) bw.writeU8(pb);
        var start = bw.offset;
        bw.writeBytes(b);
        if (pb) twosComplement(bw.data, start, bw.offset);
        return this;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        var p = br.readBytes(br.left());
        if (p.length === 0) throw new Error('Zero length integer.');
        var neg = p[0] & 0x80;

        if (p.length === 1) {
          if (neg) p[0] = (p[0] ^ 0xff) + 1;
          this.negative = neg !== 0;
          this.value = p;
          return this;
        }

        if (p[0] === 0x00 && (p[1] & 0x80) === 0) throw new Error('Non-minimal integer.');
        if (p[0] === 0xff && (p[1] & 0x80) === 0x80) throw new Error('Non-minimal integer.');
        var pad = 0;

        if (p[0] === 0x00) {
          pad = 1;
        } else if (p[0] === 0xff) {
          for (var i = 1; i < p.length; i++) {
            pad |= p[i];
          }

          pad = pad !== 0 ? 1 : 0;
        }

        if (pad && neg === (p[1] & 0x80)) throw new Error('Invalid integer padding.');
        if (pad) p = p.slice(1);
        if (neg) twosComplement(p, 0, p.length);
        this.negative = neg !== 0;
        this.value = trimLeft$1(p);
        return this;
      }
    }, {
      key: "set",
      value: function set(value, negative) {
        if (typeof value === 'number') return this.fromNumber(value);
        if (value == null) value = ZERO$1;
        assert_1$1(Buffer.isBuffer(value));
        this.value = trimLeft$1(value);
        this.negative = false;

        if (negative != null) {
          assert_1$1(typeof negative === 'boolean');
          this.negative = negative;
        }

        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return !this.negative && this.value.equals(ZERO$1);
      }
    }, {
      key: "formatValue",
      value: function formatValue() {
        return this.value.toString('hex');
      }
    }, {
      key: "toNumber",
      value: function toNumber() {
        var num = bufio.readUBE(this.value, 0, this.value.length);
        if (this.negative) num = -num;
        return num;
      }
    }, {
      key: "fromNumber",
      value: function fromNumber(num) {
        assert_1$1(Number.isSafeInteger(num));
        var buf = Buffer.alloc(8);
        var neg = false;

        if (num < 0) {
          neg = true;
          num = -num;
        }

        bufio.writeU64BE(buf, num, 0);
        this.value = trimLeft$1(buf);
        this.negative = neg;
        return this;
      }
    }, {
      key: "format",
      value: function format() {
        var name = this.constructor.name;
        if (this.value.length <= 6) return "<".concat(name, ": ").concat(this.toNumber(), ">");
        var sign = this.negative ? '-' : '';
        var hex = this.value.toString('hex');
        return "<".concat(name, ": ").concat(sign, "0x").concat(hex, ">");
      }
    }, {
      key: "type",
      get: function get() {
        return types$2.INTEGER;
      }
    }]);

    return Integer;
  }(Node);
  /**
   * Unsigned
   */


  var Unsigned = /*#__PURE__*/function (_Integer) {
    _inherits__default['default'](Unsigned, _Integer);

    var _super9 = _createSuper$m(Unsigned);

    function Unsigned() {
      _classCallCheck__default['default'](this, Unsigned);

      for (var _len3 = arguments.length, options = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        options[_key3] = arguments[_key3];
      }

      return _super9.call.apply(_super9, [this].concat(options));
    }

    _createClass__default['default'](Unsigned, [{
      key: "getBodySize",
      value: function getBodySize() {
        assert_1$1(!this.negative);
        return _get__default['default'](_getPrototypeOf__default['default'](Unsigned.prototype), "getBodySize", this).call(this);
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        assert_1$1(!this.negative);
        return _get__default['default'](_getPrototypeOf__default['default'](Unsigned.prototype), "writeBody", this).call(this, bw);
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        _get__default['default'](_getPrototypeOf__default['default'](Unsigned.prototype), "readBody", this).call(this, br);

        assert_1$1(!this.negative);
        return this;
      }
    }, {
      key: "set",
      value: function set(value) {
        return _get__default['default'](_getPrototypeOf__default['default'](Unsigned.prototype), "set", this).call(this, value);
      }
    }, {
      key: "toNumber",
      value: function toNumber() {
        assert_1$1(!this.negative);
        return _get__default['default'](_getPrototypeOf__default['default'](Unsigned.prototype), "toNumber", this).call(this);
      }
    }, {
      key: "fromNumber",
      value: function fromNumber(num) {
        _get__default['default'](_getPrototypeOf__default['default'](Unsigned.prototype), "fromNumber", this).call(this, num);

        assert_1$1(!this.negative);
        return this;
      }
    }]);

    return Unsigned;
  }(Integer);
  /**
   * BitString
   */


  var BitString = /*#__PURE__*/function (_Node8) {
    _inherits__default['default'](BitString, _Node8);

    var _super10 = _createSuper$m(BitString);

    function BitString() {
      var _this17;

      var _this16;

      _classCallCheck__default['default'](this, BitString);

      _this16 = _super10.call(this);
      _this16.bits = 0;
      _this16.value = EMPTY$4;

      (_this17 = _this16).from.apply(_this17, arguments);

      return _this16;
    }

    _createClass__default['default'](BitString, [{
      key: "getBodySize",
      value: function getBodySize() {
        return 1 + this.value.length;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        var prefix = 8 - (this.bits & 7) & 7;
        bw.writeU8(prefix);
        bw.writeBytes(this.value);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        var data = br.readBytes(br.left());
        if (data.length === 0) throw new Error('Zero length bit string.');
        var padding = data[0];

        if (padding > 7 || data.length === 1 && padding > 0 || (data[data.length - 1] & (1 << padding) - 1) !== 0) {
          throw new Error('Invalid padding bits.');
        }

        this.bits = (data.length - 1) * 8 - padding;
        this.value = data.slice(1);
        return this;
      }
    }, {
      key: "rightAlign",
      value: function rightAlign() {
        var data = this.value;
        var shift = 8 - (this.bits & 7);
        if (shift === 8 || data.length === 0) return data;
        var out = Buffer.alloc(data.length);
        out[0] = data[0] >>> shift;

        for (var i = 1; i < data.length; i++) {
          out[i] = data[i - 1] << 8 - shift;
          out[i] |= data[i] >>> shift;
        }

        return out;
      }
    }, {
      key: "getBit",
      value: function getBit(i) {
        assert_1$1(i >>> 0 === i);
        if (i < 0 || i > this.bits) return 0;
        var x = i >>> 3;
        var y = 7 - (i & 7);
        return this.value[x] >>> y & 1;
      }
    }, {
      key: "setBit",
      value: function setBit(i, val) {
        assert_1$1(i >>> 0 === i);
        if (i < 0 || i > this.bits) return this;
        var x = i >>> 3;
        var y = 7 - (i & 7);
        if (val) this.value[x] |= 1 << y;else this.value[x] &= ~(1 << y);
        return this;
      }
    }, {
      key: "set",
      value: function set(value) {
        if (value == null) value = EMPTY$4;

        if (typeof value === 'number') {
          assert_1$1(value >>> 0 === value);
          this.bits = value;
          this.value = Buffer.alloc(value + 7 >>> 3);
        } else {
          assert_1$1(Buffer.isBuffer(value));
          this.bits = value.length * 8;
          this.value = value;
        }

        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.bits === 0 && this.value.length === 0;
      }
    }, {
      key: "format",
      value: function format() {
        var value = this.rightAlign();
        if (value.length > 32) value = value.slice(0, 32);
        return "<".concat(this.constructor.name, ": ").concat(this.bits, ":").concat(value.toString('hex'), ">");
      }
    }, {
      key: "type",
      get: function get() {
        return types$2.BITSTRING;
      }
    }]);

    return BitString;
  }(Node);
  /**
   * OctString
   */


  var OctString = /*#__PURE__*/function (_Node9) {
    _inherits__default['default'](OctString, _Node9);

    var _super11 = _createSuper$m(OctString);

    function OctString() {
      var _this19;

      var _this18;

      _classCallCheck__default['default'](this, OctString);

      _this18 = _super11.call(this);
      _this18.value = EMPTY$4;

      (_this19 = _this18).from.apply(_this19, arguments);

      return _this18;
    }

    _createClass__default['default'](OctString, [{
      key: "getBodySize",
      value: function getBodySize() {
        return this.value.length;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        bw.writeBytes(this.value);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.value = br.readBytes(br.left());
        return this;
      }
    }, {
      key: "set",
      value: function set(value) {
        if (value == null) value = EMPTY$4;
        assert_1$1(Buffer.isBuffer(value));
        this.value = value;
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.value.length === 0;
      }
    }, {
      key: "format",
      value: function format() {
        var value = this.value;
        if (value.length > 32) value = value.slice(0, 32);
        return "<".concat(this.constructor.name, ": ").concat(value.toString('hex'), ">");
      }
    }, {
      key: "type",
      get: function get() {
        return types$2.OCTSTRING;
      }
    }]);

    return OctString;
  }(Node);
  /**
   * Null
   */


  var Null = /*#__PURE__*/function (_Node10) {
    _inherits__default['default'](Null, _Node10);

    var _super12 = _createSuper$m(Null);

    function Null() {
      var _this21;

      var _this20;

      _classCallCheck__default['default'](this, Null);

      _this20 = _super12.call(this);

      (_this21 = _this20).from.apply(_this21, arguments);

      return _this20;
    }

    _createClass__default['default'](Null, [{
      key: "getBodySize",
      value: function getBodySize() {
        return 0;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        if (br.left() !== 0) throw new Error('Non-minimal NULL.');
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return true;
      }
    }, {
      key: "format",
      value: function format() {
        return "<".concat(this.constructor.name, ">");
      }
    }, {
      key: "type",
      get: function get() {
        return types$2.NULL;
      }
    }]);

    return Null;
  }(Node);
  /**
   * OID
   */


  var OID = /*#__PURE__*/function (_Node11) {
    _inherits__default['default'](OID, _Node11);

    var _super13 = _createSuper$m(OID);

    function OID() {
      var _this23;

      var _this22;

      _classCallCheck__default['default'](this, OID);

      _this22 = _super13.call(this);
      _this22.value = EMPTY_OID;

      (_this23 = _this22).from.apply(_this23, arguments);

      return _this22;
    }

    _createClass__default['default'](OID, [{
      key: "getBodySize",
      value: function getBodySize() {
        var oid = this.value;
        if (oid.length < 2 || oid[0] > 2 || oid[0] < 2 && oid[1] >= 40) throw new Error('Invalid OID.');
        var size = sizeBase128(oid[0] * 40 + oid[1]);

        for (var i = 2; i < oid.length; i++) {
          size += sizeBase128(oid[i]);
        }

        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        var oid = this.value;
        var data = bw.data;
        if (oid.length < 2 || oid[0] > 2 || oid[0] < 2 && oid[1] >= 40) throw new Error('Invalid OID.');
        var off = bw.offset;
        off = writeBase128(data, oid[0] * 40 + oid[1], off);

        for (var i = 2; i < oid.length; i++) {
          off = writeBase128(data, oid[i], off);
        }

        bw.offset = off;
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        var data = br.readBytes(br.left(), true);
        if (data.length === 0) throw new Error('Zero length OID.');
        var s = new Uint32Array(data.length + 1);

        var _readBase = readBase128(data, 0),
            _readBase2 = _slicedToArray__default['default'](_readBase, 2),
            v = _readBase2[0],
            off = _readBase2[1];

        if (v < 80) {
          s[0] = v / 40 >>> 0;
          s[1] = v % 40;
        } else {
          s[0] = 2;
          s[1] = v - 80;
        }

        var i = 2;

        for (; off < data.length; i++) {
          var _readBase3 = readBase128(data, off);

          var _readBase4 = _slicedToArray__default['default'](_readBase3, 2);

          v = _readBase4[0];
          off = _readBase4[1];
          s[i] = v;
        }

        this.value = s.subarray(0, i);
        return this;
      }
    }, {
      key: "equals",
      value: function equals(oid) {
        assert_1$1(oid instanceof OID);
        return isEqual(this.value, oid.value);
      }
    }, {
      key: "set",
      value: function set(value) {
        if (value == null) value = EMPTY_OID;
        if (typeof value === 'string') return this.fromString(value);
        if (Array.isArray(value)) return this.fromArray(value);
        assert_1$1(value instanceof Uint32Array);
        this.value = value;
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return isEqual(this.value, EMPTY_OID);
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var arr = [];

        for (var i = 0; i < this.value.length; i++) {
          arr.push(this.value[i]);
        }

        return arr;
      }
    }, {
      key: "fromArray",
      value: function fromArray(arr) {
        assert_1$1(Array.isArray(arr));
        var out = new Uint32Array(arr.length);

        for (var i = 0; i < arr.length; i++) {
          var val = arr[i];
          assert_1$1(val >>> 0 === val);
          out[i] = val;
        }

        this.value = out;
        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        var str = '';

        for (var i = 0; i < this.value.length; i++) {
          if (i > 0) str += '.';
          str += this.value[i].toString(10);
        }

        return str;
      }
    }, {
      key: "fromString",
      value: function fromString(str) {
        assert_1$1(typeof str === 'string');
        if (objects.attrs.hasOwnProperty(str)) str = objects.attrs[str];else if (objects.keyAlgs.hasOwnProperty(str)) str = objects.keyAlgs[str];else if (objects.hashes.hasOwnProperty(str)) str = objects.hashes[str];else if (objects.curves.hasOwnProperty(str)) str = objects.curves[str];
        var parts = str.split('.');
        var out = new Uint32Array(parts.length);

        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          out[i] = parseU32(part);
        }

        this.value = out;
        return this;
      }
    }, {
      key: "getAttributeName",
      value: function getAttributeName() {
        return objects.attrsByVal[this.toString()] || null;
      }
    }, {
      key: "getSignatureAlgorithmName",
      value: function getSignatureAlgorithmName() {
        return objects.sigAlgsByVal[this.toString()] || null;
      }
    }, {
      key: "getSignatureHash",
      value: function getSignatureHash() {
        return objects.sigToHash[this.toString()] || null;
      }
    }, {
      key: "getSignatureHashName",
      value: function getSignatureHashName() {
        var oid = this.getSignatureHash();
        if (!oid) return null;
        return objects.hashesByVal[oid] || null;
      }
    }, {
      key: "getKeyAlgorithmName",
      value: function getKeyAlgorithmName() {
        return objects.keyAlgsByVal[this.toString()] || null;
      }
    }, {
      key: "getHashName",
      value: function getHashName() {
        return objects.hashesByVal[this.toString()] || null;
      }
    }, {
      key: "getCurveName",
      value: function getCurveName() {
        return objects.curvesByVal[this.toString()] || null;
      }
    }, {
      key: "format",
      value: function format() {
        var oid = this.toString();
        var name = objects.attrsByVal[oid] || objects.sigAlgsByVal[oid] || objects.keyAlgsByVal[oid] || objects.hashesByVal[oid] || objects.curvesByVal[oid] || 'UNKNOWN';
        var str = "".concat(oid, " (").concat(name, ")");
        return "<".concat(this.constructor.name, ": ").concat(str, ">");
      }
    }, {
      key: "type",
      get: function get() {
        return types$2.OID;
      }
    }]);

    return OID;
  }(Node);
  /**
   * Enum
   */


  var Enum = /*#__PURE__*/function (_Integer2) {
    _inherits__default['default'](Enum, _Integer2);

    var _super14 = _createSuper$m(Enum);

    function Enum() {
      _classCallCheck__default['default'](this, Enum);

      for (var _len4 = arguments.length, options = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        options[_key4] = arguments[_key4];
      }

      return _super14.call.apply(_super14, [this].concat(options));
    }

    _createClass__default['default'](Enum, [{
      key: "type",
      get: function get() {
        return types$2.ENUM;
      }
    }]);

    return Enum;
  }(Integer);
  /**
   * Utf8String
   */


  var Utf8String = /*#__PURE__*/function (_Str) {
    _inherits__default['default'](Utf8String, _Str);

    var _super15 = _createSuper$m(Utf8String);

    function Utf8String() {
      _classCallCheck__default['default'](this, Utf8String);

      for (var _len5 = arguments.length, options = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        options[_key5] = arguments[_key5];
      }

      return _super15.call.apply(_super15, [this].concat(options));
    }

    _createClass__default['default'](Utf8String, [{
      key: "type",
      get: function get() {
        return types$2.UTF8STRING;
      }
    }, {
      key: "encoding",
      get: function get() {
        return 'utf8';
      }
    }]);

    return Utf8String;
  }(Str);
  /**
   * RawSequence
   */


  var RawSequence = /*#__PURE__*/function (_Node12) {
    _inherits__default['default'](RawSequence, _Node12);

    var _super16 = _createSuper$m(RawSequence);

    function RawSequence() {
      var _this25;

      var _this24;

      _classCallCheck__default['default'](this, RawSequence);

      _this24 = _super16.call(this);
      _this24.value = EMPTY$4;

      (_this25 = _this24).from.apply(_this25, arguments);

      return _this24;
    }

    _createClass__default['default'](RawSequence, [{
      key: "getBodySize",
      value: function getBodySize() {
        return this.value.length;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        bw.writeBytes(this.value);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.value = br.readBytes(br.left());
        return this;
      }
    }, {
      key: "set",
      value: function set(value) {
        if (value == null) value = EMPTY$4;
        if (Array.isArray(value)) return this.fromArray(value);
        assert_1$1(Buffer.isBuffer(value));
        this.value = value;
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.value.length === 0;
      }
    }, {
      key: "children",
      value: /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function children() {
        var br;
        return _regeneratorRuntime__default['default'].wrap(function children$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                br = bufio.read(this.value);

              case 1:
                if (!br.left()) {
                  _context.next = 6;
                  break;
                }

                _context.next = 4;
                return Any.read(br).node;

              case 4:
                _context.next = 1;
                break;

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, children, this);
      })
    }, {
      key: "toArray",
      value: function toArray() {
        var out = [];

        var _iterator = _createForOfIteratorHelper$8(this.children()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var el = _step.value;
            out.push(el);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return out;
      }
    }, {
      key: "fromArray",
      value: function fromArray(value) {
        assert_1$1(Array.isArray(value));
        var size = 0;

        var _iterator2 = _createForOfIteratorHelper$8(value),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var el = _step2.value;
            assert_1$1(el instanceof Node);
            size += el.getSize();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        var bw = bufio.write(size);

        var _iterator3 = _createForOfIteratorHelper$8(value),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _el = _step3.value;

            _el.write(bw);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        this.value = bw.render();
        return this;
      }
    }, {
      key: "format",
      value: function format() {
        return this.toArray();
      }
    }, {
      key: "type",
      get: function get() {
        return types$2.SEQUENCE;
      }
    }]);

    return RawSequence;
  }(Node);
  /**
   * RawSet
   */


  var RawSet = /*#__PURE__*/function (_RawSequence) {
    _inherits__default['default'](RawSet, _RawSequence);

    var _super17 = _createSuper$m(RawSet);

    function RawSet() {
      _classCallCheck__default['default'](this, RawSet);

      for (var _len6 = arguments.length, options = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        options[_key6] = arguments[_key6];
      }

      return _super17.call.apply(_super17, [this].concat(options));
    }

    _createClass__default['default'](RawSet, [{
      key: "type",
      get: function get() {
        return types$2.SET;
      }
    }]);

    return RawSet;
  }(RawSequence);
  /**
   * NumString
   */


  var NumString = /*#__PURE__*/function (_Str2) {
    _inherits__default['default'](NumString, _Str2);

    var _super18 = _createSuper$m(NumString);

    function NumString() {
      _classCallCheck__default['default'](this, NumString);

      for (var _len7 = arguments.length, options = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        options[_key7] = arguments[_key7];
      }

      return _super18.call.apply(_super18, [this].concat(options));
    }

    _createClass__default['default'](NumString, [{
      key: "type",
      get: function get() {
        return types$2.NUMSTRING;
      }
    }]);

    return NumString;
  }(Str);
  /**
   * PrintString
   */


  var PrintString = /*#__PURE__*/function (_Str3) {
    _inherits__default['default'](PrintString, _Str3);

    var _super19 = _createSuper$m(PrintString);

    function PrintString() {
      _classCallCheck__default['default'](this, PrintString);

      for (var _len8 = arguments.length, options = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        options[_key8] = arguments[_key8];
      }

      return _super19.call.apply(_super19, [this].concat(options));
    }

    _createClass__default['default'](PrintString, [{
      key: "type",
      get: function get() {
        return types$2.PRINTSTRING;
      }
    }]);

    return PrintString;
  }(Str);
  /**
   * T61String
   */


  var T61String = /*#__PURE__*/function (_Str4) {
    _inherits__default['default'](T61String, _Str4);

    var _super20 = _createSuper$m(T61String);

    function T61String() {
      _classCallCheck__default['default'](this, T61String);

      for (var _len9 = arguments.length, options = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        options[_key9] = arguments[_key9];
      }

      return _super20.call.apply(_super20, [this].concat(options));
    }

    _createClass__default['default'](T61String, [{
      key: "type",
      get: function get() {
        return types$2.T61STRING;
      }
    }]);

    return T61String;
  }(Str);
  /**
   * IA5String
   */


  var IA5String = /*#__PURE__*/function (_Str5) {
    _inherits__default['default'](IA5String, _Str5);

    var _super21 = _createSuper$m(IA5String);

    function IA5String() {
      _classCallCheck__default['default'](this, IA5String);

      for (var _len10 = arguments.length, options = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        options[_key10] = arguments[_key10];
      }

      return _super21.call.apply(_super21, [this].concat(options));
    }

    _createClass__default['default'](IA5String, [{
      key: "type",
      get: function get() {
        return types$2.IA5STRING;
      }
    }]);

    return IA5String;
  }(Str);
  /**
   * Time
   */


  var Time = /*#__PURE__*/function (_Node13) {
    _inherits__default['default'](Time, _Node13);

    var _super22 = _createSuper$m(Time);

    function Time() {
      var _this27;

      var _this26;

      _classCallCheck__default['default'](this, Time);

      _this26 = _super22.call(this);
      _this26.value = 0;
      _this26.offset = 0;

      (_this27 = _this26).from.apply(_this27, arguments);

      return _this26;
    }

    _createClass__default['default'](Time, [{
      key: "set",
      value: function set(value, offset) {
        if (value == null) value = 0;
        if (offset == null) offset = 0;
        if (typeof value === 'string') return this.fromString(value);
        assert_1$1(isTime(value));
        assert_1$1(isOffset(offset));
        this.value = value;
        this.offset = offset;
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.value === 0 && this.offset === 0;
      }
    }, {
      key: "unix",
      value: function unix() {
        return this.value - this.offset;
      }
    }, {
      key: "toString",
      value: function toString() {
        var date = new Date(this.value * 1000);
        var str = date.toISOString().slice(0, -5);
        return str + serializeOffset(this.offset);
      }
    }, {
      key: "fromString",
      value: function fromString(str) {
        assert_1$1(typeof str === 'string');
        var ms = Date.parse(str);
        if (ms !== ms) throw new Error('Invalid date string.');
        var time = Math.floor(ms / 1000);
        if (!isTime(time)) throw new Error('Invalid time.');
        this.value = time;
        this.offset = 0;
        return this;
      }
    }, {
      key: "format",
      value: function format() {
        var name = this.constructor.name;
        var value = this.value;
        var off = this.offset.toString(10);
        if (this.offset >= 0) off = '+' + off;
        return "<".concat(name, ": ").concat(value).concat(off, " (").concat(this.toString(), ")>");
      }
    }]);

    return Time;
  }(Node);
  /**
   * UTCTime
   */


  var UTCTime = /*#__PURE__*/function (_Time) {
    _inherits__default['default'](UTCTime, _Time);

    var _super23 = _createSuper$m(UTCTime);

    function UTCTime() {
      _classCallCheck__default['default'](this, UTCTime);

      for (var _len11 = arguments.length, options = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        options[_key11] = arguments[_key11];
      }

      return _super23.call.apply(_super23, [this].concat(options));
    }

    _createClass__default['default'](UTCTime, [{
      key: "getBodySize",
      value: function getBodySize() {
        return this.offset === 0 ? 13 : 17;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        assert_1$1(isTime(this.value));
        var date = new Date(this.value * 1000);
        var str = '';
        str += two(date.getUTCFullYear() % 100);
        str += two(date.getUTCMonth() + 1);
        str += two(date.getUTCDate());
        str += two(date.getUTCHours());
        str += two(date.getUTCMinutes());
        str += two(date.getUTCSeconds());
        str += serializeOffset(this.offset);
        bw.writeString(str, 'binary');
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        var size = br.left();
        if (size !== 13 && size !== 17) throw new Error('Invalid UTCTIME.');
        var str = br.readString(size, 'binary');
        var year = parseU32(str.substring(0, 2));
        var mon = parseU32(str.substring(2, 4));
        var day = parseU32(str.substring(4, 6));
        var hour = parseU32(str.substring(6, 8));
        var min = parseU32(str.substring(8, 10));
        var sec = parseU32(str.substring(10, 12));
        this.value = toSeconds(year, mon, day, hour, min, sec, true);
        this.offset = parseOffset(str.substring(12));
        return this;
      }
    }, {
      key: "type",
      get: function get() {
        return types$2.UTCTIME;
      }
    }]);

    return UTCTime;
  }(Time);
  /**
   * GenTime
   */


  var GenTime = /*#__PURE__*/function (_Time2) {
    _inherits__default['default'](GenTime, _Time2);

    var _super24 = _createSuper$m(GenTime);

    function GenTime() {
      _classCallCheck__default['default'](this, GenTime);

      for (var _len12 = arguments.length, options = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        options[_key12] = arguments[_key12];
      }

      return _super24.call.apply(_super24, [this].concat(options));
    }

    _createClass__default['default'](GenTime, [{
      key: "getBodySize",
      value: function getBodySize() {
        return this.offset === 0 ? 15 : 19;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        assert_1$1(isTime(this.value));
        var date = new Date(this.value * 1000);
        var str = '';
        str += date.getUTCFullYear().toString(10);
        str += two(date.getUTCMonth() + 1);
        str += two(date.getUTCDate());
        str += two(date.getUTCHours());
        str += two(date.getUTCMinutes());
        str += two(date.getUTCSeconds());
        str += serializeOffset(this.offset);
        bw.writeString(str, 'binary');
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        var size = br.left();
        if (size !== 15 && size !== 19) throw new Error('Invalid GENTIME.');
        var str = br.readString(size, 'binary');
        var year = parseU32(str.substring(0, 4));
        var mon = parseU32(str.substring(4, 6));
        var day = parseU32(str.substring(6, 8));
        var hour = parseU32(str.substring(8, 10));
        var min = parseU32(str.substring(10, 12));
        var sec = parseU32(str.substring(12, 14));
        this.value = toSeconds(year, mon, day, hour, min, sec, false);
        this.offset = parseOffset(str.substring(14));
        return this;
      }
    }, {
      key: "type",
      get: function get() {
        return types$2.GENTIME;
      }
    }]);

    return GenTime;
  }(Time);
  /**
   * GenString
   */


  var GenString = /*#__PURE__*/function (_Str6) {
    _inherits__default['default'](GenString, _Str6);

    var _super25 = _createSuper$m(GenString);

    function GenString() {
      _classCallCheck__default['default'](this, GenString);

      for (var _len13 = arguments.length, options = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        options[_key13] = arguments[_key13];
      }

      return _super25.call.apply(_super25, [this].concat(options));
    }

    _createClass__default['default'](GenString, [{
      key: "type",
      get: function get() {
        return types$2.GENSTRING;
      }
    }]);

    return GenString;
  }(Str);
  /**
   * API
   */


  function typeToClass(type) {
    assert_1$1(type >>> 0 === type);

    switch (type) {
      case types$2.BOOLEAN:
        return Bool;

      case types$2.INTEGER:
        return Integer;

      case types$2.BITSTRING:
        return BitString;

      case types$2.OCTSTRING:
        return OctString;

      case types$2.NULL:
        return Null;

      case types$2.OID:
        return OID;

      case types$2.ENUM:
        return Enum;

      case types$2.UTF8STRING:
        return Utf8String;

      case types$2.SEQUENCE:
        return RawSequence;

      case types$2.SET:
        return RawSet;

      case types$2.NUMSTRING:
        return NumString;

      case types$2.PRINTSTRING:
        return PrintString;

      case types$2.T61STRING:
        return T61String;

      case types$2.IA5STRING:
        return IA5String;

      case types$2.UTCTIME:
        return UTCTime;

      case types$2.GENTIME:
        return GenTime;

      case types$2.GENSTRING:
        return GenString;

      default:
        throw new Error("Unknown type: ".concat(type, "."));
    }
  }
  /*
   * Helpers
   */


  function sizeHeader(size) {
    assert_1$1(size >>> 0 === size);
    if (size <= 0x7f) return 1 + 1;
    if (size <= 0xff) return 1 + 1 + 1;
    if (size <= 0xffff) return 1 + 1 + 2;
    assert_1$1(size <= 0xffffff);
    return 1 + 1 + 3;
  }

  function writeHeader(bw, type, cls, primitive, size) {
    assert_1$1(bw);
    assert_1$1(type >>> 0 === type);
    assert_1$1(cls >>> 0 === cls);
    assert_1$1(typeof primitive === 'boolean');
    assert_1$1(size >>> 0 === size);
    if (!primitive) type |= 0x20;
    type |= cls << 6; // Short form.

    if (size <= 0x7f) {
      bw.writeU8(type);
      bw.writeU8(size);
      return bw;
    } // Long form (1 byte).


    if (size <= 0xff) {
      bw.writeU8(type);
      bw.writeU8(0x80 | 1);
      bw.writeU8(size);
      return bw;
    } // Long form (2 bytes).


    if (size <= 0xffff) {
      bw.writeU8(type);
      bw.writeU8(0x80 | 2);
      bw.writeU16BE(size);
      return bw;
    }

    assert_1$1(size <= 0xffffff); // Long form (3 bytes).

    bw.writeU8(type);
    bw.writeU8(0x80 | 3);
    bw.writeU24BE(size);
    return bw;
  }

  function readHeader(br) {
    var start = br.offset;
    var field = br.readU8();
    var cls = field >>> 6;
    var primitive = (field & 0x20) === 0;
    var type = field & 0x1f;

    if (type === 0x1f) {
      var _readBase5 = readBase128(br.data, br.offset);

      var _readBase6 = _slicedToArray__default['default'](_readBase5, 2);

      type = _readBase6[0];
      br.offset = _readBase6[1];
      if (type < 0x1f) throw new Error('Non-minimal type.');
    }

    switch (cls) {
      case classes.UNIVERSAL:
      case classes.CONTEXT:
        break;

      default:
        throw new Error('Unknown class.');
    }

    var size = readSize$1(br);
    var len = br.offset - start;
    return {
      type: type,
      cls: cls,
      primitive: primitive,
      size: size,
      len: len
    };
  }

  function peekHeader(br, optional) {
    var offset = br.offset;
    var hdr = null;
    var err = null;

    try {
      hdr = readHeader(br);
    } catch (e) {
      err = e;
    }

    br.offset = offset;
    if (!optional && !hdr) throw err;
    return hdr;
  }

  function readSize$1(br) {
    var field = br.readU8();
    var bytes = field & 0x7f; // Definite form

    if ((field & 0x80) === 0) {
      // Short form
      return bytes;
    } // Indefinite form.


    if (bytes === 0) throw new Error('Indefinite length.');
    var len = 0;

    for (var i = 0; i < bytes; i++) {
      var ch = br.readU8();
      if (len >= 1 << 24) throw new Error('Length too large.');
      len *= 0x100;
      len += ch;
      if (len === 0) throw new Error('Unexpected leading zeroes.');
    }

    if (len < 0x80) throw new Error('Non-minimal length.');
    return len;
  }

  function sizeBase128(n) {
    assert_1$1(n >>> 0 === n);
    if (n === 0) return 1;
    var len = 0;

    while (n > 0) {
      len += 1;
      n >>>= 7;
    }

    return len;
  }

  function writeBase128(data, n, off) {
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(n >>> 0 === n);
    assert_1$1(off >>> 0 === off);
    var l = sizeBase128(n);

    for (var i = l - 1; i >= 0; i--) {
      var o = n >>> i * 7;
      o &= 0x7f;
      if (i !== 0) o |= 0x80;
      if (off >= data.length) throw new bufio.EncodingError(off, 'Out of bounds write');
      data[off] = o;
      off += 1;
    }

    return off;
  }

  function readBase128(data, off) {
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(off >>> 0 === off);
    var shifted = 0;
    var num = 0;

    for (; off < data.length; shifted++) {
      if (shifted === 5) throw new Error('Base128 integer too large.');
      var b = data[off];
      num *= 128;
      num += b & 0x7f;
      off += 1;

      if ((b & 0x80) === 0) {
        if (num > 0xffffffff) throw new Error('Base128 integer too large.');
        return [num, off];
      }
    }

    throw new Error('Base128 integer too short.');
  }

  function two(num) {
    if (num < 10) return '0' + num.toString(10);
    return num.toString(10);
  }

  function isNumString(str) {
    assert_1$1(typeof str === 'string');

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch >= 0x30 && ch <= 0x39) continue;
      if (ch === 0x20) continue;
      return false;
    }

    return true;
  }

  function isPrintString(str) {
    assert_1$1(typeof str === 'string');

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i); // 0 - 9

      if (ch >= 0x30 && ch <= 0x39) continue; // A - Z

      if (ch >= 0x41 && ch <= 0x5a) continue; // a - z

      if (ch >= 0x61 && ch <= 0x7a) continue;

      switch (ch) {
        case 0x20: // ' '

        case 0x26: // & - nonstandard

        case 0x27: // '

        case 0x28: // (

        case 0x29: // )

        case 0x2a: // * - nonstandard

        case 0x2b: // +

        case 0x2c: // ,

        case 0x2d: // -

        case 0x2e: // .

        case 0x2f: // /

        case 0x3a: // :

        case 0x3d: // =

        case 0x3f:
          // ?
          continue;
      }

      return false;
    }

    return true;
  }

  function isIA5String(str) {
    assert_1$1(typeof str === 'string');

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch >= 0x80) return false;
    }

    return true;
  }

  function parseU32(str) {
    assert_1$1(typeof str === 'string');
    var word = 0;
    if (str.length === 0 || str.length > 10) throw new Error('Invalid integer.');

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i) - 0x30;
      if (ch < 0 || ch > 9) throw new Error('Invalid integer.');
      word *= 10;
      word += ch;
      if (word > 0xffffffff) throw new Error('Invalid integer.');
    }

    return word;
  }

  function isEqual(a, b) {
    assert_1$1(a instanceof Uint32Array);
    assert_1$1(b instanceof Uint32Array);
    if (a.length !== b.length) return false;

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }

    return true;
  }

  function trimLeft$1(buf) {
    assert_1$1(Buffer.isBuffer(buf));
    if (buf.length === 0) return Buffer.from([0x00]);
    if (buf[0] !== 0x00) return buf;

    for (var i = 1; i < buf.length; i++) {
      if (buf[i] !== 0x00) return buf.slice(i);
    }

    return buf.slice(-1);
  }

  function twosComplement(num, start, end) {
    assert_1$1(Buffer.isBuffer(num));
    assert_1$1(start >>> 0 === start);
    assert_1$1(end >>> 0 === end);
    assert_1$1(start <= end);
    var carry = 1;

    for (var i = end - 1; i >= start; i--) {
      carry += num[i] ^ 0xff;
      num[i] = carry & 0xff;
      carry >>>= 8;
    }

    return num;
  }

  function isTime(time) {
    if (!Number.isSafeInteger(time)) return false; // ASN.1 time ranges from;
    //   0000-01-01T00:00:00.000Z
    // to:
    //   9999-12-31T00:59:59.000Z

    if (time < MIN_TIME || time > MAX_TIME) return false;
    return true;
  }

  function toSeconds(year, mon, day, hour, min, sec, utc) {
    assert_1$1(year >>> 0 === year);
    assert_1$1(mon >>> 0 === mon);
    assert_1$1(day >>> 0 === day);
    assert_1$1(hour >>> 0 === hour);
    assert_1$1(min >>> 0 === min);
    assert_1$1(sec >>> 0 === sec);
    assert_1$1(typeof utc === 'boolean');

    if (utc) {
      if (year < 70) year = 2000 + year;else year = 1900 + year;
    } // Highest valid date:
    //   new Date(8640000000000000)


    if (year > 275760) throw new Error('Invalid year.');
    if (mon < 1 || mon > 12 || day < 1 || day > 32) throw new Error('Invalid month or day.');
    if (hour > 23 || min > 59 || sec > 59) throw new Error('Invalid hours, minutes, or seconds.');
    var ms = Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    assert_1$1(ms === ms);
    var time = ms / 1000;
    assert_1$1(isTime(time));
    return time;
  }

  function isOffset(offset) {
    if (!Number.isSafeInteger(offset)) return false; // UTC timezones range from -12:00 to +14:00.

    if (offset < MIN_OFFSET || offset > MAX_OFFSET) return false;
    return true;
  }

  function serializeOffset(offset) {
    assert_1$1(isOffset(offset));
    if (offset === 0) return 'Z';
    var str = '';

    if (offset < 0) {
      str += '-';
      offset = -offset;
    } else {
      str += '+';
    }

    var minutes = offset / 60 >>> 0;
    var hour = minutes / 60 >>> 0;
    var min = minutes % 60;
    str += two(hour);
    str += two(min);
    return str;
  }

  function parseOffset(str) {
    assert_1$1(typeof str === 'string');
    if (str.length === 0) throw new Error('Invalid time offset.');
    var zone = str[0];

    switch (zone) {
      case 'Z':
        {
          if (str.length !== 1) throw new Error('Non-minimal time offset.');
          return 0;
        }

      case '+':
      case '-':
        {
          if (str.length !== 5) throw new Error('Non-minimal time offset.');
          var hour = parseU32(str.substring(1, 3));
          var min = parseU32(str.substring(3, 5));
          var minutes = hour * 60 + min;
          var offset = minutes * 60;
          if (zone === '-') offset = -offset;
          if (!isOffset(offset)) throw new Error('Not a time zone.');
          return offset;
        }
    }

    throw new Error('Invalid time offset.');
  }
  /*
   * Expose
   */


  var EMPTY_1 = EMPTY$4;
  var ZERO_1 = ZERO$1;
  var EMPTY_OID_1 = EMPTY_OID;
  var types_1 = types$2;
  var typesByVal_1 = typesByVal;
  var classes_1 = classes;
  var classesByVal_1 = classesByVal;
  var objects_1 = objects;
  var TARGET_1 = TARGET;
  var OPTIONAL_1 = OPTIONAL;
  var MODE_1 = MODE;
  var NORMAL_1 = NORMAL;
  var EXPLICIT_1 = EXPLICIT;
  var IMPLICIT_1 = IMPLICIT;
  var Node_1 = Node;
  var Sequence_1 = Sequence;
  var _Set = Set$1;
  var Any_1 = Any;
  var Choice_1 = Choice;
  var Str_1 = Str;
  var _String = Str;
  var Bool_1 = Bool;
  var _Boolean = Bool;
  var Integer_1 = Integer;
  var Unsigned_1 = Unsigned;
  var BitString_1 = BitString;
  var OctString_1 = OctString;
  var Null_1 = Null;
  var OID_1 = OID;
  var Enum_1 = Enum;
  var Utf8String_1 = Utf8String;
  var RawSequence_1 = RawSequence;
  var RawSet_1 = RawSet;
  var NumString_1 = NumString;
  var PrintString_1 = PrintString;
  var T61String_1 = T61String;
  var IA5String_1 = IA5String;
  var Time_1 = Time;
  var UTCTime_1 = UTCTime;
  var GenTime_1 = GenTime;
  var GenString_1 = GenString;
  var typeToClass_1 = typeToClass;
  var asn1$1 = {
    EMPTY: EMPTY_1,
    ZERO: ZERO_1,
    EMPTY_OID: EMPTY_OID_1,
    types: types_1,
    typesByVal: typesByVal_1,
    classes: classes_1,
    classesByVal: classesByVal_1,
    objects: objects_1,
    TARGET: TARGET_1,
    OPTIONAL: OPTIONAL_1,
    MODE: MODE_1,
    NORMAL: NORMAL_1,
    EXPLICIT: EXPLICIT_1,
    IMPLICIT: IMPLICIT_1,
    Node: Node_1,
    Sequence: Sequence_1,
    Set: _Set,
    Any: Any_1,
    Choice: Choice_1,
    Str: Str_1,
    String: _String,
    Bool: Bool_1,
    Boolean: _Boolean,
    Integer: Integer_1,
    Unsigned: Unsigned_1,
    BitString: BitString_1,
    OctString: OctString_1,
    Null: Null_1,
    OID: OID_1,
    Enum: Enum_1,
    Utf8String: Utf8String_1,
    RawSequence: RawSequence_1,
    RawSet: RawSet_1,
    NumString: NumString_1,
    PrintString: PrintString_1,
    T61String: T61String_1,
    IA5String: IA5String_1,
    Time: Time_1,
    UTCTime: UTCTime_1,
    GenTime: GenTime_1,
    GenString: GenString_1,
    typeToClass: typeToClass_1
  };

  /*
   * Constants
   */


  var CHARSET$2 = '0123456789abcdef';
  var TABLE$2 = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
  /*
   * Encoding
   */

  function _encode(data, endian) {
    assert_1$1(Buffer.isBuffer(data));
    var len = data.length;
    var i = endian < 0 ? len - 1 : 0;
    var str = '';

    while (len--) {
      str += CHARSET$2[data[i] >> 4];
      str += CHARSET$2[data[i] & 15];
      i += endian;
    }

    return str;
  }
  /*
   * Decoding
   */


  function _decode(str, endian) {
    assert_1$1(typeof str === 'string');
    var len = str.length;
    var i = endian < 0 ? len - 2 : 0;
    var j = 0;
    var z = 0;
    if (len & 1) throw new Error('Invalid hex string.');
    len >>>= 1;
    endian *= 2;
    var data = Buffer.alloc(len);

    while (len--) {
      var c1 = str.charCodeAt(i + 0);
      var c2 = str.charCodeAt(i + 1);
      var hi = TABLE$2[c1 & 0x7f];
      var lo = TABLE$2[c2 & 0x7f];
      z |= c1 | c2 | hi | lo;
      data[j++] = hi << 4 | lo;
      i += endian;
    } // Check for errors at the end.


    if (z & 0xffffff80) throw new Error('Invalid hex string.');
    return data;
  }
  /*
   * Testing
   */


  function _test(str) {
    assert_1$1(typeof str === 'string');
    if (str.length & 1) return false;

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch & 0xff80) return false;
      if (TABLE$2[ch] === -1) return false;
    }

    return true;
  }
  /*
   * Base16
   */


  function encode$2(data) {
    return _encode(data, 1);
  }

  function decode$2(str) {
    return _decode(str, 1);
  }

  function test$1(str) {
    return _test(str);
  }
  /*
   * Base16 (Little Endian)
   */


  function encodeLE(data) {
    return _encode(data, -1);
  }

  function decodeLE(str) {
    return _decode(str, -1);
  }

  function testLE(str) {
    return _test(str);
  }
  /*
   * Expose
   */


  var native_1$8 = 0;
  var encode_1 = encode$2;
  var decode_1 = decode$2;
  var test_1 = test$1;
  var encodeLE_1 = encodeLE;
  var decodeLE_1 = decodeLE;
  var testLE_1 = testLE;
  var base16 = {
    native: native_1$8,
    encode: encode_1,
    decode: decode_1,
    test: test_1,
    encodeLE: encodeLE_1,
    decodeLE: decodeLE_1,
    testLE: testLE_1
  };

  var base16Browser = base16;

  /*
   * Constants
   */


  var CHARSET$3 = 'abcdefghijklmnopqrstuvwxyz234567';
  var TABLE$3 = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1];
  var CHARSET_HEX = '0123456789abcdefghijklmnopqrstuv';
  var TABLE_HEX = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1];
  var PADDING$3 = [0, 6, 4, 3, 1];
  /**
   * Encode a base32 string.
   * @private
   * @param {Buffer} data
   * @param {String} charset
   * @param {Boolean} [pad=false]
   * @returns {String}
   */

  function _encode$1(data, charset, pad) {
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(typeof pad === 'boolean');
    var str = '';
    var mode = 0;
    var left = 0;

    for (var i = 0; i < data.length; i++) {
      var ch = data[i];

      switch (mode) {
        case 0:
          str += charset[ch >>> 3];
          left = (ch & 7) << 2;
          mode = 1;
          break;

        case 1:
          str += charset[left | ch >>> 6];
          str += charset[ch >>> 1 & 31];
          left = (ch & 1) << 4;
          mode = 2;
          break;

        case 2:
          str += charset[left | ch >>> 4];
          left = (ch & 15) << 1;
          mode = 3;
          break;

        case 3:
          str += charset[left | ch >>> 7];
          str += charset[ch >>> 2 & 31];
          left = (ch & 3) << 3;
          mode = 4;
          break;

        case 4:
          str += charset[left | ch >>> 5];
          str += charset[ch & 31];
          mode = 0;
          break;
      }
    }

    if (mode > 0) {
      str += charset[left];

      if (pad) {
        for (var _i = 0; _i < PADDING$3[mode]; _i++) {
          str += '=';
        }
      }
    }

    return str;
  }
  /**
   * Decode a base32 string.
   * @private
   * @param {String} str
   * @param {Array} table
   * @param {Boolean} [unpad=false]
   * @returns {Buffer}
   */


  function _decode$1(str, table, unpad) {
    assert_1$1(typeof str === 'string');
    assert_1$1(typeof unpad === 'boolean');

    var size = _decodeSize(str);

    var data = Buffer.alloc(size);
    var mode = 0;
    var left = 0;
    var j = 0;
    var i = 0;

    for (; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch & 0xff80) throw new Error('Invalid base32 string.');
      var val = table[ch];
      if (val === -1) break;

      switch (mode) {
        case 0:
          left = val;
          mode = 1;
          break;

        case 1:
          data[j++] = left << 3 | val >>> 2;
          left = val & 3;
          mode = 2;
          break;

        case 2:
          left = left << 5 | val;
          mode = 3;
          break;

        case 3:
          data[j++] = left << 1 | val >>> 4;
          left = val & 15;
          mode = 4;
          break;

        case 4:
          data[j++] = left << 4 | val >>> 1;
          left = val & 1;
          mode = 5;
          break;

        case 5:
          left = left << 5 | val;
          mode = 6;
          break;

        case 6:
          data[j++] = left << 2 | val >>> 3;
          left = val & 7;
          mode = 7;
          break;

        case 7:
          data[j++] = left << 5 | val;
          left = 0;
          mode = 0;
          break;
      }
    }

    if (mode === 1 || mode === 3 || mode === 6) throw new Error('Invalid base32 string.');
    if (left > 0) throw new Error('Invalid base32 string.');
    if (str.length !== i + (-mode & 7) * unpad) throw new Error('Invalid base32 string.');

    for (; i < str.length; i++) {
      var _ch = str.charCodeAt(i);

      if (_ch !== 0x3d) throw new Error('Invalid base32 string.');
    }

    assert_1$1(j === size);
    return data;
  }
  /**
   * Calculate decoding size.
   * @private
   * @param {String} str
   * @returns {Number}
   */


  function _decodeSize(str) {
    var len = str.length;

    for (var i = 0; i < 6 && len > 0; i++) {
      if (str[len - 1] === '=') len -= 1;
    }

    var size = (len >>> 3) * 5;

    switch (len & 7) {
      case 7:
        size += 1;

      case 6: // Invalid.

      case 5:
        size += 1;

      case 4:
        size += 1;

      case 3: // Invalid.

      case 2:
        size += 1;
    }

    return size;
  }
  /**
   * Test a base32 string.
   * @private
   * @param {String} str
   * @param {Array} table
   * @param {Boolean} [unpad=false]
   * @returns {Boolean}
   */


  function _test$1(str, table, unpad) {
    assert_1$1(typeof str === 'string');
    assert_1$1(typeof unpad === 'boolean');
    var i = 0;

    for (; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch & 0xff80) return false;
      if (table[ch] === -1) break;
    }

    var mode = i & 7;

    switch (mode) {
      case 1:
        return false;

      case 2:
        if (table[str.charCodeAt(i - 1)] & 3) return false;
        break;

      case 3:
        return false;

      case 4:
        if (table[str.charCodeAt(i - 1)] & 15) return false;
        break;

      case 5:
        if (table[str.charCodeAt(i - 1)] & 1) return false;
        break;

      case 6:
        return false;

      case 7:
        if (table[str.charCodeAt(i - 1)] & 7) return false;
        break;
    }

    if (str.length !== i + (-mode & 7) * unpad) return false;

    for (; i < str.length; i++) {
      var _ch2 = str.charCodeAt(i);

      if (_ch2 !== 0x3d) return false;
    }

    return true;
  }
  /**
   * Encode a base32 string.
   * @param {Buffer} data
   * @param {Boolean} [pad=false]
   * @returns {String}
   */


  function encode$3(data) {
    var pad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return _encode$1(data, CHARSET$3, pad);
  }
  /**
   * Decode a base32 string.
   * @param {String} str
   * @param {Boolean} [unpad=false]
   * @returns {Buffer}
   */


  function decode$3(str) {
    var unpad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return _decode$1(str, TABLE$3, unpad);
  }
  /**
   * Test a base32 string.
   * @param {String} str
   * @param {Boolean} [unpad=false]
   * @returns {Buffer}
   */


  function test$2(str) {
    var unpad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return _test$1(str, TABLE$3, unpad);
  }
  /**
   * Encode a base32hex string.
   * @param {Buffer} data
   * @param {Boolean} [pad=false]
   * @returns {String}
   */


  function encodeHex(data) {
    var pad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return _encode$1(data, CHARSET_HEX, pad);
  }
  /**
   * Decode a base32hex string.
   * @param {String} str
   * @param {Boolean} [unpad=false]
   * @returns {Buffer}
   */


  function decodeHex(str) {
    var unpad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return _decode$1(str, TABLE_HEX, unpad);
  }
  /**
   * Test a base32 hex string.
   * @param {String} str
   * @param {Boolean} [unpad=false]
   * @returns {Buffer}
   */


  function testHex(str) {
    var unpad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return _test$1(str, TABLE_HEX, unpad);
  }
  /*
   * Expose
   */


  var native_1$9 = 0;
  var encode_1$1 = encode$3;
  var decode_1$1 = decode$3;
  var test_1$1 = test$2;
  var encodeHex_1 = encodeHex;
  var decodeHex_1 = decodeHex;
  var testHex_1 = testHex;
  var base32 = {
    native: native_1$9,
    encode: encode_1$1,
    decode: decode_1$1,
    test: test_1$1,
    encodeHex: encodeHex_1,
    decodeHex: decodeHex_1,
    testHex: testHex_1
  };

  var base32Browser = base32;

  /*
   * Constants
   */


  var CHARSET$4 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  var TABLE$4 = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1, -1, -1, -1, -1, -1, 9, 10, 11, 12, 13, 14, 15, 16, -1, 17, 18, 19, 20, 21, -1, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1, -1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, -1, -1, -1, -1, -1];
  var pool$2 = Buffer.alloc(128);
  /**
   * Encode a base58 string.
   * @param {Buffer} data
   * @returns {String}
   */

  function encode$4(data) {
    assert_1$1(Buffer.isBuffer(data));
    var zeroes = 0;
    var i = 0;

    for (; i < data.length; i++) {
      if (data[i] !== 0) break;
      zeroes += 1;
    }

    var size = ((data.length - zeroes) * 138 / 100 | 0) + 1;
    var b58 = size <= 128 ? pool$2.fill(0) : Buffer.alloc(size);
    var length = 0;

    for (; i < data.length; i++) {
      var carry = data[i];
      var j = 0;

      for (var k = size - 1; k >= 0; k--, j++) {
        if (carry === 0 && j >= length) break;
        carry += b58[k] * 256;
        b58[k] = carry % 58;
        carry = carry / 58 | 0;
      }

      assert_1$1(carry === 0);
      length = j;
    }

    i = size - length;

    while (i < size && b58[i] === 0) {
      i += 1;
    }

    var str = '';

    for (var _j = 0; _j < zeroes; _j++) {
      str += '1';
    }

    while (i < size) {
      str += CHARSET$4[b58[i++]];
    }

    return str;
  }
  /**
   * Decode a base58 string.
   * @param {String} str
   * @returns {Buffer}
   * @throws on non-base58 character.
   */


  function decode$4(str) {
    assert_1$1(typeof str === 'string');
    var zeroes = 0;
    var i = 0;

    for (; i < str.length; i++) {
      if (str[i] !== '1') break;
      zeroes += 1;
    }

    var size = (str.length * 733 / 1000 | 0) + 1;
    var b256 = size <= 128 ? pool$2.fill(0) : Buffer.alloc(size);
    var length = 0;

    for (; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch & 0xff80) throw new Error('Invalid base58 string.');
      var val = TABLE$4[ch];
      if (val === -1) throw new Error('Invalid base58 string.');
      var carry = val;
      var _j2 = 0;

      for (var k = size - 1; k >= 0; k--, _j2++) {
        if (carry === 0 && _j2 >= length) break;
        carry += b256[k] * 58;
        b256[k] = carry;
        carry >>>= 8;
      }

      assert_1$1(carry === 0);
      length = _j2;
    } // See: https://github.com/bitcoin/bitcoin/commit/2bcf1fc4


    i = size - length;
    var out = Buffer.alloc(zeroes + (size - i));
    var j;

    for (j = 0; j < zeroes; j++) {
      out[j] = 0;
    }

    while (i < size) {
      out[j++] = b256[i++];
    }

    return out;
  }
  /**
   * Test whether the string is a base58 string.
   * @param {String} str
   * @returns {Buffer}
   */


  function test$3(str) {
    assert_1$1(typeof str === 'string');

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch & 0xff80) return false;
      if (TABLE$4[ch] === -1) return false;
    }

    return true;
  }
  /*
   * Expose
   */


  var native_1$a = 0;
  var encode_1$2 = encode$4;
  var decode_1$2 = decode$4;
  var test_1$2 = test$3;
  var base58$1 = {
    native: native_1$a,
    encode: encode_1$2,
    decode: decode_1$2,
    test: test_1$2
  };

  var base58Browser$1 = base58$1;

  /*
   * Constants
   */


  var CHARSET$5 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  var CHARSET_URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
  var TABLE$5 = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1];
  var TABLE_URL = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1];
  /*
   * Encoding
   */

  function _encode$2(data, charset, pad) {
    assert_1$1(Buffer.isBuffer(data));
    var left = data.length;
    var str = '';
    var i = 0;

    while (left >= 3) {
      var c1 = data[i++];
      var c2 = data[i++];
      var c3 = data[i++];
      str += charset[c1 >> 2];
      str += charset[(c1 & 3) << 4 | c2 >> 4];
      str += charset[(c2 & 0x0f) << 2 | c3 >> 6];
      str += charset[c3 & 0x3f];
      left -= 3;
    }

    switch (left) {
      case 1:
        {
          var _c = data[i++];
          str += charset[_c >> 2];
          str += charset[(_c & 3) << 4];
          if (pad) str += '==';
          break;
        }

      case 2:
        {
          var _c2 = data[i++];
          var _c3 = data[i++];
          str += charset[_c2 >> 2];
          str += charset[(_c2 & 3) << 4 | _c3 >> 4];
          str += charset[(_c3 & 0x0f) << 2];
          if (pad) str += '=';
          break;
        }
    }

    return str;
  }
  /*
   * Decoding
   */


  function _decode$2(str, table, size) {
    assert_1$1(typeof str === 'string');
    var data = Buffer.alloc(size);
    var left = str.length;
    var i = 0;
    var j = 0;
    if (left > 0 && str[left - 1] === '=') left -= 1;
    if (left > 0 && str[left - 1] === '=') left -= 1;
    if ((left & 3) === 1) // Fail early.
      throw new Error('Invalid base64 string.');

    while (left >= 4) {
      var c1 = str.charCodeAt(i++);
      var c2 = str.charCodeAt(i++);
      var c3 = str.charCodeAt(i++);
      var c4 = str.charCodeAt(i++);
      if ((c1 | c2 | c3 | c4) & 0xff80) throw new Error('Invalid base64 string.');
      var t1 = table[c1];
      var t2 = table[c2];
      var t3 = table[c3];
      var t4 = table[c4];
      if ((t1 | t2 | t3 | t4) < 0) throw new Error('Invalid base64 string.');
      data[j++] = t1 << 2 | t2 >> 4;
      data[j++] = t2 << 4 | t3 >> 2;
      data[j++] = t3 << 6 | t4 >> 0;
      left -= 4;
    }

    switch (left) {
      case 1:
        {
          throw new Error('Invalid base64 string.');
        }

      case 2:
        {
          var _c4 = str.charCodeAt(i++);

          var _c5 = str.charCodeAt(i++);

          if ((_c4 | _c5) & 0xff80) throw new Error('Invalid base64 string.');
          var _t = table[_c4];
          var _t2 = table[_c5];
          if ((_t | _t2) < 0) throw new Error('Invalid base64 string.');
          data[j++] = _t << 2 | _t2 >> 4;
          if (_t2 & 15) throw new Error('Invalid base64 string.');
          break;
        }

      case 3:
        {
          var _c6 = str.charCodeAt(i++);

          var _c7 = str.charCodeAt(i++);

          var _c8 = str.charCodeAt(i++);

          if ((_c6 | _c7 | _c8) & 0xff80) throw new Error('Invalid base64 string.');
          var _t3 = table[_c6];
          var _t4 = table[_c7];
          var _t5 = table[_c8];
          if ((_t3 | _t4 | _t5) < 0) throw new Error('Invalid base64 string.');
          data[j++] = _t3 << 2 | _t4 >> 4;
          data[j++] = _t4 << 4 | _t5 >> 2;
          if (_t5 & 3) throw new Error('Invalid base64 string.');
          break;
        }
    }

    assert_1$1(j === size);
    return data;
  }
  /*
   * Testing
   */


  function _test$2(str, table) {
    assert_1$1(typeof str === 'string');
    var len = str.length;
    if (len > 0 && str[len - 1] === '=') len -= 1;
    if (len > 0 && str[len - 1] === '=') len -= 1;
    if ((len & 3) === 1) return false;

    for (var i = 0; i < len; i++) {
      var ch = str.charCodeAt(i);
      if (ch & 0xff80) return false;
      if (table[ch] === -1) return false;
    }

    switch (len & 3) {
      case 1:
        return false;

      case 2:
        return (table[str.charCodeAt(len - 1)] & 15) === 0;

      case 3:
        return (table[str.charCodeAt(len - 1)] & 3) === 0;
    }

    return true;
  }
  /*
   * Base64
   */


  function encode$5(data) {
    return _encode$2(data, CHARSET$5, true);
  }

  function decode$5(str) {
    var size = decodeSize(str);
    if (!checkPadding(str, size)) throw new Error('Invalid base64 padding.');
    return _decode$2(str, TABLE$5, size);
  }

  function test$4(str) {
    var size = decodeSize(str);
    if (!checkPadding(str, size)) return false;
    return _test$2(str, TABLE$5);
  }
  /*
   * Base64-URL
   */


  function encodeURL(data) {
    return _encode$2(data, CHARSET_URL, false);
  }

  function decodeURL(str) {
    var size = decodeSize(str);
    if (!checkPadding(str, 0)) throw new Error('Invalid base64 padding.');
    return _decode$2(str, TABLE_URL, size);
  }

  function testURL(str) {
    if (!checkPadding(str, 0)) return false;
    return _test$2(str, TABLE_URL);
  }
  /*
   * Helpers
   */


  function decodeSize(str) {
    assert_1$1(typeof str === 'string');
    var len = str.length;
    if (len > 0 && str[len - 1] === '=') len -= 1;
    if (len > 0 && str[len - 1] === '=') len -= 1;
    var size = (len >>> 2) * 3;
    var rem = len & 3;
    if (rem) size += rem - 1;
    return size;
  }

  function checkPadding(str, size) {
    assert_1$1(typeof str === 'string');

    switch (size % 3) {
      case 0:
        {
          if (str.length === 0) return true;
          if (str.length === 1) return str[0] !== '=';
          return str[str.length - 2] !== '=' && str[str.length - 1] !== '=';
        }

      case 1:
        {
          return str.length >= 4 && str[str.length - 2] === '=' && str[str.length - 1] === '=';
        }

      case 2:
        {
          return str.length >= 4 && str[str.length - 2] !== '=' && str[str.length - 1] === '=';
        }

      default:
        {
          throw new Error('unreachable');
        }
    }
  }
  /*
   * Expose
   */


  var native_1$b = 0;
  var encode_1$3 = encode$5;
  var decode_1$3 = decode$5;
  var test_1$3 = test$4;
  var encodeURL_1 = encodeURL;
  var decodeURL_1 = decodeURL;
  var testURL_1 = testURL;
  var base64 = {
    native: native_1$b,
    encode: encode_1$3,
    decode: decode_1$3,
    test: test_1$3,
    encodeURL: encodeURL_1,
    decodeURL: decodeURL_1,
    testURL: testURL_1
  };

  var base64Browser = base64;

  /**
   * Constants
   */


  var POOL65 = Buffer.alloc(65);
  var CHARSET$6 = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
  var TABLE$6 = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, 10, 17, 21, 20, 26, 30, 7, 5, -1, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1];
  /**
   * Update checksum.
   * @ignore
   * @param {Number} c
   * @returns {Number}
   */

  function polymod(c) {
    var b = c >>> 25;
    return (c & 0x1ffffff) << 5 ^ 0x3b6a57b2 & -(b >> 0 & 1) ^ 0x26508e6d & -(b >> 1 & 1) ^ 0x1ea119fa & -(b >> 2 & 1) ^ 0x3d4233dd & -(b >> 3 & 1) ^ 0x2a1462b3 & -(b >> 4 & 1);
  }
  /**
   * Encode hrp and data as a bech32 string.
   * @param {String} hrp
   * @param {Buffer} data
   * @returns {String}
   */


  function serialize(hrp, data) {
    assert_1$1(typeof hrp === 'string');
    assert_1$1(Buffer.isBuffer(data));
    if (hrp.length === 0 || hrp.length > 83) throw new Error('Invalid bech32 human-readable part.');
    if (hrp.length + 1 + data.length + 6 > 90) throw new Error('Invalid bech32 data length.');
    var str = '';
    var chk = 1;
    var i;

    for (i = 0; i < hrp.length; i++) {
      var ch = hrp.charCodeAt(i);
      if (ch < 33 || ch > 126) throw new Error('Invalid bech32 character.');
      if (ch >= 65 && ch <= 90) throw new Error('Invalid bech32 character.');
      chk = polymod(chk) ^ ch >> 5;
    }

    chk = polymod(chk);

    for (var _i = 0; _i < hrp.length; _i++) {
      var _ch = hrp.charCodeAt(_i);

      chk = polymod(chk) ^ _ch & 0x1f;
      str += hrp[_i];
    }

    str += '1';

    for (var _i2 = 0; _i2 < data.length; _i2++) {
      var _ch2 = data[_i2];
      if (_ch2 >> 5) throw new Error('Invalid bech32 value.');
      chk = polymod(chk) ^ _ch2;
      str += CHARSET$6[_ch2];
    }

    for (var _i3 = 0; _i3 < 6; _i3++) {
      chk = polymod(chk);
    }

    chk ^= 1;

    for (var _i4 = 0; _i4 < 6; _i4++) {
      str += CHARSET$6[chk >>> (5 - _i4) * 5 & 0x1f];
    }

    return str;
  }
  /**
   * Decode a bech32 string.
   * @param {String} str
   * @returns {Array} [hrp, data]
   */


  function deserialize(str) {
    assert_1$1(typeof str === 'string');
    if (str.length < 8 || str.length > 90) throw new Error('Invalid bech32 string length.');
    var lower = false;
    var upper = false;
    var hlen = 0;

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch < 33 || ch > 126) throw new Error('Invalid bech32 character.');
      if (ch >= 97 && ch <= 122) lower = true;else if (ch >= 65 && ch <= 90) upper = true;else if (ch === 49) hlen = i;
    }

    if (hlen === 0) throw new Error('Invalid bech32 human-readable part.');
    var dlen = str.length - (hlen + 1);
    if (dlen < 6) throw new Error('Invalid bech32 data length.');
    if (lower && upper) throw new Error('Invalid bech32 casing.');
    var chk = 1;
    var hrp = '';

    for (var _i5 = 0; _i5 < hlen; _i5++) {
      var _ch3 = str.charCodeAt(_i5);

      if (_ch3 >= 65 && _ch3 <= 90) _ch3 += 32;
      chk = polymod(chk) ^ _ch3 >> 5;
      hrp += String.fromCharCode(_ch3);
    }

    chk = polymod(chk);

    for (var _i6 = 0; _i6 < hlen; _i6++) {
      chk = polymod(chk) ^ str.charCodeAt(_i6) & 0x1f;
    }

    var data = Buffer.alloc(dlen - 6);
    var j = 0;

    for (var _i7 = hlen + 1; _i7 < str.length; _i7++) {
      var val = TABLE$6[str.charCodeAt(_i7)];
      if (val === -1) throw new Error('Invalid bech32 character.');
      chk = polymod(chk) ^ val;
      if (_i7 < str.length - 6) data[j++] = val;
    }

    if (chk !== 1) throw new Error('Invalid bech32 checksum.');
    assert_1$1(j === data.length);
    return [hrp, data];
  }
  /**
   * Test whether a string is a bech32 string.
   * @param {String} str
   * @returns {Boolean}
   */


  function is(str) {
    assert_1$1(typeof str === 'string');

    try {
      deserialize(str);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Convert serialized data to another base.
   * @param {Buffer} dst
   * @param {Number} dstoff
   * @param {Number} dstbits
   * @param {Buffer} src
   * @param {Number} srcoff
   * @param {Number} srcbits
   * @param {Boolean} pad
   * @returns {Buffer}
   */


  function convert(dst, dstoff, dstbits, src, srcoff, srcbits, pad) {
    assert_1$1(Buffer.isBuffer(dst));
    assert_1$1(dstoff >>> 0 === dstoff);
    assert_1$1(dstbits >>> 0 === dstbits);
    assert_1$1(Buffer.isBuffer(src));
    assert_1$1(srcoff >>> 0 === srcoff);
    assert_1$1(srcbits >>> 0 === srcbits);
    assert_1$1(typeof pad === 'boolean');
    assert_1$1(dstbits >= 1 && dstbits <= 8);
    assert_1$1(srcbits >= 1 && srcbits <= 8);
    var mask = (1 << dstbits) - 1;
    var acc = 0;
    var bits = 0;
    var i = srcoff;
    var j = dstoff;

    for (; i < src.length; i++) {
      acc = acc << srcbits | src[i];
      bits += srcbits;

      while (bits >= dstbits) {
        bits -= dstbits;
        dst[j++] = acc >>> bits & mask;
      }
    }

    var left = dstbits - bits;

    if (pad) {
      if (bits) dst[j++] = acc << left & mask;
    } else {
      if (acc << left & mask || bits >= srcbits) throw new Error('Invalid bits.');
    }

    assert_1$1(j <= dst.length);
    return dst.slice(0, j);
  }
  /**
   * Calculate size required for bit conversion.
   * @param {Number} len
   * @param {Number} srcbits
   * @param {Number} dstbits
   * @param {Boolean} pad
   * @returns {Number}
   */


  function convertSize(len, srcbits, dstbits, pad) {
    assert_1$1(len >>> 0 === len);
    assert_1$1(srcbits >>> 0 === srcbits);
    assert_1$1(dstbits >>> 0 === dstbits);
    assert_1$1(typeof pad === 'boolean');
    assert_1$1(srcbits >= 1 && srcbits <= 8);
    assert_1$1(dstbits >= 1 && dstbits <= 8);
    return (len * srcbits + (dstbits - 1) * (pad | 0)) / dstbits >>> 0;
  }
  /**
   * Convert serialized data to another base.
   * @param {Buffer} data
   * @param {Number} srcbits
   * @param {Number} dstbits
   * @param {Boolean} pad
   * @returns {Buffer}
   */


  function convertBits(data, srcbits, dstbits, pad) {
    assert_1$1(Buffer.isBuffer(data));
    var size = convertSize(data.length, srcbits, dstbits, pad);
    var out = Buffer.alloc(size);
    return convert(out, 0, dstbits, data, 0, srcbits, pad);
  }
  /**
   * Serialize data to bech32 address.
   * @param {String} hrp
   * @param {Number} version
   * @param {Buffer} hash
   * @returns {String}
   */


  function encode$6(hrp, version, hash) {
    assert_1$1(typeof hrp === 'string');
    assert_1$1(version >>> 0 === version);
    assert_1$1(Buffer.isBuffer(hash));
    if (version > 31) throw new Error('Invalid bech32 version.');
    if (hash.length < 2 || hash.length > 40) throw new Error('Invalid bech32 data length.');
    var out = POOL65;
    out[0] = version;
    var data = convert(out, 1, 5, hash, 0, 8, true);
    return serialize(hrp, data);
  }
  /**
   * Deserialize data from bech32 address.
   * @param {String} addr
   * @returns {Array}
   */


  function decode$6(addr) {
    var _deserialize = deserialize(addr),
        _deserialize2 = _slicedToArray__default['default'](_deserialize, 2),
        hrp = _deserialize2[0],
        data = _deserialize2[1];

    if (data.length === 0 || data.length > 65) throw new Error('Invalid bech32 data length.');
    var version = data[0];
    if (version > 31) throw new Error('Invalid bech32 version.');
    var output = data; // Works because dstbits > srcbits.

    var hash = convert(output, 0, 8, data, 1, 5, false);
    if (hash.length < 2 || hash.length > 40) throw new Error('Invalid bech32 data length.');
    return [hrp, version, hash];
  }
  /**
   * Test whether a string is a bech32 string.
   * @param {String} addr
   * @returns {Boolean}
   */


  function test$5(addr) {
    assert_1$1(typeof addr === 'string');

    try {
      decode$6(addr);
      return true;
    } catch (e) {
      return false;
    }
  }
  /*
   * Expose
   */


  var native_1$c = 0;
  var serialize_1 = serialize;
  var deserialize_1 = deserialize;
  var is_1 = is;
  var convertBits_1 = convertBits;
  var encode_1$4 = encode$6;
  var decode_1$4 = decode$6;
  var test_1$4 = test$5;
  var bech32 = {
    native: native_1$c,
    serialize: serialize_1,
    deserialize: deserialize_1,
    is: is_1,
    convertBits: convertBits_1,
    encode: encode_1$4,
    decode: decode_1$4,
    test: test_1$4
  };

  var bech32Browser = bech32;

  /**
   * Constants
   */


  var POOL104 = Buffer.alloc(104);
  var CHARSET$7 = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
  var TABLE$7 = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, 10, 17, 21, 20, 26, 30, 7, 5, -1, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1, -1, 29, -1, 24, 13, 25, 9, 8, 23, -1, 18, 22, 31, 27, 19, -1, 1, 0, 3, 16, 11, 28, 12, 14, 6, 4, 2, -1, -1, -1, -1, -1];
  /**
   * Update checksum
   * @ignore
   * @param {Number[]} c
   * @param {Number} d
   */

  function polymod$1(c, d) {
    // b = c >> 35
    var b = c[1] >>> 3; // c = (c & 0x7ffffffff) << 5

    c[0] &= 0xffffffff;
    c[1] &= 0x00000007;
    c[1] <<= 5;
    c[1] |= c[0] >>> 27;
    c[0] <<= 5; // c ^= 0x98f2bc8e61 & -((b >> 0) & 1)

    if (b >>> 0 & 1) {
      c[0] ^= 0xf2bc8e61;
      c[1] ^= 0x00000098;
    } // c ^= 0x79b76d99e2 & -((b >> 1) & 1)


    if (b >>> 1 & 1) {
      c[0] ^= 0xb76d99e2;
      c[1] ^= 0x00000079;
    } // c ^= 0xf33e5fb3c4 & -((b >> 2) & 1)


    if (b >>> 2 & 1) {
      c[0] ^= 0x3e5fb3c4;
      c[1] ^= 0x000000f3;
    } // c ^= 0xae2eabe2a8 & -((b >> 3) & 1)


    if (b >>> 3 & 1) {
      c[0] ^= 0x2eabe2a8;
      c[1] ^= 0x000000ae;
    } // c ^= 0x1e4f43e470 & -((b >> 4) & 1)


    if (b >>> 4 & 1) {
      c[0] ^= 0x4f43e470;
      c[1] ^= 0x0000001e;
    } // c ^= d


    c[0] ^= d;
  }
  /**
   * Serialize data to cash32.
   * @param {String} prefix
   * @param {Buffer} data
   * @returns {String}
   */


  function serialize$1(prefix, data) {
    assert_1$1(typeof prefix === 'string');
    assert_1$1(Buffer.isBuffer(data));
    if (prefix.length === 0 || prefix.length > 83) throw new Error('Invalid cash32 prefix.');
    if (data.length > 104) throw new Error('Invalid cash32 data.');
    var chk = [1, 0];
    var str = '';

    for (var i = 0; i < prefix.length; i++) {
      var ch = prefix.charCodeAt(i);
      if (ch < 97 || ch > 122) throw new Error('Invalid cash32 prefix.');
      polymod$1(chk, ch & 0x1f);
      str += String.fromCharCode(ch);
    }

    polymod$1(chk, 0);
    str += ':';

    for (var _i = 0; _i < data.length; _i++) {
      var _ch = data[_i];
      if (_ch >> 5) throw new Error('Invalid cash32 value.');
      polymod$1(chk, _ch);
      str += CHARSET$7[_ch];
    }

    for (var _i2 = 0; _i2 < 8; _i2++) {
      polymod$1(chk, 0);
    }

    chk[0] ^= 1; // First two rounds shift by 35 and 30.

    str += CHARSET$7[chk[1] >>> 3 & 0x1f];
    str += CHARSET$7[(chk[0] >>> 30 | chk[1] << 2) & 0x1f]; // Now 25 down to 0.

    for (var _i3 = 2; _i3 < 8; _i3++) {
      str += CHARSET$7[chk[0] >>> (7 - _i3) * 5 & 0x1f];
    }

    return str;
  }
  /**
   * Decode cash32 string.
   * @param {String} str
   * @param {String} fallback
   * @returns {Array} [prefix, data]
   */


  function deserialize$1(str, fallback) {
    assert_1$1(typeof str === 'string');
    assert_1$1(typeof fallback === 'string');
    if (str.length < 8 || str.length > 196) // 83 + 1 + 112
      throw new Error('Invalid cash32 string.');
    var lower = false;
    var upper = false;
    var number = false;
    var plen = 0;

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i);

      if (ch >= 97 && ch <= 122) {
        lower = true;
        continue;
      }

      if (ch >= 65 && ch <= 90) {
        upper = true;
        continue;
      }

      if (ch >= 48 && ch <= 57) {
        number = true;
        continue;
      }

      if (ch === 58) {
        if (number || i === 0 || plen !== 0) throw new Error('Invalid cash32 prefix.');
        plen = i;
        continue;
      }

      throw new Error('Invalid cash32 string.');
    }

    if (lower && upper) throw new Error('Invalid cash32 casing.');
    var chk = [1, 0];
    var prefix = '';
    var dlen;

    if (plen === 0) {
      if (fallback.length === 0 || fallback.length > 83) throw new Error('Invalid cash32 prefix.');

      for (var _i4 = 0; _i4 < fallback.length; _i4++) {
        var _ch2 = fallback.charCodeAt(_i4);

        if (_ch2 < 97 || _ch2 > 122) throw new Error('Invalid cash32 prefix.');
        polymod$1(chk, _ch2 & 0x1f);
      }

      prefix = fallback;
      dlen = str.length;
    } else {
      if (plen > 83) throw new Error('Invalid cash32 prefix.');

      for (var _i5 = 0; _i5 < plen; _i5++) {
        var _ch3 = str.charCodeAt(_i5) | 32;

        polymod$1(chk, _ch3 & 0x1f);
        prefix += String.fromCharCode(_ch3);
      }

      dlen = str.length - (plen + 1);
    }

    if (dlen < 8 || dlen > 112) throw new Error('Invalid cash32 data.');
    polymod$1(chk, 0);
    var data = Buffer.alloc(dlen - 8);
    var j = 0;

    for (var _i6 = str.length - dlen; _i6 < str.length; _i6++) {
      var val = TABLE$7[str.charCodeAt(_i6)];
      if (val === -1) throw new Error('Invalid cash32 character.');
      polymod$1(chk, val);
      if (_i6 < str.length - 8) data[j++] = val;
    }

    if (chk[0] !== 1 || chk[1] !== 0) throw new Error('Invalid cash32 checksum.');
    assert_1$1(j === data.length);
    return [prefix, data];
  }
  /**
   * Test whether a string is a cash32 string.
   * @param {String} str
   * @param {String} fallback
   * @returns {Boolean}
   */


  function is$1(str, fallback) {
    assert_1$1(typeof str === 'string');
    assert_1$1(typeof fallback === 'string');

    try {
      deserialize$1(str, fallback);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Convert serialized data to another base.
   * @param {Buffer} dst
   * @param {Number} dstoff
   * @param {Number} dstbits
   * @param {Buffer} src
   * @param {Number} srcoff
   * @param {Number} srcbits
   * @param {Boolean} pad
   * @returns {Buffer}
   */


  function convert$1(dst, dstoff, dstbits, src, srcoff, srcbits, pad) {
    assert_1$1(Buffer.isBuffer(dst));
    assert_1$1(dstoff >>> 0 === dstoff);
    assert_1$1(dstbits >>> 0 === dstbits);
    assert_1$1(Buffer.isBuffer(src));
    assert_1$1(srcoff >>> 0 === srcoff);
    assert_1$1(srcbits >>> 0 === srcbits);
    assert_1$1(typeof pad === 'boolean');
    assert_1$1(dstbits >= 1 && dstbits <= 8);
    assert_1$1(srcbits >= 1 && srcbits <= 8);
    var mask = (1 << dstbits) - 1;
    var maxacc = (1 << srcbits + dstbits - 1) - 1;
    var acc = 0;
    var bits = 0;
    var i = srcoff;
    var j = dstoff;

    for (; i < src.length; i++) {
      acc = (acc << srcbits | src[i]) & maxacc;
      bits += srcbits;

      while (bits >= dstbits) {
        bits -= dstbits;
        dst[j++] = acc >>> bits & mask;
      }
    }

    var left = dstbits - bits;

    if (pad) {
      if (bits) dst[j++] = acc << left & mask;
    } else {
      if (bits >= srcbits || acc << left & mask) throw new Error('Invalid bits.');
    }

    assert_1$1(j <= dst.length);
    return dst.slice(0, j);
  }
  /**
   * Calculate size required for bit conversion.
   * @param {Number} len
   * @param {Number} srcbits
   * @param {Number} dstbits
   * @param {Boolean} pad
   * @returns {Number}
   */


  function convertSize$1(len, srcbits, dstbits, pad) {
    assert_1$1(len >>> 0 === len);
    assert_1$1(srcbits >>> 0 === srcbits);
    assert_1$1(dstbits >>> 0 === dstbits);
    assert_1$1(typeof pad === 'boolean');
    assert_1$1(srcbits >= 1 && srcbits <= 8);
    assert_1$1(dstbits >= 1 && dstbits <= 8);
    return (len * srcbits + (dstbits - 1) * (pad | 0)) / dstbits >>> 0;
  }
  /**
   * Convert serialized data to another base.
   * @param {Buffer} data
   * @param {Number} srcbits
   * @param {Number} dstbits
   * @param {Boolean} pad
   * @returns {Buffer}
   */


  function convertBits$1(data, srcbits, dstbits, pad) {
    assert_1$1(Buffer.isBuffer(data));
    var size = convertSize$1(data.length, srcbits, dstbits, pad);
    var out = Buffer.alloc(size);
    return convert$1(out, 0, dstbits, data, 0, srcbits, pad);
  }
  /**
   * Get cash32 encoded size.
   * @param {Number} size
   * @returns {Number}
   */


  function encodedSize(size) {
    assert_1$1(size >>> 0 === size);

    switch (size) {
      case 20:
        return 0;

      case 24:
        return 1;

      case 28:
        return 2;

      case 32:
        return 3;

      case 40:
        return 4;

      case 48:
        return 5;

      case 56:
        return 6;

      case 64:
        return 7;

      default:
        throw new Error('Non-standard length.');
    }
  }
  /**
   * Serialize data to cash32
   * @param {String} prefix
   * @param {Number} type - (0 = P2PKH, 1 = P2SH)
   * @param {Buffer} hash
   * @returns {String}
   */


  function encode$7(prefix, type, hash) {
    assert_1$1(typeof prefix === 'string');
    assert_1$1(type >>> 0 === type);
    assert_1$1(Buffer.isBuffer(hash));
    if (type > 15) throw new Error('Invalid cash32 type.');
    var size = encodedSize(hash.length);
    var data = Buffer.alloc(hash.length + 1);
    data[0] = type << 3 | size;
    hash.copy(data, 1);
    var output = POOL104;
    var conv = convert$1(output, 0, 5, data, 0, 8, true);
    return serialize$1(prefix, conv);
  }
  /**
   * Deserialize data from cash32 address.
   * @param {String} addr
   * @param {String} expect
   * @returns {Array}
   */


  function decode$7(addr) {
    var expect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bitcoincash';

    var _deserialize = deserialize$1(addr, expect),
        _deserialize2 = _slicedToArray__default['default'](_deserialize, 2),
        prefix = _deserialize2[0],
        conv = _deserialize2[1];

    if (prefix !== expect) throw new Error('Invalid cash32 prefix.');
    if (conv.length === 0 || conv.length > 104) throw new Error('Invalid cash32 data.');
    var output = conv; // Works because dstbits > srcbits.

    var data = convert$1(output, 0, 8, conv, 0, 5, false);
    if (data.length === 0 || data.length > 1 + 64) throw new Error('Invalid cash32 data.');
    var type = data[0] >> 3 & 31;
    var hash = data.slice(1);
    var size = 20 + 4 * (data[0] & 3);
    if (data[0] & 4) size *= 2;
    if (type > 15) throw new Error('Invalid cash32 type.');
    if (size !== hash.length) throw new Error('Invalid cash32 data length.');
    return [type, hash];
  }
  /**
   * Test whether a string is a cash32 string.
   * @param {String} addr
   * @param {String} expect
   * @returns {Boolean}
   */


  function test$6(addr) {
    var expect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bitcoincash';
    assert_1$1(typeof addr === 'string');
    assert_1$1(typeof expect === 'string');

    try {
      decode$7(addr, expect);
      return true;
    } catch (e) {
      return false;
    }
  }
  /*
   * Expose
   */


  var native_1$d = 0;
  var serialize_1$1 = serialize$1;
  var deserialize_1$1 = deserialize$1;
  var is_1$1 = is$1;
  var convertBits_1$1 = convertBits$1;
  var encode_1$5 = encode$7;
  var decode_1$5 = decode$7;
  var test_1$5 = test$6;
  var cash32 = {
    native: native_1$d,
    serialize: serialize_1$1,
    deserialize: deserialize_1$1,
    is: is_1$1,
    convertBits: convertBits_1$1,
    encode: encode_1$5,
    decode: decode_1$5,
    test: test_1$5
  };

  var cash32Browser = cash32;

  var _marked = /*#__PURE__*/_regeneratorRuntime__default['default'].mark(lines);
  /*
   * Lines
   */


  function lines(str) {
    var i, j, n, ch, line, _line;

    return _regeneratorRuntime__default['default'].wrap(function lines$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assert_1$1(typeof str === 'string');
            i = 0;
            j = 0;
            n = 0;

            if (str.length > 0) {
              if (str.charCodeAt(0) === 0xfeff) {
                i += 1;
                j += 1;
              }
            }

          case 5:
            if (!(i < str.length)) {
              _context.next = 22;
              break;
            }

            ch = str.charCodeAt(i);
            _context.t0 = ch;
            _context.next = _context.t0 === 0x0d
            /*'\r'*/
            ? 10 : _context.t0 === 0x0a
            /*'\n'*/
            ? 10 : _context.t0 === 0x85
            /*NEL*/
            ? 10 : 19;
            break;

          case 10:
            if (!(j !== i)) {
              _context.next = 15;
              break;
            }

            line = trimSpace(str.substring(j, i));

            if (!(line.length > 0)) {
              _context.next = 15;
              break;
            }

            _context.next = 15;
            return [n, line];

          case 15:
            if (ch === 0x0d && i + 1 < str.length) {
              if (str.charCodeAt(i + 1) === 0x0a) i += 1;
            }

            j = i + 1;
            n += 1;
            return _context.abrupt("break", 19);

          case 19:
            i++;
            _context.next = 5;
            break;

          case 22:
            if (!(j !== i)) {
              _context.next = 27;
              break;
            }

            _line = trimSpace(str.substring(j, i));

            if (!(_line.length > 0)) {
              _context.next = 27;
              break;
            }

            _context.next = 27;
            return [n, _line];

          case 27:
          case "end":
            return _context.stop();
        }
      }
    }, _marked);
  }
  /*
   * Helpers
   */


  function trimSpace(str) {
    assert_1$1(typeof str === 'string');

    for (var i = str.length - 1; i >= 0; i--) {
      var ch = str.charCodeAt(i);

      switch (ch) {
        case 0x09
        /*'\t'*/
        :
        case 0x0b
        /*'\v'*/
        :
        case 0x0c
        /*'\f'*/
        :
        case 0x20
        /*' '*/
        :
        case 0xa0
        /*nbsp*/
        :
          continue;
      }

      return str.substring(0, i + 1);
    }

    return str;
  }
  /*
   * Expose
   */


  var lines_1 = lines;

  var _marked$1 = /*#__PURE__*/_regeneratorRuntime__default['default'].mark(decode$8);

  function _createForOfIteratorHelper$9(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }

  function _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /*
   * Constants
   */


  var EMPTY$5 = Buffer.alloc(0);
  /**
   * PEMBlock
   */

  var PEMBlock = /*#__PURE__*/function () {
    function PEMBlock(type, data) {
      _classCallCheck__default['default'](this, PEMBlock);

      if (type == null) type = 'PRIVACY-ENHANCED MESSAGE';
      if (data == null) data = EMPTY$5;
      assert_1$1(typeof type === 'string');
      assert_1$1(Buffer.isBuffer(data));
      this.type = type;
      this.headers = new Map();
      this.data = data;
    }

    _createClass__default['default'](PEMBlock, [{
      key: "toString",
      value: function toString(armor) {
        return encode$8(this.type, this.headers, this.data, armor);
      }
    }, {
      key: "fromString",
      value: function fromString(str, armor) {
        var iter = decode$8(str, armor);
        var it = iter.next();
        if (it.done) throw new Error('No PEM data found.');
        var block = it.value;
        this.type = block.type;
        this.headers = block.headers;
        this.data = block.data;
        return this;
      }
    }, {
      key: "getProcType",
      value: function getProcType() {
        var hdr = this.headers.get('Proc-Type');
        if (!hdr) return null;
        return ProcType.fromString(hdr);
      }
    }, {
      key: "setProcType",
      value: function setProcType(version, state) {
        assert_1$1(version != null && state);
        var proc = new ProcType(version, state);
        this.headers.set('Proc-Type', proc.toString());
        return this;
      }
    }, {
      key: "unsetProcType",
      value: function unsetProcType() {
        this.headers.delete('Proc-Type');
        return this;
      }
    }, {
      key: "getDEKInfo",
      value: function getDEKInfo() {
        var hdr = this.headers.get('DEK-Info');
        if (!hdr) return null;
        return DEKInfo.fromString(hdr);
      }
    }, {
      key: "setDEKInfo",
      value: function setDEKInfo(name, iv) {
        assert_1$1(name);
        var info = new DEKInfo(name, iv);
        this.headers.set('DEK-Info', info.toString());
        return this;
      }
    }, {
      key: "unsetDEKInfo",
      value: function unsetDEKInfo() {
        this.headers.delete('DEK-Info');
        return this;
      }
    }, {
      key: "isEncrypted",
      value: function isEncrypted() {
        var type;

        try {
          type = this.getProcType();
        } catch (e) {
          return false;
        }

        if (!type) return false;
        return type.version === 4 && type.state === 'ENCRYPTED';
      }
    }], [{
      key: "fromString",
      value: function fromString(str, armor) {
        return new this().fromString(str, armor);
      }
    }]);

    return PEMBlock;
  }();
  /**
   * ProcType
   */


  var ProcType = /*#__PURE__*/function () {
    function ProcType(version, state) {
      _classCallCheck__default['default'](this, ProcType);

      if (version == null) version = 0;
      if (state == null) state = 'NONE';
      assert_1$1(version >>> 0 === version);
      assert_1$1(typeof state === 'string');
      this.version = version;
      this.state = state.toUpperCase();
    }

    _createClass__default['default'](ProcType, [{
      key: "toString",
      value: function toString() {
        return "".concat(this.version, ",").concat(this.state);
      }
    }, {
      key: "fromString",
      value: function fromString(str) {
        assert_1$1(typeof str === 'string');
        var parts = str.split(',', 3);
        if (parts.length !== 2) throw new Error('Invalid Proc-Type.');
        this.version = parseU32$1(parts[0]);
        this.state = parts[1].toUpperCase();
        return this;
      }
    }], [{
      key: "fromString",
      value: function fromString(str) {
        return new this().fromString(str);
      }
    }]);

    return ProcType;
  }();
  /**
   * DEKInfo
   */


  var DEKInfo = /*#__PURE__*/function () {
    function DEKInfo(name, iv) {
      _classCallCheck__default['default'](this, DEKInfo);

      if (name == null) name = 'AES-128-ECB';
      if (iv == null) iv = EMPTY$5;
      assert_1$1(typeof name === 'string');
      assert_1$1(Buffer.isBuffer(iv));
      this.name = name.toUpperCase();
      this.iv = iv;
    }

    _createClass__default['default'](DEKInfo, [{
      key: "toString",
      value: function toString() {
        var name = this.name;
        if (this.iv.length === 0) return name;
        var iv = this.iv.toString('hex');
        return "".concat(name, ",").concat(iv.toUpperCase());
      }
    }, {
      key: "fromString",
      value: function fromString(str) {
        assert_1$1(typeof str === 'string');
        var parts = str.split(',', 3);
        if (parts.length < 1 || parts.length > 2) throw new Error('Invalid DEK-Info.');
        var name = parts[0];
        if (name.length === 0) throw new Error('Invalid DEK-Info name.');
        this.name = name.toUpperCase();
        this.iv = EMPTY$5;

        if (parts.length > 1) {
          var hex = parts[1];
          var iv = Buffer.from(hex, 'hex');
          if (iv.length !== hex.length >>> 1) throw new Error('Invalid DEK-Info IV.');
          this.iv = iv;
        }

        return this;
      }
    }], [{
      key: "fromString",
      value: function fromString(str) {
        return new this().fromString(str);
      }
    }]);

    return DEKInfo;
  }();
  /*
   * PEM
   */


  function encode$8(type, headers, data) {
    var armor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    assert_1$1(typeof type === 'string');
    assert_1$1(headers instanceof Map);
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(typeof armor === 'boolean');
    var str = '';
    str += "-----BEGIN ".concat(type, "-----\n");

    if (headers.size > 0) {
      var _iterator = _createForOfIteratorHelper$9(headers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray__default['default'](_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          str += "".concat(key, ": ").concat(value, "\n");
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      str += '\n';
    }

    var s = base64Browser.encode(data);

    for (var i = 0; i < s.length; i += 64) {
      str += s.substring(i, i + 64) + '\n';
    }

    if (armor) {
      var crc = crc24(data);
      str += "=".concat(base64Browser.encode(crc), "\n");
    }

    str += "-----END ".concat(type, "-----\n");
    return str;
  }

  function decode$8(str) {
    var armor,
        chunk,
        block,
        crc,
        _iterator2,
        _step2,
        _step2$value,
        line,
        index,
        key,
        value,
        preamble,
        type,
        _type,
        _args = arguments;

    return _regeneratorRuntime__default['default'].wrap(function decode$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            armor = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
            assert_1$1(typeof str === 'string');
            assert_1$1(typeof armor === 'boolean');
            chunk = '';
            block = null;
            crc = null;
            _iterator2 = _createForOfIteratorHelper$9(lines_1(str));
            _context.prev = 7;

            _iterator2.s();

          case 9:
            if ((_step2 = _iterator2.n()).done) {
              _context.next = 60;
              break;
            }

            _step2$value = _slicedToArray__default['default'](_step2.value, 2), line = _step2$value[1];
            index = line.indexOf(':');

            if (!(index !== -1)) {
              _context.next = 19;
              break;
            }

            if (block) {
              _context.next = 15;
              break;
            }

            throw new Error('PEM parse error (misplaced header).');

          case 15:
            key = line.substring(0, index).trim();
            value = line.substring(index + 1).trim();
            block.headers.set(key, value);
            return _context.abrupt("continue", 58);

          case 19:
            if (!(line.length >= 15 && line.substring(0, 5) === '-----')) {
              _context.next = 46;
              break;
            }

            if (!(line.slice(-5) !== '-----')) {
              _context.next = 22;
              break;
            }

            throw new Error('PEM parse error (invalid preamble).');

          case 22:
            preamble = line.slice(5, -5);

            if (!(preamble.substring(0, 6) === 'BEGIN ')) {
              _context.next = 30;
              break;
            }

            if (!block) {
              _context.next = 26;
              break;
            }

            throw new Error('PEM parse error (un-ended block).');

          case 26:
            type = preamble.substring(6).trim();
            block = new PEMBlock();
            block.type = type;
            return _context.abrupt("continue", 58);

          case 30:
            if (!(preamble.substring(0, 4) === 'END ')) {
              _context.next = 45;
              break;
            }

            if (block) {
              _context.next = 33;
              break;
            }

            throw new Error('PEM parse error (unexpected end).');

          case 33:
            _type = preamble.substring(4).trim();

            if (!(block.type !== _type)) {
              _context.next = 36;
              break;
            }

            throw new Error('PEM parse error (type mismatch).');

          case 36:
            block.data = base64Browser.decode(chunk);

            if (!(crc && !crc24(block.data).equals(crc))) {
              _context.next = 39;
              break;
            }

            throw new Error('PEM parse error (invalid armor checksum).');

          case 39:
            _context.next = 41;
            return block;

          case 41:
            chunk = '';
            block = null;
            crc = null;
            return _context.abrupt("continue", 58);

          case 45:
            throw new Error('PEM parse error (unknown preamble).');

          case 46:
            if (block) {
              _context.next = 48;
              break;
            }

            throw new Error('PEM parse error (unexpected data).');

          case 48:
            if (!(line.length === 5 && line.charCodeAt(0) === 0x3d
            /*'='*/
            )) {
              _context.next = 55;
              break;
            }

            if (armor) {
              _context.next = 51;
              break;
            }

            return _context.abrupt("continue", 58);

          case 51:
            if (!crc) {
              _context.next = 53;
              break;
            }

            throw new Error('PEM parse error (unexpected armor checksum).');

          case 53:
            crc = base64Browser.decode(line.substring(1));
            return _context.abrupt("continue", 58);

          case 55:
            if (!(line.length > 96)) {
              _context.next = 57;
              break;
            }

            throw new Error('PEM parse error (line too long).');

          case 57:
            chunk += line.replace(/[\t\v ]/g, '');

          case 58:
            _context.next = 9;
            break;

          case 60:
            _context.next = 65;
            break;

          case 62:
            _context.prev = 62;
            _context.t0 = _context["catch"](7);

            _iterator2.e(_context.t0);

          case 65:
            _context.prev = 65;

            _iterator2.f();

            return _context.finish(65);

          case 68:
            if (!(block || crc)) {
              _context.next = 70;
              break;
            }

            throw new Error('PEM parse error (un-ended block).');

          case 70:
            if (!(chunk.length !== 0)) {
              _context.next = 72;
              break;
            }

            throw new Error('PEM parse error (trailing data).');

          case 72:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$1, null, [[7, 62, 65, 68]]);
  }

  function toPEM(data, type, armor) {
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(typeof type === 'string');
    var block = new PEMBlock();
    block.type = type;
    block.data = data;
    return block.toString(armor);
  }

  function fromPEM(str, type, armor) {
    assert_1$1(typeof str === 'string');
    assert_1$1(typeof type === 'string');
    var block = PEMBlock.fromString(str, armor);
    if (block.type !== type) throw new Error('PEM type mismatch.');
    return block.data;
  }
  /*
   * Helpers
   */


  function crc24(data) {
    assert_1$1(Buffer.isBuffer(data));
    var crc = 0xb704ce;

    for (var i = 0; i < data.length; i++) {
      var ch = data[i];
      crc ^= ch << 16;

      for (var j = 0; j < 8; j++) {
        crc <<= 1;
        if (crc & 0x1000000) crc ^= 0x1864cfb;
      }
    }

    crc &= 0xffffff;
    var buf = Buffer.alloc(3);
    buf[2] = crc;
    crc >>>= 8;
    buf[1] = crc;
    crc >>>= 8;
    buf[0] = crc;
    return buf;
  }

  function parseU32$1(str) {
    assert_1$1(typeof str === 'string');
    if (str.length < 1 || str.length > 10) throw new Error('Invalid integer.');
    var word = 0;

    for (var i = 0; i < str.length; i++) {
      var ch = str.charCodeAt(i);
      if (ch < 0x30 || ch > 0x39) throw new Error('Invalid integer.');
      word *= 10;
      word += ch - 0x30;
      if (i > 0 && word === 0) throw new Error('Invalid integer.');
      if (word > 0xffffffff) throw new Error('Invalid integer.');
    }

    return word;
  }
  /*
   * Expose
   */


  var PEMBlock_1 = PEMBlock;
  var ProcType_1 = ProcType;
  var DEKInfo_1 = DEKInfo;
  var encode_1$6 = encode$8;
  var decode_1$6 = decode$8;
  var toPEM_1 = toPEM;
  var fromPEM_1 = fromPEM;
  var pem = {
    PEMBlock: PEMBlock_1,
    ProcType: ProcType_1,
    DEKInfo: DEKInfo_1,
    encode: encode_1$6,
    decode: decode_1$6,
    toPEM: toPEM_1,
    fromPEM: fromPEM_1
  };

  function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * DSAParams
   */
  // DSSParams_OpenSSL ::= SEQUENCE {
  //   p INTEGER,
  //   q INTEGER,
  //   g INTEGER
  // }


  var DSAParams$1 = /*#__PURE__*/function (_asn1$Sequence) {
    _inherits__default['default'](DSAParams, _asn1$Sequence);

    var _super = _createSuper$n(DSAParams);

    function DSAParams(p, q, g) {
      var _this;

      _classCallCheck__default['default'](this, DSAParams);

      _this = _super.call(this);
      _this.p = new asn1$1.Unsigned(p);
      _this.q = new asn1$1.Unsigned(q);
      _this.g = new asn1$1.Unsigned(g);
      return _this;
    }

    _createClass__default['default'](DSAParams, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.p.getSize();
        size += this.q.getSize();
        size += this.g.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.p.write(bw);
        this.q.write(bw);
        this.g.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.p.read(br);
        this.q.read(br);
        this.g.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.p.clean() && this.q.clean() && this.g.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'DSA PARAMETERS');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'DSA PARAMETERS');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          p: this.p,
          q: this.q,
          g: this.g
        };
      }
    }]);

    return DSAParams;
  }(asn1$1.Sequence);
  /**
   * DSAPublicKey
   */
  // DSSPublicKey_OpenSSL ::= SEQUENCE {
  //   y INTEGER,
  //   p INTEGER,
  //   q INTEGER,
  //   g INTEGER
  // }


  var DSAPublicKey$1 = /*#__PURE__*/function (_asn1$Sequence2) {
    _inherits__default['default'](DSAPublicKey, _asn1$Sequence2);

    var _super2 = _createSuper$n(DSAPublicKey);

    function DSAPublicKey(y, p, q, g) {
      var _this2;

      _classCallCheck__default['default'](this, DSAPublicKey);

      _this2 = _super2.call(this);
      _this2.y = new asn1$1.Unsigned(y);
      _this2.p = new asn1$1.Unsigned(p);
      _this2.q = new asn1$1.Unsigned(q);
      _this2.g = new asn1$1.Unsigned(g);
      return _this2;
    }

    _createClass__default['default'](DSAPublicKey, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.y.getSize();
        size += this.p.getSize();
        size += this.q.getSize();
        size += this.g.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.y.write(bw);
        this.p.write(bw);
        this.q.write(bw);
        this.g.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.y.read(br);
        this.p.read(br);
        this.q.read(br);
        this.g.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.y.clean() && this.p.clean() && this.q.clean() && this.g.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'DSA PUBLIC KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'DSA PUBLIC KEY');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          y: this.y,
          p: this.p,
          q: this.q,
          g: this.g
        };
      }
    }]);

    return DSAPublicKey;
  }(asn1$1.Sequence);
  /**
   * DSAPrivateKey
   */
  // DSSPrivatKey_OpenSSL ::= SEQUENCE {
  //   version INTEGER,
  //   p INTEGER,
  //   q INTEGER,
  //   g INTEGER,
  //   y INTEGER,
  //   x INTEGER
  // }


  var DSAPrivateKey$1 = /*#__PURE__*/function (_asn1$Sequence3) {
    _inherits__default['default'](DSAPrivateKey, _asn1$Sequence3);

    var _super3 = _createSuper$n(DSAPrivateKey);

    function DSAPrivateKey(version, p, q, g, y, x) {
      var _this3;

      _classCallCheck__default['default'](this, DSAPrivateKey);

      _this3 = _super3.call(this);
      _this3.version = new asn1$1.Unsigned(version);
      _this3.p = new asn1$1.Unsigned(p);
      _this3.q = new asn1$1.Unsigned(q);
      _this3.g = new asn1$1.Unsigned(g);
      _this3.y = new asn1$1.Unsigned(y);
      _this3.x = new asn1$1.Unsigned(x);
      return _this3;
    }

    _createClass__default['default'](DSAPrivateKey, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.version.getSize();
        size += this.p.getSize();
        size += this.q.getSize();
        size += this.g.getSize();
        size += this.y.getSize();
        size += this.x.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.version.write(bw);
        this.p.write(bw);
        this.q.write(bw);
        this.g.write(bw);
        this.y.write(bw);
        this.x.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.version.read(br);
        this.p.read(br);
        this.q.read(br);
        this.g.read(br);
        this.y.read(br);
        this.x.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.p.clean() && this.q.clean() && this.g.clean() && this.y.clean() && this.x.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'DSA PRIVATE KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'DSA PRIVATE KEY');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          version: this.version,
          p: this.p,
          q: this.q,
          g: this.g,
          y: this.y,
          x: this.x
        };
      }
    }]);

    return DSAPrivateKey;
  }(asn1$1.Sequence);
  /*
   * Expose
   */


  var DSAParams_1 = DSAParams$1;
  var DSAPublicKey_1 = DSAPublicKey$1;
  var DSAPrivateKey_1 = DSAPrivateKey$1;
  var openssl = {
    DSAParams: DSAParams_1,
    DSAPublicKey: DSAPublicKey_1,
    DSAPrivateKey: DSAPrivateKey_1
  };

  /*
   * Constants
   */


  var FINALIZED$6 = -1;
  var DESC$2 = Buffer.alloc(8, 0x00);
  var PADDING$4 = Buffer.alloc(64, 0x00);
  PADDING$4[0] = 0x80;
  var K$2 = new Uint32Array([0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391]);
  var S$2 = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
  /**
   * MD5
   */

  var MD5 = /*#__PURE__*/function () {
    function MD5() {
      _classCallCheck__default['default'](this, MD5);

      this.state = new Uint32Array(4);
      this.msg = new Uint32Array(16);
      this.block = Buffer.alloc(64);
      this.size = FINALIZED$6;
    }

    _createClass__default['default'](MD5, [{
      key: "init",
      value: function init() {
        this.state[0] = 0x67452301;
        this.state[1] = 0xefcdab89;
        this.state[2] = 0x98badcfe;
        this.state[3] = 0x10325476;
        this.size = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._update(data, data.length);

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return this._final(Buffer.alloc(16));
      }
    }, {
      key: "_update",
      value: function _update(data, len) {
        assert_1$1(this.size !== FINALIZED$6, 'Context is not initialized.');
        var pos = this.size & 63;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 64 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 64) return;

          this._transform(this.block, 0);
        }

        while (len >= 64) {
          this._transform(data, off);

          off += 64;
          len -= 64;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
    }, {
      key: "_final",
      value: function _final(out) {
        assert_1$1(this.size !== FINALIZED$6, 'Context is not initialized.');
        var pos = this.size & 63;
        var len = this.size * 8;
        writeU32$g(DESC$2, len >>> 0, 0);
        writeU32$g(DESC$2, len * (1 / 0x100000000) >>> 0, 4);

        this._update(PADDING$4, 1 + (119 - pos & 63));

        this._update(DESC$2, 8);

        for (var i = 0; i < 4; i++) {
          writeU32$g(out, this.state[i], i * 4);
          this.state[i] = 0;
        }

        for (var _i = 0; _i < 16; _i++) {
          this.msg[_i] = 0;
        }

        for (var _i2 = 0; _i2 < 64; _i2++) {
          this.block[_i2] = 0;
        }

        this.size = FINALIZED$6;
        return out;
      }
    }, {
      key: "_transform",
      value: function _transform(chunk, pos) {
        var W = this.msg;
        var a = this.state[0];
        var b = this.state[1];
        var c = this.state[2];
        var d = this.state[3];
        var i = 0;

        for (; i < 16; i++) {
          W[i] = readU32$h(chunk, pos + i * 4);
        }

        for (i = 0; i < 64; i++) {
          var f = void 0,
              g = void 0;

          if (i < 16) {
            f = b & c | ~b & d;
            g = i;
          } else if (i < 32) {
            f = d & b | ~d & c;
            g = 5 * i + 1 & 15;
          } else if (i < 48) {
            f = b ^ c ^ d;
            g = 3 * i + 5 & 15;
          } else {
            f = c ^ (b | ~d);
            g = 7 * i & 15;
          }

          f >>>= 0;
          f = f + a + K$2[i] + W[g];
          f >>>= 0;
          a = d;
          d = c;
          c = b;
          b = b + rotl32$2(f, S$2[i]);
          b >>>= 0;
        }

        this.state[0] += a;
        this.state[1] += b;
        this.state[2] += c;
        this.state[3] += d;
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new MD5();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(MD5, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return MD5.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 16);
        assert_1$1(Buffer.isBuffer(right) && right.length === 16);
        return MD5.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = MD5.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return MD5.hmac().init(key).update(data).final();
      }
    }]);

    return MD5;
  }();
  /*
   * Static
   */


  MD5.native = 0;
  MD5.id = 'MD5';
  MD5.size = 16;
  MD5.bits = 128;
  MD5.blockSize = 64;
  MD5.zero = Buffer.alloc(16, 0x00);
  MD5.ctx = new MD5();
  /*
   * Helpers
   */

  function rotl32$2(w, b) {
    return w << b | w >>> 32 - b;
  }

  function readU32$h(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }

  function writeU32$g(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var md5 = MD5;

  var md5Browser = md5;

  var PEMBlock$1 = pem.PEMBlock;
  /*
   * Constants
   */

  var ciphers = {
    __proto__: null,
    'AES-128': [16, 16],
    'AES-192': [24, 16],
    'AES-256': [32, 16],
    'ARC2-40': [5, 8],
    'ARC2-64': [8, 8],
    'ARC2-128': [16, 8],
    'BF': [16, 8],
    'BLOWFISH': [16, 8],
    'CAMELLIA-128': [16, 16],
    'CAMELLIA-192': [24, 16],
    'CAMELLIA-256': [32, 16],
    'CAST5': [16, 8],
    'DES': [8, 8],
    'DES-EDE': [16, 8],
    'DES-EDE3': [24, 8],
    'IDEA': [16, 8],
    'SERPENT-128': [16, 16],
    'SERPENT-192': [24, 16],
    'SERPENT-256': [32, 16],
    'TWOFISH-128': [16, 16],
    'TWOFISH-192': [24, 16],
    'TWOFISH-256': [32, 16]
  };
  /**
   * Encrypt a block.
   * @param {PEMBlock} block
   * @param {String} name
   * @param {String} passwd
   * @returns {PEMBlock}
   */

  function encrypt$3(block, name, passwd) {
    assert_1$1(block instanceof PEMBlock$1);
    assert_1$1(typeof name === 'string');
    assert_1$1(typeof passwd === 'string');
    if (block.isEncrypted()) throw new Error('PEM block is already encrypted.');

    var _cipherInfo = cipherInfo(name),
        _cipherInfo2 = _slicedToArray__default['default'](_cipherInfo, 2),
        keySize = _cipherInfo2[0],
        ivSize = _cipherInfo2[1];

    var iv = randomBrowser.randomBytes(ivSize);

    var _eb2k$derive = eb2kBrowser.derive(md5Browser, passwd, iv, keySize, ivSize),
        _eb2k$derive2 = _slicedToArray__default['default'](_eb2k$derive, 1),
        key = _eb2k$derive2[0];

    block.data = cipherBrowser.encrypt(name, key, iv, block.data);
    block.setProcType(4, 'ENCRYPTED');
    block.setDEKInfo(name, iv);
    return block;
  }
  /**
   * Decrypt a block.
   * @param {PEMBlock} block
   * @param {String} passwd
   * @returns {PEMBlock}
   */


  function decrypt$3(block, passwd) {
    assert_1$1(block instanceof PEMBlock$1);
    assert_1$1(typeof passwd === 'string');
    if (!block.isEncrypted()) throw new Error('PEM block is not encrypted.');
    var info = block.getDEKInfo();
    if (!info) throw new Error('DEK-Info not found.');

    var _cipherInfo3 = cipherInfo(info.name),
        _cipherInfo4 = _slicedToArray__default['default'](_cipherInfo3, 2),
        keySize = _cipherInfo4[0],
        ivSize = _cipherInfo4[1];

    var _eb2k$derive3 = eb2kBrowser.derive(md5Browser, passwd, info.iv, keySize, ivSize),
        _eb2k$derive4 = _slicedToArray__default['default'](_eb2k$derive3, 1),
        key = _eb2k$derive4[0];

    block.data = cipherBrowser.decrypt(info.name, key, info.iv, block.data);
    block.unsetProcType();
    block.unsetDEKInfo();
    return block;
  }
  /*
   * Helpers
   */


  function cipherInfo(name) {
    assert_1$1(typeof name === 'string');
    if (name.substring(0, 3) === 'RC2') name = 'A' + name;
    if (name.length < 5 || name[name.length - 4] !== '-') throw new Error("Unsupported cipher: ".concat(name, "."));
    var algo = name.substring(0, name.length - 4);
    var info = ciphers[algo];
    if (!info) throw new Error("Unsupported cipher: ".concat(name, "."));
    return info;
  }
  /*
   * Expose
   */


  var encrypt_1$3 = encrypt$3;
  var decrypt_1$3 = decrypt$3;
  var pemcrypt = {
    encrypt: encrypt_1$3,
    decrypt: decrypt_1$3
  };

  function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * RSAPublicKey
   */
  // RSAPublicKey ::= SEQUENCE {
  //     modulus           INTEGER,  -- n
  //     publicExponent    INTEGER   -- e
  // }


  var RSAPublicKey = /*#__PURE__*/function (_asn1$Sequence) {
    _inherits__default['default'](RSAPublicKey, _asn1$Sequence);

    var _super = _createSuper$o(RSAPublicKey);

    function RSAPublicKey(n, e) {
      var _this;

      _classCallCheck__default['default'](this, RSAPublicKey);

      _this = _super.call(this);
      _this.n = new asn1$1.Unsigned(n);
      _this.e = new asn1$1.Unsigned(e);
      return _this;
    }

    _createClass__default['default'](RSAPublicKey, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.n.getSize();
        size += this.e.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.n.write(bw);
        this.e.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.n.read(br);
        this.e.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.n.clean() && this.e.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'RSA PUBLIC KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'RSA PUBLIC KEY');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          n: this.n,
          e: this.e
        };
      }
    }]);

    return RSAPublicKey;
  }(asn1$1.Sequence);
  /**
   * RSAPrivateKey
   */
  // RSAPrivateKey ::= SEQUENCE {
  //   version           Version,
  //   modulus           INTEGER,  -- n
  //   publicExponent    INTEGER,  -- e
  //   privateExponent   INTEGER,  -- d
  //   prime1            INTEGER,  -- p
  //   prime2            INTEGER,  -- q
  //   exponent1         INTEGER,  -- d mod (p-1)
  //   exponent2         INTEGER,  -- d mod (q-1)
  //   coefficient       INTEGER,  -- (inverse of q) mod p
  //   otherPrimeInfos   OtherPrimeInfos OPTIONAL
  // }


  var RSAPrivateKey = /*#__PURE__*/function (_asn1$Sequence2) {
    _inherits__default['default'](RSAPrivateKey, _asn1$Sequence2);

    var _super2 = _createSuper$o(RSAPrivateKey);

    function RSAPrivateKey(version, n, e, d, p, q, dp, dq, qi) {
      var _this2;

      _classCallCheck__default['default'](this, RSAPrivateKey);

      _this2 = _super2.call(this);
      _this2.version = new asn1$1.Unsigned(version);
      _this2.n = new asn1$1.Unsigned(n);
      _this2.e = new asn1$1.Unsigned(e);
      _this2.d = new asn1$1.Unsigned(d);
      _this2.p = new asn1$1.Unsigned(p);
      _this2.q = new asn1$1.Unsigned(q);
      _this2.dp = new asn1$1.Unsigned(dp);
      _this2.dq = new asn1$1.Unsigned(dq);
      _this2.qi = new asn1$1.Unsigned(qi);
      return _this2;
    }

    _createClass__default['default'](RSAPrivateKey, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.version.getSize();
        size += this.n.getSize();
        size += this.e.getSize();
        size += this.d.getSize();
        size += this.p.getSize();
        size += this.q.getSize();
        size += this.dp.getSize();
        size += this.dq.getSize();
        size += this.qi.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.version.write(bw);
        this.n.write(bw);
        this.e.write(bw);
        this.d.write(bw);
        this.p.write(bw);
        this.q.write(bw);
        this.dp.write(bw);
        this.dq.write(bw);
        this.qi.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.version.read(br);
        this.n.read(br);
        this.e.read(br);
        this.d.read(br);
        this.p.read(br);
        this.q.read(br);
        this.dp.read(br);
        this.dq.read(br);
        this.qi.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.n.clean() && this.e.clean() && this.d.clean() && this.p.clean() && this.q.clean() && this.dp.clean() && this.dq.clean() && this.qi.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'RSA PRIVATE KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'RSA PRIVATE KEY');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          version: this.version,
          n: this.n,
          e: this.e,
          d: this.d,
          p: this.p,
          q: this.q,
          dp: this.dp,
          dq: this.dq,
          qi: this.qi
        };
      }
    }]);

    return RSAPrivateKey;
  }(asn1$1.Sequence);
  /*
   * Expose
   */


  var RSAPublicKey_1 = RSAPublicKey;
  var RSAPrivateKey_1 = RSAPrivateKey;
  var pkcs1 = {
    RSAPublicKey: RSAPublicKey_1,
    RSAPrivateKey: RSAPrivateKey_1
  };

  function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * DHParams
   */


  var DHParams = /*#__PURE__*/function (_asn1$Sequence) {
    _inherits__default['default'](DHParams, _asn1$Sequence);

    var _super = _createSuper$p(DHParams);

    function DHParams(p, g) {
      var _this;

      _classCallCheck__default['default'](this, DHParams);

      _this = _super.call(this);
      _this.p = new asn1$1.Unsigned(p);
      _this.g = new asn1$1.Unsigned(g);
      return _this;
    }

    _createClass__default['default'](DHParams, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.p.getSize();
        size += this.g.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.p.write(bw);
        this.g.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.p.read(br);
        this.g.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.p.clean() && this.g.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'DH PARAMETERS');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'DH PARAMETERS');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          p: this.p,
          g: this.g
        };
      }
    }]);

    return DHParams;
  }(asn1$1.Sequence);
  /*
   * Expose
   */


  var DHParams_1 = DHParams;
  var pkcs3 = {
    DHParams: DHParams_1
  };

  /*
   * PKCS5
   */


  var pkcs5 = {
    pad: function pad(pt, size) {
      assert_1$1(Buffer.isBuffer(pt));
      assert_1$1(size >>> 0 === size);
      assert_1$1(size > 0 && size < 256);
      var left = size - pt.length % size;
      var out = Buffer.alloc(pt.length + left);
      pt.copy(out, 0);

      for (var i = pt.length; i < out.length; i++) {
        out[i] = left;
      }

      return out;
    },
    unpad: function unpad(pt, size) {
      assert_1$1(Buffer.isBuffer(pt));
      assert_1$1(size >>> 0 === size);
      assert_1$1(size > 0 && size < 256);
      if (pt.length < size || pt.length % size !== 0) throw new Error('Invalid block.');
      var left = pt[pt.length - 1];
      var res = 1; // left != 0

      res &= left - 1 >>> 31 ^ 1; // left <= size

      res &= left - size - 1 >>> 31; // left = 0 if left == 0 or left > size

      left &= -res; // Verify padding in constant time.

      var end = size - left;

      for (var i = 0; i < size; i++) {
        var ch = pt[i]; // i < end or ch == left

        res &= i - end >>> 31 | (ch ^ left) - 1 >>> 31;
      }

      if (!res) throw new Error('Invalid padding.');
      return pt.slice(0, end);
    }
  };
  /*
   * Expose
   */

  var pkcs5_1 = pkcs5;

  function _createForOfIteratorHelper$a(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$a(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$a(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$a(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen); }

  function _arrayLikeToArray$a(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var types$3 = asn1$1.types;
  /**
   * Certificate
   */
  // Certificate  ::=  SEQUENCE  {
  //      tbsCertificate       TBSCertificate,
  //      signatureAlgorithm   AlgorithmIdentifier,
  //      signature            BIT STRING  }

  var Certificate = /*#__PURE__*/function (_asn1$Sequence) {
    _inherits__default['default'](Certificate, _asn1$Sequence);

    var _super = _createSuper$q(Certificate);

    function Certificate() {
      var _this;

      _classCallCheck__default['default'](this, Certificate);

      _this = _super.call(this);
      _this.tbsCertificate = new TBSCertificate();
      _this.signatureAlgorithm = new AlgorithmIdentifier();
      _this.signature = new asn1$1.BitString();
      return _this;
    }

    _createClass__default['default'](Certificate, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.tbsCertificate.getSize();
        size += this.signatureAlgorithm.getSize();
        size += this.signature.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.tbsCertificate.write(bw);
        this.signatureAlgorithm.write(bw);
        this.signature.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.tbsCertificate.read(br);
        this.signatureAlgorithm.read(br);
        this.signature.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.tbsCertificate.clean() && this.signatureAlgorithm.clean() && this.signature.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'CERTIFICATE');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'CERTIFICATE');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          tbsCertificate: this.tbsCertificate,
          signatureAlgorithm: this.signatureAlgorithm,
          signature: this.signature
        };
      }
    }, {
      key: "isRaw",
      get: function get() {
        return true;
      }
    }]);

    return Certificate;
  }(asn1$1.Sequence);
  /**
   * TBSCertificate
   */
  // TBSCertificate  ::=  SEQUENCE  {
  //      version         [0]  Version DEFAULT v1,
  //      serialNumber         CertificateSerialNumber,
  //      signature            AlgorithmIdentifier,
  //      issuer               Name,
  //      validity             Validity,
  //      subject              Name,
  //      subjectPublicKeyInfo SubjectPublicKeyInfo,
  //      issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
  //      subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
  //      extensions      [3]  Extensions OPTIONAL }
  //
  // Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }


  var TBSCertificate = /*#__PURE__*/function (_asn1$Sequence2) {
    _inherits__default['default'](TBSCertificate, _asn1$Sequence2);

    var _super2 = _createSuper$q(TBSCertificate);

    function TBSCertificate() {
      var _this2;

      _classCallCheck__default['default'](this, TBSCertificate);

      _this2 = _super2.call(this);
      _this2.version = new asn1$1.Unsigned().explicit(0).optional();
      _this2.serialNumber = new asn1$1.Integer();
      _this2.signature = new AlgorithmIdentifier();
      _this2.issuer = new RDNSequence();
      _this2.validity = new Validity();
      _this2.subject = new RDNSequence();
      _this2.subjectPublicKeyInfo = new SubjectPublicKeyInfo();
      _this2.issuerUniqueID = new asn1$1.BitString().implicit(1).optional();
      _this2.subjectUniqueID = new asn1$1.BitString().implicit(2).optional();
      _this2.extensions = new Extensions().explicit(3).optional();
      return _this2;
    }

    _createClass__default['default'](TBSCertificate, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.version.getSize();
        size += this.serialNumber.getSize();
        size += this.signature.getSize();
        size += this.issuer.getSize();
        size += this.validity.getSize();
        size += this.subject.getSize();
        size += this.subjectPublicKeyInfo.getSize();
        size += this.issuerUniqueID.getSize();
        size += this.subjectUniqueID.getSize();
        size += this.extensions.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.version.write(bw);
        this.serialNumber.write(bw);
        this.signature.write(bw);
        this.issuer.write(bw);
        this.validity.write(bw);
        this.subject.write(bw);
        this.subjectPublicKeyInfo.write(bw);
        this.issuerUniqueID.write(bw);
        this.subjectUniqueID.write(bw);
        this.extensions.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.version.read(br);
        this.serialNumber.read(br);
        this.signature.read(br);
        this.issuer.read(br);
        this.validity.read(br);
        this.subject.read(br);
        this.subjectPublicKeyInfo.read(br);
        this.issuerUniqueID.read(br);
        this.subjectUniqueID.read(br);
        this.extensions.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.version.clean() && this.serialNumber.clean() && this.signature.clean() && this.issuer.clean() && this.validity.clean() && this.subject.clean() && this.subjectPublicKeyInfo.clean() && this.issuerUniqueID.clean() && this.subjectUniqueID.clean() && this.extensions.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'TBS CERTIFICATE');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'TBS CERTIFICATE');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          version: this.version,
          serialNumber: this.serialNumber,
          signature: this.signature,
          issuer: this.issuer,
          validity: this.validity,
          subject: this.subject,
          subjectPublicKeyInfo: this.subjectPublicKeyInfo,
          issuerUniqueID: this.issuerUniqueID,
          subjectUniqueID: this.subjectUniqueID,
          extensions: this.extensions
        };
      }
    }, {
      key: "isRaw",
      get: function get() {
        return true;
      }
    }]);

    return TBSCertificate;
  }(asn1$1.Sequence);
  /**
   * AlgorithmIdentifier
   */
  // AlgorithmIdentifier  ::=  SEQUENCE  {
  //      algorithm               OBJECT IDENTIFIER,
  //      parameters              ANY DEFINED BY algorithm OPTIONAL  }


  var AlgorithmIdentifier = /*#__PURE__*/function (_asn1$Sequence3) {
    _inherits__default['default'](AlgorithmIdentifier, _asn1$Sequence3);

    var _super3 = _createSuper$q(AlgorithmIdentifier);

    function AlgorithmIdentifier(algorithm, parameters) {
      var _this3;

      _classCallCheck__default['default'](this, AlgorithmIdentifier);

      _this3 = _super3.call(this);
      _this3.algorithm = new asn1$1.OID(algorithm);
      _this3.parameters = new asn1$1.Any(parameters).optional();
      return _this3;
    }

    _createClass__default['default'](AlgorithmIdentifier, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.algorithm.getSize();
        size += this.parameters.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.algorithm.write(bw);
        this.parameters.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.algorithm.read(br);
        this.parameters.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.algorithm.clean() && this.parameters.clean();
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          algorithm: this.algorithm,
          parameters: this.parameters
        };
      }
    }]);

    return AlgorithmIdentifier;
  }(asn1$1.Sequence);
  /**
   * RDNSequence
   */
  // Name ::= CHOICE { -- only one possibility for now --
  //      rdnSequence  RDNSequence }
  //
  // RDNSequence ::= SEQUENCE OF RelativeDistinguishedName


  var RDNSequence = /*#__PURE__*/function (_asn1$Sequence4) {
    _inherits__default['default'](RDNSequence, _asn1$Sequence4);

    var _super4 = _createSuper$q(RDNSequence);

    function RDNSequence() {
      var _this4;

      _classCallCheck__default['default'](this, RDNSequence);

      _this4 = _super4.call(this);
      _this4.names = [];
      return _this4;
    }

    _createClass__default['default'](RDNSequence, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;

        var _iterator = _createForOfIteratorHelper$a(this.names),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var rdn = _step.value;
            size += rdn.getSize();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        var _iterator2 = _createForOfIteratorHelper$a(this.names),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var rdn = _step2.value;
            rdn.write(bw);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        while (br.left()) {
          var rdn = RDN.read(br);
          this.names.push(rdn);
        }

        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.names.length === 0;
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          names: this.names
        };
      }
    }]);

    return RDNSequence;
  }(asn1$1.Sequence);
  /**
   * RDN
   */
  // RelativeDistinguishedName ::=
  //      SET SIZE (1..MAX) OF AttributeTypeAndValue
  //


  var RDN = /*#__PURE__*/function (_asn1$Set) {
    _inherits__default['default'](RDN, _asn1$Set);

    var _super5 = _createSuper$q(RDN);

    function RDN(id, value) {
      var _this5;

      _classCallCheck__default['default'](this, RDN);

      _this5 = _super5.call(this);
      _this5.attributes = [new Attribute(id, value)];
      return _this5;
    }

    _createClass__default['default'](RDN, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        assert_1$1(this.attributes.length >= 1);

        var _iterator3 = _createForOfIteratorHelper$a(this.attributes),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var attr = _step3.value;
            size += attr.getSize();
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        assert_1$1(this.attributes.length >= 1);

        var _iterator4 = _createForOfIteratorHelper$a(this.attributes),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var attr = _step4.value;
            attr.write(bw);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.attributes[0].read(br);

        while (br.left()) {
          var attr = Attribute.read(br);
          this.attributes.push(attr);
        }

        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.attributes.length === 1 && this.attributes[0].clean();
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          attributes: this.attributes
        };
      }
    }]);

    return RDN;
  }(asn1$1.Set);
  /**
   * Attribute
   */
  // AttributeTypeAndValue ::= SEQUENCE {
  //      type     AttributeType,
  //      value    AttributeValue }
  //
  // AttributeType ::= OBJECT IDENTIFIER
  //
  // AttributeValue ::= ANY -- DEFINED BY AttributeType


  var Attribute = /*#__PURE__*/function (_asn1$Sequence5) {
    _inherits__default['default'](Attribute, _asn1$Sequence5);

    var _super6 = _createSuper$q(Attribute);

    function Attribute(id, value) {
      var _this6;

      _classCallCheck__default['default'](this, Attribute);

      _this6 = _super6.call(this);
      _this6.id = new asn1$1.OID(id);
      _this6.value = new asn1$1.Any(value);
      return _this6;
    }

    _createClass__default['default'](Attribute, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.id.getSize();
        size += this.value.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.id.write(bw);
        this.value.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.id.read(br);
        this.value.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.id.clean() && this.value.clean();
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          id: this.id,
          value: this.value
        };
      }
    }]);

    return Attribute;
  }(asn1$1.Sequence);
  /**
   * Validity
   */
  // Validity ::= SEQUENCE {
  //      notBefore      Time,
  //      notAfter       Time  }


  var Validity = /*#__PURE__*/function (_asn1$Sequence6) {
    _inherits__default['default'](Validity, _asn1$Sequence6);

    var _super7 = _createSuper$q(Validity);

    function Validity() {
      var _this7;

      _classCallCheck__default['default'](this, Validity);

      _this7 = _super7.call(this);
      _this7.notBefore = new Time$1();
      _this7.notAfter = new Time$1();
      return _this7;
    }

    _createClass__default['default'](Validity, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.notBefore.getSize();
        size += this.notAfter.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.notBefore.write(bw);
        this.notAfter.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.notBefore.read(br);
        this.notAfter.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.notBefore.clean() && this.notAfter.clean();
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          notBefore: this.notBefore,
          notAfter: this.notAfter
        };
      }
    }]);

    return Validity;
  }(asn1$1.Sequence);
  /**
   * Time
   */
  // Time ::= CHOICE {
  //      utcTime        UTCTime,
  //      generalTime    GeneralizedTime }


  var Time$1 = /*#__PURE__*/function (_asn1$Choice) {
    _inherits__default['default'](Time, _asn1$Choice);

    var _super8 = _createSuper$q(Time);

    function Time(options) {
      _classCallCheck__default['default'](this, Time);

      return _super8.call(this, new asn1$1.UTCTime(), options);
    }

    _createClass__default['default'](Time, [{
      key: "choices",
      value: function choices() {
        return [types$3.UTCTIME, types$3.GENTIME];
      }
    }]);

    return Time;
  }(asn1$1.Choice); // SubjectPublicKeyInfo  ::=  SEQUENCE  {
  //      algorithm            AlgorithmIdentifier,
  //      subjectPublicKey     BIT STRING  }


  var SubjectPublicKeyInfo = /*#__PURE__*/function (_asn1$Sequence7) {
    _inherits__default['default'](SubjectPublicKeyInfo, _asn1$Sequence7);

    var _super9 = _createSuper$q(SubjectPublicKeyInfo);

    function SubjectPublicKeyInfo(algorithm, parameters, publicKey) {
      var _this8;

      _classCallCheck__default['default'](this, SubjectPublicKeyInfo);

      _this8 = _super9.call(this);
      _this8.algorithm = new AlgorithmIdentifier(algorithm, parameters);
      _this8.publicKey = new asn1$1.BitString(publicKey);
      return _this8;
    }

    _createClass__default['default'](SubjectPublicKeyInfo, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.algorithm.getSize();
        size += this.publicKey.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.algorithm.write(bw);
        this.publicKey.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.algorithm.read(br);
        this.publicKey.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.algorithm.clean() && this.publicKey.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'PUBLIC KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'PUBLIC KEY');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          algorithm: this.algorithm,
          publicKey: this.publicKey
        };
      }
    }, {
      key: "isRaw",
      get: function get() {
        return true;
      }
    }]);

    return SubjectPublicKeyInfo;
  }(asn1$1.Sequence);
  /**
   * Extensions
   */


  var Extensions = /*#__PURE__*/function (_asn1$Sequence8) {
    _inherits__default['default'](Extensions, _asn1$Sequence8);

    var _super10 = _createSuper$q(Extensions);

    function Extensions() {
      var _this9;

      _classCallCheck__default['default'](this, Extensions);

      _this9 = _super10.call(this);
      _this9.extensions = [];
      return _this9;
    }

    _createClass__default['default'](Extensions, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;

        var _iterator5 = _createForOfIteratorHelper$a(this.extensions),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var ext = _step5.value;
            size += ext.getSize();
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        var _iterator6 = _createForOfIteratorHelper$a(this.extensions),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var ext = _step6.value;
            ext.write(bw);
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        var _iterator7 = _createForOfIteratorHelper$a(this.extensions),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var ext = _step7.value;
            ext.read(br);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.extensions.length === 0;
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          extensions: this.extensions
        };
      }
    }]);

    return Extensions;
  }(asn1$1.Sequence);
  /**
   * Extension
   */
  // Extension  ::=  SEQUENCE  {
  //      extnID      OBJECT IDENTIFIER,
  //      critical    BOOLEAN DEFAULT FALSE,
  //      extnValue   OCTET STRING }


  var Extension = /*#__PURE__*/function (_asn1$Sequence9) {
    _inherits__default['default'](Extension, _asn1$Sequence9);

    var _super11 = _createSuper$q(Extension);

    function Extension() {
      var _this10;

      _classCallCheck__default['default'](this, Extension);

      _this10 = _super11.call(this);
      _this10.extnID = new asn1$1.OID();
      _this10.critical = new asn1$1.Bool().optional();
      _this10.extnValue = new asn1$1.OctString();
      return _this10;
    }

    _createClass__default['default'](Extension, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.extnID.getSize();
        size += this.critical.getSize();
        size += this.extnValue.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.extnID.write(bw);
        this.critical.write(bw);
        this.extnValue.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.extnID.read(br);
        this.critical.read(br);
        this.extnValue.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.extnID.clean() && this.critical.clean() && this.extnValue.clean();
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          extnID: this.extnID,
          critical: this.critical,
          extnValue: this.extnValue
        };
      }
    }]);

    return Extension;
  }(asn1$1.Sequence);
  /**
   * DigestInfo
   */
  // See: https://www.ietf.org/rfc/rfc3447.txt
  // Section 9.2
  //
  // DigestInfo ::= SEQUENCE {
  //   digestAlgorithm AlgorithmIdentifier,
  //   digest OCTET STRING
  // }


  var DigestInfo = /*#__PURE__*/function (_asn1$Sequence10) {
    _inherits__default['default'](DigestInfo, _asn1$Sequence10);

    var _super12 = _createSuper$q(DigestInfo);

    function DigestInfo(algorithm, digest) {
      var _this11;

      _classCallCheck__default['default'](this, DigestInfo);

      _this11 = _super12.call(this);
      _this11.algorithm = new AlgorithmIdentifier(algorithm);

      _this11.algorithm.parameters.optional(false);

      _this11.digest = new asn1$1.OctString(digest);
      return _this11;
    }

    _createClass__default['default'](DigestInfo, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.algorithm.getSize();
        size += this.digest.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.algorithm.write(bw);
        this.digest.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.algorithm.read(br);
        this.digest.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.algorithm.clean() && this.digest.clean();
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          algorithm: this.algorithm,
          digest: this.digest
        };
      }
    }]);

    return DigestInfo;
  }(asn1$1.Sequence);
  /*
   * Expose
   */


  var Certificate_1 = Certificate;
  var TBSCertificate_1 = TBSCertificate;
  var AlgorithmIdentifier_1 = AlgorithmIdentifier;
  var RDNSequence_1 = RDNSequence;
  var RDN_1 = RDN;
  var Attribute_1 = Attribute;
  var Validity_1 = Validity;
  var Time_1$1 = Time$1;
  var SubjectPublicKeyInfo_1 = SubjectPublicKeyInfo;
  var Extensions_1 = Extensions;
  var Extension_1 = Extension;
  var DigestInfo_1 = DigestInfo;
  var x509 = {
    Certificate: Certificate_1,
    TBSCertificate: TBSCertificate_1,
    AlgorithmIdentifier: AlgorithmIdentifier_1,
    RDNSequence: RDNSequence_1,
    RDN: RDN_1,
    Attribute: Attribute_1,
    Validity: Validity_1,
    Time: Time_1$1,
    SubjectPublicKeyInfo: SubjectPublicKeyInfo_1,
    Extensions: Extensions_1,
    Extension: Extension_1,
    DigestInfo: DigestInfo_1
  };

  function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * PublicKeyInfo
   */
  // PublicKeyInfo ::= SEQUENCE {
  //   algorithm       AlgorithmIdentifier,
  //   PublicKey       BIT STRING
  // }


  var PublicKeyInfo = /*#__PURE__*/function (_asn1$Sequence) {
    _inherits__default['default'](PublicKeyInfo, _asn1$Sequence);

    var _super = _createSuper$r(PublicKeyInfo);

    function PublicKeyInfo(algorithm, identifier, publicKey) {
      var _this;

      _classCallCheck__default['default'](this, PublicKeyInfo);

      _this = _super.call(this);
      _this.algorithm = new x509.AlgorithmIdentifier(algorithm, identifier);
      _this.publicKey = new asn1$1.BitString(publicKey);
      return _this;
    }

    _createClass__default['default'](PublicKeyInfo, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.algorithm.getSize();
        size += this.publicKey.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.algorithm.write(bw);
        this.publicKey.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.algorithm.read(br);
        this.publicKey.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.algorithm.clean() && this.publicKey.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'PUBLIC KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'PUBLIC KEY');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          algorithm: this.algorithm,
          publicKey: this.publicKey
        };
      }
    }]);

    return PublicKeyInfo;
  }(asn1$1.Sequence);
  /**
   * PrivateKeyInfo
   */
  // PrivateKeyInfo ::= SEQUENCE {
  //   version         Version,
  //   algorithm       AlgorithmIdentifier,
  //   PrivateKey      OCTET STRING
  // }
  //
  // PrivateKeyInfo ::= SEQUENCE {
  //    version Version,
  //    privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},
  //    privateKey PrivateKey,
  //    attributes [0] Attributes OPTIONAL
  // }
  //
  // Version ::= INTEGER {v1(0)} (v1,...)
  //
  // PrivateKey ::= OCTET STRING


  var PrivateKeyInfo = /*#__PURE__*/function (_asn1$Sequence2) {
    _inherits__default['default'](PrivateKeyInfo, _asn1$Sequence2);

    var _super2 = _createSuper$r(PrivateKeyInfo);

    function PrivateKeyInfo(version, algorithm, parameters, privateKey) {
      var _this2;

      _classCallCheck__default['default'](this, PrivateKeyInfo);

      _this2 = _super2.call(this);
      _this2.version = new asn1$1.Unsigned(version);
      _this2.algorithm = new x509.AlgorithmIdentifier(algorithm, parameters);
      _this2.privateKey = new asn1$1.OctString(privateKey);
      return _this2;
    }

    _createClass__default['default'](PrivateKeyInfo, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.version.getSize();
        size += this.algorithm.getSize();
        size += this.privateKey.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.version.write(bw);
        this.algorithm.write(bw);
        this.privateKey.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.version.read(br);
        this.algorithm.read(br);
        this.privateKey.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.version.clean() && this.algorithm.clean() && this.privateKey.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'PRIVATE KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'PRIVATE KEY');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          version: this.version,
          algorithm: this.algorithm,
          privateKey: this.privateKey
        };
      }
    }, {
      key: "isRaw",
      get: function get() {
        return true;
      }
    }]);

    return PrivateKeyInfo;
  }(asn1$1.Sequence);
  /**
   * EncryptedPrivateKeyInfo
   */
  // EncryptedPrivateKeyInfo ::= SEQUENCE {
  //   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
  //   encryptedData        EncryptedData
  // }
  //
  // EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
  //
  // EncryptedData ::= OCTET STRING


  var EncryptedPrivateKeyInfo = /*#__PURE__*/function (_asn1$Sequence3) {
    _inherits__default['default'](EncryptedPrivateKeyInfo, _asn1$Sequence3);

    var _super3 = _createSuper$r(EncryptedPrivateKeyInfo);

    function EncryptedPrivateKeyInfo(algorithm, identifier, data) {
      var _this3;

      _classCallCheck__default['default'](this, EncryptedPrivateKeyInfo);

      _this3 = _super3.call(this);
      _this3.algorithm = new x509.AlgorithmIdentifier(algorithm, identifier);
      _this3.data = new asn1$1.OctString(data);
      return _this3;
    }

    _createClass__default['default'](EncryptedPrivateKeyInfo, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.algorithm.getSize();
        size += this.data.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.algorithm.write(bw);
        this.data.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.algorithm.read(br);
        this.data.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.algorithm.clean() && this.data.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'ENCRYPTED PRIVATE KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'ENCRYPTED PRIVATE KEY');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          algorithm: this.algorithm,
          data: this.data
        };
      }
    }]);

    return EncryptedPrivateKeyInfo;
  }(asn1$1.Sequence);
  /*
   * Expose
   */


  var PublicKeyInfo_1 = PublicKeyInfo;
  var PrivateKeyInfo_1 = PrivateKeyInfo;
  var EncryptedPrivateKeyInfo_1 = EncryptedPrivateKeyInfo;
  var pkcs8 = {
    PublicKeyInfo: PublicKeyInfo_1,
    PrivateKeyInfo: PrivateKeyInfo_1,
    EncryptedPrivateKeyInfo: EncryptedPrivateKeyInfo_1
  };

  function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * DSA Parms
   */
  // Dss-Parms  ::=  SEQUENCE  {
  //     p             INTEGER,
  //     q             INTEGER,
  //     g             INTEGER  }


  var DSAParams$2 = /*#__PURE__*/function (_asn1$Sequence) {
    _inherits__default['default'](DSAParams, _asn1$Sequence);

    var _super = _createSuper$s(DSAParams);

    function DSAParams(p, q, g) {
      var _this;

      _classCallCheck__default['default'](this, DSAParams);

      _this = _super.call(this);
      _this.p = new asn1$1.Unsigned(p);
      _this.q = new asn1$1.Unsigned(q);
      _this.g = new asn1$1.Unsigned(g);
      return _this;
    }

    _createClass__default['default'](DSAParams, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.p.getSize();
        size += this.q.getSize();
        size += this.g.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.p.write(bw);
        this.q.write(bw);
        this.g.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.p.read(br);
        this.q.read(br);
        this.g.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.p.clean() && this.q.clean() && this.g.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'DSA PARAMETERS');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'DSA PARAMETERS');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          p: this.p,
          q: this.q,
          g: this.g
        };
      }
    }]);

    return DSAParams;
  }(asn1$1.Sequence);
  /**
   * DSA Public Key
   */
  // DSAPublicKey ::= INTEGER -- public key, Y


  var DSAPublicKey$2 = /*#__PURE__*/function (_asn1$Unsigned) {
    _inherits__default['default'](DSAPublicKey, _asn1$Unsigned);

    var _super2 = _createSuper$s(DSAPublicKey);

    function DSAPublicKey(y) {
      _classCallCheck__default['default'](this, DSAPublicKey);

      return _super2.call(this, y);
    }

    _createClass__default['default'](DSAPublicKey, [{
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'DSA PUBLIC KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'DSA PUBLIC KEY');
        return this.decode(data);
      }
    }, {
      key: "y",
      get: function get() {
        return this.value;
      },
      set: function set(value) {
        this.value = value;
      }
    }]);

    return DSAPublicKey;
  }(asn1$1.Unsigned);
  /**
   * DSA Signature
   */


  var DSASignature$1 = /*#__PURE__*/function (_asn1$Sequence2) {
    _inherits__default['default'](DSASignature, _asn1$Sequence2);

    var _super3 = _createSuper$s(DSASignature);

    function DSASignature(r, s) {
      var _this2;

      _classCallCheck__default['default'](this, DSASignature);

      _this2 = _super3.call(this);
      _this2.r = new asn1$1.Unsigned(r);
      _this2.s = new asn1$1.Unsigned(s);
      return _this2;
    }

    _createClass__default['default'](DSASignature, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.r.getSize();
        size += this.s.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.r.write(bw);
        this.s.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.r.read(br);
        this.s.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.r.clean() && this.s.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'DSA SIGNATURE');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'DSA SIGNATURE');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          r: this.r,
          s: this.s
        };
      }
    }]);

    return DSASignature;
  }(asn1$1.Sequence);
  /*
   * Expose
   */


  var DSAParams_1$1 = DSAParams$2;
  var DSAPublicKey_1$1 = DSAPublicKey$2;
  var DSASignature_1 = DSASignature$1;
  var rfc3279 = {
    DSAParams: DSAParams_1$1,
    DSAPublicKey: DSAPublicKey_1$1,
    DSASignature: DSASignature_1
  };

  function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * ECPrivateKey
   */
  // ECPrivateKey ::= SEQUENCE {
  //   version INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
  //   privateKey OCTET STRING,
  //   parameters [0] ECDomainParameters {{ SECGCurveNames }} OPTIONAL,
  //   publicKey [1] BIT STRING OPTIONAL
  // }
  // ECDomainParameters{ECDOMAIN:IOSet} ::= CHOICE {
  //   specified SpecifiedECDomain,
  //   named ECDOMAIN.&id({IOSet}),
  //   implicitCA NULL
  // }
  // ECDOMAIN ::= CLASS {
  //   &id OBJECT IDENTIFIER UNIQUE
  // }
  // Golang seems to be using this instead:
  // ECPrivateKey ::= SEQUENCE {
  //   version       INTEGER { ecPrivkeyVer1(1) },
  //   privateKey    OCTET STRING,
  //   parameters    [0] EXPLICIT ECDomainParameters OPTIONAL,
  //   publicKey     [1] EXPLICIT BIT STRING OPTIONAL
  // }


  var ECPrivateKey = /*#__PURE__*/function (_asn1$Sequence) {
    _inherits__default['default'](ECPrivateKey, _asn1$Sequence);

    var _super = _createSuper$t(ECPrivateKey);

    function ECPrivateKey(version, privateKey, namedCurveOID, publicKey) {
      var _this;

      _classCallCheck__default['default'](this, ECPrivateKey);

      _this = _super.call(this);
      _this.version = new asn1$1.Unsigned(version);
      _this.privateKey = new asn1$1.OctString(privateKey);
      _this.namedCurveOID = new asn1$1.OID(namedCurveOID).explicit(0).optional();
      _this.publicKey = new asn1$1.BitString(publicKey).explicit(1).optional();
      return _this;
    }

    _createClass__default['default'](ECPrivateKey, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.version.getSize();
        size += this.privateKey.getSize();
        size += this.namedCurveOID.getSize();
        size += this.publicKey.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.version.write(bw);
        this.privateKey.write(bw);
        this.namedCurveOID.write(bw);
        this.publicKey.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.version.read(br);
        this.privateKey.read(br);
        this.namedCurveOID.read(br);
        this.publicKey.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.version.clean() && this.privateKey.clean() && this.namedCurveOID.clean() && this.publicKey.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'EC PRIVATE KEY');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'EC PRIVATE KEY');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          version: this.version,
          privateKey: this.privateKey,
          namedCurveOID: this.namedCurveOID,
          publicKey: this.publicKey
        };
      }
    }]);

    return ECPrivateKey;
  }(asn1$1.Sequence);
  /**
   * ECDSA Signature
   */
  // ECDSA-Signature ::= CHOICE {
  //   two-ints-plus ECDSA-Sig-Value,
  //   point-int [0] ECDSA-Full-R,
  //   ... -- Future representations may be added
  // }
  // ECDSA-Full-R ::= SEQUENCE {
  //   r ECPoint,
  //   s INTEGER
  // }
  // ECPoint ::= OCTET STRING
  // ECDSA-Sig-Value ::= SEQUENCE {
  //   r INTEGER,
  //   s INTEGER,
  //   a INTEGER OPTIONAL,
  //   y CHOICE { b BOOLEAN, f FieldElement } OPTIONAL
  // }


  var ECDSASignature = /*#__PURE__*/function (_asn1$Sequence2) {
    _inherits__default['default'](ECDSASignature, _asn1$Sequence2);

    var _super2 = _createSuper$t(ECDSASignature);

    function ECDSASignature(r, s) {
      var _this2;

      _classCallCheck__default['default'](this, ECDSASignature);

      _this2 = _super2.call(this);
      _this2.r = new asn1$1.Unsigned(r);
      _this2.s = new asn1$1.Unsigned(s);
      return _this2;
    }

    _createClass__default['default'](ECDSASignature, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;
        size += this.r.getSize();
        size += this.s.getSize();
        return size;
      }
    }, {
      key: "writeBody",
      value: function writeBody(bw) {
        this.r.write(bw);
        this.s.write(bw);
        return bw;
      }
    }, {
      key: "readBody",
      value: function readBody(br) {
        this.r.read(br);
        this.s.read(br);
        return this;
      }
    }, {
      key: "clean",
      value: function clean() {
        return this.r.clean() && this.s.clean();
      }
    }, {
      key: "toPEM",
      value: function toPEM() {
        return pem.toPEM(this.encode(), 'EC SIGNATURE');
      }
    }, {
      key: "fromPEM",
      value: function fromPEM(str) {
        var data = pem.fromPEM(str, 'EC SIGNATURE');
        return this.decode(data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: this.constructor.name,
          r: this.r,
          s: this.s
        };
      }
    }]);

    return ECDSASignature;
  }(asn1$1.Sequence);
  /*
   * Expose
   */


  var ECPrivateKey_1 = ECPrivateKey;
  var ECDSASignature_1 = ECDSASignature;
  var sec1 = {
    ECPrivateKey: ECPrivateKey_1,
    ECDSASignature: ECDSASignature_1
  };

  var asn1$2 = asn1$1;
  var base16$1 = base16Browser;
  var base32$1 = base32Browser;
  var base58$2 = base58Browser$1;
  var base64$1 = base64Browser;
  var bech32$1 = bech32Browser;
  var cash32$1 = cash32Browser;
  var lines$1 = lines_1;
  var openssl$1 = openssl;
  var pem$1 = pem;
  var pemcrypt$1 = pemcrypt;
  var pkcs1$1 = pkcs1;
  var pkcs3$1 = pkcs3;
  var pkcs5$1 = pkcs5_1;
  var pkcs8$1 = pkcs8;
  var rfc3279$1 = rfc3279;
  var sec1$1 = sec1;
  var util$2 = util$1;
  var x509$1 = x509;
  var encoding$1 = {
    asn1: asn1$2,
    base16: base16$1,
    base32: base32$1,
    base58: base58$2,
    base64: base64$1,
    bech32: bech32$1,
    cash32: cash32$1,
    lines: lines$1,
    openssl: openssl$1,
    pem: pem$1,
    pemcrypt: pemcrypt$1,
    pkcs1: pkcs1$1,
    pkcs3: pkcs3$1,
    pkcs5: pkcs5$1,
    pkcs8: pkcs8$1,
    rfc3279: rfc3279$1,
    sec1: sec1$1,
    util: util$2,
    x509: x509$1
  };

  /*
   * Constants
   */


  var FINALIZED$7 = -1;
  var PADDING$5 = Buffer.alloc(32, 0x00);
  var DESC$3 = Buffer.alloc(32, 0x00);
  var C = Buffer.from([0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff]);
  var S_CRYPTOPRO = [Buffer.from([10, 4, 5, 6, 8, 1, 3, 7, 13, 12, 14, 0, 9, 2, 11, 15]), Buffer.from([5, 15, 4, 0, 2, 13, 11, 9, 1, 7, 6, 3, 12, 14, 10, 8]), Buffer.from([7, 15, 12, 14, 9, 4, 1, 0, 3, 11, 5, 2, 6, 10, 8, 13]), Buffer.from([4, 10, 7, 12, 0, 15, 2, 8, 14, 1, 6, 5, 13, 11, 9, 3]), Buffer.from([7, 6, 4, 11, 9, 12, 2, 10, 1, 8, 0, 14, 15, 13, 3, 5]), Buffer.from([7, 6, 2, 4, 13, 9, 15, 0, 10, 1, 5, 11, 8, 14, 12, 3]), Buffer.from([13, 14, 4, 1, 7, 0, 5, 10, 3, 12, 8, 15, 6, 2, 9, 11]), Buffer.from([1, 3, 10, 9, 5, 11, 4, 15, 8, 6, 7, 14, 13, 0, 2, 12])];
  var S_TEST = [Buffer.from([4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3]), Buffer.from([14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9]), Buffer.from([5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11]), Buffer.from([7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3]), Buffer.from([6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2]), Buffer.from([4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14]), Buffer.from([13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12]), Buffer.from([1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12])];
  var S_S2015 = [Buffer.from([12, 4, 6, 2, 10, 5, 11, 9, 14, 8, 13, 7, 0, 3, 15, 1]), Buffer.from([6, 8, 2, 3, 9, 10, 5, 12, 1, 14, 4, 7, 11, 13, 0, 15]), Buffer.from([11, 3, 5, 8, 2, 15, 10, 13, 14, 1, 7, 4, 12, 9, 6, 0]), Buffer.from([12, 8, 2, 1, 13, 4, 15, 6, 7, 0, 10, 5, 3, 14, 9, 11]), Buffer.from([7, 15, 5, 10, 8, 1, 6, 13, 0, 9, 3, 14, 11, 4, 2, 12]), Buffer.from([5, 13, 15, 6, 9, 2, 12, 10, 11, 7, 8, 1, 4, 3, 14, 0]), Buffer.from([8, 14, 2, 5, 6, 9, 1, 12, 15, 4, 11, 0, 13, 10, 3, 7]), Buffer.from([1, 7, 14, 13, 0, 5, 8, 3, 4, 15, 10, 6, 9, 12, 11, 2])];
  /**
   * GOST94
   */

  var GOST94 = /*#__PURE__*/function () {
    function GOST94() {
      _classCallCheck__default['default'](this, GOST94);

      this.S = S_CRYPTOPRO;
      this.state = Buffer.alloc(32);
      this.sigma = Buffer.alloc(32);
      this.block = Buffer.alloc(32);
      this.size = FINALIZED$7;
    }

    _createClass__default['default'](GOST94, [{
      key: "init",
      value: function init(box) {
        if (box == null) box = S_CRYPTOPRO;
        assert_1$1(Array.isArray(box) && box.length === 8);
        this.S = box;
        this.state.fill(0);
        this.sigma.fill(0);
        this.size = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._update(data, data.length);

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return this._final(Buffer.alloc(32));
      }
    }, {
      key: "_update",
      value: function _update(data, len) {
        assert_1$1(this.size !== FINALIZED$7, 'Context is not initialized.');
        var pos = this.size & 31;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 32 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 32) return;

          this._transform(this.block, 0);
        }

        while (len >= 32) {
          this._transform(data, off);

          off += 32;
          len -= 32;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
    }, {
      key: "_final",
      value: function _final(out) {
        assert_1$1(this.size !== FINALIZED$7, 'Context is not initialized.');
        var bits = this.size * 8;
        var pos = this.size & 31;
        if (pos !== 0) this._update(PADDING$5, 32 - pos);
        var hi = bits * (1 / 0x100000000) >>> 0;
        var lo = bits >>> 0;
        writeU32$h(DESC$3, lo, 0);
        writeU32$h(DESC$3, hi, 4);

        this._f(DESC$3);

        this._f(this.sigma);

        this.state.copy(out, 0);
        this.state.fill(0);
        this.sigma.fill(0);
        this.block.fill(0);
        DESC$3.fill(0, 0, 8);
        this.size = FINALIZED$7;
        return out;
      }
    }, {
      key: "_transform",
      value: function _transform(chunk, pos) {
        var m = chunk.slice(pos, pos + 32);

        this._f(m);

        this._sum(m);
      }
    }, {
      key: "_shuffle",
      value: function _shuffle(m, s) {
        var res = Buffer.alloc(32);
        s.copy(res, 0);

        for (var i = 0; i < 12; i++) {
          psi(res);
        }

        XM(res, m);
        psi(res);
        XM(this.state, res);

        for (var _i = 0; _i < 61; _i++) {
          psi(this.state);
        }
      }
    }, {
      key: "_f",
      value: function _f(m) {
        var s = Buffer.alloc(32);
        this.state.copy(s, 0);
        var k, u, v;
        k = P$1(X$1(this.state, m));
        encrypt$4(s, 0, k, this.S);
        u = A(this.state);
        v = A(A(m));
        k = P$1(X$1(u, v));
        encrypt$4(s, 8, k, this.S);
        u = A(u);
        XM(u, C);
        v = A(A(v));
        k = P$1(X$1(u, v));
        encrypt$4(s, 16, k, this.S);
        u = A(u);
        v = A(A(v));
        k = P$1(X$1(u, v));
        encrypt$4(s, 24, k, this.S);

        this._shuffle(m, s);
      }
    }, {
      key: "_sum",
      value: function _sum(m) {
        var c = 0;

        for (var i = 0; i < 32; i++) {
          c += this.sigma[i] + m[i];
          this.sigma[i] = c;
          c >>>= 8;
        }
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new GOST94();
      }
    }, {
      key: "hmac",
      value: function hmac$1(box) {
        return new hmac(GOST94, 32, [box]);
      }
    }, {
      key: "digest",
      value: function digest(data, box) {
        return GOST94.ctx.init(box).update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right, box) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 32);
        assert_1$1(Buffer.isBuffer(right) && right.length === 32);
        return GOST94.ctx.init(box).update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, box) {
        var ctx = GOST94.ctx;
        ctx.init(box);
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key, box) {
        return GOST94.hmac(box).init(key).update(data).final();
      }
    }]);

    return GOST94;
  }();
  /*
   * Static
   */


  GOST94.native = 0;
  GOST94.id = 'GOST94';
  GOST94.size = 32;
  GOST94.bits = 256;
  GOST94.blockSize = 32;
  GOST94.zero = Buffer.alloc(32, 0x00);
  GOST94.ctx = new GOST94();
  GOST94.CRYPTOPRO = S_CRYPTOPRO;
  GOST94.TEST = S_TEST;
  GOST94.S2015 = S_S2015;
  /*
   * Helpers
   */

  function sbox(a, S) {
    var v = 0;

    for (var i = 0; i < 8; i++) {
      var shft = 4 * i;
      var k = (a & 15 << shft) >>> shft;
      v += S[i][k] << shft;
    }

    return v >>> 0;
  }

  function G$2(a, k, S) {
    return rotl32$3(sbox(a + k >>> 0, S), 11);
  }

  function encrypt$4(msg, pos, key, sbox) {
    var k = new Uint32Array(8);
    var a = readU32$i(msg, pos + 0);
    var b = readU32$i(msg, pos + 4);

    for (var i = 0; i < 8; i++) {
      k[i] = readU32$i(key, i * 4);
    }

    for (var x = 0; x < 3; x++) {
      for (var _i2 = 0; _i2 < 8; _i2++) {
        var t = b ^ G$2(a, k[_i2], sbox);
        b = a;
        a = t;
      }
    }

    for (var _i3 = 7; _i3 >= 0; _i3--) {
      var _t = b ^ G$2(a, k[_i3], sbox);

      b = a;
      a = _t;
    }

    writeU32$h(msg, b, pos + 0);
    writeU32$h(msg, a, pos + 4);
  }

  function X$1(a, b) {
    var out = Buffer.alloc(32);

    for (var i = 0; i < 32; i++) {
      out[i] = a[i] ^ b[i];
    }

    return out;
  }

  function XM(a, b) {
    for (var i = 0; i < 32; i++) {
      a[i] ^= b[i];
    }
  }

  function A(x) {
    var out = Buffer.alloc(32);
    x.copy(out, 0, 8, 32);

    for (var i = 0; i < 8; i++) {
      out[24 + i] = x[i] ^ x[i + 8];
    }

    return out;
  }

  function P$1(y) {
    var out = Buffer.alloc(32);

    for (var i = 0; i < 4; i++) {
      for (var k = 0; k < 8; k++) {
        out[i + 4 * k] = y[8 * i + k];
      }
    }

    return out;
  }

  function psi(block) {
    var out = Buffer.alloc(32);
    block.copy(out, 0, 2, 32);
    block.copy(out, 30, 0, 2);
    out[30] ^= block[2];
    out[31] ^= block[3];
    out[30] ^= block[4];
    out[31] ^= block[5];
    out[30] ^= block[6];
    out[31] ^= block[7];
    out[30] ^= block[24];
    out[31] ^= block[25];
    out[30] ^= block[30];
    out[31] ^= block[31];
    out.copy(block, 0);
  }

  function rotl32$3(w, b) {
    return w << b | w >>> 32 - b;
  }

  function readU32$i(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }

  function writeU32$h(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var gost94 = GOST94;

  var gost94Browser = gost94;

  /*
   * Constants
   */


  var FINALIZED$8 = -1;
  var DESC$4 = Buffer.alloc(8, 0x00);
  var PADDING$6 = Buffer.alloc(64, 0x00);
  PADDING$6[0] = 0x80;
  var r = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);
  var rh = new Uint8Array([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);
  var s = new Uint8Array([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);
  var sh = new Uint8Array([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);
  /**
   * RIPEMD160
   */

  var RIPEMD160 = /*#__PURE__*/function () {
    function RIPEMD160() {
      _classCallCheck__default['default'](this, RIPEMD160);

      this.state = new Uint32Array(5);
      this.msg = new Uint32Array(16);
      this.block = Buffer.alloc(64);
      this.size = FINALIZED$8;
    }

    _createClass__default['default'](RIPEMD160, [{
      key: "init",
      value: function init() {
        this.state[0] = 0x67452301;
        this.state[1] = 0xefcdab89;
        this.state[2] = 0x98badcfe;
        this.state[3] = 0x10325476;
        this.state[4] = 0xc3d2e1f0;
        this.size = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._update(data, data.length);

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return this._final(Buffer.alloc(20));
      }
    }, {
      key: "_update",
      value: function _update(data, len) {
        assert_1$1(this.size !== FINALIZED$8, 'Context is not initialized.');
        var pos = this.size & 63;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 64 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 64) return;

          this._transform(this.block, 0);
        }

        while (len >= 64) {
          this._transform(data, off);

          off += 64;
          len -= 64;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
    }, {
      key: "_final",
      value: function _final(out) {
        assert_1$1(this.size !== FINALIZED$8, 'Context is not initialized.');
        var pos = this.size & 63;
        var len = this.size * 8;
        writeU32$i(DESC$4, len >>> 0, 0);
        writeU32$i(DESC$4, len * (1 / 0x100000000) >>> 0, 4);

        this._update(PADDING$6, 1 + (119 - pos & 63));

        this._update(DESC$4, 8);

        for (var i = 0; i < 5; i++) {
          writeU32$i(out, this.state[i], i * 4);
          this.state[i] = 0;
        }

        for (var _i = 0; _i < 16; _i++) {
          this.msg[_i] = 0;
        }

        for (var _i2 = 0; _i2 < 64; _i2++) {
          this.block[_i2] = 0;
        }

        this.size = FINALIZED$8;
        return out;
      }
    }, {
      key: "_transform",
      value: function _transform(chunk, pos) {
        var W = this.msg;
        var A = this.state[0];
        var B = this.state[1];
        var C = this.state[2];
        var D = this.state[3];
        var E = this.state[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;

        for (var i = 0; i < 16; i++) {
          W[i] = readU32$j(chunk, pos + i * 4);
        }

        for (var j = 0; j < 80; j++) {
          var a = A + f(j, B, C, D) + W[r[j]] + K$3(j);
          var b = rotl32$4(a, s[j]);

          var _T = b + E;

          A = E;
          E = D;
          D = rotl32$4(C, 10);
          C = B;
          B = _T;
          a = Ah + f(79 - j, Bh, Ch, Dh) + W[rh[j]] + Kh(j);
          b = rotl32$4(a, sh[j]);
          _T = b + Eh;
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32$4(Ch, 10);
          Ch = Bh;
          Bh = _T;
        }

        var T = this.state[1] + C + Dh;
        this.state[1] = this.state[2] + D + Eh;
        this.state[2] = this.state[3] + E + Ah;
        this.state[3] = this.state[4] + A + Bh;
        this.state[4] = this.state[0] + B + Ch;
        this.state[0] = T;
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new RIPEMD160();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(RIPEMD160, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return RIPEMD160.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 20);
        assert_1$1(Buffer.isBuffer(right) && right.length === 20);
        return RIPEMD160.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = RIPEMD160.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return RIPEMD160.hmac().init(key).update(data).final();
      }
    }]);

    return RIPEMD160;
  }();
  /*
   * Static
   */


  RIPEMD160.native = 0;
  RIPEMD160.id = 'RIPEMD160';
  RIPEMD160.size = 20;
  RIPEMD160.bits = 160;
  RIPEMD160.blockSize = 64;
  RIPEMD160.zero = Buffer.alloc(20, 0x00);
  RIPEMD160.ctx = new RIPEMD160();
  /*
   * Helpers
   */

  function rotl32$4(w, b) {
    return w << b | w >>> 32 - b;
  }

  function f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;
    if (j <= 31) return x & y | ~x & z;
    if (j <= 47) return (x | ~y) ^ z;
    if (j <= 63) return x & z | y & ~z;
    return x ^ (y | ~z);
  }

  function K$3(j) {
    if (j <= 15) return 0x00000000;
    if (j <= 31) return 0x5a827999;
    if (j <= 47) return 0x6ed9eba1;
    if (j <= 63) return 0x8f1bbcdc;
    return 0xa953fd4e;
  }

  function Kh(j) {
    if (j <= 15) return 0x50a28be6;
    if (j <= 31) return 0x5c4dd124;
    if (j <= 47) return 0x6d703ef3;
    if (j <= 63) return 0x7a6d76e9;
    return 0x00000000;
  }

  function readU32$j(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }

  function writeU32$i(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var ripemd160 = RIPEMD160;

  /*
   * Constants
   */


  var rmd = new ripemd160();
  /**
   * Hash160
   */

  var Hash160 = /*#__PURE__*/function () {
    function Hash160() {
      _classCallCheck__default['default'](this, Hash160);

      this.ctx = new sha256();
    }

    _createClass__default['default'](Hash160, [{
      key: "init",
      value: function init() {
        this.ctx.init();
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        this.ctx.update(data);
        return this;
      }
    }, {
      key: "final",
      value: function final() {
        var out = Buffer.alloc(32);

        this.ctx._final(out);

        rmd.init();
        rmd.update(out);

        rmd._final(out);

        return out.slice(0, 20);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new Hash160();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(Hash160, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return Hash160.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 20);
        assert_1$1(Buffer.isBuffer(right) && right.length === 20);
        return Hash160.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = Hash160.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return Hash160.hmac().init(key).update(data).final();
      }
    }]);

    return Hash160;
  }();
  /*
   * Static
   */


  Hash160.native = 0;
  Hash160.id = 'HASH160';
  Hash160.size = 20;
  Hash160.bits = 160;
  Hash160.blockSize = 64;
  Hash160.zero = Buffer.alloc(20, 0x00);
  Hash160.ctx = new Hash160();
  /*
   * Expose
   */

  var hash160 = Hash160;

  var hash160Browser = hash160;

  /**
   * Hash256
   */


  var Hash256 = /*#__PURE__*/function () {
    function Hash256() {
      _classCallCheck__default['default'](this, Hash256);

      this.ctx = new sha256();
    }

    _createClass__default['default'](Hash256, [{
      key: "init",
      value: function init() {
        this.ctx.init();
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        this.ctx.update(data);
        return this;
      }
    }, {
      key: "final",
      value: function final() {
        var out = Buffer.alloc(32);

        this.ctx._final(out);

        this.ctx.init();
        this.ctx.update(out);

        this.ctx._final(out);

        return out;
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new Hash256();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(Hash256, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return Hash256.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 32);
        assert_1$1(Buffer.isBuffer(right) && right.length === 32);
        return Hash256.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = Hash256.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return Hash256.hmac().init(key).update(data).final();
      }
    }]);

    return Hash256;
  }();
  /*
   * Static
   */


  Hash256.native = 0;
  Hash256.id = 'HASH256';
  Hash256.size = 32;
  Hash256.bits = 256;
  Hash256.blockSize = 64;
  Hash256.zero = Buffer.alloc(32, 0x00);
  Hash256.ctx = new Hash256();
  /*
   * Expose
   */

  var hash256$1 = Hash256;

  var hash256Browser = hash256$1;

  /*
   * Constants
   */


  var RESEED_INTERVAL$2 = 0x1000000000000;
  var ONE$1 = Buffer.from([0x01]);
  var TWO = Buffer.from([0x02]);
  var THREE = Buffer.from([0x03]);
  /**
   * HashDRBG
   */

  var HashDRBG = /*#__PURE__*/function () {
    function HashDRBG(hash, entropy, nonce, pers) {
      _classCallCheck__default['default'](this, HashDRBG);

      assert_1$1(hash && typeof hash.id === 'string');
      this.hash = hash;
      this.minEntropy = hash.id === 'SHA1' ? 10 : 24;
      this.seedLen = hash.size <= 32 ? 55 : 111;
      this.V = Buffer.alloc(this.seedLen);
      this.C = Buffer.alloc(this.seedLen);
      this.len = Buffer.alloc(8);
      this.rounds = 0;
      if (entropy) this.init(entropy, nonce, pers);
    }

    _createClass__default['default'](HashDRBG, [{
      key: "init",
      value: function init(entropy, nonce, pers) {
        if (nonce == null) nonce = Buffer.alloc(0);
        if (pers == null) pers = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(entropy));
        assert_1$1(Buffer.isBuffer(nonce));
        assert_1$1(Buffer.isBuffer(pers));
        var seed = Buffer.concat([entropy, nonce, pers]);
        if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');
        this.V = this.derive(seed, this.seedLen, 0xff);
        this.C = this.derive(this.V, this.seedLen, 0x00);
        this.rounds = 1;
        return this;
      }
    }, {
      key: "reseed",
      value: function reseed(entropy, add) {
        if (add == null) add = Buffer.alloc(0);
        assert_1$1(Buffer.isBuffer(entropy));
        assert_1$1(Buffer.isBuffer(add));
        if (this.rounds === 0) throw new Error('DRBG not initialized.');
        var seed = Buffer.concat([this.V, entropy, add]);
        if (seed.length < this.minEntropy) throw new Error('Not enough entropy.');
        this.V = this.derive(seed, this.seedLen, 0x01);
        this.C = this.derive(this.V, this.seedLen, 0x00);
        this.rounds = 1;
        return this;
      }
    }, {
      key: "generate",
      value: function generate(len, add) {
        assert_1$1(len >>> 0 === len);
        assert_1$1(add == null || Buffer.isBuffer(add));
        if (this.rounds === 0) throw new Error('DRBG not initialized.');
        if (this.rounds > RESEED_INTERVAL$2) throw new Error('Reseed is required.');
        if (add && add.length > 0) this.sum(this.V, this.hash.multi(TWO, this.V, add));
        var data = Buffer.from(this.V);
        var blocks = Math.ceil(len / this.hash.size);
        var out = Buffer.alloc(blocks * this.hash.size);

        for (var i = 0; i < blocks; i++) {
          this.hash.digest(data).copy(out, i * this.hash.size);
          this.sum(data, ONE$1);
        }

        this.update();
        this.rounds += 1;
        return out.slice(0, len);
      }
    }, {
      key: "randomBytes",
      value: function randomBytes(size) {
        return this.generate(size);
      }
      /*
       * Helpers
       */

    }, {
      key: "update",
      value: function update() {
        var H = this.hash.multi(THREE, this.V);
        var hi = this.rounds / 0x100000000 >>> 0;
        var lo = this.rounds >>> 0;
        this.len[0] = hi >>> 24;
        this.len[1] = hi >>> 16;
        this.len[2] = hi >>> 8;
        this.len[3] = hi;
        this.len[4] = lo >>> 24;
        this.len[5] = lo >>> 16;
        this.len[6] = lo >>> 8;
        this.len[7] = lo;
        this.sum(this.V, H, this.C, this.len);
        return this;
      }
    }, {
      key: "derive",
      value: function derive(input, len, prepend) {
        assert_1$1(Buffer.isBuffer(input));
        assert_1$1(len >>> 0 === len);
        assert_1$1((prepend & 0xff) === prepend);
        var pre = prepend !== 0xff | 0;
        var data = Buffer.alloc(5 + pre + input.length);
        data[0] = 0x01;
        data[1] = len >>> 21;
        data[2] = len >>> 13;
        data[3] = len >>> 5;
        data[4] = (len & 0x1f) << 3;
        if (pre) data[5] = prepend;
        input.copy(data, 5 + pre);
        var blocks = Math.ceil(len / this.hash.size);
        var out = Buffer.alloc(blocks * this.hash.size);

        for (var i = 0; i < blocks; i++) {
          this.hash.digest(data).copy(out, i * this.hash.size);
          data[0] += 1;
        }

        return out.slice(0, len);
      }
    }, {
      key: "sum",
      value: function sum(dst) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        for (var _i = 0, _args = args; _i < _args.length; _i++) {
          var buf = _args[_i];
          var i = buf.length - 1;
          var j = dst.length - 1;
          var carry = 0;

          while (i >= 0) {
            carry += buf[i] + dst[j];
            dst[j] = carry & 0xff;
            carry >>>= 8;
            i -= 1;
            j -= 1;
          }

          while (carry > 0 && j >= 0) {
            carry += dst[j];
            dst[j] = carry & 0xff;
            carry >>>= 8;
            j -= 1;
          }
        }

        return dst;
      }
    }]);

    return HashDRBG;
  }();
  /*
   * Static
   */


  HashDRBG.native = 0;
  /*
   * Expose
   */

  var hashDrbg = HashDRBG;

  var hashDrbgBrowser = hashDrbg;

  /**
   * HKDF
   */


  function extract(hash, ikm, salt) {
    assert_1$1(hash && typeof hash.id === 'string');
    if (ikm == null) ikm = Buffer.alloc(0);
    if (salt == null) salt = Buffer.alloc(hash.size, 0x00);
    return hash.mac(ikm, salt);
  }

  function expand$1(hash, prk, info, len) {
    if (info == null) info = Buffer.alloc(0);
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(prk));
    assert_1$1(Buffer.isBuffer(info));
    assert_1$1(len >>> 0 === len);
    if (prk.length !== hash.size) throw new RangeError('Invalid PRK length.');
    var blocks = Math.ceil(len / hash.size);
    if (blocks > 255) throw new RangeError('Invalid output length.');
    var out = Buffer.alloc(blocks * hash.size);
    var ctr = Buffer.from([0]);
    var mac = hash.hmac();
    var prev = Buffer.alloc(0);
    var pos = 0;

    for (var i = 0; i < blocks; i++) {
      ctr[0] += 1;
      mac.init(prk);
      mac.update(prev);
      mac.update(info);
      mac.update(ctr);
      prev = mac.final();
      pos += prev.copy(out, pos);
    }

    return out.slice(0, len);
  }

  function derive$4(hash, ikm, salt, info, len) {
    var prk = extract(hash, ikm, salt);
    return expand$1(hash, prk, info, len);
  }
  /*
   * Expose
   */


  var native_1$e = 0;
  var extract_1 = extract;
  var expand_1 = expand$1;
  var derive_1$4 = derive$4;
  var hkdf = {
    native: native_1$e,
    extract: extract_1,
    expand: expand_1,
    derive: derive_1$4
  };

  var hkdfBrowser = hkdf;

  function _createSuper$u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$u(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Keccak224
   */


  var Keccak224 = /*#__PURE__*/function (_Keccak) {
    _inherits__default['default'](Keccak224, _Keccak);

    var _super = _createSuper$u(Keccak224);

    function Keccak224() {
      _classCallCheck__default['default'](this, Keccak224);

      return _super.call(this);
    }

    _createClass__default['default'](Keccak224, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak224.prototype), "init", this).call(this, 224);
      }
    }, {
      key: "final",
      value: function final() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak224.prototype), "final", this).call(this, 0x01, null);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new Keccak224();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak224), "hmac", this).call(this, 224, 0x01, null);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak224), "digest", this).call(this, data, 224, 0x01, null);
      }
    }, {
      key: "root",
      value: function root(left, right) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak224), "root", this).call(this, left, right, 224, 0x01, null);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak224), "multi", this).call(this, x, y, z, 224, 0x01, null);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak224), "mac", this).call(this, data, key, 224, 0x01, null);
      }
    }]);

    return Keccak224;
  }(keccakBrowser);

  Keccak224.native = keccakBrowser.native;
  Keccak224.id = 'KECCAK224';
  Keccak224.size = 28;
  Keccak224.bits = 224;
  Keccak224.blockSize = 144;
  Keccak224.zero = Buffer.alloc(28, 0x00);
  Keccak224.ctx = new Keccak224();
  /*
   * Expose
   */

  var keccak224 = Keccak224;

  function _createSuper$v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$v(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Keccak256
   */


  var Keccak256 = /*#__PURE__*/function (_Keccak) {
    _inherits__default['default'](Keccak256, _Keccak);

    var _super = _createSuper$v(Keccak256);

    function Keccak256() {
      _classCallCheck__default['default'](this, Keccak256);

      return _super.call(this);
    }

    _createClass__default['default'](Keccak256, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak256.prototype), "init", this).call(this, 256);
      }
    }, {
      key: "final",
      value: function final() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak256.prototype), "final", this).call(this, 0x01, null);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new Keccak256();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak256), "hmac", this).call(this, 256, 0x01, null);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak256), "digest", this).call(this, data, 256, 0x01, null);
      }
    }, {
      key: "root",
      value: function root(left, right) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak256), "root", this).call(this, left, right, 256, 0x01, null);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak256), "multi", this).call(this, x, y, z, 256, 0x01, null);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak256), "mac", this).call(this, data, key, 256, 0x01, null);
      }
    }]);

    return Keccak256;
  }(keccakBrowser);

  Keccak256.native = keccakBrowser.native;
  Keccak256.id = 'KECCAK256';
  Keccak256.size = 32;
  Keccak256.bits = 256;
  Keccak256.blockSize = 136;
  Keccak256.zero = Buffer.alloc(32, 0x00);
  Keccak256.ctx = new Keccak256();
  /*
   * Expose
   */

  var keccak256 = Keccak256;

  function _createSuper$w(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$w(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$w() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Keccak384
   */


  var Keccak384 = /*#__PURE__*/function (_Keccak) {
    _inherits__default['default'](Keccak384, _Keccak);

    var _super = _createSuper$w(Keccak384);

    function Keccak384() {
      _classCallCheck__default['default'](this, Keccak384);

      return _super.call(this);
    }

    _createClass__default['default'](Keccak384, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak384.prototype), "init", this).call(this, 384);
      }
    }, {
      key: "final",
      value: function final() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak384.prototype), "final", this).call(this, 0x01, null);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new Keccak384();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak384), "hmac", this).call(this, 384, 0x01, null);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak384), "digest", this).call(this, data, 384, 0x01, null);
      }
    }, {
      key: "root",
      value: function root(left, right) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak384), "root", this).call(this, left, right, 384, 0x01, null);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak384), "multi", this).call(this, x, y, z, 384, 0x01, null);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak384), "mac", this).call(this, data, key, 384, 0x01, null);
      }
    }]);

    return Keccak384;
  }(keccakBrowser);

  Keccak384.native = keccakBrowser.native;
  Keccak384.id = 'KECCAK384';
  Keccak384.size = 48;
  Keccak384.bits = 384;
  Keccak384.blockSize = 104;
  Keccak384.zero = Buffer.alloc(48, 0x00);
  Keccak384.ctx = new Keccak384();
  /*
   * Expose
   */

  var keccak384 = Keccak384;

  function _createSuper$x(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$x(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$x() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * Keccak512
   */


  var Keccak512 = /*#__PURE__*/function (_Keccak) {
    _inherits__default['default'](Keccak512, _Keccak);

    var _super = _createSuper$x(Keccak512);

    function Keccak512() {
      _classCallCheck__default['default'](this, Keccak512);

      return _super.call(this);
    }

    _createClass__default['default'](Keccak512, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak512.prototype), "init", this).call(this, 512);
      }
    }, {
      key: "final",
      value: function final() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak512.prototype), "final", this).call(this, 0x01, null);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new Keccak512();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak512), "hmac", this).call(this, 512, 0x01, null);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak512), "digest", this).call(this, data, 512, 0x01, null);
      }
    }, {
      key: "root",
      value: function root(left, right) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak512), "root", this).call(this, left, right, 512, 0x01, null);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak512), "multi", this).call(this, x, y, z, 512, 0x01, null);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](Keccak512), "mac", this).call(this, data, key, 512, 0x01, null);
      }
    }]);

    return Keccak512;
  }(keccakBrowser);

  Keccak512.native = keccakBrowser.native;
  Keccak512.id = 'KECCAK512';
  Keccak512.size = 32;
  Keccak512.bits = 512;
  Keccak512.blockSize = 72;
  Keccak512.zero = Buffer.alloc(32, 0x00);
  Keccak512.ctx = new Keccak512();
  /*
   * Expose
   */

  var keccak512 = Keccak512;

  function _createSuper$y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$y(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /*
   * Constants
   */


  var PREFIX = Buffer.from('KMAC', 'binary');
  var EMPTY$6 = Buffer.alloc(0);
  /*
   * KMAC
   */

  var KMAC = /*#__PURE__*/function (_CSHAKE) {
    _inherits__default['default'](KMAC, _CSHAKE);

    var _super = _createSuper$y(KMAC);

    function KMAC() {
      _classCallCheck__default['default'](this, KMAC);

      return _super.call(this);
    }

    _createClass__default['default'](KMAC, [{
      key: "init",
      value: function init(bits, key, pers) {
        if (key == null) key = EMPTY$6;
        assert_1$1(Buffer.isBuffer(key));

        _get__default['default'](_getPrototypeOf__default['default'](KMAC.prototype), "init", this).call(this, bits, PREFIX, pers);

        _get__default['default'](_getPrototypeOf__default['default'](KMAC.prototype), "bytePad", this).call(this, [key], this.rate / 8);

        return this;
      }
    }, {
      key: "final",
      value: function final(len) {
        if (len == null) {
          var size = this.rate / 8;
          len = 100 - size / 2;
        }

        _get__default['default'](_getPrototypeOf__default['default'](KMAC.prototype), "rightEncode", this).call(this, len * 8);

        return _get__default['default'](_getPrototypeOf__default['default'](KMAC.prototype), "final", this).call(this, len);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new KMAC();
      }
    }, {
      key: "hmac",
      value: function hmac$1(bits, key, pers, len) {
        if (bits == null) bits = 256;
        assert_1$1(bits >>> 0 === bits);
        assert_1$1(bits === 128 || bits === 256);
        var rate = 1600 - bits * 2;
        return new hmac(KMAC, rate / 8, [bits, key, pers], [len]);
      }
    }, {
      key: "digest",
      value: function digest(data, bits, key, pers, len) {
        return KMAC.ctx.init(bits, key, pers).update(data).final(len);
      }
    }, {
      key: "root",
      value: function root(left, right, bits, key, pers, len) {
        if (bits == null) bits = 256;
        if (len == null) len = 0;

        if (len === 0) {
          assert_1$1(bits >>> 0 === bits);
          len = bits >>> 3;
        }

        assert_1$1(len >>> 0 === len);
        assert_1$1(Buffer.isBuffer(left) && left.length === len);
        assert_1$1(Buffer.isBuffer(right) && right.length === len);
        var ctx = KMAC.ctx;
        ctx.init(bits, key, pers);
        ctx.update(left);
        ctx.update(right);
        return ctx.final(len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, bits, key, pers, len) {
        var ctx = KMAC.ctx;
        ctx.init(bits, key, pers);
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final(len);
      }
    }, {
      key: "mac",
      value: function mac(data, salt, bits, key, pers, len) {
        return KMAC.hmac(bits, key, pers, len).init(salt).update(data).final();
      }
    }]);

    return KMAC;
  }(cshake);
  /*
   * Static
   */


  KMAC.native = cshake.native;
  KMAC.id = 'KMAC256';
  KMAC.size = 32;
  KMAC.bits = 256;
  KMAC.blockSize = 136;
  KMAC.zero = Buffer.alloc(32, 0x00);
  KMAC.ctx = new KMAC();
  /*
   * Expose
   */

  var kmac = KMAC;

  function _createSuper$z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$z(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * KMAC128
   */


  var KMAC128 = /*#__PURE__*/function (_KMAC) {
    _inherits__default['default'](KMAC128, _KMAC);

    var _super = _createSuper$z(KMAC128);

    function KMAC128() {
      _classCallCheck__default['default'](this, KMAC128);

      return _super.call(this);
    }

    _createClass__default['default'](KMAC128, [{
      key: "init",
      value: function init(key, pers) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC128.prototype), "init", this).call(this, 128, key, pers);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new KMAC128();
      }
    }, {
      key: "hmac",
      value: function hmac(key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC128), "hmac", this).call(this, 128, key, pers, len);
      }
    }, {
      key: "digest",
      value: function digest(data, key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC128), "digest", this).call(this, data, 128, key, pers, len);
      }
    }, {
      key: "root",
      value: function root(left, right, key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC128), "root", this).call(this, left, right, 128, key, pers, len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC128), "multi", this).call(this, x, y, z, 128, key, pers, len);
      }
    }, {
      key: "mac",
      value: function mac(data, salt, key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC128), "mac", this).call(this, data, salt, 128, key, pers, len);
      }
    }]);

    return KMAC128;
  }(kmac);

  KMAC128.native = kmac.native;
  KMAC128.id = 'KMAC128';
  KMAC128.size = 16;
  KMAC128.bits = 128;
  KMAC128.blockSize = 168;
  KMAC128.zero = Buffer.alloc(16, 0x00);
  KMAC128.ctx = new KMAC128();
  /*
   * Expose
   */

  var kmac128 = KMAC128;

  function _createSuper$A(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$A(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$A() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * KMAC256
   */


  var KMAC256 = /*#__PURE__*/function (_KMAC) {
    _inherits__default['default'](KMAC256, _KMAC);

    var _super = _createSuper$A(KMAC256);

    function KMAC256() {
      _classCallCheck__default['default'](this, KMAC256);

      return _super.call(this);
    }

    _createClass__default['default'](KMAC256, [{
      key: "init",
      value: function init(key, pers) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC256.prototype), "init", this).call(this, 256, key, pers);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new KMAC256();
      }
    }, {
      key: "hmac",
      value: function hmac(key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC256), "hmac", this).call(this, 256, key, pers, len);
      }
    }, {
      key: "digest",
      value: function digest(data, key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC256), "digest", this).call(this, data, 256, key, pers, len);
      }
    }, {
      key: "root",
      value: function root(left, right, key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC256), "root", this).call(this, left, right, 256, key, pers, len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC256), "multi", this).call(this, x, y, z, 256, key, pers, len);
      }
    }, {
      key: "mac",
      value: function mac(data, salt, key, pers, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](KMAC256), "mac", this).call(this, data, salt, 256, key, pers, len);
      }
    }]);

    return KMAC256;
  }(kmac);

  KMAC256.native = kmac.native;
  KMAC256.id = 'KMAC256';
  KMAC256.size = 32;
  KMAC256.bits = 256;
  KMAC256.blockSize = 136;
  KMAC256.zero = Buffer.alloc(32, 0x00);
  KMAC256.ctx = new KMAC256();
  /*
   * Expose
   */

  var kmac256 = KMAC256;

  /*
   * Constants
   */


  var FINALIZED$9 = -1;
  var S$3 = new Uint8Array([0x29, 0x2e, 0x43, 0xc9, 0xa2, 0xd8, 0x7c, 0x01, 0x3d, 0x36, 0x54, 0xa1, 0xec, 0xf0, 0x06, 0x13, 0x62, 0xa7, 0x05, 0xf3, 0xc0, 0xc7, 0x73, 0x8c, 0x98, 0x93, 0x2b, 0xd9, 0xbc, 0x4c, 0x82, 0xca, 0x1e, 0x9b, 0x57, 0x3c, 0xfd, 0xd4, 0xe0, 0x16, 0x67, 0x42, 0x6f, 0x18, 0x8a, 0x17, 0xe5, 0x12, 0xbe, 0x4e, 0xc4, 0xd6, 0xda, 0x9e, 0xde, 0x49, 0xa0, 0xfb, 0xf5, 0x8e, 0xbb, 0x2f, 0xee, 0x7a, 0xa9, 0x68, 0x79, 0x91, 0x15, 0xb2, 0x07, 0x3f, 0x94, 0xc2, 0x10, 0x89, 0x0b, 0x22, 0x5f, 0x21, 0x80, 0x7f, 0x5d, 0x9a, 0x5a, 0x90, 0x32, 0x27, 0x35, 0x3e, 0xcc, 0xe7, 0xbf, 0xf7, 0x97, 0x03, 0xff, 0x19, 0x30, 0xb3, 0x48, 0xa5, 0xb5, 0xd1, 0xd7, 0x5e, 0x92, 0x2a, 0xac, 0x56, 0xaa, 0xc6, 0x4f, 0xb8, 0x38, 0xd2, 0x96, 0xa4, 0x7d, 0xb6, 0x76, 0xfc, 0x6b, 0xe2, 0x9c, 0x74, 0x04, 0xf1, 0x45, 0x9d, 0x70, 0x59, 0x64, 0x71, 0x87, 0x20, 0x86, 0x5b, 0xcf, 0x65, 0xe6, 0x2d, 0xa8, 0x02, 0x1b, 0x60, 0x25, 0xad, 0xae, 0xb0, 0xb9, 0xf6, 0x1c, 0x46, 0x61, 0x69, 0x34, 0x40, 0x7e, 0x0f, 0x55, 0x47, 0xa3, 0x23, 0xdd, 0x51, 0xaf, 0x3a, 0xc3, 0x5c, 0xf9, 0xce, 0xba, 0xc5, 0xea, 0x26, 0x2c, 0x53, 0x0d, 0x6e, 0x85, 0x28, 0x84, 0x09, 0xd3, 0xdf, 0xcd, 0xf4, 0x41, 0x81, 0x4d, 0x52, 0x6a, 0xdc, 0x37, 0xc8, 0x6c, 0xc1, 0xab, 0xfa, 0x24, 0xe1, 0x7b, 0x08, 0x0c, 0xbd, 0xb1, 0x4a, 0x78, 0x88, 0x95, 0x8b, 0xe3, 0x63, 0xe8, 0x6d, 0xe9, 0xcb, 0xd5, 0xfe, 0x3b, 0x00, 0x1d, 0x39, 0xf2, 0xef, 0xb7, 0x0e, 0x66, 0x58, 0xd0, 0xe4, 0xa6, 0x77, 0x72, 0xf8, 0xeb, 0x75, 0x4b, 0x0a, 0x31, 0x44, 0x50, 0xb4, 0x8f, 0xed, 0x1f, 0x1a, 0xdb, 0x99, 0x8d, 0x33, 0x9f, 0x11, 0x83, 0x14]);
  /**
   * MD2
   */

  var MD2 = /*#__PURE__*/function () {
    function MD2() {
      _classCallCheck__default['default'](this, MD2);

      this.state = Buffer.alloc(48);
      this.checksum = Buffer.alloc(16);
      this.block = Buffer.alloc(16);
      this.size = FINALIZED$9;
    }

    _createClass__default['default'](MD2, [{
      key: "init",
      value: function init() {
        this.state.fill(0);
        this.checksum.fill(0);
        this.size = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._update(data, data.length);

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return this._final(Buffer.alloc(16));
      }
    }, {
      key: "_update",
      value: function _update(data, len) {
        assert_1$1(this.size !== FINALIZED$9, 'Context is not initialized.');
        var pos = this.size & 15;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 16 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 16) return;

          this._transform(this.block, 0);
        }

        while (len >= 16) {
          this._transform(data, off);

          off += 16;
          len -= 16;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
    }, {
      key: "_final",
      value: function _final(out) {
        assert_1$1(this.size !== FINALIZED$9, 'Context is not initialized.');
        var pos = this.size & 15;
        var left = 16 - pos;
        var pad = Buffer.alloc(left);

        for (var i = 0; i < pad.length; i++) {
          pad[i] = left;
        }

        this._update(pad, left);

        this._update(this.checksum, 16);

        this.state.copy(out, 0, 0, 16);
        this.state.fill(0);
        this.checksum.fill(0);
        this.block.fill(0);
        this.size = FINALIZED$9;
        return out;
      }
    }, {
      key: "_transform",
      value: function _transform(chunk, pos) {
        for (var j = 0; j < 16; j++) {
          this.state[16 + j] = chunk[pos + j];
          this.state[32 + j] = this.state[16 + j] ^ this.state[j];
        }

        var t = 0;

        for (var _j = 0; _j < 18; _j++) {
          for (var k = 0; k < 48; k++) {
            this.state[k] ^= S$3[t];
            t = this.state[k];
          }

          t = t + _j & 0xff;
        }

        var l = this.checksum[15];

        for (var _j2 = 0; _j2 < 16; _j2++) {
          this.checksum[_j2] ^= S$3[chunk[pos + _j2] ^ l];
          l = this.checksum[_j2];
        }
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new MD2();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(MD2, 16);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return MD2.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 16);
        assert_1$1(Buffer.isBuffer(right) && right.length === 16);
        return MD2.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = MD2.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return MD2.hmac().init(key).update(data).final();
      }
    }]);

    return MD2;
  }();
  /*
   * Static
   */


  MD2.native = 0;
  MD2.id = 'MD2';
  MD2.size = 16;
  MD2.bits = 128;
  MD2.blockSize = 16;
  MD2.zero = Buffer.alloc(16, 0x00);
  MD2.ctx = new MD2();
  /*
   * Expose
   */

  var md2 = MD2;

  var md2Browser = md2;

  /*
   * Constants
   */


  var FINALIZED$a = -1;
  var DESC$5 = Buffer.alloc(8, 0x00);
  var PADDING$7 = Buffer.alloc(64, 0x00);
  PADDING$7[0] = 0x80;
  var K$4 = new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
  /**
   * MD4
   */

  var MD4 = /*#__PURE__*/function () {
    function MD4() {
      _classCallCheck__default['default'](this, MD4);

      this.state = new Uint32Array(4);
      this.msg = new Uint32Array(16);
      this.block = Buffer.alloc(64);
      this.size = FINALIZED$a;
    }

    _createClass__default['default'](MD4, [{
      key: "init",
      value: function init() {
        this.state[0] = K$4[0];
        this.state[1] = K$4[1];
        this.state[2] = K$4[2];
        this.state[3] = K$4[3];
        this.size = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._update(data, data.length);

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return this._final(Buffer.alloc(16));
      }
    }, {
      key: "_update",
      value: function _update(data, len) {
        assert_1$1(this.size !== FINALIZED$a, 'Context is not initialized.');
        var pos = this.size & 63;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 64 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 64) return;

          this._transform(this.block, 0);
        }

        while (len >= 64) {
          this._transform(data, off);

          off += 64;
          len -= 64;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
      /**
       * Finalize MD4 context.
       * @private
       * @param {Buffer} out
       * @returns {Buffer}
       */

    }, {
      key: "_final",
      value: function _final(out) {
        assert_1$1(this.size !== FINALIZED$a, 'Context is not initialized.');
        var pos = this.size & 63;
        var len = this.size * 8;
        writeU32$j(DESC$5, len >>> 0, 0);
        writeU32$j(DESC$5, len * (1 / 0x100000000) >>> 0, 4);

        this._update(PADDING$7, 1 + (119 - pos & 63));

        this._update(DESC$5, 8);

        for (var i = 0; i < 4; i++) {
          writeU32$j(out, this.state[i], i * 4);
          this.state[i] = 0;
        }

        for (var _i = 0; _i < 16; _i++) {
          this.msg[_i] = 0;
        }

        for (var _i2 = 0; _i2 < 64; _i2++) {
          this.block[_i2] = 0;
        }

        this.size = FINALIZED$a;
        return out;
      }
    }, {
      key: "_transform",
      value: function _transform(chunk, pos) {
        var W = this.msg;
        var a = this.state[0];
        var b = this.state[1];
        var c = this.state[2];
        var d = this.state[3];

        for (var i = 0; i < 16; i++) {
          W[i] = readU32$k(chunk, pos + i * 4);
        } // round 1


        for (var _i3 = 0, _arr = [0, 4, 8, 12]; _i3 < _arr.length; _i3++) {
          var _i4 = _arr[_i3];
          a = op1(a, b, c, d, W[_i4], 3);
          d = op1(d, a, b, c, W[_i4 + 1], 7);
          c = op1(c, d, a, b, W[_i4 + 2], 11);
          b = op1(b, c, d, a, W[_i4 + 3], 19);
        } // round 2


        for (var _i5 = 0; _i5 < 4; _i5++) {
          a = op2(a, b, c, d, W[_i5], 3);
          d = op2(d, a, b, c, W[_i5 + 4], 5);
          c = op2(c, d, a, b, W[_i5 + 8], 9);
          b = op2(b, c, d, a, W[_i5 + 12], 13);
        } // round 3


        for (var _i6 = 0, _arr2 = [0, 2, 1, 3]; _i6 < _arr2.length; _i6++) {
          var _i7 = _arr2[_i6];
          a = op3(a, b, c, d, W[_i7], 3);
          d = op3(d, a, b, c, W[_i7 + 8], 9);
          c = op3(c, d, a, b, W[_i7 + 4], 11);
          b = op3(b, c, d, a, W[_i7 + 12], 15);
        }

        this.state[0] += a;
        this.state[1] += b;
        this.state[2] += c;
        this.state[3] += d;
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new MD4();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(MD4, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return MD4.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 16);
        assert_1$1(Buffer.isBuffer(right) && right.length === 16);
        return MD4.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = MD4.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return MD4.hmac().init(key).update(data).final();
      }
    }]);

    return MD4;
  }();
  /*
   * Static
   */


  MD4.native = 0;
  MD4.id = 'MD4';
  MD4.size = 16;
  MD4.bits = 128;
  MD4.blockSize = 64;
  MD4.zero = Buffer.alloc(16, 0x00);
  MD4.ctx = new MD4();
  /*
   * Helpers
   */

  function f$1(x, y, z) {
    return x & y | ~x & z;
  }

  function g(x, y, z) {
    return x & y | x & z | y & z;
  }

  function h$1(x, y, z) {
    return x ^ y ^ z;
  }

  function op1(a, b, c, d, k, s) {
    return rotl32$5(a + f$1(b, c, d) + k, s);
  }

  function op2(a, b, c, d, k, s) {
    return rotl32$5(a + g(b, c, d) + k + 0x5a827999, s);
  }

  function op3(a, b, c, d, k, s) {
    return rotl32$5(a + h$1(b, c, d) + k + 0x6ed9eba1, s);
  }

  function rotl32$5(w, b) {
    return w << b | w >>> 32 - b;
  }

  function readU32$k(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }

  function writeU32$j(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var md4 = MD4;

  var md4Browser = md4;

  /*
   * Constants
   */


  var FINALIZED$b = -1;
  var DESC$6 = Buffer.alloc(8, 0x00);
  var PADDING$8 = Buffer.alloc(64, 0x00);
  PADDING$8[0] = 0x80;
  var K$5 = new Uint32Array([0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6]);
  /**
   * SHA1
   */

  var SHA1 = /*#__PURE__*/function () {
    function SHA1() {
      _classCallCheck__default['default'](this, SHA1);

      this.state = new Uint32Array(5);
      this.msg = new Uint32Array(80);
      this.block = Buffer.alloc(64);
      this.size = FINALIZED$b;
    }

    _createClass__default['default'](SHA1, [{
      key: "init",
      value: function init() {
        this.state[0] = 0x67452301;
        this.state[1] = 0xefcdab89;
        this.state[2] = 0x98badcfe;
        this.state[3] = 0x10325476;
        this.state[4] = 0xc3d2e1f0;
        this.size = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._update(data, data.length);

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return this._final(Buffer.alloc(20));
      }
    }, {
      key: "_update",
      value: function _update(data, len) {
        assert_1$1(this.size !== FINALIZED$b, 'Context is not initialized.');
        var pos = this.size & 63;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 64 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 64) return;

          this._transform(this.block, 0);
        }

        while (len >= 64) {
          this._transform(data, off);

          off += 64;
          len -= 64;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
    }, {
      key: "_final",
      value: function _final(out) {
        assert_1$1(this.size !== FINALIZED$b, 'Context is not initialized.');
        var pos = this.size & 63;
        var len = this.size * 8;
        writeU32$k(DESC$6, len * (1 / 0x100000000) >>> 0, 0);
        writeU32$k(DESC$6, len >>> 0, 4);

        this._update(PADDING$8, 1 + (119 - pos & 63));

        this._update(DESC$6, 8);

        for (var i = 0; i < 5; i++) {
          writeU32$k(out, this.state[i], i * 4);
          this.state[i] = 0;
        }

        for (var _i = 0; _i < 80; _i++) {
          this.msg[_i] = 0;
        }

        for (var _i2 = 0; _i2 < 64; _i2++) {
          this.block[_i2] = 0;
        }

        this.size = FINALIZED$b;
        return out;
      }
    }, {
      key: "_transform",
      value: function _transform(chunk, pos) {
        var W = this.msg;
        var a = this.state[0];
        var b = this.state[1];
        var c = this.state[2];
        var d = this.state[3];
        var e = this.state[4];
        var i = 0;

        for (; i < 16; i++) {
          W[i] = readU32$l(chunk, pos + i * 4);
        }

        for (; i < 80; i++) {
          W[i] = rotl32$6(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        }

        for (i = 0; i < 80; i++) {
          var s = i / 20 | 0;
          var t = rotl32$6(a, 5) + ft_1(s, b, c, d) + e + W[i] + K$5[s];
          e = d;
          d = c;
          c = rotl32$6(b, 30);
          b = a;
          a = t >>> 0;
        }

        this.state[0] += a;
        this.state[1] += b;
        this.state[2] += c;
        this.state[3] += d;
        this.state[4] += e;
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA1();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(SHA1, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return SHA1.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 20);
        assert_1$1(Buffer.isBuffer(right) && right.length === 20);
        return SHA1.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = SHA1.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return SHA1.hmac().init(key).update(data).final();
      }
    }]);

    return SHA1;
  }();
  /*
   * Static
   */


  SHA1.native = 0;
  SHA1.id = 'SHA1';
  SHA1.size = 20;
  SHA1.bits = 160;
  SHA1.blockSize = 64;
  SHA1.zero = Buffer.alloc(20, 0x00);
  SHA1.ctx = new SHA1();
  /*
   * Helpers
   */

  function rotl32$6(w, b) {
    return w << b | w >>> 32 - b;
  }

  function ft_1(s, x, y, z) {
    if (s === 0) return ch32(x, y, z);
    if (s === 1 || s === 3) return p32(x, y, z);
    if (s === 2) return maj32(x, y, z);
    return 0;
  }

  function ch32(x, y, z) {
    return x & y ^ ~x & z;
  }

  function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }

  function p32(x, y, z) {
    return x ^ y ^ z;
  }

  function readU32$l(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function writeU32$k(data, num, off) {
    data[off++] = num >>> 24;
    data[off++] = num >>> 16;
    data[off++] = num >>> 8;
    data[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var sha1 = SHA1;

  /**
   * MD5SHA1
   */


  var MD5SHA1 = /*#__PURE__*/function () {
    function MD5SHA1() {
      _classCallCheck__default['default'](this, MD5SHA1);

      this.md5 = new md5();
      this.sha1 = new sha1();
    }

    _createClass__default['default'](MD5SHA1, [{
      key: "init",
      value: function init() {
        this.md5.init();
        this.sha1.init();
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        this.md5.update(data);
        this.sha1.update(data);
        return this;
      }
    }, {
      key: "final",
      value: function final() {
        var md = Buffer.alloc(36);
        this.md5.final().copy(md, 0);
        this.sha1.final().copy(md, 16);
        return md;
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new MD5SHA1();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(MD5SHA1, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return MD5SHA1.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 36);
        assert_1$1(Buffer.isBuffer(right) && right.length === 36);
        return MD5SHA1.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = MD5SHA1.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return MD5SHA1.hmac().init(key).update(data).final();
      }
    }]);

    return MD5SHA1;
  }();
  /*
   * Static
   */


  MD5SHA1.native = 0;
  MD5SHA1.id = 'MD5SHA1';
  MD5SHA1.size = 36;
  MD5SHA1.bits = 288;
  MD5SHA1.blockSize = 64;
  MD5SHA1.zero = Buffer.alloc(36, 0x00);
  MD5SHA1.ctx = new MD5SHA1();
  /*
   * Expose
   */

  var md5sha1 = MD5SHA1;

  var md5sha1Browser = md5sha1;

  function _createForOfIteratorHelper$b(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$b(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$b(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$b(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen); }

  function _arrayLikeToArray$b(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  //
  // Bitcoin hashes odd nodes with themselves,
  // allowing an attacker to add a duplicate
  // TXID, creating an even number of leaves
  // and computing the same root (CVE-2012-2459).
  // In contrast, RFC 6962 simply propagates
  // odd nodes up.
  //
  // RFC 6962:
  //
  //              R
  //             / \
  //            /   \
  //           /     \
  //          /       \
  //         /         \
  //        k           j <-- same as below
  //       / \          |
  //      /   \         |
  //     /     \        |
  //    h       i       j
  //   / \     / \     / \
  //  a   b   c   d   e   f
  //
  // Bitcoin Behavior:
  //
  //              R
  //             / \
  //            /   \
  //           /     \
  //          /       \
  //         /         \
  //        k           l <-- HASH(j || j)
  //       / \          |
  //      /   \         |
  //     /     \        |
  //    h       i       j
  //   / \     / \     / \
  //  a   b   c   d   e   f
  //
  // This creates a situation where these leaves:
  //
  //        R
  //       / \
  //      /   \
  //     /     \
  //    d       e <-- HASH(c || c)
  //   / \     / \
  //  a   b   c   c
  //
  // Compute the same root as:
  //
  //       R
  //      / \
  //     /   \
  //    d     e <-- HASH(c || c)
  //   / \    |
  //  a   b   c
  //
  // Why does this matter? Duplicate TXIDs are
  // invalid right? They're spending the same
  // inputs! The problem arises in certain
  // implementation optimizations which may
  // mark a block hash invalid. In other words,
  // an invalid block shares the same block
  // hash as a valid one!
  //
  // See:
  //   https://tools.ietf.org/html/rfc6962#section-2.1
  //   https://nvd.nist.gov/vuln/detail/CVE-2012-2459
  //   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459
  //   https://bitcointalk.org/?topic=81749

  /**
   * Build a merkle tree from leaves.
   * @param {Object} alg
   * @param {Buffer[]} leaves
   * @returns {Array} [nodes, malleated]
   */


  function createTree(alg, leaves) {
    assert_1$1(alg && typeof alg.root === 'function');
    assert_1$1(Array.isArray(leaves));
    var nodes = new Array(leaves.length);

    for (var _i = 0; _i < leaves.length; _i++) {
      nodes[_i] = leaves[_i];
    }

    var size = nodes.length;
    var malleated = false;
    var i = 0;

    if (size === 0) {
      nodes.push(alg.zero);
      return [nodes, malleated];
    }

    while (size > 1) {
      for (var j = 0; j < size; j += 2) {
        var k = Math.min(j + 1, size - 1);
        var left = nodes[i + j];
        var right = nodes[i + k];

        if (k === j + 1 && k + 1 === size && left.equals(right)) {
          malleated = true;
        }

        var hash = alg.root(left, right);
        nodes.push(hash);
      }

      i += size;
      size = size + 1 >>> 1;
    }

    return [nodes, malleated];
  }
  /**
   * Calculate merkle root from leaves.
   * @param {Object} alg
   * @param {Buffer[]} leaves
   * @returns {Array} [root, malleated]
   */


  function createRoot(alg, leaves) {
    assert_1$1(alg && typeof alg.root === 'function');
    assert_1$1(Array.isArray(leaves));

    var _createTree = createTree(alg, leaves),
        _createTree2 = _slicedToArray__default['default'](_createTree, 2),
        nodes = _createTree2[0],
        malleated = _createTree2[1];

    var root = nodes[nodes.length - 1];
    return [root, malleated];
  }
  /**
   * Collect a merkle branch from vector index.
   * @param {Object} alg
   * @param {Number} index
   * @param {Buffer[]} leaves
   * @returns {Buffer[]} branch
   */


  function createBranch(alg, index, leaves) {
    assert_1$1(alg && typeof alg.root === 'function');
    assert_1$1(index >>> 0 === index);
    assert_1$1(Array.isArray(leaves));
    assert_1$1(index < leaves.length);
    var size = leaves.length;

    var _createTree3 = createTree(alg, leaves),
        _createTree4 = _slicedToArray__default['default'](_createTree3, 1),
        nodes = _createTree4[0];

    var branch = [];
    var i = 0;

    while (size > 1) {
      var j = Math.min(index ^ 1, size - 1);
      branch.push(nodes[i + j]);
      index >>>= 1;
      i += size;
      size = size + 1 >>> 1;
    }

    return branch;
  }
  /**
   * Derive merkle root from branch.
   * @param {Object} alg
   * @param {Buffer} hash
   * @param {Buffer[]} branch
   * @param {Number} index
   * @returns {Buffer} root
   */


  function deriveRoot(alg, hash, branch, index) {
    assert_1$1(alg && typeof alg.root === 'function');
    assert_1$1(Buffer.isBuffer(hash));
    assert_1$1(Array.isArray(branch));
    assert_1$1(index >>> 0 === index);
    var root = hash;

    var _iterator = _createForOfIteratorHelper$b(branch),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _hash = _step.value;
        if (index & 1 && _hash.equals(root)) return alg.zero;
        if (index & 1) root = alg.root(_hash, root);else root = alg.root(root, _hash);
        index >>>= 1;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return root;
  }
  /*
   * Expose
   */


  var createTree_1 = createTree;
  var createRoot_1 = createRoot;
  var createBranch_1 = createBranch;
  var deriveRoot_1 = deriveRoot;
  var merkle = {
    createTree: createTree_1,
    createRoot: createRoot_1,
    createBranch: createBranch_1,
    deriveRoot: deriveRoot_1
  };

  function _createForOfIteratorHelper$c(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$c(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$c(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$c(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(o, minLen); }

  function _arrayLikeToArray$c(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /*
   * Constants
   */


  var EMPTY$7 = Buffer.alloc(0);
  var INTERNAL = Buffer.from([0x01]);
  var LEAF = Buffer.from([0x00]);
  /**
   * Build a merkle tree from leaves.
   * @param {Object} alg
   * @param {Buffer[]} leaves
   * @returns {Buffer[]} nodes
   */

  function createTree$1(alg, leaves) {
    assert_1$1(alg && typeof alg.multi === 'function');
    assert_1$1(Array.isArray(leaves));
    var nodes = [];
    var sentinel = hashEmpty(alg);

    var _iterator = _createForOfIteratorHelper$c(leaves),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var data = _step.value;
        var leaf = hashLeaf(alg, data);
        nodes.push(leaf);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var size = nodes.length;
    var i = 0;

    if (size === 0) {
      nodes.push(sentinel);
      return nodes;
    }

    while (size > 1) {
      for (var j = 0; j < size; j += 2) {
        var l = j;
        var r = j + 1;
        var left = nodes[i + l];
        var right = void 0;
        if (r < size) right = nodes[i + r];else right = sentinel;
        var hash = hashInternal(alg, left, right);
        nodes.push(hash);
      }

      i += size;
      size = size + 1 >>> 1;
    }

    return nodes;
  }
  /**
   * Calculate merkle root from leaves.
   * @param {Object} alg
   * @param {Buffer[]} leaves
   * @returns {Buffer} root
   */


  function createRoot$1(alg, leaves) {
    var nodes = createTree$1(alg, leaves);
    var root = nodes[nodes.length - 1];
    return root;
  }
  /**
   * Collect a merkle branch from vector index.
   * @param {Object} alg
   * @param {Number} index
   * @param {Buffer[]} leaves
   * @returns {Buffer[]} branch
   */


  function createBranch$1(alg, index, leaves) {
    assert_1$1(index >>> 0 === index);
    var nodes = createTree$1(alg, leaves);
    var sentinel = hashEmpty(alg);
    var branch = [];
    var size = leaves.length;
    var i = 0;
    assert_1$1(index < leaves.length);

    while (size > 1) {
      var j = index ^ 1;
      if (j < size) branch.push(nodes[i + j]);else branch.push(sentinel);
      index >>>= 1;
      i += size;
      size = size + 1 >>> 1;
    }

    return branch;
  }
  /**
   * Derive merkle root from branch.
   * @param {Object} alg
   * @param {Buffer} leaf
   * @param {Buffer[]} branch
   * @param {Number} index
   * @returns {Buffer} root
   */


  function deriveRoot$1(alg, leaf, branch, index) {
    assert_1$1(alg && typeof alg.multi === 'function');
    assert_1$1(Buffer.isBuffer(leaf));
    assert_1$1(Array.isArray(branch));
    assert_1$1(index >>> 0 === index);
    var root = hashLeaf(alg, leaf);

    var _iterator2 = _createForOfIteratorHelper$c(branch),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var hash = _step2.value;
        if (index & 1) root = hashInternal(alg, hash, root);else root = hashInternal(alg, root, hash);
        index >>>= 1;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return root;
  }
  /**
   * Get sentinel hash.
   * @param {Object} alg
   * @returns {Buffer}
   */


  function hashEmpty(alg) {
    return alg.digest(EMPTY$7);
  }
  /**
   * Hash a leaf node.
   * @param {Object} alg
   * @param {Buffer} data
   * @returns {Buffer}
   */


  function hashLeaf(alg, data) {
    return alg.multi(LEAF, data);
  }
  /**
   * Hash an internal node.
   * @param {Object} alg
   * @param {Buffer} left
   * @param {Buffer} right
   * @returns {Buffer}
   */


  function hashInternal(alg, left, right) {
    assert_1$1(right != null);
    return alg.multi(INTERNAL, left, right);
  }
  /*
   * Expose
   */


  var createTree_1$1 = createTree$1;
  var createRoot_1$1 = createRoot$1;
  var createBranch_1$1 = createBranch$1;
  var deriveRoot_1$1 = deriveRoot$1;
  var hashEmpty_1 = hashEmpty;
  var hashLeaf_1 = hashLeaf;
  var hashInternal_1 = hashInternal;
  var mrkl = {
    createTree: createTree_1$1,
    createRoot: createRoot_1$1,
    createBranch: createBranch_1$1,
    deriveRoot: deriveRoot_1$1,
    hashEmpty: hashEmpty_1,
    hashLeaf: hashLeaf_1,
    hashInternal: hashInternal_1
  };

  /**
   * Murmur3 hash.
   * @param {Buffer} data
   * @param {Number} seed
   * @returns {Number}
   */


  function sum(data, seed) {
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(typeof seed === 'number');
    var tail = data.length - (data.length & 3);
    var c1 = 0xcc9e2d51;
    var c2 = 0x1b873593;
    var h1 = seed | 0;

    for (var i = 0; i < tail; i += 4) {
      var _k = readU32$m(data, i);

      _k = mul32(_k, c1);
      _k = rotl32$7(_k, 15);
      _k = mul32(_k, c2);
      h1 ^= _k;
      h1 = rotl32$7(h1, 13);
      h1 = mul32(h1, 5) + 0xe6546b64 | 0;
    }

    var k1 = 0;

    switch (data.length & 3) {
      case 3:
        k1 ^= data[tail + 2] << 16;

      case 2:
        k1 ^= data[tail + 1] << 8;

      case 1:
        k1 ^= data[tail + 0];
        k1 = mul32(k1, c1);
        k1 = rotl32$7(k1, 15);
        k1 = mul32(k1, c2);
        h1 ^= k1;
    }

    h1 ^= data.length;
    h1 ^= h1 >>> 16;
    h1 = mul32(h1, 0x85ebca6b);
    h1 ^= h1 >>> 13;
    h1 = mul32(h1, 0xc2b2ae35);
    h1 ^= h1 >>> 16;
    return h1 >>> 0;
  }
  /**
   * Murmur3 hash.
   * @param {Buffer} data
   * @param {Number} n
   * @param {Number} tweak
   * @returns {Number}
   */


  function tweak(data, n, tweak) {
    assert_1$1(typeof n === 'number');
    assert_1$1(typeof tweak === 'number');
    var seed = mul32(n, 0xfba4c795) + (tweak | 0);
    return sum(data, seed);
  }
  /*
   * Helpers
   */


  function mul32(a, b) {
    var alo = a & 0xffff;
    var blo = b & 0xffff;
    var ahi = a >>> 16;
    var bhi = b >>> 16;
    var lo = alo * blo;
    var hi = ahi * blo + bhi * alo + (lo >>> 16);
    return hi << 16 | lo & 0xffff;
  }

  function rotl32$7(w, b) {
    return w << b | w >>> 32 - b;
  }

  function readU32$m(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }
  /**
   * Expose
   */


  var native_1$f = 0;
  var sum_1 = sum;
  var tweak_1 = tweak;
  var murmur3 = {
    native: native_1$f,
    sum: sum_1,
    tweak: tweak_1
  };

  var murmur3Browser = murmur3;

  function _createForOfIteratorHelper$d(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$d(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$d(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$d(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(o, minLen); }

  function _arrayLikeToArray$d(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /**
   * Schnorr
   */


  var Schnorr = /*#__PURE__*/function () {
    function Schnorr(curve, hash) {
      _classCallCheck__default['default'](this, Schnorr);

      this.curve = curve;
      this.hash = hash;
      this.rng = new batchRng(this.curve, this.encode.bind(this));
    }

    _createClass__default['default'](Schnorr, [{
      key: "check",
      value: function check() {
        // [SCHNORR] "Footnotes".
        // Must be congruent to 3 mod 4.
        if (this.curve.p.andln(3) !== 3) throw new Error("Schnorr is not supported for ".concat(this.curve.id, "."));
      }
    }, {
      key: "encode",
      value: function encode(key) {
        // Extra speedy key reserialization.
        assert_1$1(Buffer.isBuffer(key));
        var fieldSize = this.curve.fieldSize;
        if (key.length === 1 + fieldSize) return key;
        if (key.length !== 1 + fieldSize * 2) throw new Error('Invalid point.');
        var out = Buffer.alloc(1 + fieldSize);
        out[0] = 0x02 | key[key.length - 1] & 1;
        key.copy(out, 1, 1, 1 + fieldSize);
        return out;
      }
    }, {
      key: "hashInt",
      value: function hashInt() {
        // [SCHNORR] "Specification".
        // eslint-disable-next-line
        var h = new this.hash();
        h.init();

        for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
          items[_key] = arguments[_key];
        }

        for (var _i = 0, _items = items; _i < _items.length; _i++) {
          var item = _items[_i];
          h.update(item);
        }

        var hash = h.final();
        if (hash.length > this.curve.scalarSize) hash = hash.slice(0, this.curve.scalarSize);
        var num = bnBrowser.decode(hash, this.curve.endian);
        return num.imod(this.curve.n);
      }
    }, {
      key: "hashNonce",
      value: function hashNonce(a, m) {
        return this.hashInt(a, m);
      }
    }, {
      key: "hashChallenge",
      value: function hashChallenge(R, A, m) {
        return this.hashInt(R, this.encode(A), m);
      }
    }, {
      key: "sign",
      value: function sign(msg, key) {
        assert_1$1(Buffer.isBuffer(msg));
        this.check();
        return this._sign(msg, key);
      }
    }, {
      key: "_sign",
      value: function _sign(msg, key) {
        // Schnorr Signing.
        //
        // [SCHNORR] "Signing".
        // [CASH] "Recommended practices for secure signature generation".
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `m` be a 32-byte array.
        //   - Let `a` be a secret non-zero scalar.
        //   - k != 0.
        //
        // Computation:
        //
        //   A = G * a
        //   k = H(a, m) mod n
        //   R = G * k
        //   k = -k mod n, if y(R) is not square
        //   r = x(R)
        //   e = H(r, A, m) mod n
        //   s = (k + e * a) mod n
        //   S = (r, s)
        //
        // Note that `k` must remain secret,
        // otherwise an attacker can compute:
        //
        //   a = (s - k) / e mod n
        var n = this.curve.n;
        var G = this.curve.g;
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(n) >= 0) throw new Error('Invalid private key.');
        var A = G.mulBlind(a);
        var k = this.hashNonce(key, msg);
        if (k.isZero()) throw new Error('Signing failed (k\' = 0).');
        var R = G.mulBlind(k);
        if (!R.isSquare()) k.ineg().imod(n);
        var Rraw = R.encodeX();
        var Araw = A.encode();
        var e = this.hashChallenge(Rraw, Araw, msg);
        var s = k.add(e.mul(a)).imod(n);
        return Buffer.concat([Rraw, this.curve.encodeScalar(s)]);
      }
    }, {
      key: "verify",
      value: function verify(msg, sig, key) {
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(sig));
        assert_1$1(Buffer.isBuffer(key));
        this.check();
        if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;

        try {
          return this._verify(msg, sig, key);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "_verify",
      value: function _verify(msg, sig, key) {
        // Schnorr Verification.
        //
        // [SCHNORR] "Verification".
        // [CASH] "Signature verification algorithm".
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `m` be a 32-byte array.
        //   - Let `r` and `s` be signature elements.
        //   - Let `A` be a valid group element.
        //   - r^3 + a * r + b is square in F(p).
        //   - r < p, s < n.
        //   - R != O.
        //
        // Computation:
        //
        //   R = (r, sqrt(r^3 + a * r + b))
        //   e = H(r, A, m) mod n
        //   R == G * s - A * e
        //
        // We can skip a square root with:
        //
        //   e = H(r, A, m) mod n
        //   R = G * s - A * e
        //   y(R) is square
        //   x(R) == r
        //
        // We can also avoid affinization by
        // replacing the two assertions with:
        //
        //   (y(R) * z(R) mod p) is square
        //   x(R) == r * z(R)^2 mod p
        //
        // Furthermore, squareness can be calculated
        // with a variable time Jacobi symbol algorithm.
        var _this$curve = this.curve,
            p = _this$curve.p,
            n = _this$curve.n;
        var G = this.curve.g;
        var Rraw = sig.slice(0, this.curve.fieldSize);
        var sraw = sig.slice(this.curve.fieldSize);
        var r = this.curve.decodeField(Rraw);
        var s = this.curve.decodeScalar(sraw);
        var A = this.curve.decodePoint(key);
        if (r.cmp(p) >= 0 || s.cmp(n) >= 0) return false;
        var e = this.hashChallenge(Rraw, key, msg);
        var R = G.jmulAdd(s, A, e.ineg().imod(n));
        if (!R.isSquare()) return false;
        if (!R.eqX(r)) return false;
        return true;
      }
    }, {
      key: "verifyBatch",
      value: function verifyBatch(batch) {
        assert_1$1(Array.isArray(batch));
        this.check();

        var _iterator = _createForOfIteratorHelper$d(batch),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var item = _step.value;
            assert_1$1(Array.isArray(item) && item.length === 3);

            var _item = _slicedToArray__default['default'](item, 3),
                msg = _item[0],
                sig = _item[1],
                key = _item[2];

            assert_1$1(Buffer.isBuffer(msg));
            assert_1$1(Buffer.isBuffer(sig));
            assert_1$1(Buffer.isBuffer(key));
            if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        try {
          return this._verifyBatch(batch);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "_verifyBatch",
      value: function _verifyBatch(batch) {
        // Schnorr Batch Verification.
        //
        // [SCHNORR] "Batch Verification".
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `m` be a 32-byte array.
        //   - Let `r` and `s` be signature elements.
        //   - Let `A` be a valid group element.
        //   - Let `i` be the batch item index.
        //   - r^3 + a * r + b is square in F(p).
        //   - r < p, s < n.
        //   - a1 = 1 mod n.
        //
        // Computation:
        //
        //   Ri = (ri, sqrt(ri^3 + a * ri + b))
        //   ei = H(ri, Ai, mi) mod n
        //   ai = random integer in [1,n-1]
        //   lhs = si * ai + ... mod n
        //   rhs = Ri * ai + Ai * (ei * ai mod n) + ...
        //   G * -lhs + rhs == O
        var n = this.curve.n;
        var G = this.curve.g;
        var points = new Array(1 + batch.length * 2);
        var coeffs = new Array(1 + batch.length * 2);
        var sum = new bnBrowser(0);
        this.rng.init(batch);
        points[0] = G;
        coeffs[0] = sum;

        for (var i = 0; i < batch.length; i++) {
          var _batch$i = _slicedToArray__default['default'](batch[i], 3),
              msg = _batch$i[0],
              sig = _batch$i[1],
              key = _batch$i[2];

          var Rraw = sig.slice(0, this.curve.fieldSize);
          var sraw = sig.slice(this.curve.fieldSize);
          var R = this.curve.decodeSquare(Rraw);
          var s = this.curve.decodeScalar(sraw);
          var A = this.curve.decodePoint(key);
          if (s.cmp(n) >= 0) return false;
          var e = this.hashChallenge(Rraw, key, msg);
          var a = this.rng.generate(i);
          var ea = e.mul(a).imod(n);
          sum.iadd(s.mul(a)).imod(n);
          points[1 + i * 2 + 0] = R;
          coeffs[1 + i * 2 + 0] = a;
          points[1 + i * 2 + 1] = A;
          coeffs[1 + i * 2 + 1] = ea;
        }

        sum.ineg().imod(n);
        return this.curve.jmulAll(points, coeffs).isInfinity();
      }
    }]);

    return Schnorr;
  }();
  /*
   * Expose
   */


  var schnorrLegacy = Schnorr;

  function _createForOfIteratorHelper$e(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$e(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$e(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$e(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(o, minLen); }

  function _arrayLikeToArray$e(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /**
   * ECDSA
   */


  var ECDSA = /*#__PURE__*/function () {
    function ECDSA(name, hash, pre) {
      _classCallCheck__default['default'](this, ECDSA);

      assert_1$1(typeof name === 'string');
      assert_1$1(hash);
      this.id = name;
      this.type = 'ecdsa';
      this.hash = hash;
      this.native = 0;
      this._pre = pre || null;
      this._curve = null;
      this._schnorr = null;
    }

    _createClass__default['default'](ECDSA, [{
      key: "privateKeyGenerate",
      value: function privateKeyGenerate() {
        var a = this.curve.randomScalar(randomBrowser);
        return this.curve.encodeScalar(a);
      }
    }, {
      key: "privateKeyVerify",
      value: function privateKeyVerify(key) {
        assert_1$1(Buffer.isBuffer(key));
        var a;

        try {
          a = this.curve.decodeScalar(key);
        } catch (e) {
          return false;
        }

        return !a.isZero() && a.cmp(this.curve.n) < 0;
      }
    }, {
      key: "privateKeyExport",
      value: function privateKeyExport(key) {
        var pub = this.publicKeyCreate(key, false);

        var _this$publicKeyExport = this.publicKeyExport(pub),
            x = _this$publicKeyExport.x,
            y = _this$publicKeyExport.y;

        return {
          d: Buffer.from(key),
          x: x,
          y: y
        };
      }
    }, {
      key: "privateKeyImport",
      value: function privateKeyImport(json) {
        assert_1$1(json && _typeof__default['default'](json) === 'object');
        var a = bnBrowser.decode(json.d, this.curve.endian);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        return this.curve.encodeScalar(a);
      }
    }, {
      key: "privateKeyTweakAdd",
      value: function privateKeyTweakAdd(key, tweak) {
        var t = this.curve.decodeScalar(tweak);
        if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var k = a.add(t).imod(this.curve.n);
        if (k.isZero()) throw new Error('Invalid private key.');
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "privateKeyTweakMul",
      value: function privateKeyTweakMul(key, tweak) {
        var t = this.curve.decodeScalar(tweak);
        if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var k = a.mul(t).imod(this.curve.n);
        if (k.isZero()) throw new Error('Invalid private key.');
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "privateKeyReduce",
      value: function privateKeyReduce(key) {
        assert_1$1(Buffer.isBuffer(key));
        if (key.length > this.curve.scalarSize) key = key.slice(0, this.curve.scalarSize);
        var a = bnBrowser.decode(key, this.curve.endian).imod(this.curve.n);
        if (a.isZero()) throw new Error('Invalid private key.');
        return this.curve.encodeScalar(a);
      }
    }, {
      key: "privateKeyNegate",
      value: function privateKeyNegate(key) {
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var k = a.neg().imod(this.curve.n);
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "privateKeyInvert",
      value: function privateKeyInvert(key) {
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var k = a.invert(this.curve.n);
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "publicKeyCreate",
      value: function publicKeyCreate(key, compress) {
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var A = this.curve.g.mulBlind(a);
        return A.encode(compress);
      }
    }, {
      key: "publicKeyConvert",
      value: function publicKeyConvert(key, compress) {
        var A = this.curve.decodePoint(key);
        return A.encode(compress);
      }
    }, {
      key: "publicKeyFromUniform",
      value: function publicKeyFromUniform(bytes, compress) {
        var u = this.curve.decodeUniform(bytes);
        var A = this.curve.pointFromUniform(u);
        return A.encode(compress);
      }
    }, {
      key: "publicKeyToUniform",
      value: function publicKeyToUniform(key) {
        var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : randomBrowser.randomInt();
        var A = this.curve.decodePoint(key);
        var u = this.curve.pointToUniform(A, hint);
        return this.curve.encodeUniform(u, hint >>> 8);
      }
    }, {
      key: "publicKeyFromHash",
      value: function publicKeyFromHash(bytes, compress) {
        var A = this.curve.pointFromHash(bytes);
        return A.encode(compress);
      }
    }, {
      key: "publicKeyToHash",
      value: function publicKeyToHash(key) {
        var A = this.curve.decodePoint(key);
        return this.curve.pointToHash(A, 0, randomBrowser);
      }
    }, {
      key: "publicKeyVerify",
      value: function publicKeyVerify(key) {
        assert_1$1(Buffer.isBuffer(key));

        try {
          this.curve.decodePoint(key);
        } catch (e) {
          return false;
        }

        return true;
      }
    }, {
      key: "publicKeyExport",
      value: function publicKeyExport(key) {
        var _this$curve$decodePoi = this.curve.decodePoint(key),
            x = _this$curve$decodePoi.x,
            y = _this$curve$decodePoi.y;

        return {
          x: this.curve.encodeField(x.fromRed()),
          y: this.curve.encodeField(y.fromRed())
        };
      }
    }, {
      key: "publicKeyImport",
      value: function publicKeyImport(json, compress) {
        assert_1$1(json && _typeof__default['default'](json) === 'object');
        var x = bnBrowser.decode(json.x, this.curve.endian);
        if (x.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');

        if (json.y != null) {
          var y = bnBrowser.decode(json.y, this.curve.endian);
          if (y.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');

          var _A = this.curve.point(x, y);

          if (!_A.validate()) throw new Error('Invalid point.');
          return _A.encode(compress);
        }

        var A = this.curve.pointFromX(x, json.sign);
        return A.encode(compress);
      }
    }, {
      key: "publicKeyTweakAdd",
      value: function publicKeyTweakAdd(key, tweak, compress) {
        var t = this.curve.decodeScalar(tweak);
        if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var A = this.curve.decodePoint(key);
        var T = this.curve.g.jmul(t);
        var P = T.add(A);
        return P.encode(compress);
      }
    }, {
      key: "publicKeyTweakMul",
      value: function publicKeyTweakMul(key, tweak, compress) {
        var t = this.curve.decodeScalar(tweak);
        if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var A = this.curve.decodePoint(key);
        var P = A.mul(t);
        return P.encode(compress);
      }
    }, {
      key: "publicKeyCombine",
      value: function publicKeyCombine(keys, compress) {
        assert_1$1(Array.isArray(keys));
        var P = this.curve.jpoint();

        var _iterator = _createForOfIteratorHelper$e(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;
            var A = this.curve.decodePoint(key);
            P = P.add(A);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return P.encode(compress);
      }
    }, {
      key: "publicKeyNegate",
      value: function publicKeyNegate(key, compress) {
        var A = this.curve.decodePoint(key);
        var P = A.neg();
        return P.encode(compress);
      }
    }, {
      key: "signatureNormalize",
      value: function signatureNormalize(sig) {
        var _this$_decodeCompact = this._decodeCompact(sig),
            _this$_decodeCompact2 = _slicedToArray__default['default'](_this$_decodeCompact, 2),
            r = _this$_decodeCompact2[0],
            s = _this$_decodeCompact2[1];

        if (s.cmp(this.curve.nh) > 0) s.ineg().imod(this.curve.n);
        return this._encodeCompact(r, s);
      }
    }, {
      key: "signatureNormalizeDER",
      value: function signatureNormalizeDER(sig) {
        var _this$_decodeDER = this._decodeDER(sig, false),
            _this$_decodeDER2 = _slicedToArray__default['default'](_this$_decodeDER, 2),
            r = _this$_decodeDER2[0],
            s = _this$_decodeDER2[1];

        if (s.cmp(this.curve.nh) > 0) s.ineg().imod(this.curve.n);
        return this._encodeDER(r, s);
      }
    }, {
      key: "signatureExport",
      value: function signatureExport(sig) {
        var _this$_decodeCompact3 = this._decodeCompact(sig),
            _this$_decodeCompact4 = _slicedToArray__default['default'](_this$_decodeCompact3, 2),
            r = _this$_decodeCompact4[0],
            s = _this$_decodeCompact4[1];

        return this._encodeDER(r, s);
      }
    }, {
      key: "signatureImport",
      value: function signatureImport(sig) {
        var _this$_decodeDER3 = this._decodeDER(sig, false),
            _this$_decodeDER4 = _slicedToArray__default['default'](_this$_decodeDER3, 2),
            r = _this$_decodeDER4[0],
            s = _this$_decodeDER4[1];

        return this._encodeCompact(r, s);
      }
    }, {
      key: "isLowS",
      value: function isLowS(sig) {
        assert_1$1(Buffer.isBuffer(sig));
        var s;

        try {
          var _this$_decodeCompact5 = this._decodeCompact(sig);

          var _this$_decodeCompact6 = _slicedToArray__default['default'](_this$_decodeCompact5, 2);

          s = _this$_decodeCompact6[1];
        } catch (e) {
          return false;
        }

        return s.cmp(this.curve.nh) <= 0;
      }
    }, {
      key: "isLowDER",
      value: function isLowDER(sig) {
        assert_1$1(Buffer.isBuffer(sig));
        var s;

        try {
          var _this$_decodeDER5 = this._decodeDER(sig, false);

          var _this$_decodeDER6 = _slicedToArray__default['default'](_this$_decodeDER5, 2);

          s = _this$_decodeDER6[1];
        } catch (e) {
          return false;
        }

        return s.cmp(this.curve.nh) <= 0;
      }
    }, {
      key: "sign",
      value: function sign(msg, key) {
        var _this$_sign = this._sign(msg, key),
            _this$_sign2 = _slicedToArray__default['default'](_this$_sign, 2),
            r = _this$_sign2[0],
            s = _this$_sign2[1];

        return this._encodeCompact(r, s);
      }
    }, {
      key: "signRecoverable",
      value: function signRecoverable(msg, key) {
        var _this$_sign3 = this._sign(msg, key),
            _this$_sign4 = _slicedToArray__default['default'](_this$_sign3, 3),
            r = _this$_sign4[0],
            s = _this$_sign4[1],
            param = _this$_sign4[2];

        return [this._encodeCompact(r, s), param];
      }
    }, {
      key: "signDER",
      value: function signDER(msg, key) {
        var _this$_sign5 = this._sign(msg, key),
            _this$_sign6 = _slicedToArray__default['default'](_this$_sign5, 2),
            r = _this$_sign6[0],
            s = _this$_sign6[1];

        return this._encodeDER(r, s);
      }
    }, {
      key: "signRecoverableDER",
      value: function signRecoverableDER(msg, key) {
        var _this$_sign7 = this._sign(msg, key),
            _this$_sign8 = _slicedToArray__default['default'](_this$_sign7, 3),
            r = _this$_sign8[0],
            s = _this$_sign8[1],
            param = _this$_sign8[2];

        return [this._encodeDER(r, s), param];
      }
    }, {
      key: "_sign",
      value: function _sign(msg, key) {
        // ECDSA Signing.
        //
        // [SEC1] Page 44, Section 4.1.3.
        // [GECC] Algorithm 4.29, Page 184, Section 4.4.1.
        // [RFC6979] Page 9, Section 2.4.
        // [RFC6979] Page 10, Section 3.2.
        //
        // Assumptions:
        //
        //   - Let `m` be an integer reduced from bytes.
        //   - Let `a` be a secret non-zero scalar.
        //   - Let `k` be a random non-zero scalar.
        //   - R != O, r != 0, s != 0.
        //
        // Computation:
        //
        //   k = random integer in [1,n-1]
        //   R = G * k
        //   r = x(R) mod n
        //   s = (r * a + m) / k mod n
        //   s = -s mod n, if s > n / 2
        //   S = (r, s)
        //
        // We can blind the scalar arithmetic
        // with a random integer `b` like so:
        //
        //   b = random integer in [1,n-1]
        //   s = (r * (a * b) + m * b) / (k * b) mod n
        //
        // Note that `k` must remain secret,
        // otherwise an attacker can compute:
        //
        //   a = (s * k - m) / r mod n
        //
        // This means that if two signatures
        // share the same `r` value, an attacker
        // can compute:
        //
        //   k = (m1 - m2) / (+-s1 - +-s2) mod n
        //   a = (s1 * k - m1) / r mod n
        //
        // Assuming:
        //
        //   s1 = (r * a + m1) / k mod n
        //   s2 = (r * a + m2) / k mod n
        //
        // To mitigate this, `k` can be generated
        // deterministically using the HMAC-DRBG
        // construction described in [RFC6979].
        var _this$curve = this.curve,
            n = _this$curve.n,
            nh = _this$curve.nh;
        var G = this.curve.g;
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(n) >= 0) throw new Error('Invalid private key.');

        var m = this._reduce(msg);

        var nonce = this.curve.encodeScalar(m);
        var drbg = new hmacDrbgBrowser(this.hash, key, nonce);

        for (;;) {
          var bytes = drbg.generate(this.curve.scalarSize);

          var k = this._truncate(bytes);

          if (k.isZero() || k.cmp(n) >= 0) continue;
          var R = G.mulBlind(k);
          if (R.isInfinity()) continue;
          var x = R.getX();
          var r = x.mod(n);
          if (r.isZero()) continue;
          var b = this.curve.randomScalar(randomBrowser);
          var ki = k.mul(b).fermat(n);
          var ba = a.mul(b).imod(n);
          var bm = m.mul(b).imod(n);
          var sk = r.mul(ba).iadd(bm).imod(n);
          var s = sk.mul(ki).imod(n);
          if (s.isZero()) continue;
          var param = R.isOdd() | !x.eq(r) << 1;

          if (s.cmp(nh) > 0) {
            s.ineg().imod(n);
            param ^= 1;
          }

          return [r, s, param];
        }
      }
    }, {
      key: "verify",
      value: function verify(msg, sig, key) {
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(sig));
        assert_1$1(Buffer.isBuffer(key));
        var r, s;

        try {
          var _this$_decodeCompact7 = this._decodeCompact(sig);

          var _this$_decodeCompact8 = _slicedToArray__default['default'](_this$_decodeCompact7, 2);

          r = _this$_decodeCompact8[0];
          s = _this$_decodeCompact8[1];
        } catch (e) {
          return false;
        }

        try {
          return this._verify(msg, r, s, key);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "verifyDER",
      value: function verifyDER(msg, sig, key) {
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(sig));
        assert_1$1(Buffer.isBuffer(key));
        var r, s;

        try {
          var _this$_decodeDER7 = this._decodeDER(sig, false);

          var _this$_decodeDER8 = _slicedToArray__default['default'](_this$_decodeDER7, 2);

          r = _this$_decodeDER8[0];
          s = _this$_decodeDER8[1];
        } catch (e) {
          return false;
        }

        try {
          return this._verify(msg, r, s, key);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "_verify",
      value: function _verify(msg, r, s, key) {
        // ECDSA Verification.
        //
        // [SEC1] Page 46, Section 4.1.4.
        // [GECC] Algorithm 4.30, Page 184, Section 4.4.1.
        //
        // Assumptions:
        //
        //   - Let `m` be an integer reduced from bytes.
        //   - Let `r` and `s` be signature elements.
        //   - Let `A` be a valid group element.
        //   - r != 0, r < n.
        //   - s != 0, s < n.
        //   - R != O.
        //
        // Computation:
        //
        //   u1 = m / s mod n
        //   u2 = r / s mod n
        //   R = G * u1 + A * u2
        //   r == x(R) mod n
        //
        // Note that the signer can verify their
        // own signatures more efficiently with:
        //
        //   R = G * ((u1 + u2 * a) mod n)
        //
        // Furthermore, we can avoid affinization
        // of `R` by scaling `r` by `z^2` and
        // repeatedly adding `n * z^2` to it up
        // to a certain threshold.
        var n = this.curve.n;
        var G = this.curve.g;

        var m = this._reduce(msg);

        var A = this.curve.decodePoint(key);
        if (r.isZero() || r.cmp(n) >= 0) return false;
        if (s.isZero() || s.cmp(n) >= 0) return false;
        var si = s.invert(n);
        var u1 = m.mul(si).imod(n);
        var u2 = r.mul(si).imod(n);
        var R = G.jmulAdd(u1, A, u2);
        return R.eqR(r);
      }
    }, {
      key: "recover",
      value: function recover(msg, sig, param, compress) {
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(sig));
        assert_1$1(param >>> 0 === param);
        assert_1$1((param & 3) === param, 'The recovery param is more than two bits.');
        var r, s;

        try {
          var _this$_decodeCompact9 = this._decodeCompact(sig);

          var _this$_decodeCompact10 = _slicedToArray__default['default'](_this$_decodeCompact9, 2);

          r = _this$_decodeCompact10[0];
          s = _this$_decodeCompact10[1];
        } catch (e) {
          return null;
        }

        var A;

        try {
          A = this._recover(msg, r, s, param);
        } catch (e) {
          return null;
        }

        return A.encode(compress);
      }
    }, {
      key: "recoverDER",
      value: function recoverDER(msg, sig, param, compress) {
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(sig));
        assert_1$1(param >>> 0 === param);
        assert_1$1((param & 3) === param, 'The recovery param is more than two bits.');
        var r, s;

        try {
          var _this$_decodeDER9 = this._decodeDER(sig, false);

          var _this$_decodeDER10 = _slicedToArray__default['default'](_this$_decodeDER9, 2);

          r = _this$_decodeDER10[0];
          s = _this$_decodeDER10[1];
        } catch (e) {
          return null;
        }

        var A;

        try {
          A = this._recover(msg, r, s, param);
        } catch (e) {
          return null;
        }

        return A.encode(compress);
      }
    }, {
      key: "_recover",
      value: function _recover(msg, r, s, param) {
        // ECDSA Public Key Recovery.
        //
        // [SEC1] Page 47, Section 4.1.6.
        //
        // Assumptions:
        //
        //   - Let `m` be an integer reduced from bytes.
        //   - Let `r` and `s` be signature elements.
        //   - Let `i` be an integer in [0,3].
        //   - x^3 + a * x + b is square in F(p).
        //   - If i > 1 then r < (p mod n).
        //   - r != 0, r < n.
        //   - s != 0, s < n.
        //   - A != O.
        //
        // Computation:
        //
        //   x = r + n, if i > 1
        //     = r, otherwise
        //   R' = (x, sqrt(x^3 + a * x + b))
        //   R = -R', if i mod 2 == 1
        //     = +R', otherwise
        //   s1 = m / r mod n
        //   s2 = s / r mod n
        //   A = R * s2 - G * s1
        //
        // Note that this implementation will have
        // trouble on curves where `p / n > 1`.
        var _this$curve2 = this.curve,
            n = _this$curve2.n,
            pmodn = _this$curve2.pmodn;
        var G = this.curve.g;

        var m = this._reduce(msg);

        if (r.isZero() || r.cmp(n) >= 0) throw new Error('Invalid R value.');
        if (s.isZero() || s.cmp(n) >= 0) throw new Error('Invalid S value.');
        var sign = (param & 1) !== 0;
        var high = param >>> 1;
        var x = r;

        if (high) {
          if (this.curve.highOrder) throw new Error('Invalid high bit.');
          if (x.cmp(pmodn) >= 0) throw new Error('Invalid R value.');
          x = x.add(n);
        }

        var R = this.curve.pointFromX(x, sign);
        var ri = r.invert(n);
        var s1 = m.mul(ri).ineg().imod(n);
        var s2 = s.mul(ri).imod(n);
        var A = G.mulAdd(s1, R, s2);
        if (A.isInfinity()) throw new Error('Invalid point.');
        return A;
      }
    }, {
      key: "derive",
      value: function derive(pub, priv, compress) {
        var A = this.curve.decodePoint(pub);
        var a = this.curve.decodeScalar(priv);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');

        if (this.curve.h.cmpn(1) > 0) {
          if (A.isSmall()) throw new Error('Invalid point.');
        }

        var P = A.mulConst(a, randomBrowser);
        return P.encode(compress);
      }
      /*
       * Schnorr
       */

    }, {
      key: "schnorrSign",
      value: function schnorrSign(msg, key) {
        return this.schnorr.sign(msg, key);
      }
    }, {
      key: "schnorrVerify",
      value: function schnorrVerify(msg, sig, key) {
        return this.schnorr.verify(msg, sig, key);
      }
    }, {
      key: "schnorrVerifyBatch",
      value: function schnorrVerifyBatch(batch) {
        return this.schnorr.verifyBatch(batch);
      }
      /*
       * Helpers
       */

    }, {
      key: "_encodeCompact",
      value: function _encodeCompact(r, s) {
        return Buffer.concat([this.curve.encodeScalar(r), this.curve.encodeScalar(s)]);
      }
    }, {
      key: "_decodeCompact",
      value: function _decodeCompact(sig) {
        assert_1$1(Buffer.isBuffer(sig));
        var n = this.curve.n;
        var size = this.curve.scalarSize;
        if (sig.length !== size * 2) throw new Error('Invalid signature size.');
        var Rraw = sig.slice(0, size);
        var Sraw = sig.slice(size, size * 2);
        var r = this.curve.decodeScalar(Rraw);
        var s = this.curve.decodeScalar(Sraw);
        if (r.cmp(n) >= 0 || s.cmp(n) >= 0) throw new Error('Invalid signature.');
        return [r, s];
      }
    }, {
      key: "_encodeDER",
      value: function _encodeDER(r, s) {
        var size = asn1.sizeInt(r) + asn1.sizeInt(s);
        var out = Buffer.alloc(asn1.sizeSeq(size));
        var pos = 0;
        pos = asn1.writeSeq(out, pos, size);
        pos = asn1.writeInt(out, pos, r);
        pos = asn1.writeInt(out, pos, s);
        assert_1$1(pos === out.length);
        return out;
      }
    }, {
      key: "_decodeDER",
      value: function _decodeDER(sig, strict) {
        assert_1$1(Buffer.isBuffer(sig));
        assert_1$1(typeof strict === 'boolean');
        var n = this.curve.n;
        var pos = 0;
        var r, s;
        pos = asn1.readSeq(sig, pos, strict);

        var _asn1$readInt = asn1.readInt(sig, pos, strict);

        var _asn1$readInt2 = _slicedToArray__default['default'](_asn1$readInt, 2);

        r = _asn1$readInt2[0];
        pos = _asn1$readInt2[1];

        var _asn1$readInt3 = asn1.readInt(sig, pos, strict);

        var _asn1$readInt4 = _slicedToArray__default['default'](_asn1$readInt3, 2);

        s = _asn1$readInt4[0];
        pos = _asn1$readInt4[1];
        if (strict && pos !== sig.length) throw new Error('Trailing bytes.');
        if (r.cmp(n) >= 0 || s.cmp(n) >= 0) throw new Error('Invalid signature.');
        return [r, s];
      }
    }, {
      key: "_truncate",
      value: function _truncate(msg) {
        // Byte array to integer conversion.
        //
        // [SEC1] Step 5, Page 45, Section 4.1.3.
        // [FIPS186] Page 25, Section B.2.
        //
        // The two sources above disagree on this.
        //
        // FIPS186 simply modulos the entire byte
        // array by the order, whereas SEC1 takes
        // the left-most ceil(log2(n+1)) bits modulo
        // the order (and maybe does other stuff).
        //
        // Instead of trying to decipher all of
        // this nonsense, we simply replicate the
        // OpenSSL behavior (which, in actuality,
        // is more similar to the SEC1 behavior).
        assert_1$1(Buffer.isBuffer(msg));
        var bits = this.curve.n.bitLength();
        var bytes = bits + 7 >>> 3;
        if (msg.length > bytes) msg = msg.slice(0, bytes);
        var m = bnBrowser.decode(msg, this.curve.endian);
        var d = msg.length * 8 - bits;
        if (d > 0) m.iushrn(d);
        return m;
      }
    }, {
      key: "_reduce",
      value: function _reduce(msg) {
        return this._truncate(msg).imod(this.curve.n);
      }
    }, {
      key: "curve",
      get: function get() {
        if (!this._curve) {
          this._curve = elliptic.curve(this.id, this._pre);

          this._curve.precompute(randomBrowser);

          this._pre = null;
        }

        return this._curve;
      }
    }, {
      key: "schnorr",
      get: function get() {
        if (!this._schnorr) this._schnorr = new schnorrLegacy(this.curve, this.hash);
        return this._schnorr;
      }
    }, {
      key: "size",
      get: function get() {
        return this.curve.fieldSize;
      }
    }, {
      key: "bits",
      get: function get() {
        return this.curve.fieldBits;
      }
    }]);

    return ECDSA;
  }();
  /*
   * Expose
   */


  var ecdsa = ECDSA;

  /*
   * Expose
   */


  var p192 = new ecdsa('P192', sha256Browser);

  var p192Browser = p192;

  /*
   * Expose
   */


  var p224 = new ecdsa('P224', sha256Browser);

  var p224Browser = p224;

  /*
   * Expose
   */


  var p256 = new ecdsa('P256', sha256Browser);

  var p256Browser = p256;

  function _createSuper$B(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$B(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$B() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHA384
   */


  var SHA384 = /*#__PURE__*/function (_SHA) {
    _inherits__default['default'](SHA384, _SHA);

    var _super = _createSuper$B(SHA384);

    function SHA384() {
      _classCallCheck__default['default'](this, SHA384);

      return _super.call(this);
    }

    _createClass__default['default'](SHA384, [{
      key: "init",
      value: function init() {
        this.state[0] = 0xcbbb9d5d;
        this.state[1] = 0xc1059ed8;
        this.state[2] = 0x629a292a;
        this.state[3] = 0x367cd507;
        this.state[4] = 0x9159015a;
        this.state[5] = 0x3070dd17;
        this.state[6] = 0x152fecd8;
        this.state[7] = 0xf70e5939;
        this.state[8] = 0x67332667;
        this.state[9] = 0xffc00b31;
        this.state[10] = 0x8eb44a87;
        this.state[11] = 0x68581511;
        this.state[12] = 0xdb0c2e0d;
        this.state[13] = 0x64f98fa7;
        this.state[14] = 0x47b5481d;
        this.state[15] = 0xbefa4fa4;
        this.size = 0;
        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA384.prototype), "final", this).call(this).slice(0, 48);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA384();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(SHA384, 128);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return SHA384.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 48);
        assert_1$1(Buffer.isBuffer(right) && right.length === 48);
        return SHA384.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = SHA384.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return SHA384.hmac().init(key).update(data).final();
      }
    }]);

    return SHA384;
  }(sha512);
  /*
   * Static
   */


  SHA384.native = 0;
  SHA384.id = 'SHA384';
  SHA384.size = 48;
  SHA384.bits = 384;
  SHA384.blockSize = 128;
  SHA384.zero = Buffer.alloc(48, 0x00);
  SHA384.ctx = new SHA384();
  /*
   * Expose
   */

  var sha384 = SHA384;

  var sha384Browser = sha384;

  /*
   * Expose
   */


  var p384 = new ecdsa('P384', sha384Browser);

  var p384Browser = p384;

  /*
   * Expose
   */


  var p521 = new ecdsa('P521', sha512Browser);

  var p521Browser = p521;

  var crypto$1 = commonjsGlobal.crypto || commonjsGlobal.msCrypto || {};
  var subtle = crypto$1.subtle || {};
  /**
   * Perform key derivation using PBKDF2.
   * @param {Function} hash
   * @param {Buffer} pass
   * @param {Buffer} salt
   * @param {Number} iter
   * @param {Number} len
   * @returns {Buffer}
   */

  function derive$5(hash, pass, salt, iter, len) {
    if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');
    if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
    if (salt == null) salt = Buffer.alloc(0);
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(pass));
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(iter >>> 0 === iter);
    assert_1$1(len >>> 0 === len);
    var size = hash.size;
    var blocks = Math.ceil(len / size);
    var out = Buffer.alloc(blocks * size);
    var state = Buffer.alloc(salt.length + 4);
    salt.copy(state, 0); // Preemptively shorten key.

    if (pass.length > hash.blockSize) {
      pass = hash.digest(pass);
      assert_1$1(pass.length <= hash.blockSize);
    }

    for (var i = 0; i < blocks; i++) {
      var round = i + 1;
      state[salt.length + 0] = round >>> 24;
      state[salt.length + 1] = round >>> 16;
      state[salt.length + 2] = round >>> 8;
      state[salt.length + 3] = round;
      var block = hash.mac(state, pass);
      var mac = block;

      for (var j = 1; j < iter; j++) {
        mac = hash.mac(mac, pass);

        for (var k = 0; k < size; k++) {
          block[k] ^= mac[k];
        }
      }

      block.copy(out, i * size);
    }

    return out.slice(0, len);
  }
  /**
   * Execute pbkdf2 asynchronously.
   * @param {Function} hash
   * @param {Buffer} pass
   * @param {Buffer} salt
   * @param {Number} iter
   * @param {Number} len
   * @returns {Promise}
   */


  function deriveAsync(_x, _x2, _x3, _x4, _x5) {
    return _deriveAsync.apply(this, arguments);
  }
  /*
   * Helpers
   */


  function _deriveAsync() {
    _deriveAsync = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(hash, pass, salt, iter, len) {
      var name, algo, use, options, key, out;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (typeof pass === 'string') pass = Buffer.from(pass, 'utf8');
              if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
              if (salt == null) salt = Buffer.alloc(0);
              assert_1$1(hash && typeof hash.id === 'string');
              assert_1$1(Buffer.isBuffer(pass));
              assert_1$1(Buffer.isBuffer(salt));
              assert_1$1(iter >>> 0 === iter);
              assert_1$1(len >>> 0 === len);
              name = getHash(hash);

              if (!(!subtle.importKey || !subtle.deriveBits || !name)) {
                _context.next = 11;
                break;
              }

              return _context.abrupt("return", derive$5(hash, pass, salt, iter, len));

            case 11:
              algo = {
                name: 'PBKDF2'
              };
              use = ['deriveBits'];
              options = {
                name: 'PBKDF2',
                salt: salt,
                iterations: iter,
                hash: name
              };
              _context.next = 16;
              return subtle.importKey('raw', pass, algo, false, use);

            case 16:
              key = _context.sent;
              _context.next = 19;
              return subtle.deriveBits(options, key, len * 8);

            case 19:
              out = _context.sent;
              return _context.abrupt("return", Buffer.from(out));

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _deriveAsync.apply(this, arguments);
  }

  function getHash(hash) {
    switch (hash.id) {
      case 'SHA1':
        return 'SHA-1';

      case 'SHA256':
        return 'SHA-256';

      case 'SHA384':
        return 'SHA-384';

      case 'SHA512':
        return 'SHA-512';

      default:
        return null;
    }
  }
  /*
   * Expose
   */


  var native_1$g = 0;
  var derive_1$5 = derive$5;
  var deriveAsync_1 = deriveAsync;
  var pbkdf2 = {
    native: native_1$g,
    derive: derive_1$5,
    deriveAsync: deriveAsync_1
  };

  var pbkdf2Browser = pbkdf2;

  var sha1Browser = sha1;

  var ripemd160Browser = ripemd160;

  function _createSuper$C(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$C(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$C() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHA224
   */


  var SHA224 = /*#__PURE__*/function (_SHA) {
    _inherits__default['default'](SHA224, _SHA);

    var _super = _createSuper$C(SHA224);

    function SHA224() {
      _classCallCheck__default['default'](this, SHA224);

      return _super.call(this);
    }

    _createClass__default['default'](SHA224, [{
      key: "init",
      value: function init() {
        this.state[0] = 0xc1059ed8;
        this.state[1] = 0x367cd507;
        this.state[2] = 0x3070dd17;
        this.state[3] = 0xf70e5939;
        this.state[4] = 0xffc00b31;
        this.state[5] = 0x68581511;
        this.state[6] = 0x64f98fa7;
        this.state[7] = 0xbefa4fa4;
        this.size = 0;
        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA224.prototype), "final", this).call(this).slice(0, 28);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA224();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(SHA224, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return SHA224.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 28);
        assert_1$1(Buffer.isBuffer(right) && right.length === 28);
        return SHA224.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = SHA224.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return SHA224.hmac().init(key).update(data).final();
      }
    }]);

    return SHA224;
  }(sha256);
  /*
   * Static
   */


  SHA224.native = 0;
  SHA224.id = 'SHA224';
  SHA224.size = 28;
  SHA224.bits = 224;
  SHA224.blockSize = 64;
  SHA224.zero = Buffer.alloc(28, 0x00);
  SHA224.ctx = new SHA224();
  /*
   * Expose
   */

  var sha224 = SHA224;

  var sha224Browser = sha224;

  /*
   * Constants
   */


  var EMPTY$8 = Buffer.alloc(0);
  var ZERO$2 = Buffer.alloc(1, 0x00);
  /*
   * PGPDF
   */

  function deriveSimple(hash, input, size) {
    return deriveSalted(hash, input, EMPTY$8, size);
  }

  function deriveSalted(hash, input, salt, size) {
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(input));
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(size >>> 0 === size); // eslint-disable-next-line

    var ctx = new hash();
    var out = Buffer.alloc(size);
    var i = 0;
    var pos = 0;

    while (pos < size) {
      ctx.init();

      for (var j = 0; j < i; j++) {
        ctx.update(ZERO$2);
      }

      ctx.update(salt);
      ctx.update(input);
      pos += ctx.final().copy(out, pos);
      i += 1;
    }

    return out;
  }

  function deriveIterated(hash, input, salt, count, size) {
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(input));
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(count >>> 0 === count);
    assert_1$1(size >>> 0 === size); // eslint-disable-next-line

    var ctx = new hash();
    var out = Buffer.alloc(size);
    var combined = salt.length + input.length;
    if (count < combined) count = combined;
    var i = 0;
    var pos = 0;

    while (pos < size) {
      ctx.init();

      for (var j = 0; j < i; j++) {
        ctx.update(ZERO$2);
      }

      var w = 0;

      while (w < count) {
        if (w + combined > count) {
          var todo = count - w;

          if (todo < salt.length) {
            ctx.update(salt.slice(0, todo));
          } else {
            ctx.update(salt);
            ctx.update(input.slice(0, todo - salt.length));
          }

          break;
        }

        ctx.update(salt);
        ctx.update(input);
        w += combined;
      }

      pos += ctx.final().copy(out, pos);
      i += 1;
    }

    return out;
  }
  /*
   * Expose
   */


  var native_1$h = 0;
  var deriveSimple_1 = deriveSimple;
  var deriveSalted_1 = deriveSalted;
  var deriveIterated_1 = deriveIterated;
  var pgpdf = {
    native: native_1$h,
    deriveSimple: deriveSimple_1,
    deriveSalted: deriveSalted_1,
    deriveIterated: deriveIterated_1
  };

  var pgpdfBrowser = pgpdf;

  function _createForOfIteratorHelper$f(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$f(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$f(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$f(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(o, minLen); }

  function _arrayLikeToArray$f(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper$D(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$D(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$D() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var PEMBlock$2 = pem.PEMBlock;
  var countLeft$1 = util$1.countLeft;
  /*
   * Constants
   */

  var packetTypes = {
    NONE: 0,
    PUBKEY_ENC: 1,
    SIGNATURE: 2,
    SYMKEY_ENC: 3,
    ONEPASS_SIG: 4,
    PRIVATE_KEY: 5,
    PUBLIC_KEY: 6,
    PRIVATE_SUBKEY: 7,
    COMPRESSED: 8,
    ENCRYPTED: 9,
    MARKER: 10,
    PLAINTEXT: 11,
    RING_TRUST: 12,
    USER_ID: 13,
    PUBLIC_SUBKEY: 14,
    OLD_COMMENT: 16,
    ATTRIBUTE: 17,
    ENCRYPTED_MDC: 18,
    MDC: 19,
    ENCRYPTED_AEAD: 20
  };
  var packetTypesByVal = {
    0: 'NONE',
    1: 'PUBKEY_ENC',
    2: 'SIGNATURE',
    3: 'SYMKEY_ENC',
    4: 'ONEPASS_SIG',
    5: 'PRIVATE_KEY',
    6: 'PUBLIC_KEY',
    7: 'PRIVATE_SUBKEY',
    8: 'COMPRESSED',
    9: 'ENCRYPTED',
    10: 'MARKER',
    11: 'PLAINTEXT',
    12: 'RING_TRUST',
    13: 'USER_ID',
    14: 'PUBLIC_SUBKEY',
    16: 'OLD_COMMENT',
    17: 'ATTRIBUTE',
    18: 'ENCRYPTED_MDC',
    19: 'MDC',
    20: 'ENCRYPTED_AEAD'
  };
  var sigTypes = {
    BINARY: 0x00,
    TEXT: 0x01,
    GENERIC_CERT: 0x10,
    PERSONA_CERT: 0x11,
    CASUAL_CERT: 0x12,
    POSITIVE_CERT: 0x13,
    SUBKEY_BINDING: 0x18,
    PRIMARY_KEY_BINDING: 0x19,
    DIRECT_SIGNATURE: 0x1f,
    KEY_REVOCATION: 0x20,
    SUBKEY_REVOCATION: 0x28
  };
  var sigTypesByVal = {
    0x00: 'BINARY',
    0x01: 'TEXT',
    0x10: 'GENERIC_CERT',
    0x11: 'PERSONA_CERT',
    0x12: 'CASUAL_CERT',
    0x13: 'POSITIVE_CERT',
    0x18: 'SUBKEY_BINDING',
    0x19: 'PRIMARY_KEY_BINDING',
    0x1f: 'DIRECT_SIGNATURE',
    0x20: 'KEY_REVOCATION',
    0x28: 'SUBKEY_REVOCATION'
  };
  var keyTypes = {
    RSA: 1,
    RSA_ENCRYPT_ONLY: 2,
    RSA_SIGN_ONLY: 3,
    ELGAMAL: 16,
    DSA: 17,
    ECDH: 18,
    ECDSA: 19,
    ELGAMAL_LEGACY: 20,
    EDDSA: 22
  };
  var keyTypesByVal = {
    1: 'RSA',
    2: 'RSA_ENCRYPT_ONLY',
    3: 'RSA_SIGN_ONLY',
    16: 'ELGAMAL',
    17: 'DSA',
    18: 'ECDH',
    19: 'ECDSA',
    20: 'ELGAMAL_LEGACY',
    22: 'EDDSA'
  };
  var cipherTypes = {
    NONE: 0,
    IDEA: 1,
    DES3: 2,
    CAST5: 3,
    BLOWFISH: 4,
    AES128: 7,
    AES192: 8,
    AES256: 9,
    TWOFISH: 10,
    CAMELLIA128: 11,
    CAMELLIA192: 12,
    CAMELLIA256: 13
  };
  var cipherTypesByVal = {
    0: 'NONE',
    1: 'IDEA',
    2: 'DES3',
    3: 'CAST5',
    4: 'BLOWFISH',
    7: 'AES128',
    8: 'AES192',
    9: 'AES256',
    10: 'TWOFISH',
    11: 'CAMELLIA128',
    12: 'CAMELLIA192',
    13: 'CAMELLIA256'
  };
  var hashTypes = {
    MD5: 1,
    SHA1: 2,
    RIPEMD160: 3,
    SHA256: 8,
    SHA384: 9,
    SHA512: 10,
    SHA224: 11
  };
  var hashTypesByVal = {
    1: 'MD5',
    2: 'SHA1',
    3: 'RIPEMD160',
    8: 'SHA256',
    9: 'SHA384',
    10: 'SHA512',
    11: 'SHA224'
  };
  var hashToHash = {
    1: md5Browser,
    2: sha1Browser,
    3: ripemd160Browser,
    8: sha256Browser,
    9: sha384Browser,
    10: sha512Browser,
    11: sha224Browser
  };
  var compressTypes = {
    NONE: 0,
    ZIP: 1,
    ZLIB: 2,
    BZIP2: 3
  };
  var compressTypesByVal = {
    0: 'NONE',
    1: 'ZIP',
    2: 'ZLIB',
    3: 'BZIP2'
  };
  var curveTypes = {
    NONE: 0,
    P256: 1,
    P384: 2,
    P521: 3,
    SECP256K1: 4,
    X25519: 5,
    BRAINPOOLP256: 6,
    BRAINPOOLP384: 7,
    BRAINPOOLP512: 8,
    ED25519: 9
  };
  var curveTypesByVal = {
    0: 'NONE',
    1: 'P256',
    2: 'P384',
    3: 'P521',
    4: 'SECP256K1',
    5: 'X25519',
    6: 'BRAINPOOLP256',
    7: 'BRAINPOOLP384',
    8: 'BRAINPOOLP512',
    9: 'ED25519'
  };
  var oids = {
    P256: Buffer.from('2a8648ce3d030107', 'hex'),
    P384: Buffer.from('2b81040022', 'hex'),
    P521: Buffer.from('2b81040023', 'hex'),
    SECP256K1: Buffer.from('2b8104000a', 'hex'),
    X25519: Buffer.from('2b060104019755010501', 'hex'),
    BRAINPOOLP256: Buffer.from('2b2403030208010107', 'hex'),
    BRAINPOOLP384: Buffer.from('2b240303020801010b', 'hex'),
    BRAINPOOLP512: Buffer.from('2b240303020801010d', 'hex'),
    ED25519: Buffer.from('2b06010401da470f01', 'hex')
  };
  var EMPTY$9 = Buffer.alloc(0);
  /**
   * PGP Message
   */

  var PGPMessage = /*#__PURE__*/function (_bio$Struct) {
    _inherits__default['default'](PGPMessage, _bio$Struct);

    var _super = _createSuper$D(PGPMessage);

    function PGPMessage() {
      var _this;

      _classCallCheck__default['default'](this, PGPMessage);

      _this = _super.call(this);
      _this.packets = [];
      return _this;
    }

    _createClass__default['default'](PGPMessage, [{
      key: "getSize",
      value: function getSize() {
        var size = 0;

        var _iterator = _createForOfIteratorHelper$f(this.packets),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var pkt = _step.value;
            size += pkt.getSize();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return size;
      }
    }, {
      key: "write",
      value: function write(bw) {
        var _iterator2 = _createForOfIteratorHelper$f(this.packets),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var pkt = _step2.value;
            pkt.write(bw);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        while (br.left()) {
          var pkt = PGPPacket.read(br);
          this.packets.push(pkt);
        }

        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'PGP MESSAGE';
        assert_1$1(typeof type === 'string');
        var block = new PEMBlock$2();
        block.type = type;
        block.data = this.encode();
        return block.toString(true);
      }
    }, {
      key: "fromString",
      value: function fromString(str) {
        var block = PEMBlock$2.fromString(str, true);
        if (block.type.substring(0, 4) !== 'PGP ') throw new Error('PEM type mismatch.');
        return this.decode(block.data);
      }
    }, {
      key: "format",
      value: function format() {
        return {
          packets: this.packets
        };
      }
    }]);

    return PGPMessage;
  }(bufio.Struct);
  /**
   * PGP Packet
   */


  var PGPPacket = /*#__PURE__*/function (_bio$Struct2) {
    _inherits__default['default'](PGPPacket, _bio$Struct2);

    var _super2 = _createSuper$D(PGPPacket);

    function PGPPacket() {
      var _this2;

      _classCallCheck__default['default'](this, PGPPacket);

      _this2 = _super2.call(this);
      _this2.type = 0;
      _this2.body = new PGPUnknown();
      return _this2;
    }

    _createClass__default['default'](PGPPacket, [{
      key: "getSize",
      value: function getSize() {
        var len = this.body.getSize();
        var size = 0;
        size += 1;

        if (len < 192) {
          size += 1;
        } else if (len < 8384) {
          size += 2;
        } else {
          size += 5;
        }

        size += len;
        return size;
      }
    }, {
      key: "write",
      value: function write(bw) {
        var len = this.body.getSize();
        bw.writeU8(0x80 | 0x40 | this.type);

        if (len < 192) {
          bw.writeU8(len);
        } else if (len < 8384) {
          len -= 192;
          bw.writeU8(192 + (len >>> 8));
          bw.writeU8(len & 0xff);
        } else {
          bw.writeU8(255);
          bw.writeU32BE(len);
        }

        this.body.write(bw);
        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        var ch = br.readU8();
        if ((ch & 0x80) === 0) throw new Error('Hi bit unset in PGP packet header.');
        var type = 0;
        var child = null;

        if ((ch & 0x40) === 0) {
          var t = (ch & 0x3f) >>> 2;
          var s = 1 << (ch & 3);
          var size = 0;

          switch (s) {
            case 1:
              size = br.readU8();
              break;

            case 2:
              size = br.readU16BE();
              break;

            case 4:
              size = br.readU32BE();
              break;

            case 8:
              size = br.left();
              break;
          }

          type = t;
          child = br.readChild(size);
        } else {
          var _t = ch & 0x3f;

          var _s = br.readU8();

          var _size = 0;

          if (_s < 192) {
            _size = _s;
          } else if (_s < 224) {
            _size = (_s - 192) * 0x100;
            _size += br.readU8() + 192;
          } else if (_s < 255) {
            throw new Error('Cannot handle PGP partial length.');
          } else {
            _size = br.readU32BE();
          }

          type = _t;
          child = br.readChild(_size);
        }

        this.type = type;

        switch (this.type) {
          case packetTypes.PUBKEY_ENC:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.SIGNATURE:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.SYMKEY_ENC:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.ONEPASS_SIG:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.PRIVATE_KEY:
            this.body = PGPPrivateKey.read(child);
            break;

          case packetTypes.PUBLIC_KEY:
            this.body = PGPPublicKey.read(child);
            break;

          case packetTypes.PRIVATE_SUBKEY:
            this.body = PGPPrivateKey.read(child);
            break;

          case packetTypes.COMPRESSED:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.ENCRYPTED:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.MARKER:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.PLAINTEXT:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.RING_TRUST:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.USER_ID:
            this.body = PGPUserID.read(child);
            break;

          case packetTypes.PUBLIC_SUBKEY:
            this.body = PGPPublicKey.read(child);
            break;

          case packetTypes.OLD_COMMENT:
            this.body = PGPPublicKey.read(child);
            break;

          case packetTypes.ATTRIBUTE:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.ENCRYPTED_MDC:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.MDC:
            this.body = PGPUnknown.read(child);
            break;

          case packetTypes.ENCRYPTED_AEAD:
            this.body = PGPUnknown.read(child);
            break;

          default:
            this.body = PGPUnknown.read(child);
            break;
        }

        return this;
      }
    }, {
      key: "format",
      value: function format() {
        return {
          type: packetTypesByVal[this.type] || 'UNKNOWN',
          body: this.body
        };
      }
    }]);

    return PGPPacket;
  }(bufio.Struct);
  /**
   * PGP Body
   */


  var PGPBody = /*#__PURE__*/function (_bio$Struct3) {
    _inherits__default['default'](PGPBody, _bio$Struct3);

    var _super3 = _createSuper$D(PGPBody);

    function PGPBody() {
      _classCallCheck__default['default'](this, PGPBody);

      return _super3.call(this);
    }

    return PGPBody;
  }(bufio.Struct);
  /**
   * PGP Unknown
   */


  var PGPUnknown = /*#__PURE__*/function (_PGPBody) {
    _inherits__default['default'](PGPUnknown, _PGPBody);

    var _super4 = _createSuper$D(PGPUnknown);

    function PGPUnknown() {
      var _this3;

      _classCallCheck__default['default'](this, PGPUnknown);

      _this3 = _super4.call(this);
      _this3.data = EMPTY$9;
      return _this3;
    }

    _createClass__default['default'](PGPUnknown, [{
      key: "getSize",
      value: function getSize() {
        return this.data.length;
      }
    }, {
      key: "write",
      value: function write(bw) {
        bw.writeBytes(this.data);
        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        this.data = br.readBytes(br.left());
        return this;
      }
    }, {
      key: "format",
      value: function format() {
        return {
          data: this.data.toString('hex')
        };
      }
    }]);

    return PGPUnknown;
  }(PGPBody);
  /**
   * PGP Public Key
   */


  var PGPPublicKey = /*#__PURE__*/function (_PGPBody2) {
    _inherits__default['default'](PGPPublicKey, _PGPBody2);

    var _super5 = _createSuper$D(PGPPublicKey);

    function PGPPublicKey() {
      var _this4;

      _classCallCheck__default['default'](this, PGPPublicKey);

      _this4 = _super5.call(this);
      _this4.version = 4;
      _this4.algorithm = 0;
      _this4.expires = 0;
      _this4.timestamp = 0; // RSA

      _this4.n = new MPI();
      _this4.e = new MPI(); // El Gamal

      _this4.p = new MPI();
      _this4.g = new MPI();
      _this4.y = new MPI(); // DSA

      _this4.p;
      _this4.q = new MPI();
      _this4.g;
      _this4.y; // ECDH

      _this4.oid = EMPTY$9;
      _this4.point = new MPI();
      _this4.kdfHash = 0;
      _this4.kdfAlg = 0; // ECDSA

      _this4.oid;
      _this4.point; // Unknown

      _this4.data = EMPTY$9;
      return _this4;
    }

    _createClass__default['default'](PGPPublicKey, [{
      key: "isRSA",
      value: function isRSA() {
        switch (this.algorithm) {
          case keyTypes.RSA:
          case keyTypes.RSA_ENCRYPT_ONLY:
          case keyTypes.RSA_SIGN_ONLY:
            return true;
        }

        return false;
      }
    }, {
      key: "isElgamal",
      value: function isElgamal() {
        switch (this.algorithm) {
          case keyTypes.ELGAMAL:
          case keyTypes.ELGAMAL_LEGACY:
            return true;
        }

        return false;
      }
    }, {
      key: "getSize",
      value: function getSize() {
        var size = 0;
        size += 1;

        switch (this.version) {
          case 2:
          case 3:
            {
              size += 4;
              size += 2;
              size += 1;
              break;
            }

          case 4:
            {
              size += 4;
              size += 1;
              break;
            }

          default:
            {
              throw new Error('Unknown PGP key version.');
            }
        }

        switch (this.algorithm) {
          case keyTypes.RSA:
          case keyTypes.RSA_ENCRYPT_ONLY:
          case keyTypes.RSA_SIGN_ONLY:
            {
              size += this.n.getSize();
              size += this.e.getSize();
              break;
            }

          case keyTypes.ELGAMAL:
          case keyTypes.ELGAMAL_LEGACY:
            {
              size += this.p.getSize();
              size += this.g.getSize();
              size += this.y.getSize();
              break;
            }

          case keyTypes.DSA:
            {
              size += this.p.getSize();
              size += this.q.getSize();
              size += this.g.getSize();
              size += this.y.getSize();
              break;
            }

          case keyTypes.ECDH:
            {
              size += 1;
              size += this.oid.length;
              size += this.point.getSize();
              size += 4;
              break;
            }

          case keyTypes.ECDSA:
          case keyTypes.EDDSA:
            {
              size += 1;
              size += this.oid.length;
              size += this.point.getSize();
              break;
            }

          default:
            {
              size += this.data.length;
              break;
            }
        }

        return size;
      }
    }, {
      key: "write",
      value: function write(bw) {
        bw.writeU8(this.version);

        switch (this.version) {
          case 2:
          case 3:
            {
              if (!this.isRSA()) throw new Error('Unknown PGP key algorithm.');
              bw.writeU32BE(this.timestamp);
              bw.writeU16BE(this.expires);
              bw.writeU8(this.algorithm);
              break;
            }

          case 4:
            {
              bw.writeU32BE(this.timestamp);
              bw.writeU8(this.algorithm);
              break;
            }

          default:
            {
              throw new Error('Unknown PGP key version.');
            }
        }

        switch (this.algorithm) {
          case keyTypes.RSA:
          case keyTypes.RSA_ENCRYPT_ONLY:
          case keyTypes.RSA_SIGN_ONLY:
            {
              this.n.write(bw);
              this.e.write(bw);
              break;
            }

          case keyTypes.ELGAMAL:
          case keyTypes.ELGAMAL_LEGACY:
            {
              this.p.write(bw);
              this.g.write(bw);
              this.y.write(bw);
              break;
            }

          case keyTypes.DSA:
            {
              this.p.write(bw);
              this.q.write(bw);
              this.g.write(bw);
              this.y.write(bw);
              break;
            }

          case keyTypes.ECDH:
            {
              bw.writeU8(this.oid.length);
              bw.writeBytes(this.oid);
              this.point.write(bw);
              bw.writeU8(3);
              bw.writeU8(0x01);
              bw.writeU8(this.kdfHash);
              bw.writeU8(this.kdfAlg);
              break;
            }

          case keyTypes.ECDSA:
          case keyTypes.EDDSA:
            {
              bw.writeU8(this.oid.length);
              bw.writeBytes(this.oid);
              this.point.write(bw);
              break;
            }

          default:
            {
              bw.writeBytes(this.data);
              break;
            }
        }

        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        this.version = br.readU8();

        switch (this.version) {
          case 2:
          case 3:
            {
              this.timestamp = br.readU32BE();
              this.expires = br.readU16BE();
              this.algorithm = br.readU8();

              if (!this.isRSA()) {
                if (this.version === 3 && this.isElgamal()) {
                  this.expires = 0;
                  this.version = 4;
                } else {
                  throw new Error('Unknown PGP key algorithm.');
                }
              }

              break;
            }

          case 4:
            {
              this.timestamp = br.readU32BE();
              this.algorithm = br.readU8();
              break;
            }

          default:
            {
              throw new Error('Unknown PGP key version.');
            }
        }

        switch (this.algorithm) {
          case keyTypes.RSA:
          case keyTypes.RSA_ENCRYPT_ONLY:
          case keyTypes.RSA_SIGN_ONLY:
            {
              this.n.read(br);
              this.e.read(br);
              break;
            }

          case keyTypes.ELGAMAL:
          case keyTypes.ELGAMAL_LEGACY:
            {
              this.p.read(br);
              this.g.read(br);
              this.y.read(br);
              break;
            }

          case keyTypes.DSA:
            {
              this.p.read(br);
              this.q.read(br);
              this.g.read(br);
              this.y.read(br);
              break;
            }

          case keyTypes.ECDH:
            {
              this.oid = br.readBytes(br.readU8());
              this.point.read(br);
              var size = br.readU8();
              if (size < 3 || size > br.left()) throw new Error('Invalid ECDH params.'); // Reserved.

              if (br.readU8() !== 0x01) throw new Error('Invalid ECDH reserved byte.');
              this.kdfHash = br.readU8();
              this.kdfAlg = br.readU8();
              break;
            }

          case keyTypes.ECDSA:
          case keyTypes.EDDSA:
            {
              this.oid = br.readBytes(br.readU8());
              this.point.read(br);
              break;
            }

          default:
            {
              this.data = br.readBytes(br.left());
              break;
            }
        }

        return this;
      }
    }, {
      key: "fingerprint",
      value: function fingerprint() {
        switch (this.version) {
          case 2:
          case 3:
            {
              if (!this.isRSA()) throw new Error('Unknown PGP key algorithm.');
              var data = bufio.concat(this.n.data, this.e.data);
              return md5Browser.digest(data);
            }

          case 4:
            {
              var size = this.getSize();
              var bw = bufio.write(3 + size);
              bw.writeU8(0x99);
              bw.writeU16BE(size);
              this.write(bw);
              return sha1Browser.digest(bw.render());
            }

          default:
            {
              throw new Error('Unknown PGP key version.');
            }
        }
      }
    }, {
      key: "id",
      value: function id() {
        switch (this.version) {
          case 2:
          case 3:
            {
              if (!this.isRSA()) throw new Error('Unknown PGP key algorithm.');
              if (this.n.data.length < 8) throw new Error('Unknown PGP key algorithm.');
              return this.n.data.slice(this.n.data.length - 8);
            }

          case 4:
            {
              return this.fingerprint().slice(12, 20);
            }

          default:
            {
              throw new Error('Unknown PGP key version.');
            }
        }
      }
    }, {
      key: "long",
      value: function long() {
        return this.id();
      }
    }, {
      key: "short",
      value: function short() {
        return this.id().slice(4, 8);
      }
    }, {
      key: "matches",
      value: function matches(id) {
        if (typeof id === 'string') id = decodeID(id);

        switch (id.length) {
          case 4:
            return this.short().equals(id);

          case 8:
            return this.long().equals(id);

          case 16:
          case 20:
            return this.fingerprint().equals(id);

          default:
            return false;
        }
      }
    }, {
      key: "keyHash",
      value: function keyHash() {
        var size = 6;
        if (this.version !== 4) size += 2; // Create a real key hash without any bullshit.

        var raw = this.encode().slice(size - 1);
        raw[0] = this.algorithm;
        return sha256Browser.digest(raw);
      }
    }, {
      key: "format",
      value: function format() {
        var algorithm = keyTypesByVal[this.algorithm] || 'UNKNOWN';
        var version = this.version;
        var timestamp = this.timestamp;
        var expires = this.expires;

        switch (this.algorithm) {
          case keyTypes.RSA:
          case keyTypes.RSA_ENCRYPT_ONLY:
          case keyTypes.RSA_SIGN_ONLY:
            {
              return {
                version: version,
                algorithm: algorithm,
                timestamp: timestamp,
                expires: expires,
                n: this.n.data.toString('hex'),
                e: this.e.data.toString('hex')
              };
            }

          case keyTypes.ELGAMAL:
          case keyTypes.ELGAMAL_LEGACY:
            {
              return {
                version: version,
                algorithm: algorithm,
                timestamp: timestamp,
                expires: expires,
                p: this.p.data.toString('hex'),
                g: this.g.data.toString('hex'),
                y: this.y.data.toString('hex')
              };
            }

          case keyTypes.DSA:
            {
              return {
                version: version,
                algorithm: algorithm,
                timestamp: timestamp,
                expires: expires,
                p: this.p.data.toString('hex'),
                q: this.q.data.toString('hex'),
                g: this.g.data.toString('hex'),
                y: this.y.data.toString('hex')
              };
            }

          case keyTypes.ECDH:
            {
              return {
                version: version,
                algorithm: algorithm,
                timestamp: timestamp,
                expires: expires,
                curve: curveTypesByVal[this.curve] || 'UNKNOWN',
                point: this.point.data.toString('hex'),
                kdfHash: this.kdfHash,
                kdfAlg: this.kdfAlg
              };
            }

          case keyTypes.ECDSA:
          case keyTypes.EDDSA:
            {
              return {
                version: version,
                algorithm: algorithm,
                timestamp: timestamp,
                expires: expires,
                curve: curveTypesByVal[this.curve] || 'UNKNOWN',
                point: this.point.data.toString('hex')
              };
            }

          default:
            {
              return {
                version: version,
                algorithm: algorithm,
                timestamp: timestamp,
                expires: expires,
                data: this.data.toString('hex')
              };
            }
        }
      }
    }, {
      key: "curve",
      get: function get() {
        if (this.oid.equals(oids.P256)) return curveTypes.P256;
        if (this.oid.equals(oids.P384)) return curveTypes.P384;
        if (this.oid.equals(oids.P521)) return curveTypes.P521;
        if (this.oid.equals(oids.SECP256K1)) return curveTypes.SECP256K1;
        if (this.oid.equals(oids.X25519)) return curveTypes.X25519;
        if (this.oid.equals(oids.BRAINPOOLP256)) return curveTypes.BRAINPOOLP256;
        if (this.oid.equals(oids.BRAINPOOLP384)) return curveTypes.BRAINPOOLP384;
        if (this.oid.equals(oids.BRAINPOOLP512)) return curveTypes.BRAINPOOLP512;
        if (this.oid.equals(oids.ED25519)) return curveTypes.ED25519;
        return 0;
      },
      set: function set(value) {
        switch (value) {
          case curveTypes.P256:
            this.oid = oids.P256;
            break;

          case curveTypes.P384:
            this.oid = oids.P384;
            break;

          case curveTypes.P521:
            this.oid = oids.P521;
            break;

          case curveTypes.SECP256K1:
            this.oid = oids.SECP256K1;
            break;

          case curveTypes.X25519:
            this.oid = oids.X25519;
            break;

          case curveTypes.BRAINPOOLP256:
            this.oid = oids.BRAINPOOLP256;
            break;

          case curveTypes.BRAINPOOLP384:
            this.oid = oids.BRAINPOOLP384;
            break;

          case curveTypes.BRAINPOOLP512:
            this.oid = oids.BRAINPOOLP512;
            break;

          case curveTypes.ED25519:
            this.oid = oids.ED25519;
            break;
        }
      }
    }]);

    return PGPPublicKey;
  }(PGPBody);
  /**
   * PGP Private Key
   */


  var PGPPrivateKey = /*#__PURE__*/function (_PGPBody3) {
    _inherits__default['default'](PGPPrivateKey, _PGPBody3);

    var _super6 = _createSuper$D(PGPPrivateKey);

    function PGPPrivateKey() {
      var _this5;

      _classCallCheck__default['default'](this, PGPPrivateKey);

      _this5 = _super6.call(this);
      _this5.key = new PGPPublicKey();
      _this5.params = new CipherParams();
      _this5.data = EMPTY$9;
      return _this5;
    }

    _createClass__default['default'](PGPPrivateKey, [{
      key: "secret",
      value: function secret(passphrase) {
        var data = this.data;

        if (this.params.encrypted) {
          if (passphrase == null) throw new Error('Key requires a passphrase.');
          data = this.params.decrypt(data, passphrase);
        }

        return SecretKey.decode(data, this.key.algorithm);
      }
    }, {
      key: "getSize",
      value: function getSize() {
        var size = 0;
        size += this.key.getSize();
        size += this.params.getSize();
        size += this.data.length;
        return size;
      }
    }, {
      key: "write",
      value: function write(bw) {
        this.key.write(bw);
        this.params.write(bw);
        bw.writeBytes(this.data);
        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        this.key.read(br);
        this.params.read(br);
        this.data = br.readBytes(br.left());
        return this;
      }
    }, {
      key: "format",
      value: function format() {
        var params = null;
        var data = null;

        if (this.params.encrypted) {
          params = this.params;
          data = this.data.toString('hex');
        } else {
          params = null;
          data = this.secret();
        }

        return {
          key: this.key,
          params: params,
          data: data
        };
      }
    }]);

    return PGPPrivateKey;
  }(PGPBody);
  /**
   * Cipher Params
   */


  var CipherParams = /*#__PURE__*/function (_bio$Struct4) {
    _inherits__default['default'](CipherParams, _bio$Struct4);

    var _super7 = _createSuper$D(CipherParams);

    function CipherParams() {
      var _this6;

      _classCallCheck__default['default'](this, CipherParams);

      _this6 = _super7.call(this);
      _this6.encrypted = false;
      _this6.checksum = false;
      _this6.cipher = 0;
      _this6.s2k = new S2K();
      _this6.iv = EMPTY$9;
      return _this6;
    }

    _createClass__default['default'](CipherParams, [{
      key: "blockSize",
      value: function blockSize() {
        switch (this.cipher) {
          case cipherTypes.IDEA:
          case cipherTypes.DES3:
          case cipherTypes.CAST5:
          case cipherTypes.BLOWFISH:
            return 8;

          case cipherTypes.AES128:
          case cipherTypes.AES192:
          case cipherTypes.AES256:
          case cipherTypes.TWOFISH:
          case cipherTypes.CAMELLIA128:
          case cipherTypes.CAMELLIA192:
          case cipherTypes.CAMELLIA256:
            return 16;

          default:
            throw new Error('Unknown cipher type.');
        }
      }
    }, {
      key: "keySize",
      value: function keySize() {
        switch (this.cipher) {
          case cipherTypes.IDEA:
            return 16;

          case cipherTypes.DES3:
            return 24;

          case cipherTypes.CAST5:
            return 16;

          case cipherTypes.BLOWFISH:
            return 16;

          case cipherTypes.AES128:
            return 16;

          case cipherTypes.AES192:
            return 24;

          case cipherTypes.AES256:
            return 32;

          case cipherTypes.TWOFISH:
            return 32;

          case cipherTypes.CAMELLIA128:
            return 16;

          case cipherTypes.CAMELLIA192:
            return 24;

          case cipherTypes.CAMELLIA256:
            return 32;

          default:
            throw new Error('Unknown cipher type.');
        }
      }
    }, {
      key: "algName",
      value: function algName() {
        switch (this.cipher) {
          case cipherTypes.IDEA:
            return 'IDEA-CFB';

          case cipherTypes.DES3:
            return 'DES-EDE3-CFB';

          case cipherTypes.CAST5:
            return 'CAST5-CFB';

          case cipherTypes.BLOWFISH:
            return 'BF-CFB';

          case cipherTypes.AES128:
            return 'AES-128-CFB';

          case cipherTypes.AES192:
            return 'AES-192-CFB';

          case cipherTypes.AES256:
            return 'AES-256-CFB';

          case cipherTypes.TWOFISH:
            return 'TWOFISH-256-CFB';

          case cipherTypes.CAMELLIA128:
            return 'CAMELLIA-128-CFB';

          case cipherTypes.CAMELLIA192:
            return 'CAMELLIA-192-CFB';

          case cipherTypes.CAMELLIA256:
            return 'CAMELLIA-256-CFB';

          default:
            throw new Error('Unknown cipher type.');
        }
      }
    }, {
      key: "derive",
      value: function derive(passphrase) {
        if (!this.encrypted) throw new Error('Cannot derive passphrase.');
        return this.s2k.derive(passphrase, this.keySize());
      }
    }, {
      key: "encipher",
      value: function encipher(pt, key) {
        assert_1$1(Buffer.isBuffer(pt));
        var name = this.algName();
        var add = this.checksum ? 20 : 2;
        var padded = Buffer.alloc(pt.length + add);
        pt.copy(padded, 0);

        if (this.checksum) {
          sha1Browser.digest(pt).copy(padded, pt.length);
        } else {
          var sum = 0;

          for (var i = 0; i < pt.length; i++) {
            sum += pt[i];
            sum &= 0xffff;
          }

          bufio.writeU16BE(padded, sum, pt.length);
        }

        return cipherBrowser.encrypt(name, key, this.iv, padded);
      }
    }, {
      key: "decipher",
      value: function decipher(ct, key) {
        var name = this.algName();
        var padded = cipherBrowser.decrypt(name, key, this.iv, ct);

        if (this.checksum) {
          if (padded.length < 20) throw new Error('Truncated data.');

          var _pt = padded.slice(0, -20);

          var _chk = padded.slice(-20);

          var _sum = sha1Browser.digest(_pt);

          if (!_sum.equals(_chk)) throw new Error('Invalid checksum.');
          return _pt;
        }

        if (padded.length < 2) throw new Error('Truncated data.');
        var pt = padded.slice(0, -2);
        var chk = bufio.readU16BE(padded, padded.length - 2);
        var sum = 0;

        for (var i = 0; i < pt.length; i++) {
          sum += pt[i];
          sum &= 0xffff;
        }

        if (sum !== chk) throw new Error('Invalid checksum.');
        return pt;
      }
    }, {
      key: "encrypt",
      value: function encrypt(data, passphrase) {
        var key = this.derive(passphrase);
        return this.encipher(data, key);
      }
    }, {
      key: "decrypt",
      value: function decrypt(data, passphrase) {
        var key = this.derive(passphrase);
        return this.decipher(data, key);
      }
    }, {
      key: "getSize",
      value: function getSize() {
        var size = 0;

        if (this.encrypted) {
          size += 1;
          size += 1;
          size += this.s2k.getSize();
          size += this.iv.length;
        } else {
          size += 1;
        }

        return size;
      }
    }, {
      key: "write",
      value: function write(bw) {
        if (this.encrypted) {
          assert_1$1(this.iv.length === this.blockSize());
          bw.writeU8(this.checksum ? 0xfe : 0xff);
          bw.writeU8(this.cipher);
          this.s2k.write(bw);
          bw.writeBytes(this.iv);
        } else {
          bw.writeU8(0x00);
        }

        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        var type = br.readU8();

        switch (type) {
          case 0x00:
            break;

          case 0xfe:
          case 0xff:
            this.encrypted = true;
            this.checksum = type === 0xfe;
            this.cipher = br.readU8();
            this.s2k.read(br);
            this.iv = br.readBytes(this.blockSize());
            break;

          default:
            throw new Error('Unknown S2K type.');
        }

        return this;
      }
    }, {
      key: "format",
      value: function format() {
        return {
          encrypted: this.encrypted,
          checksum: this.checksum,
          cipher: cipherTypesByVal[this.cipher] || 'UNKNOWN',
          s2k: this.s2k,
          iv: this.iv.toString('hex')
        };
      }
    }]);

    return CipherParams;
  }(bufio.Struct);
  /**
   * S2K
   */


  var S2K = /*#__PURE__*/function (_bio$Struct5) {
    _inherits__default['default'](S2K, _bio$Struct5);

    var _super8 = _createSuper$D(S2K);

    function S2K() {
      var _this7;

      _classCallCheck__default['default'](this, S2K);

      _this7 = _super8.call(this);
      _this7.mode = 0;
      _this7.hash = 0;
      _this7.count = 0;
      _this7.salt = EMPTY$9;
      _this7.serial = EMPTY$9;
      return _this7;
    }

    _createClass__default['default'](S2K, [{
      key: "derive",
      value: function derive(passphrase, size) {
        assert_1$1(typeof passphrase === 'string');
        assert_1$1(size >>> 0 === size);
        var salt = this.salt,
            count = this.count;
        var input = Buffer.from(passphrase, 'binary');
        var hash = hashToHash[this.hash];
        if (!hash) throw new Error('Unknown hash.');

        switch (this.mode) {
          case 0:
            return pgpdfBrowser.deriveSimple(hash, input, size);

          case 1:
            return pgpdfBrowser.deriveSalted(hash, input, salt, size);

          case 3:
            return pgpdfBrowser.deriveIterated(hash, input, salt, count, size);

          default:
            throw new Error('Unknown S2K mode.');
        }
      }
    }, {
      key: "getSize",
      value: function getSize() {
        var size = 2;

        switch (this.mode) {
          case 0:
            break;

          case 1:
            size += 8;
            break;

          case 3:
            size += 8;
            size += 1;
            break;

          case 1001:
            size += 3;
            size += 1;
            break;

          case 1002:
            size += 3;
            size += 1;
            size += 1;
            size += this.serial.length;
            break;

          default:
            throw new Error('Unknown S2K function.');
        }

        return size;
      }
    }, {
      key: "write",
      value: function write(bw) {
        bw.writeU8(this.mode > 0xff ? 101 : this.mode);
        bw.writeU8(this.hash);

        switch (this.mode) {
          case 0:
            break;

          case 1:
            bw.writeBytes(this.salt);
            break;

          case 3:
            bw.writeBytes(this.salt);
            bw.writeU8(encodeCount(this.count));
            break;

          case 1001:
            bw.writeString('GNU', 'binary');
            bw.writeU8(1);
            break;

          case 1002:
            bw.writeString('GNU', 'binary');
            bw.writeU8(2);
            bw.writeU8(this.serial.length);
            bw.writeBytes(this.serial);
            break;

          default:
            throw new Error('Unknown S2K function.');
        }

        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        this.mode = br.readU8();
        this.hash = br.readU8();

        switch (this.mode) {
          case 0:
            {
              break;
            }

          case 1:
            {
              this.salt = br.readBytes(8);
              break;
            }

          case 3:
            {
              this.salt = br.readBytes(8);
              this.count = decodeCount(br.readU8());
              break;
            }

          case 101:
            {
              // GNU extensions.
              // See: https://github.com/handshake-org/hs-airdrop/issues/44
              var tag = br.readString(3, 'binary');
              if (tag !== 'GNU') throw new Error('Unknown S2K function.');
              this.mode = 1000 + br.readU8();

              switch (this.mode) {
                case 1001:
                  // gnu-dummy
                  break;

                case 1002:
                  // gnu-divert-to-card
                  this.serial = br.readBytes(Math.min(br.readU8(), 16));
                  break;

                default:
                  throw new Error('Unknown S2K function.');
              }

              break;
            }

          default:
            {
              throw new Error('Unknown S2K function.');
            }
        }

        return this;
      }
    }, {
      key: "format",
      value: function format() {
        return {
          mode: this.mode,
          hash: hashTypesByVal[this.hash] || 'UNKNOWN',
          count: this.count,
          salt: this.salt.toString('hex'),
          serial: this.serial.toString('hex')
        };
      }
    }]);

    return S2K;
  }(bufio.Struct);
  /**
   * Secret Key
   */


  var SecretKey = /*#__PURE__*/function (_bio$Struct6) {
    _inherits__default['default'](SecretKey, _bio$Struct6);

    var _super9 = _createSuper$D(SecretKey);

    function SecretKey() {
      var _this8;

      _classCallCheck__default['default'](this, SecretKey);

      _this8 = _super9.call(this); // RSA

      _this8.d = new MPI();
      _this8.q = new MPI();
      _this8.p = new MPI();
      _this8.qi = new MPI(); // DSA

      _this8.x = new MPI(); // El Gamal

      _this8.x; // ECDSA

      _this8.d;
      return _this8;
    }

    _createClass__default['default'](SecretKey, [{
      key: "getSize",
      value: function getSize(algorithm) {
        assert_1$1((algorithm & 0xff) === algorithm);
        var size = 0;

        switch (algorithm) {
          case keyTypes.RSA:
          case keyTypes.RSA_ENCRYPT_ONLY:
          case keyTypes.RSA_SIGN_ONLY:
            {
              size += this.d.getSize();
              size += this.q.getSize();
              size += this.p.getSize();
              size += this.qi.getSize();
              break;
            }

          case keyTypes.ELGAMAL:
          case keyTypes.ELGAMAL_LEGACY:
            {
              size += this.x.getSize();
              break;
            }

          case keyTypes.DSA:
            {
              size += this.x.getSize();
              break;
            }

          case keyTypes.ECDSA:
          case keyTypes.EDDSA:
            {
              size += this.d.getSize();
              break;
            }

          default:
            {
              throw new Error('Unknown key type.');
            }
        }

        return size;
      }
    }, {
      key: "write",
      value: function write(bw, algorithm) {
        assert_1$1((algorithm & 0xff) === algorithm);

        switch (algorithm) {
          case keyTypes.RSA:
          case keyTypes.RSA_ENCRYPT_ONLY:
          case keyTypes.RSA_SIGN_ONLY:
            {
              this.d.write(bw);
              this.q.write(bw);
              this.p.write(bw);
              this.qi.write(bw);
              break;
            }

          case keyTypes.ELGAMAL:
          case keyTypes.ELGAMAL_LEGACY:
            {
              this.x.write(bw);
              break;
            }

          case keyTypes.DSA:
            {
              this.x.write(bw);
              break;
            }

          case keyTypes.ECDSA:
          case keyTypes.EDDSA:
            {
              this.d.write(bw);
              break;
            }

          default:
            {
              throw new Error('Unknown key type.');
            }
        }

        return bw;
      }
    }, {
      key: "read",
      value: function read(br, algorithm) {
        assert_1$1((algorithm & 0xff) === algorithm);

        switch (algorithm) {
          case keyTypes.RSA:
          case keyTypes.RSA_ENCRYPT_ONLY:
          case keyTypes.RSA_SIGN_ONLY:
            {
              this.d.read(br);
              this.q.read(br);
              this.p.read(br);
              this.qi.read(br);
              break;
            }

          case keyTypes.ELGAMAL:
          case keyTypes.ELGAMAL_LEGACY:
            {
              this.x.read(br);
              break;
            }

          case keyTypes.DSA:
            {
              this.x.read(br);
              break;
            }

          case keyTypes.ECDSA:
          case keyTypes.EDDSA:
            {
              this.d.read(br);
              break;
            }

          default:
            {
              throw new Error('Unknown key type.');
            }
        }

        return this;
      }
    }, {
      key: "format",
      value: function format() {
        if (this.p.data.length > 0) {
          return {
            d: this.d.data.toString('hex'),
            q: this.q.data.toString('hex'),
            p: this.p.data.toString('hex'),
            qi: this.qi.data.toString('hex')
          };
        }

        if (this.x.data.length > 0) {
          return {
            x: this.x.data.toString('hex')
          };
        }

        if (this.d.data.length > 0) {
          return {
            d: this.d.data.toString('hex')
          };
        }

        return {
          d: this.d.data.toString('hex'),
          q: this.q.data.toString('hex'),
          p: this.p.data.toString('hex'),
          qi: this.qi.data.toString('hex'),
          x: this.x.data.toString('hex')
        };
      }
    }]);

    return SecretKey;
  }(bufio.Struct);
  /**
   * PGP User ID
   */


  var PGPUserID = /*#__PURE__*/function (_PGPBody4) {
    _inherits__default['default'](PGPUserID, _PGPBody4);

    var _super10 = _createSuper$D(PGPUserID);

    function PGPUserID() {
      var _this9;

      _classCallCheck__default['default'](this, PGPUserID);

      _this9 = _super10.call(this);
      _this9.id = '';
      return _this9;
    }

    _createClass__default['default'](PGPUserID, [{
      key: "getSize",
      value: function getSize() {
        return Buffer.byteLength(this.id, 'utf8');
      }
    }, {
      key: "write",
      value: function write(bw) {
        bw.writeString(this.id, 'utf8');
        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        this.id = br.readString(br.left(), 'utf8');
        return this;
      }
    }, {
      key: "format",
      value: function format() {
        return {
          id: this.id
        };
      }
    }]);

    return PGPUserID;
  }(PGPBody);
  /**
   * MPI
   */


  var MPI = /*#__PURE__*/function (_bio$Struct7) {
    _inherits__default['default'](MPI, _bio$Struct7);

    var _super11 = _createSuper$D(MPI);

    function MPI(data) {
      var _this10;

      _classCallCheck__default['default'](this, MPI);

      _this10 = _super11.call(this);
      _this10.bits = 0;
      _this10.data = EMPTY$9;
      if (data != null) _this10.fromOptions(data);
      return _this10;
    }

    _createClass__default['default'](MPI, [{
      key: "get",
      value: function get() {
        return this.data;
      }
    }, {
      key: "set",
      value: function set(data) {
        return this.fromOptions(data);
      }
    }, {
      key: "fromOptions",
      value: function fromOptions(data) {
        assert_1$1(Buffer.isBuffer(data));
        this.bits = countLeft$1(data);
        this.data = data;
        return this;
      }
    }, {
      key: "getSize",
      value: function getSize() {
        return 2 + this.data.length;
      }
    }, {
      key: "write",
      value: function write(bw) {
        bw.writeU16BE(this.bits);
        bw.writeBytes(this.data);
        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        if (br.left() === 0) return this;
        var bits = br.readU16BE();
        var size = bits + 7 >>> 3;
        var s = Math.min(size, br.left());
        var data = br.readBytes(s);
        this.bits = bits;
        this.data = data;
        return this;
      }
    }]);

    return MPI;
  }(bufio.Struct);
  /*
   * ID Parsing
   */


  function encodeID(raw) {
    assert_1$1(Buffer.isBuffer(raw));

    switch (raw.length) {
      case 4:
      case 8:
      case 16:
      case 20:
        break;

      default:
        throw new Error('Invalid PGP key id/fingerprint.');
    }

    var id = raw.toString('hex');
    return "0x".concat(id.toUpperCase());
  }

  function decodeID(id) {
    assert_1$1(typeof id === 'string');
    id = id.replace(/[\t ]/g, '');

    if (id.length >= 2 && id.charCodeAt(0) === 0x30 && (id.charCodeAt(1) | 0x20) === 0x78) {
      id = id.substring(2);
    }

    if (id.length > 40) throw new Error('Invalid PGP key id/fingerprint.');
    var raw = Buffer.from(id, 'hex');
    if (raw.length !== id.length >>> 1) throw new Error('Invalid PGP key id/fingerprint.');

    switch (raw.length) {
      case 4:
      case 8:
      case 16:
      case 20:
        break;

      default:
        throw new Error('Invalid PGP key id/fingerprint.');
    }

    return raw;
  }
  /*
   * Helpers
   */


  function encodeCount(i) {
    assert_1$1(i >>> 0 === i);
    if (i < 1024 || i > 65011712) throw new RangeError('Invalid iteration count.');

    for (var j = 0; j < 256; j++) {
      var c = decodeCount(j);
      if (c >= i) return j;
    }

    return 255;
  }

  function decodeCount(c) {
    assert_1$1((c & 0xff) === c);
    return 16 + (c & 15) << (c >>> 4) + 6;
  }
  /*
   * Expose
   */


  var packetTypes_1 = packetTypes;
  var packetTypesByVal_1 = packetTypesByVal;
  var sigTypes_1 = sigTypes;
  var sigTypesByVal_1 = sigTypesByVal;
  var keyTypes_1 = keyTypes;
  var keyTypesByVal_1 = keyTypesByVal;
  var cipherTypes_1 = cipherTypes;
  var cipherTypesByVal_1 = cipherTypesByVal;
  var hashTypes_1 = hashTypes;
  var hashTypesByVal_1 = hashTypesByVal;
  var compressTypes_1 = compressTypes;
  var compressTypesByVal_1 = compressTypesByVal;
  var curveTypes_1 = curveTypes;
  var curveTypesByVal_1 = curveTypesByVal;
  var oids_1 = oids;
  var PGPMessage_1 = PGPMessage;
  var PGPPacket_1 = PGPPacket;
  var PGPBody_1 = PGPBody;
  var PGPUnknown_1 = PGPUnknown;
  var PGPPublicKey_1 = PGPPublicKey;
  var PGPPrivateKey_1 = PGPPrivateKey;
  var CipherParams_1 = CipherParams;
  var S2K_1 = S2K;
  var SecretKey_1 = SecretKey;
  var PGPUserID_1 = PGPUserID;
  var MPI_1 = MPI;
  var encodeID_1 = encodeID;
  var decodeID_1 = decodeID;
  var pgp = {
    packetTypes: packetTypes_1,
    packetTypesByVal: packetTypesByVal_1,
    sigTypes: sigTypes_1,
    sigTypesByVal: sigTypesByVal_1,
    keyTypes: keyTypes_1,
    keyTypesByVal: keyTypesByVal_1,
    cipherTypes: cipherTypes_1,
    cipherTypesByVal: cipherTypesByVal_1,
    hashTypes: hashTypes_1,
    hashTypesByVal: hashTypesByVal_1,
    compressTypes: compressTypes_1,
    compressTypesByVal: compressTypesByVal_1,
    curveTypes: curveTypes_1,
    curveTypesByVal: curveTypesByVal_1,
    oids: oids_1,
    PGPMessage: PGPMessage_1,
    PGPPacket: PGPPacket_1,
    PGPBody: PGPBody_1,
    PGPUnknown: PGPUnknown_1,
    PGPPublicKey: PGPPublicKey_1,
    PGPPrivateKey: PGPPrivateKey_1,
    CipherParams: CipherParams_1,
    S2K: S2K_1,
    SecretKey: SecretKey_1,
    PGPUserID: PGPUserID_1,
    MPI: MPI_1,
    encodeID: encodeID_1,
    decodeID: decodeID_1
  };

  /*
   * Safe
   */


  function safeCompare(x, y) {
    assert_1$1(Buffer.isBuffer(x));
    assert_1$1(Buffer.isBuffer(y));
    if (safeEqualInt(x.length, 0)) return safeEqualInt(y.length, 0); // Assumes `y` is the "constant size"
    // parameter. Note that constant size
    // doesn't necessarily mean secret.
    // Assuming we have a constant-size
    // secret key or passphrase. This
    // function should be called as:
    //
    // if (!safeCompare(input, key))
    //   throw new Error('Bad passphrase.');

    var v = x.length ^ y.length;

    for (var i = 0; i < y.length; i++) {
      v |= x[i % x.length] ^ y[i];
    }

    return v - 1 >>> 31;
  }

  function safeEqual$1(x, y) {
    assert_1$1(Buffer.isBuffer(x));
    assert_1$1(Buffer.isBuffer(y)); // Assumes the lengths of both
    // `x` and `y` are not secret.

    if (!safeEqualInt(x.length, y.length)) return 0;
    var v = 0;

    for (var i = 0; i < x.length; i++) {
      v |= x[i] ^ y[i];
    }

    return v - 1 >>> 31;
  }

  function safeEqualByte(x, y) {
    return safeEqualInt(x & 0xff, y & 0xff);
  }

  function safeEqualInt(x, y) {
    return (x ^ y) - 1 >>> 31;
  }

  function safeSelect(x, y, v) {
    return x & v - 1 | y & ~(v - 1);
  }

  function safeLT(x, y) {
    return x - y >>> 31;
  }

  function safeLTE(x, y) {
    return x - y - 1 >>> 31;
  }

  function safeGT(x, y) {
    return y - x >>> 31;
  }

  function safeGTE(x, y) {
    return y - x - 1 >>> 31;
  }

  function safeMin(x, y) {
    return safeSelect(x, y, safeLT(y, x));
  }

  function safeMax(x, y) {
    return safeSelect(x, y, safeGT(y, x));
  }

  function safeAbs(x) {
    return (x | 0) * (x >> 31 | 1);
  }

  function safeBool(x) {
    return (x >> 31 | -x >> 31) & 1;
  }

  function safeCopy(x, y, v) {
    assert_1$1(Buffer.isBuffer(x));
    assert_1$1(Buffer.isBuffer(y));
    assert_1$1(safeEqualInt(x.length, y.length));
    var xmask = v - 1 & 0xff;
    var ymask = ~(v - 1) & 0xff;

    for (var i = 0; i < x.length; i++) {
      x[i] = x[i] & xmask | y[i] & ymask;
    }
  }
  /*
   * Expose
   */


  var safeCompare_1 = safeCompare;
  var safeEqual_1 = safeEqual$1;
  var safeEqualByte_1 = safeEqualByte;
  var safeEqualInt_1 = safeEqualInt;
  var safeSelect_1 = safeSelect;
  var safeLT_1 = safeLT;
  var safeLTE_1 = safeLTE;
  var safeGT_1 = safeGT;
  var safeGTE_1 = safeGTE;
  var safeMin_1 = safeMin;
  var safeMax_1 = safeMax;
  var safeAbs_1 = safeAbs;
  var safeBool_1 = safeBool;
  var safeCopy_1 = safeCopy;
  var safe = {
    safeCompare: safeCompare_1,
    safeEqual: safeEqual_1,
    safeEqualByte: safeEqualByte_1,
    safeEqualInt: safeEqualInt_1,
    safeSelect: safeSelect_1,
    safeLT: safeLT_1,
    safeLTE: safeLTE_1,
    safeGT: safeGT_1,
    safeGTE: safeGTE_1,
    safeMin: safeMin_1,
    safeMax: safeMax_1,
    safeAbs: safeAbs_1,
    safeBool: safeBool_1,
    safeCopy: safeCopy_1
  };

  function _createSuper$E(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$E(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$E() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var randomPrime$1 = primes$1.randomPrime;
  var safeEqual$2 = safe.safeEqual,
      safeEqualByte$1 = safe.safeEqualByte,
      safeSelect$1 = safe.safeSelect,
      safeLTE$1 = safe.safeLTE;
  /*
   * Constants
   */

  var DEFAULT_BITS$1 = 2048;
  var DEFAULT_EXP = 65537;
  var MIN_BITS$1 = 512;
  var MAX_BITS$1 = 16384;
  var MIN_EXP = 3;
  var MAX_EXP = Math.pow(2, 33) - 1;
  var MAX_EXP_BITS = 33;
  var SALT_LENGTH_AUTO = 0;
  var SALT_LENGTH_HASH = -1;
  var PREFIX$1 = Buffer.alloc(8, 0x00);
  var EMPTY$a = Buffer.alloc(0);
  /**
   * PKCS1v1.5+ASN.1 DigestInfo prefixes.
   * @see [RFC8017] Page 45, Section 9.2.
   * @see [RFC8017] Page 63, Section B.1.
   * @const {Object}
   */

  var digestInfo = {
    __proto__: null,
    BLAKE2B160: Buffer.from('3027300f060b2b060104018d3a0c02010505000414', 'hex'),
    BLAKE2B256: Buffer.from('3033300f060b2b060104018d3a0c02010805000420', 'hex'),
    BLAKE2B384: Buffer.from('3043300f060b2b060104018d3a0c02010c05000430', 'hex'),
    BLAKE2B512: Buffer.from('3053300f060b2b060104018d3a0c02011005000440', 'hex'),
    BLAKE2S128: Buffer.from('3023300f060b2b060104018d3a0c02020405000410', 'hex'),
    BLAKE2S160: Buffer.from('3027300f060b2b060104018d3a0c02020505000414', 'hex'),
    BLAKE2S224: Buffer.from('302f300f060b2b060104018d3a0c0202070500041c', 'hex'),
    BLAKE2S256: Buffer.from('3033300f060b2b060104018d3a0c02020805000420', 'hex'),
    GOST94: Buffer.from('302e300a06062a850302021405000420', 'hex'),
    HASH160: Buffer.from([20]),
    HASH256: Buffer.from([32]),
    KECCAK224: Buffer.from([28]),
    KECCAK256: Buffer.from([32]),
    KECCAK384: Buffer.from([48]),
    KECCAK512: Buffer.from([64]),
    MD2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),
    MD4: Buffer.from('3020300c06082a864886f70d020405000410', 'hex'),
    MD5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),
    MD5SHA1: Buffer.from([36]),
    RIPEMD160: Buffer.from('3022300a060628cf0603003105000414', 'hex'),
    SHA1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),
    SHA224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),
    SHA256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),
    SHA384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),
    SHA512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),
    SHA3_224: Buffer.from('302d300d06096086480165030402070500041c', 'hex'),
    SHA3_256: Buffer.from('3031300d060960864801650304020805000420', 'hex'),
    SHA3_384: Buffer.from('3041300d060960864801650304020905000430', 'hex'),
    SHA3_512: Buffer.from('3051300d060960864801650304020a05000440', 'hex'),
    SHAKE128: Buffer.from('3021300d060960864801650304020b05000410', 'hex'),
    SHAKE256: Buffer.from('3031300d060960864801650304020c05000420', 'hex'),
    WHIRLPOOL: Buffer.from('304e300a060628cf0603003705000440', 'hex')
  };
  /**
   * RSAPublicKey
   */

  var RSAPublicKey$1 = /*#__PURE__*/function () {
    function RSAPublicKey() {
      _classCallCheck__default['default'](this, RSAPublicKey);

      this.n = new bnBrowser(0);
      this.e = new bnBrowser(0);
    }

    _createClass__default['default'](RSAPublicKey, [{
      key: "bits",
      value: function bits() {
        return this.n.bitLength();
      }
    }, {
      key: "size",
      value: function size() {
        return this.n.byteLength();
      }
    }, {
      key: "isSane",
      value: function isSane() {
        return this.n.sign() > 0 && this.e.sign() > 0 && this.n.bitLength() <= MAX_BITS$1 && this.e.bitLength() <= MAX_EXP_BITS;
      }
    }, {
      key: "verify",
      value: function verify() {
        // Sanity checks.
        if (!this.isSane()) return false; // n >= 2^511 and n mod 2 != 0

        if (this.n.bitLength() < MIN_BITS$1 || !this.n.isOdd()) return false; // e >= 3 and e mod 2 != 0

        if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd()) return false;
        return true;
      }
    }, {
      key: "encrypt",
      value: function encrypt(msg) {
        // [RFC8017] Page 13, Section 5.1.1.
        //           Page 16, Section 5.2.2.
        assert_1$1(Buffer.isBuffer(msg));
        var n = this.n,
            e = this.e;
        var m = bnBrowser.decode(msg);
        if (m.cmp(n) >= 0) throw new Error('Invalid RSA message size.'); // c = m^e mod n

        var c = m.powm(e, n);
        return c.encode('be', n.byteLength());
      }
    }, {
      key: "encode",
      value: function encode() {
        var size = asn1.sizeInt(this.n) + asn1.sizeInt(this.e);
        var out = Buffer.alloc(asn1.sizeSeq(size));
        var pos = 0;
        pos = asn1.writeSeq(out, pos, size);
        pos = asn1.writeInt(out, pos, this.n);
        pos = asn1.writeInt(out, pos, this.e);
        assert_1$1(pos === out.length);
        return out;
      }
    }, {
      key: "decode",
      value: function decode(data) {
        var pos = 0;
        pos = asn1.readSeq(data, pos);

        var _asn1$readInt = asn1.readInt(data, pos);

        var _asn1$readInt2 = _slicedToArray__default['default'](_asn1$readInt, 2);

        this.n = _asn1$readInt2[0];
        pos = _asn1$readInt2[1];

        var _asn1$readInt3 = asn1.readInt(data, pos);

        var _asn1$readInt4 = _slicedToArray__default['default'](_asn1$readInt3, 2);

        this.e = _asn1$readInt4[0];
        pos = _asn1$readInt4[1];
        if (pos !== data.length) throw new Error('Trailing bytes.');
        return this;
      }
    }], [{
      key: "decode",
      value: function decode(data) {
        return new RSAPublicKey().decode(data);
      }
    }]);

    return RSAPublicKey;
  }();
  /**
   * RSAPrivateKey
   */


  var RSAPrivateKey$1 = /*#__PURE__*/function (_RSAPublicKey) {
    _inherits__default['default'](RSAPrivateKey, _RSAPublicKey);

    var _super = _createSuper$E(RSAPrivateKey);

    function RSAPrivateKey() {
      var _this;

      _classCallCheck__default['default'](this, RSAPrivateKey);

      _this = _super.call(this);
      _this.d = new bnBrowser(0);
      _this.p = new bnBrowser(0);
      _this.q = new bnBrowser(0);
      _this.dp = new bnBrowser(0);
      _this.dq = new bnBrowser(0);
      _this.qi = new bnBrowser(0);
      return _this;
    }

    _createClass__default['default'](RSAPrivateKey, [{
      key: "isSane",
      value: function isSane() {
        return this.n.sign() > 0 && this.e.sign() > 0 && this.d.sign() > 0 && this.p.sign() > 0 && this.q.sign() > 0 && this.dp.sign() > 0 && this.dq.sign() > 0 && this.qi.sign() > 0 && this.n.bitLength() <= MAX_BITS$1 && this.e.bitLength() <= MAX_EXP_BITS && this.d.bitLength() <= MAX_BITS$1 && this.p.bitLength() <= MAX_BITS$1 && this.q.bitLength() <= MAX_BITS$1 && this.dp.bitLength() <= MAX_BITS$1 && this.dq.bitLength() <= MAX_BITS$1 && this.qi.bitLength() <= MAX_BITS$1;
      }
    }, {
      key: "verify",
      value: function verify() {
        // Sanity checks.
        if (!this.isSane()) return false; // n >= 2^511 and n mod 2 != 0

        if (this.n.bitLength() < MIN_BITS$1 || !this.n.isOdd()) return false; // e >= 3 and e mod 2 != 0

        if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd()) return false; // p >= 3 and p mod 2 != 0

        if (this.p.cmpn(3) < 0 || !this.p.isOdd()) return false; // q >= 3 and q mod 2 != 0

        if (this.q.cmpn(3) < 0 || !this.q.isOdd()) return false; // phi = (p - 1) * (q - 1)

        var pm1 = this.p.subn(1);
        var qm1 = this.q.subn(1);
        var phi = pm1.mul(qm1); // d >= 2 and d < phi

        if (this.d.cmpn(2) < 0 || this.d.cmp(phi) >= 0) return false; // dp != 0 and dp < p - 1

        if (this.dp.sign() === 0 || this.dp.cmp(pm1) >= 0) return false; // dq != 0 and dq < q - 1

        if (this.dq.sign() === 0 || this.dq.cmp(qm1) >= 0) return false; // qi <= 2 and qi < p

        if (this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0) return false; // p != q

        if (this.p.cmp(this.q) === 0) return false; // n == p * q

        if (this.p.mul(this.q).cmp(this.n) !== 0) return false; // lam = lcm(p - 1, q - 1)

        var lam = phi.div(pm1.gcd(qm1)); // e * d mod lam

        if (this.e.mul(this.d).imod(lam).cmpn(1) !== 0) return false; // dp == d mod (p - 1)

        if (this.d.mod(pm1).cmp(this.dp) !== 0) return false; // dq == d mod (q - 1)

        if (this.d.mod(qm1).cmp(this.dq) !== 0) return false; // q * qi mod p == 1

        if (this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0) return false;
        return true;
      }
    }, {
      key: "decrypt",
      value: function decrypt(msg) {
        // [RFC8017] Page 13, Section 5.1.2.
        //           Page 15, Section 5.2.1.
        assert_1$1(Buffer.isBuffer(msg));
        var n = this.n,
            e = this.e,
            p = this.p,
            q = this.q,
            dp = this.dp,
            dq = this.dq,
            qi = this.qi; // Decode message.

        var c = bnBrowser.decode(msg); // Validate params.

        if (c.cmp(n) >= 0) throw new Error('Invalid RSA message size.'); // Generate blinding factor.

        var b, bi;

        for (;;) {
          // s = random integer in [1,n-1]
          var s = bnBrowser.random(randomBrowser, 1, n); // bi = s^-1 mod n

          try {
            bi = s.invert(n);
          } catch (e) {
            continue;
          } // b = s^e mod n


          b = s.powm(e, n);
          break;
        } // Blind.


        c.imul(b).imod(n); // Leverage Chinese Remainder Theorem.
        //
        // Computation:
        //
        //   mp = c^(d mod p-1) mod p
        //   mq = c^(d mod q-1) mod q
        //   md = (mp - mq) / q mod p
        //   m = (md * q + mq) mod n

        var mp = c.powm(dp, p, true);
        var mq = c.powm(dq, q, true);
        var md = mp.sub(mq).mul(qi).imod(p);
        var m = md.mul(q).iadd(mq).imod(n);
        if (m.powm(e, n).cmp(c) !== 0) throw new Error('Invalid RSA private key.'); // Unblind.

        m.imul(bi).imod(n);
        return m.encode('be', n.byteLength());
      }
    }, {
      key: "generate",
      value: function generate(bits, exponent) {
        // [RFC8017] Page 9, Section 3.2.
        // [FIPS186] Page 51, Appendix B.3.1
        //           Page 55, Appendix B.3.3
        //
        // There are two methods for choosing `d`.
        // Implementations differ on whether they
        // use Euler's totient or the Carmichael
        // function.
        //
        // The best explanation of Euler's phi vs.
        // Carmichael's lambda I've seen comes from
        // the crypto stackexchange[1].
        //
        // Note that both functions are _equivalent_
        // when used with RSA, however, Carmichael's
        // may lend itself to some perf benefits.
        //
        // [1] https://crypto.stackexchange.com/a/29595
        assert_1$1(bits >>> 0 === bits);
        assert_1$1(Number.isSafeInteger(exponent) && exponent >= 0);
        assert_1$1(bits >= 64);
        assert_1$1(exponent >= 3 && (exponent & 1) !== 0);
        var e = new bnBrowser(exponent);

        for (;;) {
          var p = randomPrime$1((bits >>> 1) + (bits & 1));
          var q = randomPrime$1(bits >>> 1);
          if (p.cmp(q) === 0) continue;
          if (p.cmp(q) < 0) p.swap(q);
          if (p.sub(q).bitLength() <= (bits >>> 1) - 99) continue;
          var n = p.mul(q);
          if (n.bitLength() !== bits) continue; // Euler's totient: (p - 1) * (q - 1).

          var pm1 = p.subn(1);
          var qm1 = q.subn(1);
          var phi = pm1.mul(qm1);
          if (e.gcd(phi).cmpn(1) !== 0) continue; // Carmichael's function: lcm(p - 1, q - 1).

          var lam = phi.div(pm1.gcd(qm1));
          var d = e.invert(lam);
          if (d.bitLength() <= bits + 1 >>> 1) continue;
          var dp = d.mod(pm1);
          var dq = d.mod(qm1);
          var qi = q.invert(p);
          this.n = n;
          this.e = e;
          this.d = d;
          this.p = p;
          this.q = q;
          this.dp = dp;
          this.dq = dq;
          this.qi = qi;
          return this;
        }
      }
    }, {
      key: "_generateSubtle",
      value: function () {
        var _generateSubtle2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(bits, exponent) {
          var crypto, subtle, e, algo, ck, jwk, p, q;
          return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  assert_1$1(bits >>> 0 === bits);
                  assert_1$1(Number.isSafeInteger(exponent) && exponent >= 0);
                  assert_1$1(bits >= 64);
                  assert_1$1(exponent >= 3 && (exponent & 1) !== 0);
                  crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;

                  if (crypto) {
                    _context.next = 7;
                    break;
                  }

                  throw new Error('Crypto API not available.');

                case 7:
                  subtle = crypto.subtle;

                  if (!(!subtle || !subtle.generateKey || !subtle.exportKey)) {
                    _context.next = 10;
                    break;
                  }

                  throw new Error('Subtle API not available.');

                case 10:
                  e = new bnBrowser(exponent);
                  algo = {
                    name: 'RSASSA-PKCS1-v1_5',
                    modulusLength: bits,
                    publicExponent: e.toArrayLike(Uint8Array, 'be', 8),
                    hash: {
                      name: 'SHA-256'
                    }
                  };
                  _context.next = 14;
                  return subtle.generateKey(algo, true, ['sign']);

                case 14:
                  ck = _context.sent;
                  _context.next = 17;
                  return subtle.exportKey('jwk', ck.privateKey);

                case 17:
                  jwk = _context.sent;
                  p = bnBrowser.decode(base64Browser.decodeURL(jwk.p));
                  q = bnBrowser.decode(base64Browser.decodeURL(jwk.q));
                  return _context.abrupt("return", this.fromPQE(p, q, e));

                case 21:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function _generateSubtle(_x, _x2) {
          return _generateSubtle2.apply(this, arguments);
        }

        return _generateSubtle;
      }()
    }, {
      key: "generateAsync",
      value: function () {
        var _generateAsync = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(bits, exponent) {
          return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  _context2.next = 3;
                  return this._generateSubtle(bits, exponent);

                case 3:
                  return _context2.abrupt("return", _context2.sent);

                case 6:
                  _context2.prev = 6;
                  _context2.t0 = _context2["catch"](0);
                  return _context2.abrupt("return", this.generate(bits, exponent));

                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this, [[0, 6]]);
        }));

        function generateAsync(_x3, _x4) {
          return _generateAsync.apply(this, arguments);
        }

        return generateAsync;
      }()
    }, {
      key: "fromPQE",
      value: function fromPQE(p, q, e) {
        assert_1$1(p instanceof bnBrowser);
        assert_1$1(q instanceof bnBrowser);
        assert_1$1(e instanceof bnBrowser);

        if (p.cmp(q) < 0) {
          var _ref = [q, p];
          p = _ref[0];
          q = _ref[1];
        }

        if (p.cmp(q) === 0) throw new Error('Invalid RSA private key.');
        if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS$1) throw new Error('Invalid RSA private key.');
        if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS$1) throw new Error('Invalid RSA private key.');
        if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS) throw new Error('Invalid RSA private key.');
        if (!p.isOdd() || !q.isOdd() || !e.isOdd()) throw new Error('Invalid RSA private key.');
        var n = p.mul(q);
        assert_1$1(n.isOdd());
        if (n.bitLength() < MIN_BITS$1 || n.bitLength() > MAX_BITS$1) throw new Error('Invalid RSA private key.');
        var pm1 = p.subn(1);
        var qm1 = q.subn(1);
        var lam = pm1.lcm(qm1);
        var d = e.invert(lam);
        var dp = d.mod(pm1);
        var dq = d.mod(qm1);
        var qi = q.invert(p);
        this.n = n;
        this.e = e;
        this.d = d;
        this.p = p;
        this.q = q;
        this.dp = dp;
        this.dq = dq;
        this.qi = qi;
        return this;
      }
    }, {
      key: "fromPQD",
      value: function fromPQD(p, q, d) {
        assert_1$1(p instanceof bnBrowser);
        assert_1$1(q instanceof bnBrowser);
        assert_1$1(d instanceof bnBrowser);
        if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS$1) throw new Error('Invalid RSA private key.');
        if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS$1) throw new Error('Invalid RSA private key.');
        if (!p.isOdd() || !q.isOdd()) throw new Error('Invalid RSA private key.');
        var pm1 = p.subn(1);
        var qm1 = q.subn(1);
        var phi = pm1.mul(qm1);
        if (d.cmpn(2) < 0 || d.cmp(phi) >= 0) throw new Error('Invalid RSA private key.');
        var lam = phi.div(pm1.gcd(qm1));
        var e = d.invert(lam);
        return this.fromPQE(p, q, e);
      }
    }, {
      key: "fromNED",
      value: function fromNED(n, e, d) {
        // Factor an RSA modulus given (n, e, d).
        //
        // This is basically the same logic as the
        // Miller-Rabin primality test[1][2].
        //
        // [1] https://crypto.stackexchange.com/questions/11509
        // [2] https://crypto.stackexchange.com/questions/22374
        assert_1$1(n instanceof bnBrowser);
        assert_1$1(e instanceof bnBrowser);
        assert_1$1(d instanceof bnBrowser);
        if (n.sign() < 0) throw new Error('Invalid RSA private key.');
        if (n.bitLength() < MIN_BITS$1 || n.bitLength() > MAX_BITS$1) throw new Error('Invalid RSA private key.');
        if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS) throw new Error('Invalid RSA private key.');
        if (d.cmpn(2) < 0 || d.bitLength() > MAX_BITS$1) throw new Error('Invalid RSA private key.');
        if (!n.isOdd() || !e.isOdd()) throw new Error('Invalid RSA private key.');
        var f = e.mul(d).isubn(1);
        var nm1 = n.subn(1);
        var s = f.zeroBits();
        var g = f.ushrn(s);

        for (var i = 0; i < 64; i++) {
          var a = bnBrowser.random(randomBrowser, 2, nm1);
          var b = a.powm(g, n);
          if (b.cmpn(1) === 0 || b.cmp(nm1) === 0) continue;

          for (var j = 1; j < s; j++) {
            var c = b.sqr().imod(n);

            if (c.cmpn(1) === 0) {
              var p = n.gcd(b.subn(1));
              var q = n.gcd(b.addn(1));
              return this.fromPQE(p, q, e);
            }

            if (c.cmp(nm1) === 0) break;
            b = c;
          }
        }

        throw new Error('Invalid RSA private key.');
      }
    }, {
      key: "toPublic",
      value: function toPublic() {
        var pub = new RSAPublicKey$1();
        pub.n = this.n;
        pub.e = this.e;
        return pub;
      }
    }, {
      key: "encode",
      value: function encode() {
        var size = 0;
        size += asn1.sizeVersion(0);
        size += asn1.sizeInt(this.n);
        size += asn1.sizeInt(this.e);
        size += asn1.sizeInt(this.d);
        size += asn1.sizeInt(this.p);
        size += asn1.sizeInt(this.q);
        size += asn1.sizeInt(this.dp);
        size += asn1.sizeInt(this.dq);
        size += asn1.sizeInt(this.qi);
        var out = Buffer.alloc(asn1.sizeSeq(size));
        var pos = 0;
        pos = asn1.writeSeq(out, pos, size);
        pos = asn1.writeVersion(out, pos, 0);
        pos = asn1.writeInt(out, pos, this.n);
        pos = asn1.writeInt(out, pos, this.e);
        pos = asn1.writeInt(out, pos, this.d);
        pos = asn1.writeInt(out, pos, this.p);
        pos = asn1.writeInt(out, pos, this.q);
        pos = asn1.writeInt(out, pos, this.dp);
        pos = asn1.writeInt(out, pos, this.dq);
        pos = asn1.writeInt(out, pos, this.qi);
        assert_1$1(pos === out.length);
        return out;
      }
    }, {
      key: "decode",
      value: function decode(data) {
        var pos = 0;
        pos = asn1.readSeq(data, pos);
        pos = asn1.readVersion(data, pos, 0);

        var _asn1$readInt5 = asn1.readInt(data, pos);

        var _asn1$readInt6 = _slicedToArray__default['default'](_asn1$readInt5, 2);

        this.n = _asn1$readInt6[0];
        pos = _asn1$readInt6[1];

        var _asn1$readInt7 = asn1.readInt(data, pos);

        var _asn1$readInt8 = _slicedToArray__default['default'](_asn1$readInt7, 2);

        this.e = _asn1$readInt8[0];
        pos = _asn1$readInt8[1];

        var _asn1$readInt9 = asn1.readInt(data, pos);

        var _asn1$readInt10 = _slicedToArray__default['default'](_asn1$readInt9, 2);

        this.d = _asn1$readInt10[0];
        pos = _asn1$readInt10[1];

        var _asn1$readInt11 = asn1.readInt(data, pos);

        var _asn1$readInt12 = _slicedToArray__default['default'](_asn1$readInt11, 2);

        this.p = _asn1$readInt12[0];
        pos = _asn1$readInt12[1];

        var _asn1$readInt13 = asn1.readInt(data, pos);

        var _asn1$readInt14 = _slicedToArray__default['default'](_asn1$readInt13, 2);

        this.q = _asn1$readInt14[0];
        pos = _asn1$readInt14[1];

        var _asn1$readInt15 = asn1.readInt(data, pos);

        var _asn1$readInt16 = _slicedToArray__default['default'](_asn1$readInt15, 2);

        this.dp = _asn1$readInt16[0];
        pos = _asn1$readInt16[1];

        var _asn1$readInt17 = asn1.readInt(data, pos);

        var _asn1$readInt18 = _slicedToArray__default['default'](_asn1$readInt17, 2);

        this.dq = _asn1$readInt18[0];
        pos = _asn1$readInt18[1];

        var _asn1$readInt19 = asn1.readInt(data, pos);

        var _asn1$readInt20 = _slicedToArray__default['default'](_asn1$readInt19, 2);

        this.qi = _asn1$readInt20[0];
        pos = _asn1$readInt20[1];
        if (pos !== data.length) throw new Error('Trailing bytes.');
        return this;
      }
    }], [{
      key: "generate",
      value: function generate(bits, exponent) {
        return new RSAPrivateKey().generate(bits, exponent);
      }
    }, {
      key: "generateAsync",
      value: function () {
        var _generateAsync2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(bits, exponent) {
          return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", new RSAPrivateKey().generateAsync(bits, exponent));

                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        function generateAsync(_x5, _x6) {
          return _generateAsync2.apply(this, arguments);
        }

        return generateAsync;
      }()
    }, {
      key: "fromPQE",
      value: function fromPQE(p, q, e) {
        return new RSAPrivateKey().fromPQE(p, q, e);
      }
    }, {
      key: "fromPQD",
      value: function fromPQD(p, q, d) {
        return new RSAPrivateKey().fromPQD(p, q, d);
      }
    }, {
      key: "fromNED",
      value: function fromNED(n, e, d) {
        return new RSAPrivateKey().fromNED(n, e, d);
      }
    }, {
      key: "decode",
      value: function decode(data) {
        return new RSAPrivateKey().decode(data);
      }
    }]);

    return RSAPrivateKey;
  }(RSAPublicKey$1);
  /**
   * Generate a private key.
   * @param {Number} [bits=2048]
   * @param {Number} [exponent=65537]
   * @returns {Buffer} Private key.
   */


  function privateKeyGenerate$1(bits, exponent) {
    if (bits == null) bits = DEFAULT_BITS$1;
    if (exponent == null) exponent = DEFAULT_EXP;
    assert_1$1(bits >>> 0 === bits);
    assert_1$1(Number.isSafeInteger(exponent) && exponent >= 0);
    if (bits < MIN_BITS$1 || bits > MAX_BITS$1) throw new RangeError("\"bits\" ranges from ".concat(MIN_BITS$1, " to ").concat(MAX_BITS$1, "."));
    if (exponent < MIN_EXP || exponent > MAX_EXP) throw new RangeError("\"exponent\" ranges from ".concat(MIN_EXP, " to ").concat(MAX_EXP, "."));
    if (exponent === 1 || (exponent & 1) === 0) throw new RangeError('"exponent" must be odd.');
    var key = RSAPrivateKey$1.generate(bits, exponent);
    return key.encode();
  }
  /**
   * Generate a private key.
   * @param {Number} [bits=2048]
   * @param {Number} [exponent=65537]
   * @returns {Buffer} Private key.
   */


  function privateKeyGenerateAsync$1(_x7, _x8) {
    return _privateKeyGenerateAsync$1.apply(this, arguments);
  }
  /**
   * Get a private key's modulus size in bits.
   * @param {Buffer} key
   * @returns {Number}
   */


  function _privateKeyGenerateAsync$1() {
    _privateKeyGenerateAsync$1 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(bits, exponent) {
      var key;
      return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (bits == null) bits = DEFAULT_BITS$1;
              if (exponent == null) exponent = DEFAULT_EXP;
              assert_1$1(bits >>> 0 === bits);
              assert_1$1(Number.isSafeInteger(exponent) && exponent >= 0);

              if (!(bits < MIN_BITS$1 || bits > MAX_BITS$1)) {
                _context4.next = 6;
                break;
              }

              throw new RangeError("\"bits\" ranges from ".concat(MIN_BITS$1, " to ").concat(MAX_BITS$1, "."));

            case 6:
              if (!(exponent < MIN_EXP || exponent > MAX_EXP)) {
                _context4.next = 8;
                break;
              }

              throw new RangeError("\"exponent\" ranges from ".concat(MIN_EXP, " to ").concat(MAX_EXP, "."));

            case 8:
              if (!(exponent === 1 || (exponent & 1) === 0)) {
                _context4.next = 10;
                break;
              }

              throw new RangeError('"exponent" must be odd.');

            case 10:
              _context4.next = 12;
              return RSAPrivateKey$1.generateAsync(bits, exponent);

            case 12:
              key = _context4.sent;
              return _context4.abrupt("return", key.encode());

            case 14:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _privateKeyGenerateAsync$1.apply(this, arguments);
  }

  function privateKeyBits$1(key) {
    var k = RSAPrivateKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA private key.');
    return k.bits();
  }
  /**
   * Verify a private key.
   * @param {Buffer} key
   * @returns {Boolean}
   */


  function privateKeyVerify$1(key) {
    // [RFC8017] Page 9, Section 3.2.
    assert_1$1(Buffer.isBuffer(key));
    var k;

    try {
      k = RSAPrivateKey$1.decode(key);
    } catch (e) {
      return false;
    }

    return k.verify();
  }
  /**
   * Import a private key from an object.
   * @param {Object} json
   * @returns {Buffer}
   */


  function privateKeyImport$1(json) {
    // [RFC8017] Page 55, Section A.1.2.
    assert_1$1(json && _typeof__default['default'](json) === 'object');
    var k = new RSAPrivateKey$1();
    if (json.n != null) k.n = bnBrowser.decode(json.n);
    if (json.e != null) k.e = bnBrowser.decode(json.e);
    if (json.d != null) k.d = bnBrowser.decode(json.d);
    if (json.p != null) k.p = bnBrowser.decode(json.p);
    if (json.q != null) k.q = bnBrowser.decode(json.q);
    if (json.dp != null) k.dp = bnBrowser.decode(json.dp);
    if (json.dq != null) k.dq = bnBrowser.decode(json.dq);
    if (json.qi != null) k.qi = bnBrowser.decode(json.qi);

    if (!k.verify()) {
      if (!k.p.isZero() && !k.q.isZero()) {
        if (!k.e.isZero()) k = RSAPrivateKey$1.fromPQE(k.p, k.q, k.e);else k = RSAPrivateKey$1.fromPQD(k.p, k.q, k.d);
      } else {
        k = RSAPrivateKey$1.fromNED(k.n, k.e, k.d);
      }
    }

    return k.encode();
  }
  /**
   * Export a private key to an object.
   * @param {Buffer} key
   * @returns {Object}
   */


  function privateKeyExport$1(key) {
    // [RFC8017] Page 55, Section A.1.2.
    var k = RSAPrivateKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA private key.');
    return {
      n: k.n.encode(),
      e: k.e.encode(),
      d: k.d.encode(),
      p: k.p.encode(),
      q: k.q.encode(),
      dp: k.dp.encode(),
      dq: k.dq.encode(),
      qi: k.qi.encode()
    };
  }
  /**
   * Create a public key from a private key.
   * @param {Buffer} key
   * @returns {Buffer}
   */


  function publicKeyCreate$1(key) {
    var k = RSAPrivateKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA private key.');
    var p = k.toPublic();
    return p.encode();
  }
  /**
   * Get a public key's modulus size in bits.
   * @param {Buffer} key
   * @returns {Number}
   */


  function publicKeyBits$1(key) {
    var k = RSAPublicKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA public key.');
    return k.bits();
  }
  /**
   * Verify a public key.
   * @param {Buffer} key
   * @returns {Boolean}
   */


  function publicKeyVerify$1(key) {
    // [RFC8017] Page 8, Section 3.1.
    assert_1$1(Buffer.isBuffer(key));
    var k;

    try {
      k = RSAPublicKey$1.decode(key);
    } catch (e) {
      return false;
    }

    return k.verify();
  }
  /**
   * Import a public key from an object.
   * @param {Object} json
   * @returns {Buffer}
   */


  function publicKeyImport$1(json) {
    // [RFC8017] Page 54, Section A.1.1.
    assert_1$1(json && _typeof__default['default'](json) === 'object');
    var k = new RSAPublicKey$1();
    if (json.n != null) k.n = bnBrowser.decode(json.n);
    if (json.e != null) k.e = bnBrowser.decode(json.e);
    if (!k.verify()) throw new Error('Invalid RSA public key.');
    return k.encode();
  }
  /**
   * Export a public key to an object.
   * @param {Buffer} key
   * @returns {Object}
   */


  function publicKeyExport$1(key) {
    // [RFC8017] Page 54, Section A.1.1.
    var k = RSAPublicKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA public key.');
    return {
      n: k.n.encode(),
      e: k.e.encode()
    };
  }
  /**
   * Sign a message (PKCS1v1.5).
   * @param {Object|String|null} hash
   * @param {Buffer} msg
   * @param {Buffer} key - Private key.
   * @returns {Buffer} PKCS#1v1.5-formatted signature.
   */


  function sign$1(hash, msg, key) {
    // [RFC8017] Page 36, Section 8.2.1.
    //           Page 45, Section 9.2.
    if (hash && typeof hash.id === 'string') hash = hash.id;
    assert_1$1(hash == null || typeof hash === 'string');
    assert_1$1(Buffer.isBuffer(msg));

    var _getDigestInfo = getDigestInfo(hash, msg),
        _getDigestInfo2 = _slicedToArray__default['default'](_getDigestInfo, 2),
        prefix = _getDigestInfo2[0],
        hlen = _getDigestInfo2[1];

    if (!prefix) throw new Error('Unknown RSA hash function.');
    if (msg.length !== hlen) throw new Error('Invalid RSA message size.');
    var k = RSAPrivateKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA private key.');
    var tlen = prefix.length + hlen;
    var klen = k.size();
    if (klen < tlen + 11) throw new Error('Invalid RSA message size.'); // EM = 0x00 || 0x01 || PS || 0x00 || T

    var em = Buffer.alloc(klen);
    em[0] = 0x00;
    em[1] = 0x01;

    for (var i = 2; i < klen - tlen - 1; i++) {
      em[i] = 0xff;
    }

    em[klen - tlen - 1] = 0x00;
    prefix.copy(em, klen - tlen);
    msg.copy(em, klen - hlen);
    return k.decrypt(em);
  }
  /**
   * Verify a signature (PKCS1v1.5).
   * @param {Object|String|null} hash
   * @param {Buffer} msg
   * @param {Buffer} sig - PKCS#1v1.5-formatted.
   * @param {Buffer} key
   * @returns {Boolean}
   */


  function verify$2(hash, msg, sig, key) {
    if (hash && typeof hash.id === 'string') hash = hash.id;
    assert_1$1(hash == null || typeof hash === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(sig));
    assert_1$1(Buffer.isBuffer(key));

    try {
      return _verify$1(hash, msg, sig, key);
    } catch (e) {
      return false;
    }
  }
  /**
   * Verify a signature (PKCS1v1.5).
   * @private
   * @param {String} hash
   * @param {Buffer} msg
   * @param {Buffer} sig - PKCS#1v1.5-formatted.
   * @param {Buffer} key
   * @returns {Boolean}
   */


  function _verify$1(hash, msg, sig, key) {
    // [RFC8017] Page 37, Section 8.2.2.
    //           Page 45, Section 9.2.
    var _getDigestInfo3 = getDigestInfo(hash, msg),
        _getDigestInfo4 = _slicedToArray__default['default'](_getDigestInfo3, 2),
        prefix = _getDigestInfo4[0],
        hlen = _getDigestInfo4[1];

    if (!prefix) return false;
    if (msg.length !== hlen) return false;
    var k = RSAPublicKey$1.decode(key);
    if (!k.verify()) return false;
    var klen = k.size();
    if (sig.length !== klen) return false;
    var tlen = prefix.length + hlen;
    if (klen < tlen + 11) return false;
    var em = k.encrypt(sig); // EM = 0x00 || 0x01 || PS || 0x00 || T

    var ok = 1;
    ok &= safeEqualByte$1(em[0], 0x00);
    ok &= safeEqualByte$1(em[1], 0x01);

    for (var i = 2; i < klen - tlen - 1; i++) {
      ok &= safeEqualByte$1(em[i], 0xff);
    }

    ok &= safeEqualByte$1(em[klen - tlen - 1], 0x00);
    ok &= safeEqual$2(em.slice(klen - tlen, klen - hlen), prefix);
    ok &= safeEqual$2(em.slice(klen - hlen, klen), msg);
    return ok === 1;
  }
  /**
   * Encrypt a message with public key (PKCS1v1.5).
   * @param {Buffer} msg
   * @param {Buffer} key
   * @returns {Buffer}
   */


  function encrypt$5(msg, key) {
    // [RFC8017] Page 28, Section 7.2.1.
    assert_1$1(Buffer.isBuffer(msg));
    var k = RSAPublicKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA public key.');
    var klen = k.size();
    if (msg.length > klen - 11) throw new Error('Invalid RSA message size.'); // EM = 0x00 || 0x02 || PS || 0x00 || M

    var em = Buffer.alloc(klen);
    var mlen = msg.length;
    var plen = klen - mlen - 3;
    em[0] = 0x00;
    em[1] = 0x02;
    randomBrowser.randomFill(em, 2, plen);

    for (var i = 2; i < 2 + plen; i++) {
      while (em[i] === 0x00) {
        randomBrowser.randomFill(em, i, 1);
      }
    }

    em[klen - mlen - 1] = 0x00;
    msg.copy(em, klen - mlen);
    return k.encrypt(em);
  }
  /**
   * Decrypt a message with private key (PKCS1v1.5).
   * @param {Buffer} msg
   * @param {Buffer} key
   * @returns {Buffer}
   */


  function decrypt$4(msg, key) {
    // [RFC8017] Page 29, Section 7.2.2.
    assert_1$1(Buffer.isBuffer(msg));
    var k = RSAPrivateKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA private key.');
    var klen = k.size();
    if (klen < 11) throw new Error('Invalid RSA private key.');
    if (msg.length !== klen) throw new Error('Invalid RSA message size.'); // EM = 0x00 || 0x02 || PS || 0x00 || M

    var em = k.decrypt(msg);
    var zero = safeEqualByte$1(em[0], 0x00);
    var two = safeEqualByte$1(em[1], 0x02);
    var index = 0;
    var looking = 1;

    for (var i = 2; i < em.length; i++) {
      var equals0 = safeEqualByte$1(em[i], 0x00);
      index = safeSelect$1(index, i, looking & equals0);
      looking = safeSelect$1(looking, 0, equals0);
    }

    var validPS = safeLTE$1(2 + 8, index);
    var valid = zero & two & (looking ^ 1) & validPS;
    var offset = safeSelect$1(0, index + 1, valid);
    if (valid === 0) throw new Error('Invalid RSA ciphertext.');
    return em.slice(offset);
  }
  /**
   * Sign a message (PSS).
   * @param {Object} hash
   * @param {Buffer} msg
   * @param {Buffer} key - Private key.
   * @param {Number} [saltLen=SALT_LENGTH_HASH]
   * @returns {Buffer} PSS-formatted signature.
   */


  function signPSS(hash, msg, key, saltLen) {
    // [RFC8017] Page 33, Section 8.1.1.
    if (saltLen == null) saltLen = SALT_LENGTH_HASH;
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1((saltLen | 0) === saltLen);
    if (msg.length !== hash.size) throw new Error('Invalid RSA message size.');
    var k = RSAPrivateKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA private key.');
    var bits = k.bits();
    var klen = bits + 7 >>> 3;
    var emlen = bits + 6 >>> 3;
    if (saltLen === SALT_LENGTH_AUTO) saltLen = emlen - 2 - hash.size;else if (saltLen === SALT_LENGTH_HASH) saltLen = hash.size;
    if (saltLen < 0 || saltLen > klen) throw new Error('Invalid PSS salt length.');
    var salt = randomBrowser.randomBytes(saltLen);
    var em = pssEncode(hash, msg, bits - 1, salt); // Note that `em` may be one byte less
    // than the modulus size in the case
    // of (bits - 1) mod 8 == 0.

    return k.decrypt(em);
  }
  /**
   * Verify a signature (PSS).
   * @param {Object} hash
   * @param {Buffer} msg
   * @param {Buffer} sig - PSS-formatted.
   * @param {Buffer} key
   * @param {Number} [saltLen=SALT_LENGTH_HASH]
   * @returns {Boolean}
   */


  function verifyPSS(hash, msg, sig, key, saltLen) {
    if (saltLen == null) saltLen = SALT_LENGTH_HASH;
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(sig));
    assert_1$1(Buffer.isBuffer(key));
    assert_1$1((saltLen | 0) === saltLen);

    try {
      return _verifyPSS(hash, msg, sig, key, saltLen);
    } catch (e) {
      return false;
    }
  }
  /**
   * Verify a signature (PSS).
   * @private
   * @param {Object} hash
   * @param {Buffer} msg
   * @param {Buffer} sig - PSS-formatted.
   * @param {Buffer} key
   * @param {Number} saltLen
   * @returns {Boolean}
   */


  function _verifyPSS(hash, msg, sig, key, saltLen) {
    // [RFC8017] Page 34, Section 8.1.2.
    if (msg.length !== hash.size) return false;
    var k = RSAPublicKey$1.decode(key);
    if (!k.verify()) return false;
    var bits = k.bits();
    var klen = bits + 7 >>> 3;
    if (sig.length !== klen) return false;
    if (saltLen === SALT_LENGTH_AUTO) saltLen = 0; // Handled in pssVerify.
    else if (saltLen === SALT_LENGTH_HASH) saltLen = hash.size;
    if (saltLen < 0 || saltLen > klen) return false;
    var em = k.encrypt(sig); // Edge case: the encoding crossed a
    // a byte boundary. Our encryption
    // function pads to the modulus size
    // by default, meaning there's one
    // extra zero byte prepended.

    if ((bits - 1 & 7) === 0) {
      if (em[0] !== 0x00) return false;
      em = em.slice(1);
    }

    return pssVerify(hash, msg, em, bits - 1, saltLen);
  }
  /**
   * Encrypt a message with public key (OAEP).
   * @param {Object} hash
   * @param {Buffer} msg
   * @param {Buffer} key
   * @param {Buffer?} label
   * @returns {Buffer}
   */


  function encryptOAEP(hash, msg, key, label) {
    // [RFC8017] Page 22, Section 7.1.1.
    if (label == null) label = EMPTY$a;
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(label));
    var k = RSAPublicKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA public key.');
    var klen = k.size();
    var mlen = msg.length;
    var hlen = hash.size;
    if (mlen > klen - 2 * hlen - 2) throw new Error('Invalid RSA message size.'); // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)

    var em = Buffer.alloc(klen);
    var lhash = hash.digest(label);
    var seed = em.slice(1, 1 + hlen);
    var db = em.slice(1 + hlen);
    var dlen = db.length;
    em[0] = 0x00;
    randomBrowser.randomFill(seed, 0, seed.length);
    lhash.copy(db, 0);
    db.fill(0x00, hlen, dlen - mlen - 1);
    db[dlen - mlen - 1] = 0x01;
    msg.copy(db, dlen - mlen);
    mgf1xor(hash, db, seed);
    mgf1xor(hash, seed, db);
    return k.encrypt(em);
  }
  /**
   * Decrypt a message with private key (OAEP).
   * @param {Object} hash
   * @param {Buffer} msg
   * @param {Buffer} key
   * @param {Buffer?} label
   * @returns {Buffer}
   */


  function decryptOAEP(hash, msg, key, label) {
    // [RFC8017] Page 25, Section 7.1.2.
    if (label == null) label = EMPTY$a;
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(label));
    var k = RSAPrivateKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA private key.');
    var klen = k.size();
    var mlen = msg.length;
    var hlen = hash.size;
    if (klen < hlen * 2 + 2) throw new Error('Invalid RSA private key size.');
    if (mlen !== klen) throw new Error('Invalid RSA message size.'); // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)

    var em = k.decrypt(msg);
    var expect = hash.digest(label);
    var zero = safeEqualByte$1(em[0], 0x00);
    var seed = em.slice(1, hlen + 1);
    var db = em.slice(hlen + 1);
    mgf1xor(hash, seed, db);
    mgf1xor(hash, db, seed);
    var lhash = db.slice(0, hlen);
    var lvalid = safeEqual$2(lhash, expect);
    var rest = db.slice(hlen);
    var looking = 1;
    var index = 0;
    var invalid = 0;

    for (var i = 0; i < rest.length; i++) {
      var equals0 = safeEqualByte$1(rest[i], 0x00);
      var equals1 = safeEqualByte$1(rest[i], 0x01);
      index = safeSelect$1(index, i, looking & equals1);
      looking = safeSelect$1(looking, 0, equals1);
      invalid = safeSelect$1(invalid, 1, looking & (equals0 ^ 1));
    }

    var valid = zero & lvalid & (invalid ^ 1) & (looking ^ 1);
    if (valid === 0) throw new Error('Invalid RSA ciphertext.');
    return rest.slice(index + 1);
  }
  /**
   * "Veil" an RSA ciphertext to hide the key size.
   * @param {Buffer} msg
   * @param {Number} bits
   * @param {Buffer} key
   * @returns {Buffer}
   */


  function veil(msg, bits, key) {
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(bits >>> 0 === bits);
    var k = RSAPublicKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA public key.');
    if (msg.length !== k.size()) throw new Error('Invalid RSA ciphertext.');
    if (bits < k.bits()) throw new Error('Cannot make ciphertext smaller.');
    var bytes = bits + 7 >>> 3;
    var c = bnBrowser.decode(msg);
    if (c.cmp(k.n) >= 0) throw new Error('Invalid RSA ciphertext.');
    var vmax = bnBrowser.shift(1, bits);
    var rmax = vmax.sub(c).iadd(k.n).isubn(1).div(k.n);
    assert_1$1(rmax.sign() > 0);
    var v = vmax;

    while (v.cmp(vmax) >= 0) {
      var r = bnBrowser.random(randomBrowser, 0, rmax);
      v = c.add(r.mul(k.n));
    }

    assert_1$1(v.mod(k.n).cmp(c) === 0);
    assert_1$1(v.bitLength() <= bits);
    return v.encode('be', bytes);
  }
  /**
   * "Unveil" a veiled RSA ciphertext.
   * @param {Buffer} msg
   * @param {Number} bits
   * @param {Buffer} key
   * @returns {Buffer}
   */


  function unveil(msg, bits, key) {
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(bits >>> 0 === bits);
    var k = RSAPublicKey$1.decode(key);
    if (!k.verify()) throw new Error('Invalid RSA public key.');
    var klen = k.size();
    if (msg.length < klen) throw new Error('Invalid RSA ciphertext.');
    var v = bnBrowser.decode(msg);
    if (bits !== 0 && v.bitLength() > bits) throw new Error('Invalid RSA ciphertext.');
    var c = v.imod(k.n);
    return c.encode('be', klen);
  }
  /*
   * Digest Info
   */


  function getDigestInfo(name, msg) {
    // [RFC8017] Page 63, Section B.1.
    assert_1$1(name == null || typeof name === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    if (name == null) return [EMPTY$a, msg.length];
    var prefix = digestInfo[name];
    if (prefix == null) return [null, 0];
    if (prefix.length === 1) return [EMPTY$a, prefix[0]];
    return [prefix, prefix[prefix.length - 1]];
  }
  /*
   * MGF1
   */


  function mgf1xor(hash, out, seed) {
    // [RFC8017] Page 67, Section B.2.1.
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(out));
    assert_1$1(Buffer.isBuffer(seed));
    var ctr = Buffer.alloc(4, 0x00);
    var i = 0;

    while (i < out.length) {
      var digest = hash.multi(seed, ctr);
      var j = 0;

      while (i < out.length && j < digest.length) {
        out[i++] ^= digest[j++];
      }

      for (j = 3; j >= 0; j--) {
        ctr[j] += 1;
        if (ctr[j] !== 0x00) break;
      }
    }
  }
  /*
   * PSS
   */


  function pssEncode(hash, msg, embits, salt) {
    // [RFC8017] Page 42, Section 9.1.1.
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(embits >>> 0 === embits);
    assert_1$1(Buffer.isBuffer(salt));
    var hlen = hash.size;
    var slen = salt.length;
    var emlen = embits + 7 >>> 3;
    if (msg.length !== hlen) throw new Error('Invalid RSA message size.');
    if (emlen < hlen + slen + 2) throw new Error('Message too long.'); // EM = (PS || 0x01 || salt) || H || 0xbc

    var em = Buffer.alloc(emlen);
    var db = em.slice(0, emlen - hlen - 1);
    var h = em.slice(emlen - hlen - 1, emlen - 1);
    var h0 = hash.multi(PREFIX$1, msg, salt);
    var mask = 0xff >>> 8 * emlen - embits;
    db.fill(0x00, 0, emlen - slen - hlen - 2);
    db[emlen - slen - hlen - 2] = 0x01;
    salt.copy(db, emlen - slen - hlen - 1);
    h0.copy(h, 0);
    em[emlen - 1] = 0xbc;
    mgf1xor(hash, db, h);
    db[0] &= mask;
    return em;
  }

  function pssVerify(hash, msg, em, embits, slen) {
    // [RFC8017] Page 44, Section 9.1.2.
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(em));
    assert_1$1(embits >>> 0 === embits);
    assert_1$1(slen >>> 0 === slen);
    var hlen = hash.size;
    var emlen = embits + 7 >>> 3;
    if (msg.length !== hlen) return false;
    if (emlen < hlen + slen + 2) return false;
    if (em[emlen - 1] !== 0xbc) return false; // EM = (PS || 0x01 || salt) || H || 0xbc

    var db = em.slice(0, emlen - hlen - 1);
    var h = em.slice(emlen - hlen - 1, emlen - 1);
    var mask = 0xff >>> 8 * emlen - embits;
    if (em[0] & ~mask) return false;
    mgf1xor(hash, db, h);
    db[0] &= mask;

    if (slen === 0) {
      // Auto
      slen = -1;

      for (var i = 0; i < db.length; i++) {
        if (db[i] === 0x00) continue;

        if (db[i] === 0x01) {
          slen = db.length - (i + 1);
          break;
        }

        return false;
      }

      if (slen === -1) return false;
    } else {
      var len = db.length - slen - 1;

      for (var _i = 0; _i < len; _i++) {
        if (db[_i] !== 0x00) return false;
      }

      if (db[len] !== 0x01) return false;
    }

    var salt = db.slice(db.length - slen);
    var h0 = hash.multi(PREFIX$1, msg, salt);
    return h0.equals(h);
  }
  /*
   * Expose
   */


  var native_1$i = 0;
  var SALT_LENGTH_AUTO_1 = SALT_LENGTH_AUTO;
  var SALT_LENGTH_HASH_1 = SALT_LENGTH_HASH;
  var privateKeyGenerate_1$1 = privateKeyGenerate$1;
  var privateKeyGenerateAsync_1$1 = privateKeyGenerateAsync$1;
  var privateKeyBits_1$1 = privateKeyBits$1;
  var privateKeyVerify_1$1 = privateKeyVerify$1;
  var privateKeyImport_1$1 = privateKeyImport$1;
  var privateKeyExport_1$1 = privateKeyExport$1;
  var publicKeyCreate_1$1 = publicKeyCreate$1;
  var publicKeyBits_1$1 = publicKeyBits$1;
  var publicKeyVerify_1$1 = publicKeyVerify$1;
  var publicKeyImport_1$1 = publicKeyImport$1;
  var publicKeyExport_1$1 = publicKeyExport$1;
  var sign_1$1 = sign$1;
  var verify_1$2 = verify$2;
  var encrypt_1$4 = encrypt$5;
  var decrypt_1$4 = decrypt$4;
  var signPSS_1 = signPSS;
  var verifyPSS_1 = verifyPSS;
  var encryptOAEP_1 = encryptOAEP;
  var decryptOAEP_1 = decryptOAEP;
  var veil_1 = veil;
  var unveil_1 = unveil;
  var rsa = {
    native: native_1$i,
    SALT_LENGTH_AUTO: SALT_LENGTH_AUTO_1,
    SALT_LENGTH_HASH: SALT_LENGTH_HASH_1,
    privateKeyGenerate: privateKeyGenerate_1$1,
    privateKeyGenerateAsync: privateKeyGenerateAsync_1$1,
    privateKeyBits: privateKeyBits_1$1,
    privateKeyVerify: privateKeyVerify_1$1,
    privateKeyImport: privateKeyImport_1$1,
    privateKeyExport: privateKeyExport_1$1,
    publicKeyCreate: publicKeyCreate_1$1,
    publicKeyBits: publicKeyBits_1$1,
    publicKeyVerify: publicKeyVerify_1$1,
    publicKeyImport: publicKeyImport_1$1,
    publicKeyExport: publicKeyExport_1$1,
    sign: sign_1$1,
    verify: verify_1$2,
    encrypt: encrypt_1$4,
    decrypt: decrypt_1$4,
    signPSS: signPSS_1,
    verifyPSS: verifyPSS_1,
    encryptOAEP: encryptOAEP_1,
    decryptOAEP: decryptOAEP_1,
    veil: veil_1,
    unveil: unveil_1
  };

  var rsaBrowser = rsa;

  /*
   * RSAIES
   */


  function encrypt$6(hash, msg, pub) {
    var size = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var label = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    var key = randomBrowser.randomBytes(32);
    var ct = rsaBrowser.encryptOAEP(hash, key, pub, label);
    if (size != null) ct = rsaBrowser.veil(ct, size, pub);
    var nonce = randomBrowser.randomBytes(24);
    var sealed = secretboxBrowser.seal(msg, key, nonce);
    return Buffer.concat([ct, nonce, sealed]);
  }

  function decrypt$5(hash, msg, priv) {
    var size = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var label = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    assert_1$1(hash && typeof hash.id === 'string');
    assert_1$1(Buffer.isBuffer(msg));
    assert_1$1(Buffer.isBuffer(priv));
    if (size == null) size = rsaBrowser.privateKeyBits(priv);
    assert_1$1(size >>> 0 === size);
    var bytes = size + 7 >>> 3;
    if (msg.length < bytes + 24) throw new Error('Invalid ciphertext.');
    var pub = rsaBrowser.publicKeyCreate(priv);
    var ct = rsaBrowser.unveil(msg.slice(0, bytes), size, pub);
    var key = rsaBrowser.decryptOAEP(hash, ct, priv, label);
    var nonce = msg.slice(bytes, bytes + 24);
    var sealed = msg.slice(bytes + 24);
    return secretboxBrowser.open(sealed, key, nonce);
  }
  /*
   * Expose
   */


  var encrypt_1$5 = encrypt$6;
  var decrypt_1$5 = decrypt$5;
  var rsaies = {
    encrypt: encrypt_1$5,
    decrypt: decrypt_1$5
  };

  var naf$1 = {
    width: 9,
    points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
  };
  var doubles$1 = {
    step: 4,
    points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
  };
  var secp256k1 = {
    naf: naf$1,
    doubles: doubles$1
  };

  var secp256k1$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    naf: naf$1,
    doubles: doubles$1,
    'default': secp256k1
  });

  var pre$1 = getCjsExportFromNamespace(secp256k1$1);

  function _createForOfIteratorHelper$g(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$g(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$g(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$g(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(o, minLen); }

  function _arrayLikeToArray$g(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  /**
   * Schnorr
   */


  var Schnorr$1 = /*#__PURE__*/function () {
    function Schnorr(name, hash, pre) {
      _classCallCheck__default['default'](this, Schnorr);

      assert_1$1(typeof name === 'string');
      assert_1$1(hash);
      this.id = name;
      this.type = 'schnorr';
      this.hash = hash;
      this.native = 0;
      this._pre = pre || null;
      this._curve = null;
      this._rng = null;
      this._auxTag = null;
      this._nonceTag = null;
      this._challengeTag = null;
    }

    _createClass__default['default'](Schnorr, [{
      key: "check",
      value: function check() {
        // [BIP340] "Footnotes".
        // Must be congruent to 3 mod 4.
        if (this.curve.p.andln(3) !== 3) throw new Error("Schnorr is not supported for ".concat(this.curve.id, "."));
      }
    }, {
      key: "hashInt",
      value: function hashInt() {
        // [BIP340] "Specification".
        // eslint-disable-next-line
        var h = new this.hash();
        h.init();

        for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
          items[_key] = arguments[_key];
        }

        for (var _i = 0, _items = items; _i < _items.length; _i++) {
          var item = _items[_i];
          h.update(item);
        }

        var hash = h.final();
        if (hash.length > this.curve.scalarSize) hash = hash.slice(0, this.curve.scalarSize);
        var num = bnBrowser.decode(hash, this.curve.endian);
        return num.imod(this.curve.n);
      }
    }, {
      key: "hashAux",
      value: function hashAux(a, d) {
        assert_1$1(Buffer.isBuffer(a));
        assert_1$1(Buffer.isBuffer(d));
        if (!this._auxTag) this._auxTag = createTag(this.hash, 'BIP340/aux'); // eslint-disable-next-line

        var h = new this.hash();
        h.init();
        h.update(this._auxTag);
        h.update(d);
        var hash = h.final();
        var t = Buffer.alloc(a.length);

        for (var i = 0; i < t.length; i++) {
          t[i] = a[i] ^ hash[i % hash.length];
        }

        return t;
      }
    }, {
      key: "hashNonce",
      value: function hashNonce(a, A, m, d) {
        if (!this._nonceTag) this._nonceTag = createTag(this.hash, 'BIP340/nonce');
        return this.hashInt(this._nonceTag, this.hashAux(a, d), A, m);
      }
    }, {
      key: "hashChallenge",
      value: function hashChallenge(R, A, m) {
        if (!this._challengeTag) this._challengeTag = createTag(this.hash, 'BIP340/challenge');
        return this.hashInt(this._challengeTag, R, A, m);
      }
    }, {
      key: "privateKeyGenerate",
      value: function privateKeyGenerate() {
        var a = this.curve.randomScalar(randomBrowser);
        return this.curve.encodeScalar(a);
      }
    }, {
      key: "privateKeyVerify",
      value: function privateKeyVerify(key) {
        assert_1$1(Buffer.isBuffer(key));
        var a;

        try {
          a = this.curve.decodeScalar(key);
        } catch (e) {
          return false;
        }

        return !a.isZero() && a.cmp(this.curve.n) < 0;
      }
    }, {
      key: "privateKeyExport",
      value: function privateKeyExport(key) {
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var A = this.curve.g.mul(a);

        if (!A.isEven()) {
          a.ineg().imod(this.curve.n);
          A = A.neg();
        }

        return {
          d: this.curve.encodeScalar(a),
          x: this.curve.encodeField(A.x.fromRed()),
          y: this.curve.encodeField(A.y.fromRed())
        };
      }
    }, {
      key: "privateKeyImport",
      value: function privateKeyImport(json) {
        assert_1$1(json && _typeof__default['default'](json) === 'object');
        var a = bnBrowser.decode(json.d, this.curve.endian);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        return this.curve.encodeScalar(a);
      }
    }, {
      key: "privateKeyTweakAdd",
      value: function privateKeyTweakAdd(key, tweak) {
        var t = this.curve.decodeScalar(tweak);
        if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var A = this.curve.g.mul(a);
        if (!A.isEven()) a.ineg().imod(this.curve.n);
        var k = a.add(t).imod(this.curve.n);
        if (k.isZero()) throw new Error('Invalid private key.');
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "privateKeyTweakMul",
      value: function privateKeyTweakMul(key, tweak) {
        var t = this.curve.decodeScalar(tweak);
        if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var k = a.mul(t).imod(this.curve.n);
        if (k.isZero()) throw new Error('Invalid private key.');
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "privateKeyReduce",
      value: function privateKeyReduce(key) {
        assert_1$1(Buffer.isBuffer(key));
        if (key.length > this.curve.scalarSize) key = key.slice(0, this.curve.scalarSize);
        var a = bnBrowser.decode(key, this.curve.endian).imod(this.curve.n);
        if (a.isZero()) throw new Error('Invalid private key.');
        return this.curve.encodeScalar(a);
      }
    }, {
      key: "privateKeyInvert",
      value: function privateKeyInvert(key) {
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var k = a.invert(this.curve.n);
        return this.curve.encodeScalar(k);
      }
    }, {
      key: "publicKeyCreate",
      value: function publicKeyCreate(key) {
        // [BIP340] "Public Key Generation".
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var A = this.curve.g.mulBlind(a);
        return A.encodeX();
      }
    }, {
      key: "publicKeyFromUniform",
      value: function publicKeyFromUniform(bytes) {
        var u = this.curve.decodeUniform(bytes);
        var A = this.curve.pointFromUniform(u);
        return A.encodeX();
      }
    }, {
      key: "publicKeyToUniform",
      value: function publicKeyToUniform(key) {
        var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : randomBrowser.randomInt();
        var A = this.curve.decodeEven(key);
        var u = this.curve.pointToUniform(A, hint);
        return this.curve.encodeUniform(u, hint >>> 8);
      }
    }, {
      key: "publicKeyFromHash",
      value: function publicKeyFromHash(bytes) {
        var A = this.curve.pointFromHash(bytes);
        return A.encodeX();
      }
    }, {
      key: "publicKeyToHash",
      value: function publicKeyToHash(key) {
        var A = this.curve.decodeEven(key);
        return this.curve.pointToHash(A, 0, randomBrowser);
      }
    }, {
      key: "publicKeyVerify",
      value: function publicKeyVerify(key) {
        assert_1$1(Buffer.isBuffer(key));

        try {
          this.curve.decodeEven(key);
        } catch (e) {
          return false;
        }

        return true;
      }
    }, {
      key: "publicKeyExport",
      value: function publicKeyExport(key) {
        var _this$curve$decodeEve = this.curve.decodeEven(key),
            x = _this$curve$decodeEve.x,
            y = _this$curve$decodeEve.y;

        return {
          x: this.curve.encodeField(x.fromRed()),
          y: this.curve.encodeField(y.fromRed())
        };
      }
    }, {
      key: "publicKeyImport",
      value: function publicKeyImport(json) {
        assert_1$1(json && _typeof__default['default'](json) === 'object');
        var x = bnBrowser.decode(json.x, this.curve.endian);
        if (x.cmp(this.curve.p) >= 0) throw new Error('Invalid point.');
        var A = this.curve.pointFromX(x);
        return A.encodeX();
      }
    }, {
      key: "publicKeyTweakAdd",
      value: function publicKeyTweakAdd(key, tweak) {
        var t = this.curve.decodeScalar(tweak);
        if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var A = this.curve.decodeEven(key);
        var T = this.curve.g.jmul(t);
        var P = T.add(A);
        return P.encodeX();
      }
    }, {
      key: "publicKeyTweakMul",
      value: function publicKeyTweakMul(key, tweak) {
        var t = this.curve.decodeScalar(tweak);
        if (t.isZero() || t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var A = this.curve.decodeEven(key);
        var P = A.mul(t);
        return P.encodeX();
      }
    }, {
      key: "publicKeyTweakSum",
      value: function publicKeyTweakSum(key, tweak) {
        var t = this.curve.decodeScalar(tweak);
        if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var A = this.curve.decodeEven(key);
        var T = this.curve.g.jmul(t);
        var P = T.add(A);
        return [P.encodeX(), P.isOdd()];
      }
    }, {
      key: "publicKeyTweakTest",
      value: function publicKeyTweakTest(key, tweak, expect, negated) {
        assert_1$1(Buffer.isBuffer(key));
        assert_1$1(Buffer.isBuffer(tweak));
        assert_1$1(Buffer.isBuffer(expect));
        assert_1$1(typeof negated === 'boolean');

        try {
          return this._publicKeyTweakTest(key, tweak, expect, negated);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "_publicKeyTweakTest",
      value: function _publicKeyTweakTest(key, tweak, expect, negated) {
        var t = this.curve.decodeScalar(tweak);
        if (t.cmp(this.curve.n) >= 0) throw new Error('Invalid scalar.');
        var A = this.curve.decodeEven(key);
        var T = this.curve.g.jmul(t);
        var Q = this.curve.decodeEven(expect);
        var P = T.add(A);
        if (negated) P = P.neg();
        return P.eq(Q.toJ());
      }
    }, {
      key: "publicKeyCombine",
      value: function publicKeyCombine(keys) {
        assert_1$1(Array.isArray(keys));
        var P = this.curve.jpoint();

        var _iterator = _createForOfIteratorHelper$g(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;
            var A = this.curve.decodeEven(key);
            P = P.add(A);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return P.encodeX();
      }
    }, {
      key: "sign",
      value: function sign(msg, key) {
        var aux = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : randomBrowser.randomBytes(32);
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(aux));
        assert_1$1(aux.length === 32);
        return this._sign(msg, key, aux);
      }
    }, {
      key: "_sign",
      value: function _sign(msg, key, aux) {
        // Schnorr Signing.
        //
        // [BIP340] "Default Signing".
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `m` be a 32-byte array.
        //   - Let `a` be a secret non-zero scalar.
        //   - Let `d` be a 32-byte array.
        //   - k != 0.
        //
        // Computation:
        //
        //   A = G * a
        //   a = -a mod n, if y(A) is not even
        //   x = x(A)
        //   t = a xor H("BIP340/aux", d)
        //   k = H("BIP340/nonce", t, x, m) mod n
        //   R = G * k
        //   k = -k mod n, if y(R) is not square
        //   r = x(R)
        //   e = H("BIP340/challenge", r, x, m) mod n
        //   s = (k + e * a) mod n
        //   S = (r, s)
        //
        // Note that `k` must remain secret,
        // otherwise an attacker can compute:
        //
        //   a = (s - k) / e mod n
        var n = this.curve.n;
        var G = this.curve.g;
        var a = this.curve.decodeScalar(key);
        if (a.isZero() || a.cmp(n) >= 0) throw new Error('Invalid private key.');
        var A = G.mulBlind(a);
        if (!A.isEven()) a.ineg().imod(n);
        var araw = this.curve.encodeScalar(a);
        var Araw = A.encodeX();
        var k = this.hashNonce(araw, Araw, msg, aux);
        if (k.isZero()) throw new Error('Signing failed (k\' = 0).');
        var R = G.mulBlind(k);
        if (!R.isSquare()) k.ineg().imod(n);
        var Rraw = R.encodeX();
        var e = this.hashChallenge(Rraw, Araw, msg);
        var s = k.add(e.mul(a)).imod(n);
        return Buffer.concat([Rraw, this.curve.encodeScalar(s)]);
      }
    }, {
      key: "verify",
      value: function verify(msg, sig, key) {
        assert_1$1(Buffer.isBuffer(msg));
        assert_1$1(Buffer.isBuffer(sig));
        assert_1$1(Buffer.isBuffer(key));
        if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;
        if (key.length !== this.curve.fieldSize) return false;

        try {
          return this._verify(msg, sig, key);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "_verify",
      value: function _verify(msg, sig, key) {
        // Schnorr Verification.
        //
        // [BIP340] "Verification".
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `m` be a 32-byte array.
        //   - Let `r` and `s` be signature elements.
        //   - Let `x` be a field element.
        //   - r^3 + a * r + b is square in F(p).
        //   - x^3 + a * x + b is even in F(p).
        //   - r < p, s < n, x < p.
        //   - R != O.
        //
        // Computation:
        //
        //   R = (r, sqrt(r^3 + a * r + b))
        //   A = (x, sqrt(x^3 + a * x + b))
        //   e = H("BIP340/challenge", r, x, m) mod n
        //   R == G * s - A * e
        //
        // We can skip a square root with:
        //
        //   A = (x, sqrt(x^3 + a * x + b))
        //   e = H("BIP340/challenge", r, x, m) mod n
        //   R = G * s - A * e
        //   y(R) is square
        //   x(R) == r
        //
        // We can also avoid affinization by
        // replacing the two assertions with:
        //
        //   (y(R) * z(R) mod p) is square
        //   x(R) == r * z(R)^2 mod p
        //
        // Furthermore, squareness can be calculated
        // with a variable time Jacobi symbol algorithm.
        var _this$curve = this.curve,
            p = _this$curve.p,
            n = _this$curve.n;
        var G = this.curve.g;
        var Rraw = sig.slice(0, this.curve.fieldSize);
        var sraw = sig.slice(this.curve.fieldSize);
        var r = this.curve.decodeField(Rraw);
        var s = this.curve.decodeScalar(sraw);
        var A = this.curve.decodeEven(key);
        if (r.cmp(p) >= 0 || s.cmp(n) >= 0) return false;
        var e = this.hashChallenge(Rraw, key, msg);
        var R = G.jmulAdd(s, A, e.ineg().imod(n));
        if (!R.isSquare()) return false;
        if (!R.eqX(r)) return false;
        return true;
      }
    }, {
      key: "verifyBatch",
      value: function verifyBatch(batch) {
        assert_1$1(Array.isArray(batch));

        var _iterator2 = _createForOfIteratorHelper$g(batch),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            assert_1$1(Array.isArray(item) && item.length === 3);

            var _item = _slicedToArray__default['default'](item, 3),
                msg = _item[0],
                sig = _item[1],
                key = _item[2];

            assert_1$1(Buffer.isBuffer(msg));
            assert_1$1(Buffer.isBuffer(sig));
            assert_1$1(Buffer.isBuffer(key));
            if (sig.length !== this.curve.fieldSize + this.curve.scalarSize) return false;
            if (key.length !== this.curve.fieldSize) return false;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        try {
          return this._verifyBatch(batch);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "_verifyBatch",
      value: function _verifyBatch(batch) {
        // Schnorr Batch Verification.
        //
        // [BIP340] "Batch Verification".
        //
        // Assumptions:
        //
        //   - Let `H` be a cryptographic hash function.
        //   - Let `m` be a 32-byte array.
        //   - Let `r` and `s` be signature elements.
        //   - Let `x` be a field element.
        //   - Let `i` be the batch item index.
        //   - r^3 + a * r + b is square in F(p).
        //   - x^3 + a * x + b is even in F(p).
        //   - r < p, s < n, x < p.
        //   - a1 = 1 mod n.
        //
        // Computation:
        //
        //   Ri = (ri, sqrt(ri^3 + a * ri + b))
        //   Ai = (xi, sqrt(xi^3 + a * xi + b))
        //   ei = H("BIP340/challenge", ri, xi, mi) mod n
        //   ai = random integer in [1,n-1]
        //   lhs = si * ai + ... mod n
        //   rhs = Ri * ai + Ai * (ei * ai mod n) + ...
        //   G * -lhs + rhs == O
        var n = this.curve.n;
        var G = this.curve.g;
        var points = new Array(1 + batch.length * 2);
        var coeffs = new Array(1 + batch.length * 2);
        var sum = new bnBrowser(0);
        this.rng.init(batch);
        points[0] = G;
        coeffs[0] = sum;

        for (var i = 0; i < batch.length; i++) {
          var _batch$i = _slicedToArray__default['default'](batch[i], 3),
              msg = _batch$i[0],
              sig = _batch$i[1],
              key = _batch$i[2];

          var Rraw = sig.slice(0, this.curve.fieldSize);
          var sraw = sig.slice(this.curve.fieldSize);
          var R = this.curve.decodeSquare(Rraw);
          var s = this.curve.decodeScalar(sraw);
          var A = this.curve.decodeEven(key);
          if (s.cmp(n) >= 0) return false;
          var e = this.hashChallenge(Rraw, key, msg);
          var a = this.rng.generate(i);
          var ea = e.mul(a).imod(n);
          sum.iadd(s.mul(a)).imod(n);
          points[1 + i * 2 + 0] = R;
          coeffs[1 + i * 2 + 0] = a;
          points[1 + i * 2 + 1] = A;
          coeffs[1 + i * 2 + 1] = ea;
        }

        sum.ineg().imod(n);
        return this.curve.jmulAll(points, coeffs).isInfinity();
      }
    }, {
      key: "derive",
      value: function derive(pub, priv) {
        var A = this.curve.decodeEven(pub);
        var a = this.curve.decodeScalar(priv);
        if (a.isZero() || a.cmp(this.curve.n) >= 0) throw new Error('Invalid private key.');
        var P = A.mulConst(a, randomBrowser);
        return P.encodeX();
      }
    }, {
      key: "curve",
      get: function get() {
        if (!this._curve) {
          this._curve = elliptic.curve(this.id, this._pre);

          this._curve.precompute(randomBrowser);

          this._pre = null;
          this.check();
        }

        return this._curve;
      }
    }, {
      key: "rng",
      get: function get() {
        if (!this._rng) this._rng = new batchRng(this.curve);
        return this._rng;
      }
    }, {
      key: "size",
      get: function get() {
        return this.curve.fieldSize;
      }
    }, {
      key: "bits",
      get: function get() {
        return this.curve.fieldBits;
      }
    }]);

    return Schnorr;
  }();
  /*
   * Helpers
   */


  function createTag(alg, tag) {
    // [BIP340] "Tagged Hashes".
    var raw = Buffer.from(tag, 'binary');
    var hash = alg.digest(raw);
    return Buffer.concat([hash, hash]);
  }
  /*
   * Expose
   */


  var schnorr = new Schnorr$1('SECP256K1', sha256Browser, pre$1);

  var schnorrBrowser = schnorr;

  /*
   * Constants
   */


  var SLAB1 = Buffer.alloc(64);
  var SLAB2 = new Uint32Array(16);
  var SLAB3 = new Uint32Array(16);
  /**
   * Perform scrypt key derivation.
   * @param {Buffer} passwd
   * @param {Buffer} salt
   * @param {Number} N
   * @param {Number} r
   * @param {Number} p
   * @param {Number} len
   * @returns {Buffer}
   */

  function derive$6(passwd, salt, N, r, p, len) {
    if (typeof passwd === 'string') passwd = Buffer.from(passwd, 'utf8');
    if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
    if (salt == null) salt = Buffer.alloc(0);
    assert_1$1(Buffer.isBuffer(passwd));
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(N >>> 0 === N);
    assert_1$1(r >>> 0 === r);
    assert_1$1(p >>> 0 === p);
    assert_1$1(len >>> 0 === len);
    if (r * p >= 1 << 30) throw new Error('EFBIG');
    if ((N & N - 1) !== 0 || N === 0) throw new Error('EINVAL');
    if (N > 0xffffffff) throw new Error('EINVAL');
    var XY = Buffer.alloc(256 * r);
    var V = Buffer.alloc(128 * r * N);
    var B = pbkdf2Browser.derive(sha256Browser, passwd, salt, 1, p * 128 * r);

    for (var i = 0; i < p; i++) {
      smix(B, i * 128 * r, r, N, V, XY);
    }

    clear();
    return pbkdf2Browser.derive(sha256Browser, passwd, B, 1, len);
  }
  /**
   * Perform scrypt key derivation (async).
   * @param {Buffer} passwd
   * @param {Buffer} salt
   * @param {Number} N
   * @param {Number} r
   * @param {Number} p
   * @param {Number} len
   * @returns {Promise}
   */


  function deriveAsync$1(_x, _x2, _x3, _x4, _x5, _x6) {
    return _deriveAsync$1.apply(this, arguments);
  }
  /*
   * Helpers
   */


  function _deriveAsync$1() {
    _deriveAsync$1 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(passwd, salt, N, r, p, len) {
      var XY, V, B, i;
      return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (typeof passwd === 'string') passwd = Buffer.from(passwd, 'utf8');
              if (typeof salt === 'string') salt = Buffer.from(salt, 'utf8');
              if (salt == null) salt = Buffer.alloc(0);
              assert_1$1(Buffer.isBuffer(passwd));
              assert_1$1(Buffer.isBuffer(salt));
              assert_1$1(N >>> 0 === N);
              assert_1$1(r >>> 0 === r);
              assert_1$1(p >>> 0 === p);
              assert_1$1(len >>> 0 === len);

              if (!(r * p >= 1 << 30)) {
                _context.next = 11;
                break;
              }

              throw new Error('EFBIG');

            case 11:
              if (!((N & N - 1) !== 0 || N === 0)) {
                _context.next = 13;
                break;
              }

              throw new Error('EINVAL');

            case 13:
              if (!(N > 0xffffffff)) {
                _context.next = 15;
                break;
              }

              throw new Error('EINVAL');

            case 15:
              XY = Buffer.alloc(256 * r);
              V = Buffer.alloc(128 * r * N);
              _context.next = 19;
              return pbkdf2Browser.deriveAsync(sha256Browser, passwd, salt, 1, p * 128 * r);

            case 19:
              B = _context.sent;
              i = 0;

            case 21:
              if (!(i < p)) {
                _context.next = 27;
                break;
              }

              _context.next = 24;
              return smixAsync(B, i * 128 * r, r, N, V, XY);

            case 24:
              i++;
              _context.next = 21;
              break;

            case 27:
              clear();
              return _context.abrupt("return", pbkdf2Browser.deriveAsync(sha256Browser, passwd, B, 1, len));

            case 29:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _deriveAsync$1.apply(this, arguments);
  }

  function salsa20_8(B) {
    var B32 = SLAB2;
    var X = SLAB3;

    for (var i = 0; i < 16; i++) {
      B32[i] = readU32$n(B, i * 4);
    }

    for (var _i = 0; _i < 16; _i++) {
      X[_i] = B32[_i];
    }

    for (var _i2 = 0; _i2 < 8; _i2 += 2) {
      X[4] ^= R(X[0] + X[12], 7);
      X[8] ^= R(X[4] + X[0], 9);
      X[12] ^= R(X[8] + X[4], 13);
      X[0] ^= R(X[12] + X[8], 18);
      X[9] ^= R(X[5] + X[1], 7);
      X[13] ^= R(X[9] + X[5], 9);
      X[1] ^= R(X[13] + X[9], 13);
      X[5] ^= R(X[1] + X[13], 18);
      X[14] ^= R(X[10] + X[6], 7);
      X[2] ^= R(X[14] + X[10], 9);
      X[6] ^= R(X[2] + X[14], 13);
      X[10] ^= R(X[6] + X[2], 18);
      X[3] ^= R(X[15] + X[11], 7);
      X[7] ^= R(X[3] + X[15], 9);
      X[11] ^= R(X[7] + X[3], 13);
      X[15] ^= R(X[11] + X[7], 18);
      X[1] ^= R(X[0] + X[3], 7);
      X[2] ^= R(X[1] + X[0], 9);
      X[3] ^= R(X[2] + X[1], 13);
      X[0] ^= R(X[3] + X[2], 18);
      X[6] ^= R(X[5] + X[4], 7);
      X[7] ^= R(X[6] + X[5], 9);
      X[4] ^= R(X[7] + X[6], 13);
      X[5] ^= R(X[4] + X[7], 18);
      X[11] ^= R(X[10] + X[9], 7);
      X[8] ^= R(X[11] + X[10], 9);
      X[9] ^= R(X[8] + X[11], 13);
      X[10] ^= R(X[9] + X[8], 18);
      X[12] ^= R(X[15] + X[14], 7);
      X[13] ^= R(X[12] + X[15], 9);
      X[14] ^= R(X[13] + X[12], 13);
      X[15] ^= R(X[14] + X[13], 18);
    }

    for (var _i3 = 0; _i3 < 16; _i3++) {
      B32[_i3] += X[_i3];
    }

    for (var _i4 = 0; _i4 < 16; _i4++) {
      writeU32$l(B, B32[_i4], 4 * _i4);
    }
  }

  function R(a, b) {
    return a << b | a >>> 32 - b;
  }

  function blockmix_salsa8(B, Y, Yo, r) {
    var X = SLAB1;
    blkcpy(X, B, 0, (2 * r - 1) * 64, 64);

    for (var i = 0; i < 2 * r; i++) {
      blkxor(X, B, 0, i * 64, 64);
      salsa20_8(X);
      blkcpy(Y, X, Yo + i * 64, 0, 64);
    }

    for (var _i5 = 0; _i5 < r; _i5++) {
      blkcpy(B, Y, _i5 * 64, Yo + _i5 * 2 * 64, 64);
    }

    for (var _i6 = 0; _i6 < r; _i6++) {
      blkcpy(B, Y, (_i6 + r) * 64, Yo + (_i6 * 2 + 1) * 64, 64);
    }
  }

  function integerify(B, r) {
    return readU32$n(B, (2 * r - 1) * 64);
  }

  function smix(B, Bo, r, N, V, XY) {
    var X = XY;
    var Y = XY;
    blkcpy(X, B, 0, Bo, 128 * r);

    for (var i = 0; i < N; i++) {
      blkcpy(V, X, i * (128 * r), 0, 128 * r);
      blockmix_salsa8(X, Y, 128 * r, r);
    }

    for (var _i7 = 0; _i7 < N; _i7++) {
      var j = integerify(X, r) & N - 1;
      blkxor(X, V, 0, j * (128 * r), 128 * r);
      blockmix_salsa8(X, Y, 128 * r, r);
    }

    blkcpy(B, X, Bo, 0, 128 * r);
  }

  function smixAsync(_x7, _x8, _x9, _x10, _x11, _x12) {
    return _smixAsync.apply(this, arguments);
  }

  function _smixAsync() {
    _smixAsync = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(B, Bo, r, N, V, XY) {
      var X, Y, i, _i9, j;

      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              X = XY;
              Y = XY;
              blkcpy(X, B, 0, Bo, 128 * r);
              i = 0;

            case 4:
              if (!(i < N)) {
                _context2.next = 12;
                break;
              }

              blkcpy(V, X, i * (128 * r), 0, 128 * r);
              blockmix_salsa8(X, Y, 128 * r, r);
              _context2.next = 9;
              return wait();

            case 9:
              i++;
              _context2.next = 4;
              break;

            case 12:
              _i9 = 0;

            case 13:
              if (!(_i9 < N)) {
                _context2.next = 22;
                break;
              }

              j = integerify(X, r) & N - 1;
              blkxor(X, V, 0, j * (128 * r), 128 * r);
              blockmix_salsa8(X, Y, 128 * r, r);
              _context2.next = 19;
              return wait();

            case 19:
              _i9++;
              _context2.next = 13;
              break;

            case 22:
              blkcpy(B, X, Bo, 0, 128 * r);

            case 23:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _smixAsync.apply(this, arguments);
  }

  function blkcpy(dst, src, dstOff, srcOff, len) {
    src.copy(dst, dstOff, srcOff, srcOff + len);
  }

  function blkxor(dst, src, dstOff, srcOff, len) {
    for (var i = 0; i < len; i++) {
      dst[dstOff + i] ^= src[srcOff + i];
    }
  }

  function wait() {
    return new Promise(function (r) {
      return setImmediate(r);
    });
  }

  function clear() {
    for (var i = 0; i < 64; i++) {
      SLAB1[i] = 0;
    }

    for (var _i8 = 0; _i8 < 16; _i8++) {
      SLAB2[_i8] = 0;
      SLAB3[_i8] = 0;
    }
  }

  function readU32$n(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }

  function writeU32$l(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var native_1$j = 0;
  var derive_1$6 = derive$6;
  var deriveAsync_1$1 = deriveAsync$1;
  var scrypt = {
    native: native_1$j,
    derive: derive_1$6,
    deriveAsync: deriveAsync_1$1
  };

  var scryptBrowser = scrypt;

  /*
   * Expose
   */


  var secp256k1$2 = new ecdsa('SECP256K1', sha256Browser, pre$1);

  var secp256k1Browser = secp256k1$2;

  var _keyTypesByVal, _typeToCurve;

  function _createSuper$F(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$F(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$F() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var padLeft$2 = util$1.padLeft,
      padRight$2 = util$1.padRight;
  var PEMBlock$3 = pem.PEMBlock;
  /*
   * Constants
   */

  var keyTypes$1 = {
    DSA: 'ssh-dss',
    RSA: 'ssh-rsa',
    P256: 'ecdsa-sha2-nistp256',
    P384: 'ecdsa-sha2-nistp384',
    P521: 'ecdsa-sha2-nistp521',
    ED25519: 'ssh-ed25519'
  };
  var keyTypesByVal$1 = (_keyTypesByVal = {}, _defineProperty__default['default'](_keyTypesByVal, keyTypes$1.DSA, 'DSA'), _defineProperty__default['default'](_keyTypesByVal, keyTypes$1.RSA, 'RSA'), _defineProperty__default['default'](_keyTypesByVal, keyTypes$1.P256, 'P256'), _defineProperty__default['default'](_keyTypesByVal, keyTypes$1.P384, 'P384'), _defineProperty__default['default'](_keyTypesByVal, keyTypes$1.P521, 'P521'), _defineProperty__default['default'](_keyTypesByVal, keyTypes$1.ED25519, 'ED25519'), _keyTypesByVal);
  var typeToCurve = (_typeToCurve = {}, _defineProperty__default['default'](_typeToCurve, keyTypes$1.P256, 'nistp256'), _defineProperty__default['default'](_typeToCurve, keyTypes$1.P384, 'nistp384'), _defineProperty__default['default'](_typeToCurve, keyTypes$1.P521, 'nistp521'), _typeToCurve);
  var cipherInfo$1 = {
    '3des-cbc': ['DES-EDE3-CBC', 24, 8],
    'aes128-cbc': ['AES-128-CBC', 16, 16],
    'aes192-cbc': ['AES-192-CBC', 24, 16],
    'aes256-cbc': ['AES-256-CBC', 32, 16],
    'rijndael-cbc@lysator.liu.se': ['AES-256-CBC', 32, 16],
    'aes128-ctr': ['AES-128-CTR', 16, 16],
    'aes192-ctr': ['AES-192-CTR', 24, 16],
    'aes256-ctr': ['AES-256-CTR', 32, 16]
  };
  var AUTH_MAGIC = 'openssh-key-v1';
  var EMPTY$b = Buffer.alloc(0);
  var ZERO32 = Buffer.alloc(32, 0x00);
  /**
   * SSHPublicKey
   */

  var SSHPublicKey = /*#__PURE__*/function (_bio$Struct) {
    _inherits__default['default'](SSHPublicKey, _bio$Struct);

    var _super = _createSuper$F(SSHPublicKey);

    function SSHPublicKey() {
      var _this;

      _classCallCheck__default['default'](this, SSHPublicKey);

      _this = _super.call(this);
      _this.type = keyTypes$1.ED25519; // DSA

      _this.p = EMPTY$b;
      _this.q = EMPTY$b;
      _this.g = EMPTY$b;
      _this.y = EMPTY$b; // RSA

      _this.n = EMPTY$b;
      _this.e = EMPTY$b; // ECDSA / EDDSA

      _this.point = ZERO32; // Comment

      _this.comment = '';
      return _this;
    }

    _createClass__default['default'](SSHPublicKey, [{
      key: "getCurve",
      value: function getCurve() {
        if (!typeToCurve.hasOwnProperty(this.type)) throw new Error('No curve available.');
        return typeToCurve[this.type];
      }
    }, {
      key: "getSize",
      value: function getSize() {
        var size = 0;
        size += sizeString(this.type);

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              size += sizeBytes(this.p);
              size += sizeBytes(this.q);
              size += sizeBytes(this.g);
              size += sizeBytes(this.y);
              break;
            }

          case keyTypes$1.RSA:
            {
              size += sizeBytes(this.e);
              size += sizeBytes(this.n);
              break;
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
            {
              size += sizeBytes(this.getCurve());
              size += sizeBytes(this.point);
              break;
            }

          case keyTypes$1.ED25519:
            {
              size += sizeBytes(this.point);
              break;
            }

          default:
            {
              throw new assert_1$1.AssertionError('Invalid key.');
            }
        }

        return size;
      }
    }, {
      key: "write",
      value: function write(bw) {
        writeString$2(bw, this.type);

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              writeBytes$2(bw, this.p);
              writeBytes$2(bw, this.q);
              writeBytes$2(bw, this.g);
              writeBytes$2(bw, this.y);
              break;
            }

          case keyTypes$1.RSA:
            {
              writeBytes$2(bw, this.e);
              writeBytes$2(bw, this.n);
              break;
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
            {
              writeString$2(bw, this.getCurve());
              writeBytes$2(bw, this.point);
              break;
            }

          case keyTypes$1.ED25519:
            {
              writeBytes$2(bw, this.point);
              break;
            }

          default:
            {
              throw new assert_1$1.AssertionError('Invalid key.');
            }
        }

        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        this.type = readString$2(br);

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              this.p = readBytes$2(br);
              this.q = readBytes$2(br);
              this.g = readBytes$2(br);
              this.y = readBytes$2(br);
              break;
            }

          case keyTypes$1.RSA:
            {
              this.e = readBytes$2(br);
              this.n = readBytes$2(br);
              break;
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
            {
              if (readString$2(br) !== this.getCurve()) throw new Error('Invalid curve prefix.');
              this.point = readBytes$2(br);
              break;
            }

          case keyTypes$1.ED25519:
            {
              this.point = readBytes$2(br);
              break;
            }

          default:
            {
              throw new Error('Invalid key type.');
            }
        }

        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        var raw = this.encode();
        var comment = this.comment;
        if (comment.length > 0) comment = ' ' + comment;
        return "".concat(this.type, " ").concat(base64Browser.encode(raw)).concat(comment);
      }
    }, {
      key: "fromString",
      value: function fromString(str) {
        assert_1$1(typeof str === 'string');
        var parts = str.split(' ', 3);
        if (parts.length < 2) throw new Error('Invalid SSH key text.');

        var _parts = _slicedToArray__default['default'](parts, 2),
            type = _parts[0],
            rest = _parts[1];

        if (!keyTypesByVal$1.hasOwnProperty(type)) throw new Error("Unknown SSH public key type: ".concat(type, "."));
        var data = base64Browser.decode(rest);
        this.decode(data);
        if (this.type !== type) throw new Error('Key type mismatch.');
        if (parts.length > 2) this.comment = parts[2].trim();
        return this;
      }
    }, {
      key: "format",
      value: function format() {
        switch (this.type) {
          case keyTypes$1.DSA:
            {
              return {
                type: this.type,
                p: this.p.toString('hex'),
                q: this.q.toString('hex'),
                g: this.g.toString('hex'),
                y: this.y.toString('hex'),
                comment: this.comment
              };
            }

          case keyTypes$1.RSA:
            {
              return {
                type: this.type,
                n: this.n.toString('hex'),
                e: this.e.toString('hex'),
                comment: this.comment
              };
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
          case keyTypes$1.ED25519:
            {
              return {
                type: this.type,
                point: this.point.toString('hex'),
                comment: this.comment
              };
            }

          default:
            {
              return this;
            }
        }
      }
    }]);

    return SSHPublicKey;
  }(bufio.Struct);
  /**
   * SSHPrivateKey
   */


  var SSHPrivateKey = /*#__PURE__*/function (_bio$Struct2) {
    _inherits__default['default'](SSHPrivateKey, _bio$Struct2);

    var _super2 = _createSuper$F(SSHPrivateKey);

    function SSHPrivateKey() {
      var _this2;

      _classCallCheck__default['default'](this, SSHPrivateKey);

      _this2 = _super2.call(this);
      _this2.type = keyTypes$1.ED25519; // DSA

      _this2.p = EMPTY$b;
      _this2.q = EMPTY$b;
      _this2.g = EMPTY$b;
      _this2.y = EMPTY$b;
      _this2.x = EMPTY$b; // RSA

      _this2.n = EMPTY$b;
      _this2.e = EMPTY$b;
      _this2.d = EMPTY$b;
      _this2.p = EMPTY$b;
      _this2.q = EMPTY$b;
      _this2.dp = EMPTY$b;
      _this2.dq = EMPTY$b;
      _this2.qi = EMPTY$b; // ECDSA / EDDSA

      _this2.key = ZERO32; // Comment

      _this2.comment = '';
      _this2.modern = false;
      return _this2;
    }

    _createClass__default['default'](SSHPrivateKey, [{
      key: "getCurve",
      value: function getCurve() {
        if (!typeToCurve.hasOwnProperty(this.type)) throw new Error('No curve available.');
        return typeToCurve[this.type];
      }
    }, {
      key: "encodeSSH",
      value: function encodeSSH(passwd) {
        assert_1$1(passwd == null || typeof passwd === 'string');
        var kdf = new KDFOptions();
        var pub = new SSHPublicKey();
        var priv = new RawPrivateKey();
        var bw = bufio.write(8192);
        bw.writeString(AUTH_MAGIC);
        bw.writeU8(0);

        if (passwd != null) {
          kdf.name = 'bcrypt';
          kdf.salt = randomBrowser.randomBytes(16);
          kdf.rounds = 16;
          writeString$2(bw, 'aes256-ctr');
        } else {
          writeString$2(bw, 'none');
        }

        kdf.write(bw);
        writeInt$1(bw, 1);
        pub.type = this.type;
        writeBytes$2(bw, pub.encode());
        priv.type = this.type;

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              priv.p = this.p;
              priv.q = this.q;
              priv.g = this.g;
              priv.y = this.y;
              priv.x = this.x;
              break;
            }

          case keyTypes$1.RSA:
            {
              priv.n = this.n;
              priv.e = this.e;
              priv.d = this.d;
              priv.p = this.p;
              priv.q = this.q;
              priv.qi = this.qi;
              break;
            }

          case keyTypes$1.P256:
            {
              priv.point = p256Browser.publicKeyCreate(this.key, false);
              priv.key = this.key;
              break;
            }

          case keyTypes$1.P384:
            {
              priv.point = p384Browser.publicKeyCreate(this.key, false);
              priv.key = this.key;
              break;
            }

          case keyTypes$1.P521:
            {
              priv.point = p521Browser.publicKeyCreate(this.key, false);
              priv.key = this.key;
              break;
            }

          case keyTypes$1.ED25519:
            {
              priv.point = ed25519Browser.publicKeyCreate(this.key);
              priv.key = this.key;
              break;
            }

          default:
            {
              throw new assert_1$1.AssertionError('Invalid key.');
            }
        }

        priv.comment = this.comment;
        var raw = priv.encode(passwd != null);
        if (passwd != null) raw = encrypt$7(raw, 'aes256-ctr', passwd, kdf.salt, kdf.rounds);
        writeBytes$2(bw, raw);
        return bw.slice();
      }
    }, {
      key: "decodeSSH",
      value: function decodeSSH(data, passwd) {
        var br = bufio.read(data);
        var magic = br.readString(14, 'binary');
        if (magic !== AUTH_MAGIC || br.readU8() !== 0) throw new Error('Invalid magic prefix for SSH key.');
        var cipher = readString$2(br);
        var kdf = KDFOptions.read(br);
        if (readInt$1(br) !== 1) throw new Error('Too many SSH keys.');
        var pubRaw = readBytes$2(br);
        var publicKey = SSHPublicKey.decode(pubRaw);
        var privRaw = readBytes$2(br);

        if (cipher !== 'none') {
          if (passwd == null) throw new Error('Cannot decrypt without passphrase.');
          if (kdf.name !== 'bcrypt') throw new Error('Invalid KDF.');
          privRaw = decrypt$6(privRaw, cipher, passwd, kdf.salt, kdf.rounds);
        }

        var priv = RawPrivateKey.decode(privRaw);
        if (priv.type !== publicKey.type) throw new Error('Public/private mismatch.');
        this.type = publicKey.type;

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              this.p = priv.p;
              this.q = priv.q;
              this.g = priv.g;
              this.y = priv.y;
              this.x = priv.x;
              break;
            }

          case keyTypes$1.RSA:
            {
              this.n = priv.n;
              this.e = priv.e;
              this.d = priv.d;
              this.p = priv.p;
              this.q = priv.q;
              this.qi = priv.qi;
              break;
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
          case keyTypes$1.ED25519:
            {
              this.key = priv.key;
              break;
            }

          default:
            {
              throw new assert_1$1.AssertionError('Invalid key.');
            }
        } // Recompute dp and dq.


        if (this.type === keyTypes$1.RSA) {
          var p = bnBrowser.decode(this.p);
          var q = bnBrowser.decode(this.q);
          var d = bnBrowser.decode(this.d);
          var dp = d.mod(p.subn(1));
          var dq = d.mod(q.subn(1));
          this.dp = dp.encode();
          this.dq = dq.encode();
        }

        this.comment = priv.comment;
        this.modern = true;
        return this;
      }
    }, {
      key: "encode",
      value: function encode(passwd) {
        // Ed25519 can _only_ use the new school encoding.
        if (this.modern || this.type === keyTypes$1.ED25519) return this.encodeSSH(passwd);

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              var key = new openssl.DSAPrivateKey(0, this.p, this.q, this.g, this.y, this.x);
              return key.encode();
            }

          case keyTypes$1.RSA:
            {
              var _key = new pkcs1.RSAPrivateKey(0, this.n, this.e, this.d, this.p, this.q, this.dp, this.dq, this.qi);

              return _key.encode();
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
            {
              var curve = null;
              var pub = null;

              switch (this.type) {
                case keyTypes$1.P256:
                  curve = 'P256';
                  pub = p256Browser.publicKeyCreate(this.key, false);
                  break;

                case keyTypes$1.P384:
                  curve = 'P384';
                  pub = p384Browser.publicKeyCreate(this.key, false);
                  break;

                case keyTypes$1.P521:
                  curve = 'P521';
                  pub = p521Browser.publicKeyCreate(this.key, false);
                  break;
              }

              var _key2 = new sec1.ECPrivateKey(1, this.key, curve, pub);

              return _key2.encode();
            }

          default:
            {
              throw new assert_1$1.AssertionError('Invalid key.');
            }
        }
      }
    }, {
      key: "toString",
      value: function toString(passwd) {
        var block = new PEMBlock$3(); // Ed25519 can _only_ use the new school encoding.

        if (this.modern || this.type === keyTypes$1.ED25519) {
          block.type = 'OPENSSH PRIVATE KEY';
          block.data = this.encode(passwd);
          return block.toString();
        }

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              block.type = 'DSA PRIVATE KEY';
              break;
            }

          case keyTypes$1.RSA:
            {
              block.type = 'RSA PRIVATE KEY';
              break;
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
            {
              block.type = 'EC PRIVATE KEY';
              break;
            }

          default:
            {
              throw new assert_1$1.AssertionError('Invalid key.');
            }
        }

        block.data = this.encode(null);
        if (passwd != null) pemcrypt.encrypt(block, 'AES-128-CBC', passwd);
        return block.toString();
      }
    }, {
      key: "fromString",
      value: function fromString(str, passwd) {
        var block = PEMBlock$3.fromString(str);

        if (block.isEncrypted()) {
          if (passwd == null) throw new Error('Private key requires a passphrase.');
          pemcrypt.decrypt(block, passwd);
        }

        switch (block.type) {
          case 'DSA PRIVATE KEY':
            {
              // OpenSSL PKCS1-like format
              var key = openssl.DSAPrivateKey.decode(block.data);
              this.type = keyTypes$1.DSA;
              this.p = key.p.value;
              this.q = key.q.value;
              this.g = key.g.value;
              this.y = key.y.value;
              this.x = key.x.value;
              return this;
            }

          case 'RSA PRIVATE KEY':
            {
              // PKCS1
              var _key3 = pkcs1.RSAPrivateKey.decode(block.data);

              this.type = keyTypes$1.RSA;
              this.n = _key3.n.value;
              this.e = _key3.e.value;
              this.d = _key3.d.value;
              this.p = _key3.p.value;
              this.q = _key3.q.value;
              this.dp = _key3.dp.value;
              this.dq = _key3.dq.value;
              this.qi = _key3.qi.value;
              return this;
            }

          case 'EC PRIVATE KEY':
            {
              // SEC1
              var _key4 = sec1.ECPrivateKey.decode(block.data);

              var curve = _key4.namedCurveOID.getCurveName();

              if (!curve) throw new Error("Unknown curve: ".concat(_key4.namedCurveOID.toString(), "."));
              var type = null;
              var size = 0;

              switch (curve) {
                case 'P256':
                  type = keyTypes$1.P256;
                  size = 32;
                  break;

                case 'P384':
                  type = keyTypes$1.P384;
                  size = 48;
                  break;

                case 'P521':
                  type = keyTypes$1.P521;
                  size = 66;
                  break;

                case 'ED25519':
                  type = keyTypes$1.ED25519;
                  size = 32;
                  break;

                default:
                  throw new Error("Unsupported curve: ".concat(curve, "."));
              }

              this.type = type;
              this.key = curve === 'ED25519' ? padRight$2(_key4.privateKey.value, size) : padLeft$2(_key4.privateKey.value, size);
              return this;
            }

          case 'OPENSSH PRIVATE KEY':
            {
              // OpenSSH format
              return this.decodeSSH(block.data, passwd);
            }

          default:
            {
              throw new Error("Unknown private key type: ".concat(block.type, "."));
            }
        }
      }
    }, {
      key: "format",
      value: function format() {
        switch (this.type) {
          case keyTypes$1.DSA:
            {
              return {
                type: this.type,
                p: this.p.toString('hex'),
                q: this.q.toString('hex'),
                g: this.g.toString('hex'),
                y: this.y.toString('hex'),
                x: this.x.toString('hex'),
                comment: this.comment,
                modern: this.modern
              };
            }

          case keyTypes$1.RSA:
            {
              return {
                type: this.type,
                n: this.n.toString('hex'),
                e: this.q.toString('hex'),
                d: this.d.toString('hex'),
                p: this.p.toString('hex'),
                q: this.q.toString('hex'),
                dp: this.dp.toString('hex'),
                dq: this.dq.toString('hex'),
                qi: this.qi.toString('hex'),
                comment: this.comment,
                modern: this.modern
              };
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
          case keyTypes$1.ED25519:
            {
              return {
                type: this.type,
                key: this.key.toString('hex'),
                comment: this.comment,
                modern: this.modern
              };
            }

          default:
            {
              return this;
            }
        }
      }
    }]);

    return SSHPrivateKey;
  }(bufio.Struct);
  /**
   * KDFOptions
   */


  var KDFOptions = /*#__PURE__*/function (_bio$Struct3) {
    _inherits__default['default'](KDFOptions, _bio$Struct3);

    var _super3 = _createSuper$F(KDFOptions);

    function KDFOptions() {
      var _this3;

      _classCallCheck__default['default'](this, KDFOptions);

      _this3 = _super3.call(this);
      _this3.name = 'none';
      _this3.salt = EMPTY$b;
      _this3.rounds = 0;
      return _this3;
    }

    _createClass__default['default'](KDFOptions, [{
      key: "getBodySize",
      value: function getBodySize() {
        var size = 0;

        switch (this.name) {
          case 'none':
            break;

          case 'bcrypt':
            size += sizeBytes(this.salt);
            size += sizeInt$1(this.rounds);
            break;

          default:
            throw new Error("Unknown KDF: ".concat(this.name, "."));
        }

        return size;
      }
    }, {
      key: "getSize",
      value: function getSize() {
        var size = 0;
        size += sizeString(this.name);
        size += sizeInt$1();
        size += this.getBodySize();
        return size;
      }
    }, {
      key: "write",
      value: function write(bw) {
        writeString$2(bw, this.name);
        writeInt$1(bw, this.getBodySize());

        switch (this.name) {
          case 'none':
            break;

          case 'bcrypt':
            writeBytes$2(bw, this.salt);
            writeInt$1(bw, this.rounds);
            break;

          default:
            throw new Error("Unknown KDF: ".concat(this.name, "."));
        }

        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        this.name = readString$2(br);
        var child = readChild(br);

        switch (this.name) {
          case 'none':
            break;

          case 'bcrypt':
            this.salt = readBytes$2(child);
            this.rounds = readInt$1(child);
            break;

          default:
            throw new Error("Unknown KDF: ".concat(this.name, "."));
        }

        return this;
      }
    }]);

    return KDFOptions;
  }(bufio.Struct);
  /**
   * RawPrivateKey
   */


  var RawPrivateKey = /*#__PURE__*/function (_bio$Struct4) {
    _inherits__default['default'](RawPrivateKey, _bio$Struct4);

    var _super4 = _createSuper$F(RawPrivateKey);

    function RawPrivateKey() {
      var _this4;

      _classCallCheck__default['default'](this, RawPrivateKey);

      _this4 = _super4.call(this);
      _this4.type = keyTypes$1.ED25519; // DSA

      _this4.p = EMPTY$b;
      _this4.q = EMPTY$b;
      _this4.g = EMPTY$b;
      _this4.y = EMPTY$b;
      _this4.x = EMPTY$b; // RSA

      _this4.n = EMPTY$b;
      _this4.e = EMPTY$b;
      _this4.d = EMPTY$b;
      _this4.p = EMPTY$b;
      _this4.q = EMPTY$b;
      _this4.qi = EMPTY$b; // ECDSA / EDDSA

      _this4.point = ZERO32;
      _this4.key = ZERO32;
      _this4.comment = '';
      return _this4;
    }

    _createClass__default['default'](RawPrivateKey, [{
      key: "getSize",
      value: function getSize(useNonce) {
        var size = 0;
        size += sizeInt$1();
        size += sizeInt$1();
        size += sizeString(this.type);

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              size += sizeBytes(this.p);
              size += sizeBytes(this.q);
              size += sizeBytes(this.g);
              size += sizeBytes(this.y);
              size += sizeBytes(this.x);
              break;
            }

          case keyTypes$1.RSA:
            {
              size += sizeBytes(this.n);
              size += sizeBytes(this.e);
              size += sizeBytes(this.d);
              size += sizeBytes(this.qi);
              size += sizeBytes(this.p);
              size += sizeBytes(this.q);
              break;
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
            {
              size += sizeString(typeToCurve[this.type]);
              size += sizeBytes(this.point);
              size += sizeBytes(this.key);
              break;
            }

          case keyTypes$1.ED25519:
            {
              size += sizeBytes(this.point);
              size += sizeInt$1();
              size += this.key.length;
              size += this.point.length;
              break;
            }

          default:
            {
              throw new Error('Invalid key.');
            }
        }

        size += sizeString(this.comment);
        size += 8 - (size & 7);
        return size;
      }
    }, {
      key: "write",
      value: function write(bw, useNonce) {
        var offset = bw.offset;
        var n = 0;
        if (useNonce) n = Math.random() * 0x100000000 >>> 0;
        writeInt$1(bw, n);
        writeInt$1(bw, n);
        writeString$2(bw, this.type);

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              writeBytes$2(bw, this.p);
              writeBytes$2(bw, this.q);
              writeBytes$2(bw, this.g);
              writeBytes$2(bw, this.y);
              writeBytes$2(bw, this.x);
              break;
            }

          case keyTypes$1.RSA:
            {
              writeBytes$2(bw, this.n);
              writeBytes$2(bw, this.e);
              writeBytes$2(bw, this.d);
              writeBytes$2(bw, this.qi);
              writeBytes$2(bw, this.p);
              writeBytes$2(bw, this.q);
              break;
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
            {
              writeString$2(bw, typeToCurve[this.type]);
              writeBytes$2(bw, this.point);
              writeBytes$2(bw, this.key);
              break;
            }

          case keyTypes$1.ED25519:
            {
              writeBytes$2(bw, this.point);
              writeBytes$2(bw, bufio.concat(this.key, this.point));
              break;
            }

          default:
            {
              throw new Error('Invalid key.');
            }
        }

        writeString$2(bw, this.comment);
        var size = bw.offset - offset;
        var i = 1;

        while (size & 7) {
          bw.writeU8(i);
          size += 1;
          i += 1;
        }

        return bw;
      }
    }, {
      key: "read",
      value: function read(br) {
        if ((br.left() & 7) !== 0) throw new Error('Invalid padding.');
        if (readInt$1(br) !== readInt$1(br)) throw new Error('Decryption failed.');
        this.type = readString$2(br);

        switch (this.type) {
          case keyTypes$1.DSA:
            {
              this.p = readBytes$2(br);
              this.q = readBytes$2(br);
              this.g = readBytes$2(br);
              this.y = readBytes$2(br);
              this.x = readBytes$2(br);
              break;
            }

          case keyTypes$1.RSA:
            {
              this.n = readBytes$2(br);
              this.e = readBytes$2(br);
              this.d = readBytes$2(br);
              this.qi = readBytes$2(br);
              this.p = readBytes$2(br);
              this.q = readBytes$2(br);
              break;
            }

          case keyTypes$1.P256:
          case keyTypes$1.P384:
          case keyTypes$1.P521:
            {
              var curve = readString$2(br);
              if (curve !== typeToCurve[this.type]) throw new Error('Invalid curve.');
              this.point = readBytes$2(br);
              this.key = readBytes$2(br);
              if (this.type === keyTypes$1.P256) this.key = padLeft$2(this.key, 32);else if (this.type === keyTypes$1.P384) this.key = padLeft$2(this.key, 48);else this.key = padLeft$2(this.key, 66);
              break;
            }

          case keyTypes$1.ED25519:
            {
              var point = readBytes$2(br);
              var blob = readBytes$2(br);
              if (blob.length !== 64) throw new Error('Invalid key pair.');
              var key = blob.slice(0, 32);
              var pub = blob.slice(32, 64);
              if (!point.equals(pub)) throw new Error('Public key mismatch.');
              this.point = point;
              this.key = key;
              break;
            }

          default:
            {
              throw new Error('Invalid key.');
            }
        }

        this.comment = readString$2(br);
        var padding = br.readBytes(br.left(), true);

        for (var i = 0; i < padding.length; i++) {
          if (padding[i] !== i + 1) throw new Error('Invalid padding.');
        }

        return this;
      }
    }]);

    return RawPrivateKey;
  }(bufio.Struct);
  /*
   * Encryption
   */


  function derive$7(sname, passwd, salt, rounds) {
    assert_1$1(typeof sname === 'string');
    assert_1$1(typeof passwd === 'string');
    assert_1$1(Buffer.isBuffer(salt));
    assert_1$1(rounds >>> 0 === rounds);
    if (!cipherInfo$1.hasOwnProperty(sname)) throw new Error("Unknown cipher: ".concat(sname, "."));

    var _cipherInfo$sname = _slicedToArray__default['default'](cipherInfo$1[sname], 3),
        name = _cipherInfo$sname[0],
        keySize = _cipherInfo$sname[1],
        ivSize = _cipherInfo$sname[2];

    var size = keySize + ivSize;
    var secret = bcryptBrowser.pbkdf(passwd, salt, rounds, size);
    var key = secret.slice(0, keySize);
    var iv = secret.slice(keySize, keySize + ivSize);
    return [name, key, iv];
  }

  function encrypt$7(data, sname, passwd, salt, rounds) {
    var _derive = derive$7(sname, passwd, salt, rounds),
        _derive2 = _slicedToArray__default['default'](_derive, 3),
        name = _derive2[0],
        key = _derive2[1],
        iv = _derive2[2];

    return cipherBrowser.encrypt(name, key, iv, data);
  }

  function decrypt$6(data, sname, passwd, salt, rounds) {
    var _derive3 = derive$7(sname, passwd, salt, rounds),
        _derive4 = _slicedToArray__default['default'](_derive3, 3),
        name = _derive4[0],
        key = _derive4[1],
        iv = _derive4[2];

    return cipherBrowser.decrypt(name, key, iv, data);
  }
  /*
   * Encoding
   */


  function readString$2(br) {
    return br.readString(br.readU32BE(), 'binary');
  }

  function readBytes$2(br) {
    return br.readBytes(br.readU32BE());
  }

  function readChild(br) {
    return br.readChild(br.readU32BE());
  }

  function readInt$1(br) {
    return br.readU32BE();
  }

  function sizeString(str) {
    return 4 + str.length;
  }

  function writeString$2(bw, str) {
    bw.writeU32BE(str.length);
    bw.writeString(str, 'binary');
    return bw;
  }

  function sizeBytes(data) {
    return 4 + data.length;
  }

  function writeBytes$2(bw, data) {
    bw.writeU32BE(data.length);
    bw.writeBytes(data);
    return bw;
  }

  function sizeInt$1(num) {
    return 4;
  }

  function writeInt$1(bw, num) {
    bw.writeU32BE(num);
    return bw;
  }
  /*
   * Expose
   */


  var keyTypes_1$1 = keyTypes$1;
  var keyTypesByVal_1$1 = keyTypesByVal$1;
  var SSHPublicKey_1 = SSHPublicKey;
  var SSHPrivateKey_1 = SSHPrivateKey;
  var KDFOptions_1 = KDFOptions;
  var RawPrivateKey_1 = RawPrivateKey;
  var ssh = {
    keyTypes: keyTypes_1$1,
    keyTypesByVal: keyTypesByVal_1$1,
    SSHPublicKey: SSHPublicKey_1,
    SSHPrivateKey: SSHPrivateKey_1,
    KDFOptions: KDFOptions_1,
    RawPrivateKey: RawPrivateKey_1
  };

  function _createSuper$G(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$G(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$G() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHA3
   */


  var SHA3 = /*#__PURE__*/function (_Keccak) {
    _inherits__default['default'](SHA3, _Keccak);

    var _super = _createSuper$G(SHA3);

    function SHA3() {
      _classCallCheck__default['default'](this, SHA3);

      return _super.call(this);
    }

    _createClass__default['default'](SHA3, [{
      key: "final",
      value: function final() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3.prototype), "final", this).call(this, 0x06, null);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA3();
      }
    }, {
      key: "hmac",
      value: function hmac(bits) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3), "hmac", this).call(this, bits, 0x06, null);
      }
    }, {
      key: "digest",
      value: function digest(data, bits) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3), "digest", this).call(this, data, bits, 0x06, null);
      }
    }, {
      key: "root",
      value: function root(left, right, bits) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3), "root", this).call(this, left, right, bits, 0x06, null);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, bits) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3), "multi", this).call(this, x, y, z, bits, 0x06, null);
      }
    }, {
      key: "mac",
      value: function mac(data, key, bits) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3), "mac", this).call(this, data, key, bits, 0x06, null);
      }
    }]);

    return SHA3;
  }(keccak);
  /*
   * Static
   */


  SHA3.native = 0;
  SHA3.id = 'SHA3_256';
  SHA3.size = 32;
  SHA3.bits = 256;
  SHA3.blockSize = 136;
  SHA3.zero = Buffer.alloc(32, 0x00);
  SHA3.ctx = new SHA3();
  /*
   * Expose
   */

  var sha3 = SHA3;

  var sha3Browser = sha3;

  function _createSuper$H(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$H(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$H() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHA3-224
   */


  var SHA3_224 = /*#__PURE__*/function (_SHA) {
    _inherits__default['default'](SHA3_224, _SHA);

    var _super = _createSuper$H(SHA3_224);

    function SHA3_224() {
      _classCallCheck__default['default'](this, SHA3_224);

      return _super.call(this);
    }

    _createClass__default['default'](SHA3_224, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_224.prototype), "init", this).call(this, 224);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA3_224();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_224), "hmac", this).call(this, 224);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_224), "digest", this).call(this, data, 224);
      }
    }, {
      key: "root",
      value: function root(left, right) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_224), "root", this).call(this, left, right, 224);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_224), "multi", this).call(this, x, y, z, 224);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_224), "mac", this).call(this, data, key, 224);
      }
    }]);

    return SHA3_224;
  }(sha3Browser);
  /*
   * Static
   */


  SHA3_224.native = sha3Browser.native;
  SHA3_224.id = 'SHA3_224';
  SHA3_224.size = 28;
  SHA3_224.bits = 224;
  SHA3_224.blockSize = 144;
  SHA3_224.zero = Buffer.alloc(28, 0x00);
  SHA3_224.ctx = new SHA3_224();
  /*
   * Expose
   */

  var sha3224 = SHA3_224;

  function _createSuper$I(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$I(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$I() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHA3-256
   */


  var SHA3_256 = /*#__PURE__*/function (_SHA) {
    _inherits__default['default'](SHA3_256, _SHA);

    var _super = _createSuper$I(SHA3_256);

    function SHA3_256() {
      _classCallCheck__default['default'](this, SHA3_256);

      return _super.call(this);
    }

    _createClass__default['default'](SHA3_256, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_256.prototype), "init", this).call(this, 256);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA3_256();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_256), "hmac", this).call(this, 256);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_256), "digest", this).call(this, data, 256);
      }
    }, {
      key: "root",
      value: function root(left, right) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_256), "root", this).call(this, left, right, 256);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_256), "multi", this).call(this, x, y, z, 256);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_256), "mac", this).call(this, data, key, 256);
      }
    }]);

    return SHA3_256;
  }(sha3Browser);
  /*
   * Static
   */


  SHA3_256.native = sha3Browser.native;
  SHA3_256.id = 'SHA3_256';
  SHA3_256.size = 32;
  SHA3_256.bits = 256;
  SHA3_256.blockSize = 136;
  SHA3_256.zero = Buffer.alloc(32, 0x00);
  SHA3_256.ctx = new SHA3_256();
  /*
   * Expose
   */

  var sha3256 = SHA3_256;

  function _createSuper$J(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$J(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$J() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHA3-384
   */


  var SHA3_384 = /*#__PURE__*/function (_SHA) {
    _inherits__default['default'](SHA3_384, _SHA);

    var _super = _createSuper$J(SHA3_384);

    function SHA3_384() {
      _classCallCheck__default['default'](this, SHA3_384);

      return _super.call(this);
    }

    _createClass__default['default'](SHA3_384, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_384.prototype), "init", this).call(this, 384);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA3_384();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_384), "hmac", this).call(this, 384);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_384), "digest", this).call(this, data, 384);
      }
    }, {
      key: "root",
      value: function root(left, right) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_384), "root", this).call(this, left, right, 384);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_384), "multi", this).call(this, x, y, z, 384);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_384), "mac", this).call(this, data, key, 384);
      }
    }]);

    return SHA3_384;
  }(sha3Browser);
  /*
   * Static
   */


  SHA3_384.native = sha3Browser.native;
  SHA3_384.id = 'SHA3_384';
  SHA3_384.size = 48;
  SHA3_384.bits = 384;
  SHA3_384.blockSize = 104;
  SHA3_384.zero = Buffer.alloc(48, 0x00);
  SHA3_384.ctx = new SHA3_384();
  /*
   * Expose
   */

  var sha3384 = SHA3_384;

  function _createSuper$K(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$K(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$K() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHA3-512
   */


  var SHA3_512 = /*#__PURE__*/function (_SHA) {
    _inherits__default['default'](SHA3_512, _SHA);

    var _super = _createSuper$K(SHA3_512);

    function SHA3_512() {
      _classCallCheck__default['default'](this, SHA3_512);

      return _super.call(this);
    }

    _createClass__default['default'](SHA3_512, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_512.prototype), "init", this).call(this, 512);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHA3_512();
      }
    }, {
      key: "hmac",
      value: function hmac() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_512), "hmac", this).call(this, 512);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_512), "digest", this).call(this, data, 512);
      }
    }, {
      key: "root",
      value: function root(left, right) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_512), "root", this).call(this, left, right, 512);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_512), "multi", this).call(this, x, y, z, 512);
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHA3_512), "mac", this).call(this, data, key, 512);
      }
    }]);

    return SHA3_512;
  }(sha3Browser);
  /*
   * Static
   */


  SHA3_512.native = sha3Browser.native;
  SHA3_512.id = 'SHA3_512';
  SHA3_512.size = 64;
  SHA3_512.bits = 512;
  SHA3_512.blockSize = 72;
  SHA3_512.zero = Buffer.alloc(64, 0x00);
  SHA3_512.ctx = new SHA3_512();
  /*
   * Expose
   */

  var sha3512 = SHA3_512;

  function _createSuper$L(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$L(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

  function _isNativeReflectConstruct$L() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * SHAKE128
   */


  var SHAKE128 = /*#__PURE__*/function (_SHAKE) {
    _inherits__default['default'](SHAKE128, _SHAKE);

    var _super = _createSuper$L(SHAKE128);

    function SHAKE128() {
      _classCallCheck__default['default'](this, SHAKE128);

      return _super.call(this);
    }

    _createClass__default['default'](SHAKE128, [{
      key: "init",
      value: function init() {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE128.prototype), "init", this).call(this, 128);
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new SHAKE128();
      }
    }, {
      key: "hmac",
      value: function hmac(len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE128), "hmac", this).call(this, 128, len);
      }
    }, {
      key: "digest",
      value: function digest(data, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE128), "digest", this).call(this, data, 128, len);
      }
    }, {
      key: "root",
      value: function root(left, right, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE128), "root", this).call(this, left, right, 128, len);
      }
    }, {
      key: "multi",
      value: function multi(x, y, z, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE128), "multi", this).call(this, x, y, z, 128, len);
      }
    }, {
      key: "mac",
      value: function mac(data, key, len) {
        return _get__default['default'](_getPrototypeOf__default['default'](SHAKE128), "mac", this).call(this, data, key, 128, len);
      }
    }]);

    return SHAKE128;
  }(shake);
  /*
   * Static
   */


  SHAKE128.native = shake.native;
  SHAKE128.id = 'SHAKE128';
  SHAKE128.size = 16;
  SHAKE128.bits = 128;
  SHAKE128.blockSize = 168;
  SHAKE128.zero = Buffer.alloc(16, 0x00);
  SHAKE128.ctx = new SHAKE128();
  /*
   * Expose
   */

  var shake128 = SHAKE128;

  /*
   * Constants
   */


  var HI$1 = 1 / 0x100000000;
  /**
   * Javascript siphash 2-4 implementation.
   * @private
   * @param {Buffer} data
   * @param {Buffer} key - 128 bit key.
   * @returns {Array} [hi, lo]
   */

  function _siphash(data, key) {
    assert_1$1(Buffer.isBuffer(data));
    assert_1$1(Buffer.isBuffer(key) && key.length >= 16);
    var blocks = data.length >>> 3;
    var c0 = new U64$2(0x736f6d65, 0x70736575);
    var c1 = new U64$2(0x646f7261, 0x6e646f6d);
    var c2 = new U64$2(0x6c796765, 0x6e657261);
    var c3 = new U64$2(0x74656462, 0x79746573);
    var f0 = new U64$2(data.length << 24, 0);
    var f1 = new U64$2(0, 0xff);
    var k0 = U64$2.decode(key, 0);
    var k1 = U64$2.decode(key, 8); // Init.

    var v0 = c0.ixor(k0);
    var v1 = c1.ixor(k1);
    var v2 = c2.ixor(k0);
    var v3 = c3.ixor(k1); // Blocks.

    var p = 0;

    for (var i = 0; i < blocks; i++) {
      var d = U64$2.decode(data, p);
      v3.ixor(d);
      sipround(v0, v1, v2, v3);
      sipround(v0, v1, v2, v3);
      v0.ixor(d);
      p += 8;
    } // Trailing.


    switch (data.length & 7) {
      case 7:
        f0.hi |= data[p + 6] << 16;

      case 6:
        f0.hi |= data[p + 5] << 8;

      case 5:
        f0.hi |= data[p + 4];

      case 4:
        f0.lo |= data[p + 3] << 24;

      case 3:
        f0.lo |= data[p + 2] << 16;

      case 2:
        f0.lo |= data[p + 1] << 8;

      case 1:
        f0.lo |= data[p];
    } // Finalization.


    v3.ixor(f0);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    v0.ixor(f0);
    v2.ixor(f1);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    v0.ixor(v1);
    v0.ixor(v2);
    v0.ixor(v3);
    return [v0.hi, v0.lo];
  }
  /**
   * Javascript siphash 2-4 implementation (64 bit ints).
   * @private
   * @param {Number} hi
   * @param {Number} lo
   * @param {Buffer} key - 128 bit key.
   * @returns {Array} [hi, lo]
   */


  function _siphash64(hi, lo, key) {
    assert_1$1(typeof hi === 'number');
    assert_1$1(typeof lo === 'number');
    assert_1$1(Buffer.isBuffer(key) && key.length >= 16);
    var c0 = new U64$2(0x736f6d65, 0x70736575);
    var c1 = new U64$2(0x646f7261, 0x6e646f6d);
    var c2 = new U64$2(0x6c796765, 0x6e657261);
    var c3 = new U64$2(0x74656462, 0x79746573);
    var f0 = new U64$2(hi, lo);
    var f1 = new U64$2(0, 0xff);
    var k0 = U64$2.decode(key, 0);
    var k1 = U64$2.decode(key, 8); // Init.

    var v0 = c0.ixor(k0);
    var v1 = c1.ixor(k1);
    var v2 = c2.ixor(k0);
    var v3 = c3.ixor(k1); // Finalization.

    v3.ixor(f0);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    v0.ixor(f0);
    v2.ixor(f1);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    v0.ixor(v1);
    v0.ixor(v2);
    v0.ixor(v3);
    return [v0.hi, v0.lo];
  }
  /**
   * Javascript siphash 2-4 implementation
   * (64 bit ints with a 256 bit key).
   * @private
   * @param {Number} hi
   * @param {Number} lo
   * @param {Buffer} key - 128 bit key.
   * @returns {Array} [hi, lo]
   */


  function _siphash64k256(hi, lo, key) {
    assert_1$1(typeof hi === 'number');
    assert_1$1(typeof lo === 'number');
    assert_1$1(Buffer.isBuffer(key) && key.length >= 32);
    var f0 = new U64$2(hi, lo);
    var f1 = new U64$2(0, 0xff);
    var k0 = U64$2.decode(key, 0);
    var k1 = U64$2.decode(key, 8);
    var k2 = U64$2.decode(key, 16);
    var k3 = U64$2.decode(key, 24); // Init.

    var v0 = k0;
    var v1 = k1;
    var v2 = k2;
    var v3 = k3; // Finalization.

    v3.ixor(f0);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    v0.ixor(f0);
    v2.ixor(f1);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    sipround(v0, v1, v2, v3);
    v0.ixor(v1);
    v0.ixor(v2);
    v0.ixor(v3);
    return [v0.hi, v0.lo];
  }
  /**
   * Javascript siphash 2-4 implementation.
   * Used by bitcoin for compact block relay.
   * @param {Buffer} data
   * @param {Buffer} key - 128 bit key.
   * @returns {Array} [hi, lo]
   */


  function siphash(data, key) {
    return _siphash(data, key);
  }
  /**
   * Javascript siphash 2-4 implementation (32 bit ints).
   * Used by legacy cuckoo cycle.
   * @param {Number} num
   * @param {Buffer} key - 128 bit key.
   * @returns {Number}
   */


  function siphash32(num, key) {
    return _siphash64(0, num, key)[1];
  }
  /**
   * Javascript siphash 2-4 implementation (64 bit ints).
   * Used by legacy cuckoo cycle.
   * @param {Number} hi
   * @param {Number} lo
   * @param {Buffer} key - 128 bit key.
   * @returns {Array} [hi, lo]
   */


  function siphash64(hi, lo, key) {
    return _siphash64(hi, lo, key);
  }
  /**
   * Javascript siphash 2-4 implementation
   * (32 bit ints with a 256 bit key).
   * Used by cuckoo cycle.
   * @param {Number} num
   * @param {Buffer} key - 256 bit key.
   * @returns {Number}
   */


  function siphash32k256(num, key) {
    return _siphash64k256(0, num, key)[1];
  }
  /**
   * Javascript siphash 2-4 implementation
   * (64 bit ints with a 256 bit key).
   * Used by cuckoo cycle.
   * @param {Number} hi
   * @param {Number} lo
   * @param {Buffer} key - 256 bit key.
   * @returns {Array} [hi, lo]
   */


  function siphash64k256(hi, lo, key) {
    return _siphash64k256(hi, lo, key);
  }
  /**
   * Javascript siphash 2-4 implementation
   * plus 128 bit reduction by a modulus.
   * Used by the neutrino protocol.
   * @param {Buffer} data
   * @param {Buffer} key - 128 bit key.
   * @param {Number} mhi - Modulus hi bits.
   * @param {Number} mlo - Modulus lo bits.
   * @returns {Array} [hi, lo]
   */


  function sipmod(data, key, mhi, mlo) {
    var _siphash2 = _siphash(data, key),
        _siphash3 = _slicedToArray__default['default'](_siphash2, 2),
        hi = _siphash3[0],
        lo = _siphash3[1];

    return reduce64(hi, lo, mhi, mlo);
  }
  /**
   * U64
   * @ignore
   */


  var U64$2 = /*#__PURE__*/function () {
    function U64(hi, lo) {
      _classCallCheck__default['default'](this, U64);

      this.hi = hi | 0;
      this.lo = lo | 0;
    }

    _createClass__default['default'](U64, [{
      key: "isum",
      value: function isum(bhi, blo) {
        // Credit to @indutny for this method.
        var a = this;
        var lo = a.lo + blo | 0;
        var s = lo >> 31;
        var as = a.lo >> 31;
        var bs = blo >> 31;
        var c = (as & bs | ~s & (as ^ bs)) & 1;
        var hi = (a.hi + bhi | 0) + c;
        a.hi = hi | 0;
        a.lo = lo;
        return a;
      }
    }, {
      key: "iadd",
      value: function iadd(b) {
        return this.isum(b.hi, b.lo);
      }
    }, {
      key: "ixor",
      value: function ixor(b) {
        this.hi ^= b.hi;
        this.lo ^= b.lo;
        return this;
      }
    }, {
      key: "irotl",
      value: function irotl(bits) {
        var ahi = this.hi;
        var alo = this.lo;
        var bhi = this.hi;
        var blo = this.lo; // a = x << b

        if (bits < 32) {
          ahi <<= bits;
          ahi |= alo >>> 32 - bits;
          alo <<= bits;
        } else {
          ahi = alo << bits - 32;
          alo = 0;
        }

        bits = 64 - bits; // b = x >> (64 - b)

        if (bits < 32) {
          blo >>>= bits;
          blo |= bhi << 32 - bits;
          bhi >>>= bits;
        } else {
          blo = bhi >>> bits - 32;
          bhi = 0;
        } // a | b


        this.hi = ahi | bhi;
        this.lo = alo | blo;
        return this;
      }
    }], [{
      key: "mul",
      value: function mul(alo, blo) {
        // u32 * u32 = u64
        var a16 = alo >>> 16;
        var a00 = alo & 0xffff;
        var b16 = blo >>> 16;
        var b00 = blo & 0xffff;
        var c48 = 0;
        var c32 = 0;
        var c16 = 0;
        var c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xffff;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c48 += c32 >>> 16;
        c48 &= 0xffff;
        var hi = c48 << 16 | c32;
        var lo = c16 << 16 | c00;
        return new U64(hi, lo);
      }
    }, {
      key: "decode",
      value: function decode(data, off) {
        var lo = readU32$o(data, off);
        var hi = readU32$o(data, off + 4);
        return new U64(hi, lo);
      }
    }]);

    return U64;
  }();
  /*
   * Helpers
   */


  function sipround(v0, v1, v2, v3) {
    v0.iadd(v1);
    v1.irotl(13);
    v1.ixor(v0);
    v0.irotl(32);
    v2.iadd(v3);
    v3.irotl(16);
    v3.ixor(v2);
    v0.iadd(v3);
    v3.irotl(21);
    v3.ixor(v0);
    v2.iadd(v1);
    v1.irotl(17);
    v1.ixor(v2);
    v2.irotl(32);
  }

  function reduce64(ahi, alo, bhi, blo) {
    // Compute `((uint128_t)a * b) >> 64`.
    // Start with 4 32->64 bit multiplications.
    var axbhi = U64$2.mul(ahi, bhi);
    var axbmid = U64$2.mul(ahi, blo);
    var bxamid = U64$2.mul(bhi, alo);
    var axblo = U64$2.mul(alo, blo); // We can safely overflow in these next steps.
    // c = (axbmid & 0xffffffff) + (bxamid & 0xffffffff) + (axblo >> 32)

    var c = (axbmid.lo >>> 0) + (bxamid.lo >>> 0) + (axblo.hi >>> 0); // m = (axbmid >> 32) + (bxamid >> 32) + (c >> 32)

    var m = (axbmid.hi >>> 0) + (bxamid.hi >>> 0) + (c * HI$1 >>> 0); // axbhi + m

    var _axbhi$isum = axbhi.isum(m * HI$1 | 0, m | 0),
        hi = _axbhi$isum.hi,
        lo = _axbhi$isum.lo;

    return [hi, lo];
  }

  function readU32$o(data, off) {
    return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;
  }
  /*
   * Expose
   */


  var native_1$k = 0;
  var siphash_2 = siphash;
  var siphash32_1 = siphash32;
  var siphash64_1 = siphash64;
  var siphash32k256_1 = siphash32k256;
  var siphash64k256_1 = siphash64k256;
  var sipmod_1 = sipmod;
  var siphash_1 = {
    native: native_1$k,
    siphash: siphash_2,
    siphash32: siphash32_1,
    siphash64: siphash64_1,
    siphash32k256: siphash32k256_1,
    siphash64k256: siphash64k256_1,
    sipmod: sipmod_1
  };

  var siphashBrowser = siphash_1;

  /*
   * Constants
   */


  var FINALIZED$c = -1;
  var DESC$7 = Buffer.alloc(32, 0x00);
  var PADDING$9 = Buffer.alloc(64, 0x00);
  PADDING$9[0] = 0x80;
  var RC = new Uint32Array([0x00000000, 0x00000000, 0x1823c6e8, 0x87b8014f, 0x36a6d2f5, 0x796f9152, 0x60bc9b8e, 0xa30c7b35, 0x1de0d7c2, 0x2e4bfe57, 0x157737e5, 0x9ff04ada, 0x58c9290a, 0xb1a06b85, 0xbd5d10f4, 0xcb3e0567, 0xe427418b, 0xa77d95d8, 0xfbee7c66, 0xdd17479e, 0xca2dbf07, 0xad5a8333]);
  var C0 = new Uint32Array([0x18186018, 0xc07830d8, 0x23238c23, 0x05af4626, 0xc6c63fc6, 0x7ef991b8, 0xe8e887e8, 0x136fcdfb, 0x87872687, 0x4ca113cb, 0xb8b8dab8, 0xa9626d11, 0x01010401, 0x08050209, 0x4f4f214f, 0x426e9e0d, 0x3636d836, 0xadee6c9b, 0xa6a6a2a6, 0x590451ff, 0xd2d26fd2, 0xdebdb90c, 0xf5f5f3f5, 0xfb06f70e, 0x7979f979, 0xef80f296, 0x6f6fa16f, 0x5fcede30, 0x91917e91, 0xfcef3f6d, 0x52525552, 0xaa07a4f8, 0x60609d60, 0x27fdc047, 0xbcbccabc, 0x89766535, 0x9b9b569b, 0xaccd2b37, 0x8e8e028e, 0x048c018a, 0xa3a3b6a3, 0x71155bd2, 0x0c0c300c, 0x603c186c, 0x7b7bf17b, 0xff8af684, 0x3535d435, 0xb5e16a80, 0x1d1d741d, 0xe8693af5, 0xe0e0a7e0, 0x5347ddb3, 0xd7d77bd7, 0xf6acb321, 0xc2c22fc2, 0x5eed999c, 0x2e2eb82e, 0x6d965c43, 0x4b4b314b, 0x627a9629, 0xfefedffe, 0xa321e15d, 0x57574157, 0x8216aed5, 0x15155415, 0xa8412abd, 0x7777c177, 0x9fb6eee8, 0x3737dc37, 0xa5eb6e92, 0xe5e5b3e5, 0x7b56d79e, 0x9f9f469f, 0x8cd92313, 0xf0f0e7f0, 0xd317fd23, 0x4a4a354a, 0x6a7f9420, 0xdada4fda, 0x9e95a944, 0x58587d58, 0xfa25b0a2, 0xc9c903c9, 0x06ca8fcf, 0x2929a429, 0x558d527c, 0x0a0a280a, 0x5022145a, 0xb1b1feb1, 0xe14f7f50, 0xa0a0baa0, 0x691a5dc9, 0x6b6bb16b, 0x7fdad614, 0x85852e85, 0x5cab17d9, 0xbdbdcebd, 0x8173673c, 0x5d5d695d, 0xd234ba8f, 0x10104010, 0x80502090, 0xf4f4f7f4, 0xf303f507, 0xcbcb0bcb, 0x16c08bdd, 0x3e3ef83e, 0xedc67cd3, 0x05051405, 0x28110a2d, 0x67678167, 0x1fe6ce78, 0xe4e4b7e4, 0x7353d597, 0x27279c27, 0x25bb4e02, 0x41411941, 0x32588273, 0x8b8b168b, 0x2c9d0ba7, 0xa7a7a6a7, 0x510153f6, 0x7d7de97d, 0xcf94fab2, 0x95956e95, 0xdcfb3749, 0xd8d847d8, 0x8e9fad56, 0xfbfbcbfb, 0x8b30eb70, 0xeeee9fee, 0x2371c1cd, 0x7c7ced7c, 0xc791f8bb, 0x66668566, 0x17e3cc71, 0xdddd53dd, 0xa68ea77b, 0x17175c17, 0xb84b2eaf, 0x47470147, 0x02468e45, 0x9e9e429e, 0x84dc211a, 0xcaca0fca, 0x1ec589d4, 0x2d2db42d, 0x75995a58, 0xbfbfc6bf, 0x9179632e, 0x07071c07, 0x381b0e3f, 0xadad8ead, 0x012347ac, 0x5a5a755a, 0xea2fb4b0, 0x83833683, 0x6cb51bef, 0x3333cc33, 0x85ff66b6, 0x63639163, 0x3ff2c65c, 0x02020802, 0x100a0412, 0xaaaa92aa, 0x39384993, 0x7171d971, 0xafa8e2de, 0xc8c807c8, 0x0ecf8dc6, 0x19196419, 0xc87d32d1, 0x49493949, 0x7270923b, 0xd9d943d9, 0x869aaf5f, 0xf2f2eff2, 0xc31df931, 0xe3e3abe3, 0x4b48dba8, 0x5b5b715b, 0xe22ab6b9, 0x88881a88, 0x34920dbc, 0x9a9a529a, 0xa4c8293e, 0x26269826, 0x2dbe4c0b, 0x3232c832, 0x8dfa64bf, 0xb0b0fab0, 0xe94a7d59, 0xe9e983e9, 0x1b6acff2, 0x0f0f3c0f, 0x78331e77, 0xd5d573d5, 0xe6a6b733, 0x80803a80, 0x74ba1df4, 0xbebec2be, 0x997c6127, 0xcdcd13cd, 0x26de87eb, 0x3434d034, 0xbde46889, 0x48483d48, 0x7a759032, 0xffffdbff, 0xab24e354, 0x7a7af57a, 0xf78ff48d, 0x90907a90, 0xf4ea3d64, 0x5f5f615f, 0xc23ebe9d, 0x20208020, 0x1da0403d, 0x6868bd68, 0x67d5d00f, 0x1a1a681a, 0xd07234ca, 0xaeae82ae, 0x192c41b7, 0xb4b4eab4, 0xc95e757d, 0x54544d54, 0x9a19a8ce, 0x93937693, 0xece53b7f, 0x22228822, 0x0daa442f, 0x64648d64, 0x07e9c863, 0xf1f1e3f1, 0xdb12ff2a, 0x7373d173, 0xbfa2e6cc, 0x12124812, 0x905a2482, 0x40401d40, 0x3a5d807a, 0x08082008, 0x40281048, 0xc3c32bc3, 0x56e89b95, 0xecec97ec, 0x337bc5df, 0xdbdb4bdb, 0x9690ab4d, 0xa1a1bea1, 0x611f5fc0, 0x8d8d0e8d, 0x1c830791, 0x3d3df43d, 0xf5c97ac8, 0x97976697, 0xccf1335b, 0x00000000, 0x00000000, 0xcfcf1bcf, 0x36d483f9, 0x2b2bac2b, 0x4587566e, 0x7676c576, 0x97b3ece1, 0x82823282, 0x64b019e6, 0xd6d67fd6, 0xfea9b128, 0x1b1b6c1b, 0xd87736c3, 0xb5b5eeb5, 0xc15b7774, 0xafaf86af, 0x112943be, 0x6a6ab56a, 0x77dfd41d, 0x50505d50, 0xba0da0ea, 0x45450945, 0x124c8a57, 0xf3f3ebf3, 0xcb18fb38, 0x3030c030, 0x9df060ad, 0xefef9bef, 0x2b74c3c4, 0x3f3ffc3f, 0xe5c37eda, 0x55554955, 0x921caac7, 0xa2a2b2a2, 0x791059db, 0xeaea8fea, 0x0365c9e9, 0x65658965, 0x0fecca6a, 0xbabad2ba, 0xb9686903, 0x2f2fbc2f, 0x65935e4a, 0xc0c027c0, 0x4ee79d8e, 0xdede5fde, 0xbe81a160, 0x1c1c701c, 0xe06c38fc, 0xfdfdd3fd, 0xbb2ee746, 0x4d4d294d, 0x52649a1f, 0x92927292, 0xe4e03976, 0x7575c975, 0x8fbceafa, 0x06061806, 0x301e0c36, 0x8a8a128a, 0x249809ae, 0xb2b2f2b2, 0xf940794b, 0xe6e6bfe6, 0x6359d185, 0x0e0e380e, 0x70361c7e, 0x1f1f7c1f, 0xf8633ee7, 0x62629562, 0x37f7c455, 0xd4d477d4, 0xeea3b53a, 0xa8a89aa8, 0x29324d81, 0x96966296, 0xc4f43152, 0xf9f9c3f9, 0x9b3aef62, 0xc5c533c5, 0x66f697a3, 0x25259425, 0x35b14a10, 0x59597959, 0xf220b2ab, 0x84842a84, 0x54ae15d0, 0x7272d572, 0xb7a7e4c5, 0x3939e439, 0xd5dd72ec, 0x4c4c2d4c, 0x5a619816, 0x5e5e655e, 0xca3bbc94, 0x7878fd78, 0xe785f09f, 0x3838e038, 0xddd870e5, 0x8c8c0a8c, 0x14860598, 0xd1d163d1, 0xc6b2bf17, 0xa5a5aea5, 0x410b57e4, 0xe2e2afe2, 0x434dd9a1, 0x61619961, 0x2ff8c24e, 0xb3b3f6b3, 0xf1457b42, 0x21218421, 0x15a54234, 0x9c9c4a9c, 0x94d62508, 0x1e1e781e, 0xf0663cee, 0x43431143, 0x22528661, 0xc7c73bc7, 0x76fc93b1, 0xfcfcd7fc, 0xb32be54f, 0x04041004, 0x20140824, 0x51515951, 0xb208a2e3, 0x99995e99, 0xbcc72f25, 0x6d6da96d, 0x4fc4da22, 0x0d0d340d, 0x68391a65, 0xfafacffa, 0x8335e979, 0xdfdf5bdf, 0xb684a369, 0x7e7ee57e, 0xd79bfca9, 0x24249024, 0x3db44819, 0x3b3bec3b, 0xc5d776fe, 0xabab96ab, 0x313d4b9a, 0xcece1fce, 0x3ed181f0, 0x11114411, 0x88552299, 0x8f8f068f, 0x0c890383, 0x4e4e254e, 0x4a6b9c04, 0xb7b7e6b7, 0xd1517366, 0xebeb8beb, 0x0b60cbe0, 0x3c3cf03c, 0xfdcc78c1, 0x81813e81, 0x7cbf1ffd, 0x94946a94, 0xd4fe3540, 0xf7f7fbf7, 0xeb0cf31c, 0xb9b9deb9, 0xa1676f18, 0x13134c13, 0x985f268b, 0x2c2cb02c, 0x7d9c5851, 0xd3d36bd3, 0xd6b8bb05, 0xe7e7bbe7, 0x6b5cd38c, 0x6e6ea56e, 0x57cbdc39, 0xc4c437c4, 0x6ef395aa, 0x03030c03, 0x180f061b, 0x56564556, 0x8a13acdc, 0x44440d44, 0x1a49885e, 0x7f7fe17f, 0xdf9efea0, 0xa9a99ea9, 0x21374f88, 0x2a2aa82a, 0x4d825467, 0xbbbbd6bb, 0xb16d6b0a, 0xc1c123c1, 0x46e29f87, 0x53535153, 0xa202a6f1, 0xdcdc57dc, 0xae8ba572, 0x0b0b2c0b, 0x58271653, 0x9d9d4e9d, 0x9cd32701, 0x6c6cad6c, 0x47c1d82b, 0x3131c431, 0x95f562a4, 0x7474cd74, 0x87b9e8f3, 0xf6f6fff6, 0xe309f115, 0x46460546, 0x0a438c4c, 0xacac8aac, 0x092645a5, 0x89891e89, 0x3c970fb5, 0x14145014, 0xa04428b4, 0xe1e1a3e1, 0x5b42dfba, 0x16165816, 0xb04e2ca6, 0x3a3ae83a, 0xcdd274f7, 0x6969b969, 0x6fd0d206, 0x09092409, 0x482d1241, 0x7070dd70, 0xa7ade0d7, 0xb6b6e2b6, 0xd954716f, 0xd0d067d0, 0xceb7bd1e, 0xeded93ed, 0x3b7ec7d6, 0xcccc17cc, 0x2edb85e2, 0x42421542, 0x2a578468, 0x98985a98, 0xb4c22d2c, 0xa4a4aaa4, 0x490e55ed, 0x2828a028, 0x5d885075, 0x5c5c6d5c, 0xda31b886, 0xf8f8c7f8, 0x933fed6b, 0x86862286, 0x44a411c2]);
  var C1 = new Uint32Array([0xd8181860, 0x18c07830, 0x2623238c, 0x2305af46, 0xb8c6c63f, 0xc67ef991, 0xfbe8e887, 0xe8136fcd, 0xcb878726, 0x874ca113, 0x11b8b8da, 0xb8a9626d, 0x09010104, 0x01080502, 0x0d4f4f21, 0x4f426e9e, 0x9b3636d8, 0x36adee6c, 0xffa6a6a2, 0xa6590451, 0x0cd2d26f, 0xd2debdb9, 0x0ef5f5f3, 0xf5fb06f7, 0x967979f9, 0x79ef80f2, 0x306f6fa1, 0x6f5fcede, 0x6d91917e, 0x91fcef3f, 0xf8525255, 0x52aa07a4, 0x4760609d, 0x6027fdc0, 0x35bcbcca, 0xbc897665, 0x379b9b56, 0x9baccd2b, 0x8a8e8e02, 0x8e048c01, 0xd2a3a3b6, 0xa371155b, 0x6c0c0c30, 0x0c603c18, 0x847b7bf1, 0x7bff8af6, 0x803535d4, 0x35b5e16a, 0xf51d1d74, 0x1de8693a, 0xb3e0e0a7, 0xe05347dd, 0x21d7d77b, 0xd7f6acb3, 0x9cc2c22f, 0xc25eed99, 0x432e2eb8, 0x2e6d965c, 0x294b4b31, 0x4b627a96, 0x5dfefedf, 0xfea321e1, 0xd5575741, 0x578216ae, 0xbd151554, 0x15a8412a, 0xe87777c1, 0x779fb6ee, 0x923737dc, 0x37a5eb6e, 0x9ee5e5b3, 0xe57b56d7, 0x139f9f46, 0x9f8cd923, 0x23f0f0e7, 0xf0d317fd, 0x204a4a35, 0x4a6a7f94, 0x44dada4f, 0xda9e95a9, 0xa258587d, 0x58fa25b0, 0xcfc9c903, 0xc906ca8f, 0x7c2929a4, 0x29558d52, 0x5a0a0a28, 0x0a502214, 0x50b1b1fe, 0xb1e14f7f, 0xc9a0a0ba, 0xa0691a5d, 0x146b6bb1, 0x6b7fdad6, 0xd985852e, 0x855cab17, 0x3cbdbdce, 0xbd817367, 0x8f5d5d69, 0x5dd234ba, 0x90101040, 0x10805020, 0x07f4f4f7, 0xf4f303f5, 0xddcbcb0b, 0xcb16c08b, 0xd33e3ef8, 0x3eedc67c, 0x2d050514, 0x0528110a, 0x78676781, 0x671fe6ce, 0x97e4e4b7, 0xe47353d5, 0x0227279c, 0x2725bb4e, 0x73414119, 0x41325882, 0xa78b8b16, 0x8b2c9d0b, 0xf6a7a7a6, 0xa7510153, 0xb27d7de9, 0x7dcf94fa, 0x4995956e, 0x95dcfb37, 0x56d8d847, 0xd88e9fad, 0x70fbfbcb, 0xfb8b30eb, 0xcdeeee9f, 0xee2371c1, 0xbb7c7ced, 0x7cc791f8, 0x71666685, 0x6617e3cc, 0x7bdddd53, 0xdda68ea7, 0xaf17175c, 0x17b84b2e, 0x45474701, 0x4702468e, 0x1a9e9e42, 0x9e84dc21, 0xd4caca0f, 0xca1ec589, 0x582d2db4, 0x2d75995a, 0x2ebfbfc6, 0xbf917963, 0x3f07071c, 0x07381b0e, 0xacadad8e, 0xad012347, 0xb05a5a75, 0x5aea2fb4, 0xef838336, 0x836cb51b, 0xb63333cc, 0x3385ff66, 0x5c636391, 0x633ff2c6, 0x12020208, 0x02100a04, 0x93aaaa92, 0xaa393849, 0xde7171d9, 0x71afa8e2, 0xc6c8c807, 0xc80ecf8d, 0xd1191964, 0x19c87d32, 0x3b494939, 0x49727092, 0x5fd9d943, 0xd9869aaf, 0x31f2f2ef, 0xf2c31df9, 0xa8e3e3ab, 0xe34b48db, 0xb95b5b71, 0x5be22ab6, 0xbc88881a, 0x8834920d, 0x3e9a9a52, 0x9aa4c829, 0x0b262698, 0x262dbe4c, 0xbf3232c8, 0x328dfa64, 0x59b0b0fa, 0xb0e94a7d, 0xf2e9e983, 0xe91b6acf, 0x770f0f3c, 0x0f78331e, 0x33d5d573, 0xd5e6a6b7, 0xf480803a, 0x8074ba1d, 0x27bebec2, 0xbe997c61, 0xebcdcd13, 0xcd26de87, 0x893434d0, 0x34bde468, 0x3248483d, 0x487a7590, 0x54ffffdb, 0xffab24e3, 0x8d7a7af5, 0x7af78ff4, 0x6490907a, 0x90f4ea3d, 0x9d5f5f61, 0x5fc23ebe, 0x3d202080, 0x201da040, 0x0f6868bd, 0x6867d5d0, 0xca1a1a68, 0x1ad07234, 0xb7aeae82, 0xae192c41, 0x7db4b4ea, 0xb4c95e75, 0xce54544d, 0x549a19a8, 0x7f939376, 0x93ece53b, 0x2f222288, 0x220daa44, 0x6364648d, 0x6407e9c8, 0x2af1f1e3, 0xf1db12ff, 0xcc7373d1, 0x73bfa2e6, 0x82121248, 0x12905a24, 0x7a40401d, 0x403a5d80, 0x48080820, 0x08402810, 0x95c3c32b, 0xc356e89b, 0xdfecec97, 0xec337bc5, 0x4ddbdb4b, 0xdb9690ab, 0xc0a1a1be, 0xa1611f5f, 0x918d8d0e, 0x8d1c8307, 0xc83d3df4, 0x3df5c97a, 0x5b979766, 0x97ccf133, 0x00000000, 0x00000000, 0xf9cfcf1b, 0xcf36d483, 0x6e2b2bac, 0x2b458756, 0xe17676c5, 0x7697b3ec, 0xe6828232, 0x8264b019, 0x28d6d67f, 0xd6fea9b1, 0xc31b1b6c, 0x1bd87736, 0x74b5b5ee, 0xb5c15b77, 0xbeafaf86, 0xaf112943, 0x1d6a6ab5, 0x6a77dfd4, 0xea50505d, 0x50ba0da0, 0x57454509, 0x45124c8a, 0x38f3f3eb, 0xf3cb18fb, 0xad3030c0, 0x309df060, 0xc4efef9b, 0xef2b74c3, 0xda3f3ffc, 0x3fe5c37e, 0xc7555549, 0x55921caa, 0xdba2a2b2, 0xa2791059, 0xe9eaea8f, 0xea0365c9, 0x6a656589, 0x650fecca, 0x03babad2, 0xbab96869, 0x4a2f2fbc, 0x2f65935e, 0x8ec0c027, 0xc04ee79d, 0x60dede5f, 0xdebe81a1, 0xfc1c1c70, 0x1ce06c38, 0x46fdfdd3, 0xfdbb2ee7, 0x1f4d4d29, 0x4d52649a, 0x76929272, 0x92e4e039, 0xfa7575c9, 0x758fbcea, 0x36060618, 0x06301e0c, 0xae8a8a12, 0x8a249809, 0x4bb2b2f2, 0xb2f94079, 0x85e6e6bf, 0xe66359d1, 0x7e0e0e38, 0x0e70361c, 0xe71f1f7c, 0x1ff8633e, 0x55626295, 0x6237f7c4, 0x3ad4d477, 0xd4eea3b5, 0x81a8a89a, 0xa829324d, 0x52969662, 0x96c4f431, 0x62f9f9c3, 0xf99b3aef, 0xa3c5c533, 0xc566f697, 0x10252594, 0x2535b14a, 0xab595979, 0x59f220b2, 0xd084842a, 0x8454ae15, 0xc57272d5, 0x72b7a7e4, 0xec3939e4, 0x39d5dd72, 0x164c4c2d, 0x4c5a6198, 0x945e5e65, 0x5eca3bbc, 0x9f7878fd, 0x78e785f0, 0xe53838e0, 0x38ddd870, 0x988c8c0a, 0x8c148605, 0x17d1d163, 0xd1c6b2bf, 0xe4a5a5ae, 0xa5410b57, 0xa1e2e2af, 0xe2434dd9, 0x4e616199, 0x612ff8c2, 0x42b3b3f6, 0xb3f1457b, 0x34212184, 0x2115a542, 0x089c9c4a, 0x9c94d625, 0xee1e1e78, 0x1ef0663c, 0x61434311, 0x43225286, 0xb1c7c73b, 0xc776fc93, 0x4ffcfcd7, 0xfcb32be5, 0x24040410, 0x04201408, 0xe3515159, 0x51b208a2, 0x2599995e, 0x99bcc72f, 0x226d6da9, 0x6d4fc4da, 0x650d0d34, 0x0d68391a, 0x79fafacf, 0xfa8335e9, 0x69dfdf5b, 0xdfb684a3, 0xa97e7ee5, 0x7ed79bfc, 0x19242490, 0x243db448, 0xfe3b3bec, 0x3bc5d776, 0x9aabab96, 0xab313d4b, 0xf0cece1f, 0xce3ed181, 0x99111144, 0x11885522, 0x838f8f06, 0x8f0c8903, 0x044e4e25, 0x4e4a6b9c, 0x66b7b7e6, 0xb7d15173, 0xe0ebeb8b, 0xeb0b60cb, 0xc13c3cf0, 0x3cfdcc78, 0xfd81813e, 0x817cbf1f, 0x4094946a, 0x94d4fe35, 0x1cf7f7fb, 0xf7eb0cf3, 0x18b9b9de, 0xb9a1676f, 0x8b13134c, 0x13985f26, 0x512c2cb0, 0x2c7d9c58, 0x05d3d36b, 0xd3d6b8bb, 0x8ce7e7bb, 0xe76b5cd3, 0x396e6ea5, 0x6e57cbdc, 0xaac4c437, 0xc46ef395, 0x1b03030c, 0x03180f06, 0xdc565645, 0x568a13ac, 0x5e44440d, 0x441a4988, 0xa07f7fe1, 0x7fdf9efe, 0x88a9a99e, 0xa921374f, 0x672a2aa8, 0x2a4d8254, 0x0abbbbd6, 0xbbb16d6b, 0x87c1c123, 0xc146e29f, 0xf1535351, 0x53a202a6, 0x72dcdc57, 0xdcae8ba5, 0x530b0b2c, 0x0b582716, 0x019d9d4e, 0x9d9cd327, 0x2b6c6cad, 0x6c47c1d8, 0xa43131c4, 0x3195f562, 0xf37474cd, 0x7487b9e8, 0x15f6f6ff, 0xf6e309f1, 0x4c464605, 0x460a438c, 0xa5acac8a, 0xac092645, 0xb589891e, 0x893c970f, 0xb4141450, 0x14a04428, 0xbae1e1a3, 0xe15b42df, 0xa6161658, 0x16b04e2c, 0xf73a3ae8, 0x3acdd274, 0x066969b9, 0x696fd0d2, 0x41090924, 0x09482d12, 0xd77070dd, 0x70a7ade0, 0x6fb6b6e2, 0xb6d95471, 0x1ed0d067, 0xd0ceb7bd, 0xd6eded93, 0xed3b7ec7, 0xe2cccc17, 0xcc2edb85, 0x68424215, 0x422a5784, 0x2c98985a, 0x98b4c22d, 0xeda4a4aa, 0xa4490e55, 0x752828a0, 0x285d8850, 0x865c5c6d, 0x5cda31b8, 0x6bf8f8c7, 0xf8933fed, 0xc2868622, 0x8644a411]);
  var C2 = new Uint32Array([0x30d81818, 0x6018c078, 0x46262323, 0x8c2305af, 0x91b8c6c6, 0x3fc67ef9, 0xcdfbe8e8, 0x87e8136f, 0x13cb8787, 0x26874ca1, 0x6d11b8b8, 0xdab8a962, 0x02090101, 0x04010805, 0x9e0d4f4f, 0x214f426e, 0x6c9b3636, 0xd836adee, 0x51ffa6a6, 0xa2a65904, 0xb90cd2d2, 0x6fd2debd, 0xf70ef5f5, 0xf3f5fb06, 0xf2967979, 0xf979ef80, 0xde306f6f, 0xa16f5fce, 0x3f6d9191, 0x7e91fcef, 0xa4f85252, 0x5552aa07, 0xc0476060, 0x9d6027fd, 0x6535bcbc, 0xcabc8976, 0x2b379b9b, 0x569baccd, 0x018a8e8e, 0x028e048c, 0x5bd2a3a3, 0xb6a37115, 0x186c0c0c, 0x300c603c, 0xf6847b7b, 0xf17bff8a, 0x6a803535, 0xd435b5e1, 0x3af51d1d, 0x741de869, 0xddb3e0e0, 0xa7e05347, 0xb321d7d7, 0x7bd7f6ac, 0x999cc2c2, 0x2fc25eed, 0x5c432e2e, 0xb82e6d96, 0x96294b4b, 0x314b627a, 0xe15dfefe, 0xdffea321, 0xaed55757, 0x41578216, 0x2abd1515, 0x5415a841, 0xeee87777, 0xc1779fb6, 0x6e923737, 0xdc37a5eb, 0xd79ee5e5, 0xb3e57b56, 0x23139f9f, 0x469f8cd9, 0xfd23f0f0, 0xe7f0d317, 0x94204a4a, 0x354a6a7f, 0xa944dada, 0x4fda9e95, 0xb0a25858, 0x7d58fa25, 0x8fcfc9c9, 0x03c906ca, 0x527c2929, 0xa429558d, 0x145a0a0a, 0x280a5022, 0x7f50b1b1, 0xfeb1e14f, 0x5dc9a0a0, 0xbaa0691a, 0xd6146b6b, 0xb16b7fda, 0x17d98585, 0x2e855cab, 0x673cbdbd, 0xcebd8173, 0xba8f5d5d, 0x695dd234, 0x20901010, 0x40108050, 0xf507f4f4, 0xf7f4f303, 0x8bddcbcb, 0x0bcb16c0, 0x7cd33e3e, 0xf83eedc6, 0x0a2d0505, 0x14052811, 0xce786767, 0x81671fe6, 0xd597e4e4, 0xb7e47353, 0x4e022727, 0x9c2725bb, 0x82734141, 0x19413258, 0x0ba78b8b, 0x168b2c9d, 0x53f6a7a7, 0xa6a75101, 0xfab27d7d, 0xe97dcf94, 0x37499595, 0x6e95dcfb, 0xad56d8d8, 0x47d88e9f, 0xeb70fbfb, 0xcbfb8b30, 0xc1cdeeee, 0x9fee2371, 0xf8bb7c7c, 0xed7cc791, 0xcc716666, 0x856617e3, 0xa77bdddd, 0x53dda68e, 0x2eaf1717, 0x5c17b84b, 0x8e454747, 0x01470246, 0x211a9e9e, 0x429e84dc, 0x89d4caca, 0x0fca1ec5, 0x5a582d2d, 0xb42d7599, 0x632ebfbf, 0xc6bf9179, 0x0e3f0707, 0x1c07381b, 0x47acadad, 0x8ead0123, 0xb4b05a5a, 0x755aea2f, 0x1bef8383, 0x36836cb5, 0x66b63333, 0xcc3385ff, 0xc65c6363, 0x91633ff2, 0x04120202, 0x0802100a, 0x4993aaaa, 0x92aa3938, 0xe2de7171, 0xd971afa8, 0x8dc6c8c8, 0x07c80ecf, 0x32d11919, 0x6419c87d, 0x923b4949, 0x39497270, 0xaf5fd9d9, 0x43d9869a, 0xf931f2f2, 0xeff2c31d, 0xdba8e3e3, 0xabe34b48, 0xb6b95b5b, 0x715be22a, 0x0dbc8888, 0x1a883492, 0x293e9a9a, 0x529aa4c8, 0x4c0b2626, 0x98262dbe, 0x64bf3232, 0xc8328dfa, 0x7d59b0b0, 0xfab0e94a, 0xcff2e9e9, 0x83e91b6a, 0x1e770f0f, 0x3c0f7833, 0xb733d5d5, 0x73d5e6a6, 0x1df48080, 0x3a8074ba, 0x6127bebe, 0xc2be997c, 0x87ebcdcd, 0x13cd26de, 0x68893434, 0xd034bde4, 0x90324848, 0x3d487a75, 0xe354ffff, 0xdbffab24, 0xf48d7a7a, 0xf57af78f, 0x3d649090, 0x7a90f4ea, 0xbe9d5f5f, 0x615fc23e, 0x403d2020, 0x80201da0, 0xd00f6868, 0xbd6867d5, 0x34ca1a1a, 0x681ad072, 0x41b7aeae, 0x82ae192c, 0x757db4b4, 0xeab4c95e, 0xa8ce5454, 0x4d549a19, 0x3b7f9393, 0x7693ece5, 0x442f2222, 0x88220daa, 0xc8636464, 0x8d6407e9, 0xff2af1f1, 0xe3f1db12, 0xe6cc7373, 0xd173bfa2, 0x24821212, 0x4812905a, 0x807a4040, 0x1d403a5d, 0x10480808, 0x20084028, 0x9b95c3c3, 0x2bc356e8, 0xc5dfecec, 0x97ec337b, 0xab4ddbdb, 0x4bdb9690, 0x5fc0a1a1, 0xbea1611f, 0x07918d8d, 0x0e8d1c83, 0x7ac83d3d, 0xf43df5c9, 0x335b9797, 0x6697ccf1, 0x00000000, 0x00000000, 0x83f9cfcf, 0x1bcf36d4, 0x566e2b2b, 0xac2b4587, 0xece17676, 0xc57697b3, 0x19e68282, 0x328264b0, 0xb128d6d6, 0x7fd6fea9, 0x36c31b1b, 0x6c1bd877, 0x7774b5b5, 0xeeb5c15b, 0x43beafaf, 0x86af1129, 0xd41d6a6a, 0xb56a77df, 0xa0ea5050, 0x5d50ba0d, 0x8a574545, 0x0945124c, 0xfb38f3f3, 0xebf3cb18, 0x60ad3030, 0xc0309df0, 0xc3c4efef, 0x9bef2b74, 0x7eda3f3f, 0xfc3fe5c3, 0xaac75555, 0x4955921c, 0x59dba2a2, 0xb2a27910, 0xc9e9eaea, 0x8fea0365, 0xca6a6565, 0x89650fec, 0x6903baba, 0xd2bab968, 0x5e4a2f2f, 0xbc2f6593, 0x9d8ec0c0, 0x27c04ee7, 0xa160dede, 0x5fdebe81, 0x38fc1c1c, 0x701ce06c, 0xe746fdfd, 0xd3fdbb2e, 0x9a1f4d4d, 0x294d5264, 0x39769292, 0x7292e4e0, 0xeafa7575, 0xc9758fbc, 0x0c360606, 0x1806301e, 0x09ae8a8a, 0x128a2498, 0x794bb2b2, 0xf2b2f940, 0xd185e6e6, 0xbfe66359, 0x1c7e0e0e, 0x380e7036, 0x3ee71f1f, 0x7c1ff863, 0xc4556262, 0x956237f7, 0xb53ad4d4, 0x77d4eea3, 0x4d81a8a8, 0x9aa82932, 0x31529696, 0x6296c4f4, 0xef62f9f9, 0xc3f99b3a, 0x97a3c5c5, 0x33c566f6, 0x4a102525, 0x942535b1, 0xb2ab5959, 0x7959f220, 0x15d08484, 0x2a8454ae, 0xe4c57272, 0xd572b7a7, 0x72ec3939, 0xe439d5dd, 0x98164c4c, 0x2d4c5a61, 0xbc945e5e, 0x655eca3b, 0xf09f7878, 0xfd78e785, 0x70e53838, 0xe038ddd8, 0x05988c8c, 0x0a8c1486, 0xbf17d1d1, 0x63d1c6b2, 0x57e4a5a5, 0xaea5410b, 0xd9a1e2e2, 0xafe2434d, 0xc24e6161, 0x99612ff8, 0x7b42b3b3, 0xf6b3f145, 0x42342121, 0x842115a5, 0x25089c9c, 0x4a9c94d6, 0x3cee1e1e, 0x781ef066, 0x86614343, 0x11432252, 0x93b1c7c7, 0x3bc776fc, 0xe54ffcfc, 0xd7fcb32b, 0x08240404, 0x10042014, 0xa2e35151, 0x5951b208, 0x2f259999, 0x5e99bcc7, 0xda226d6d, 0xa96d4fc4, 0x1a650d0d, 0x340d6839, 0xe979fafa, 0xcffa8335, 0xa369dfdf, 0x5bdfb684, 0xfca97e7e, 0xe57ed79b, 0x48192424, 0x90243db4, 0x76fe3b3b, 0xec3bc5d7, 0x4b9aabab, 0x96ab313d, 0x81f0cece, 0x1fce3ed1, 0x22991111, 0x44118855, 0x03838f8f, 0x068f0c89, 0x9c044e4e, 0x254e4a6b, 0x7366b7b7, 0xe6b7d151, 0xcbe0ebeb, 0x8beb0b60, 0x78c13c3c, 0xf03cfdcc, 0x1ffd8181, 0x3e817cbf, 0x35409494, 0x6a94d4fe, 0xf31cf7f7, 0xfbf7eb0c, 0x6f18b9b9, 0xdeb9a167, 0x268b1313, 0x4c13985f, 0x58512c2c, 0xb02c7d9c, 0xbb05d3d3, 0x6bd3d6b8, 0xd38ce7e7, 0xbbe76b5c, 0xdc396e6e, 0xa56e57cb, 0x95aac4c4, 0x37c46ef3, 0x061b0303, 0x0c03180f, 0xacdc5656, 0x45568a13, 0x885e4444, 0x0d441a49, 0xfea07f7f, 0xe17fdf9e, 0x4f88a9a9, 0x9ea92137, 0x54672a2a, 0xa82a4d82, 0x6b0abbbb, 0xd6bbb16d, 0x9f87c1c1, 0x23c146e2, 0xa6f15353, 0x5153a202, 0xa572dcdc, 0x57dcae8b, 0x16530b0b, 0x2c0b5827, 0x27019d9d, 0x4e9d9cd3, 0xd82b6c6c, 0xad6c47c1, 0x62a43131, 0xc43195f5, 0xe8f37474, 0xcd7487b9, 0xf115f6f6, 0xfff6e309, 0x8c4c4646, 0x05460a43, 0x45a5acac, 0x8aac0926, 0x0fb58989, 0x1e893c97, 0x28b41414, 0x5014a044, 0xdfbae1e1, 0xa3e15b42, 0x2ca61616, 0x5816b04e, 0x74f73a3a, 0xe83acdd2, 0xd2066969, 0xb9696fd0, 0x12410909, 0x2409482d, 0xe0d77070, 0xdd70a7ad, 0x716fb6b6, 0xe2b6d954, 0xbd1ed0d0, 0x67d0ceb7, 0xc7d6eded, 0x93ed3b7e, 0x85e2cccc, 0x17cc2edb, 0x84684242, 0x15422a57, 0x2d2c9898, 0x5a98b4c2, 0x55eda4a4, 0xaaa4490e, 0x50752828, 0xa0285d88, 0xb8865c5c, 0x6d5cda31, 0xed6bf8f8, 0xc7f8933f, 0x11c28686, 0x228644a4]);
  var C3 = new Uint32Array([0x7830d818, 0x186018c0, 0xaf462623, 0x238c2305, 0xf991b8c6, 0xc63fc67e, 0x6fcdfbe8, 0xe887e813, 0xa113cb87, 0x8726874c, 0x626d11b8, 0xb8dab8a9, 0x05020901, 0x01040108, 0x6e9e0d4f, 0x4f214f42, 0xee6c9b36, 0x36d836ad, 0x0451ffa6, 0xa6a2a659, 0xbdb90cd2, 0xd26fd2de, 0x06f70ef5, 0xf5f3f5fb, 0x80f29679, 0x79f979ef, 0xcede306f, 0x6fa16f5f, 0xef3f6d91, 0x917e91fc, 0x07a4f852, 0x525552aa, 0xfdc04760, 0x609d6027, 0x766535bc, 0xbccabc89, 0xcd2b379b, 0x9b569bac, 0x8c018a8e, 0x8e028e04, 0x155bd2a3, 0xa3b6a371, 0x3c186c0c, 0x0c300c60, 0x8af6847b, 0x7bf17bff, 0xe16a8035, 0x35d435b5, 0x693af51d, 0x1d741de8, 0x47ddb3e0, 0xe0a7e053, 0xacb321d7, 0xd77bd7f6, 0xed999cc2, 0xc22fc25e, 0x965c432e, 0x2eb82e6d, 0x7a96294b, 0x4b314b62, 0x21e15dfe, 0xfedffea3, 0x16aed557, 0x57415782, 0x412abd15, 0x155415a8, 0xb6eee877, 0x77c1779f, 0xeb6e9237, 0x37dc37a5, 0x56d79ee5, 0xe5b3e57b, 0xd923139f, 0x9f469f8c, 0x17fd23f0, 0xf0e7f0d3, 0x7f94204a, 0x4a354a6a, 0x95a944da, 0xda4fda9e, 0x25b0a258, 0x587d58fa, 0xca8fcfc9, 0xc903c906, 0x8d527c29, 0x29a42955, 0x22145a0a, 0x0a280a50, 0x4f7f50b1, 0xb1feb1e1, 0x1a5dc9a0, 0xa0baa069, 0xdad6146b, 0x6bb16b7f, 0xab17d985, 0x852e855c, 0x73673cbd, 0xbdcebd81, 0x34ba8f5d, 0x5d695dd2, 0x50209010, 0x10401080, 0x03f507f4, 0xf4f7f4f3, 0xc08bddcb, 0xcb0bcb16, 0xc67cd33e, 0x3ef83eed, 0x110a2d05, 0x05140528, 0xe6ce7867, 0x6781671f, 0x53d597e4, 0xe4b7e473, 0xbb4e0227, 0x279c2725, 0x58827341, 0x41194132, 0x9d0ba78b, 0x8b168b2c, 0x0153f6a7, 0xa7a6a751, 0x94fab27d, 0x7de97dcf, 0xfb374995, 0x956e95dc, 0x9fad56d8, 0xd847d88e, 0x30eb70fb, 0xfbcbfb8b, 0x71c1cdee, 0xee9fee23, 0x91f8bb7c, 0x7ced7cc7, 0xe3cc7166, 0x66856617, 0x8ea77bdd, 0xdd53dda6, 0x4b2eaf17, 0x175c17b8, 0x468e4547, 0x47014702, 0xdc211a9e, 0x9e429e84, 0xc589d4ca, 0xca0fca1e, 0x995a582d, 0x2db42d75, 0x79632ebf, 0xbfc6bf91, 0x1b0e3f07, 0x071c0738, 0x2347acad, 0xad8ead01, 0x2fb4b05a, 0x5a755aea, 0xb51bef83, 0x8336836c, 0xff66b633, 0x33cc3385, 0xf2c65c63, 0x6391633f, 0x0a041202, 0x02080210, 0x384993aa, 0xaa92aa39, 0xa8e2de71, 0x71d971af, 0xcf8dc6c8, 0xc807c80e, 0x7d32d119, 0x196419c8, 0x70923b49, 0x49394972, 0x9aaf5fd9, 0xd943d986, 0x1df931f2, 0xf2eff2c3, 0x48dba8e3, 0xe3abe34b, 0x2ab6b95b, 0x5b715be2, 0x920dbc88, 0x881a8834, 0xc8293e9a, 0x9a529aa4, 0xbe4c0b26, 0x2698262d, 0xfa64bf32, 0x32c8328d, 0x4a7d59b0, 0xb0fab0e9, 0x6acff2e9, 0xe983e91b, 0x331e770f, 0x0f3c0f78, 0xa6b733d5, 0xd573d5e6, 0xba1df480, 0x803a8074, 0x7c6127be, 0xbec2be99, 0xde87ebcd, 0xcd13cd26, 0xe4688934, 0x34d034bd, 0x75903248, 0x483d487a, 0x24e354ff, 0xffdbffab, 0x8ff48d7a, 0x7af57af7, 0xea3d6490, 0x907a90f4, 0x3ebe9d5f, 0x5f615fc2, 0xa0403d20, 0x2080201d, 0xd5d00f68, 0x68bd6867, 0x7234ca1a, 0x1a681ad0, 0x2c41b7ae, 0xae82ae19, 0x5e757db4, 0xb4eab4c9, 0x19a8ce54, 0x544d549a, 0xe53b7f93, 0x937693ec, 0xaa442f22, 0x2288220d, 0xe9c86364, 0x648d6407, 0x12ff2af1, 0xf1e3f1db, 0xa2e6cc73, 0x73d173bf, 0x5a248212, 0x12481290, 0x5d807a40, 0x401d403a, 0x28104808, 0x08200840, 0xe89b95c3, 0xc32bc356, 0x7bc5dfec, 0xec97ec33, 0x90ab4ddb, 0xdb4bdb96, 0x1f5fc0a1, 0xa1bea161, 0x8307918d, 0x8d0e8d1c, 0xc97ac83d, 0x3df43df5, 0xf1335b97, 0x976697cc, 0x00000000, 0x00000000, 0xd483f9cf, 0xcf1bcf36, 0x87566e2b, 0x2bac2b45, 0xb3ece176, 0x76c57697, 0xb019e682, 0x82328264, 0xa9b128d6, 0xd67fd6fe, 0x7736c31b, 0x1b6c1bd8, 0x5b7774b5, 0xb5eeb5c1, 0x2943beaf, 0xaf86af11, 0xdfd41d6a, 0x6ab56a77, 0x0da0ea50, 0x505d50ba, 0x4c8a5745, 0x45094512, 0x18fb38f3, 0xf3ebf3cb, 0xf060ad30, 0x30c0309d, 0x74c3c4ef, 0xef9bef2b, 0xc37eda3f, 0x3ffc3fe5, 0x1caac755, 0x55495592, 0x1059dba2, 0xa2b2a279, 0x65c9e9ea, 0xea8fea03, 0xecca6a65, 0x6589650f, 0x686903ba, 0xbad2bab9, 0x935e4a2f, 0x2fbc2f65, 0xe79d8ec0, 0xc027c04e, 0x81a160de, 0xde5fdebe, 0x6c38fc1c, 0x1c701ce0, 0x2ee746fd, 0xfdd3fdbb, 0x649a1f4d, 0x4d294d52, 0xe0397692, 0x927292e4, 0xbceafa75, 0x75c9758f, 0x1e0c3606, 0x06180630, 0x9809ae8a, 0x8a128a24, 0x40794bb2, 0xb2f2b2f9, 0x59d185e6, 0xe6bfe663, 0x361c7e0e, 0x0e380e70, 0x633ee71f, 0x1f7c1ff8, 0xf7c45562, 0x62956237, 0xa3b53ad4, 0xd477d4ee, 0x324d81a8, 0xa89aa829, 0xf4315296, 0x966296c4, 0x3aef62f9, 0xf9c3f99b, 0xf697a3c5, 0xc533c566, 0xb14a1025, 0x25942535, 0x20b2ab59, 0x597959f2, 0xae15d084, 0x842a8454, 0xa7e4c572, 0x72d572b7, 0xdd72ec39, 0x39e439d5, 0x6198164c, 0x4c2d4c5a, 0x3bbc945e, 0x5e655eca, 0x85f09f78, 0x78fd78e7, 0xd870e538, 0x38e038dd, 0x8605988c, 0x8c0a8c14, 0xb2bf17d1, 0xd163d1c6, 0x0b57e4a5, 0xa5aea541, 0x4dd9a1e2, 0xe2afe243, 0xf8c24e61, 0x6199612f, 0x457b42b3, 0xb3f6b3f1, 0xa5423421, 0x21842115, 0xd625089c, 0x9c4a9c94, 0x663cee1e, 0x1e781ef0, 0x52866143, 0x43114322, 0xfc93b1c7, 0xc73bc776, 0x2be54ffc, 0xfcd7fcb3, 0x14082404, 0x04100420, 0x08a2e351, 0x515951b2, 0xc72f2599, 0x995e99bc, 0xc4da226d, 0x6da96d4f, 0x391a650d, 0x0d340d68, 0x35e979fa, 0xfacffa83, 0x84a369df, 0xdf5bdfb6, 0x9bfca97e, 0x7ee57ed7, 0xb4481924, 0x2490243d, 0xd776fe3b, 0x3bec3bc5, 0x3d4b9aab, 0xab96ab31, 0xd181f0ce, 0xce1fce3e, 0x55229911, 0x11441188, 0x8903838f, 0x8f068f0c, 0x6b9c044e, 0x4e254e4a, 0x517366b7, 0xb7e6b7d1, 0x60cbe0eb, 0xeb8beb0b, 0xcc78c13c, 0x3cf03cfd, 0xbf1ffd81, 0x813e817c, 0xfe354094, 0x946a94d4, 0x0cf31cf7, 0xf7fbf7eb, 0x676f18b9, 0xb9deb9a1, 0x5f268b13, 0x134c1398, 0x9c58512c, 0x2cb02c7d, 0xb8bb05d3, 0xd36bd3d6, 0x5cd38ce7, 0xe7bbe76b, 0xcbdc396e, 0x6ea56e57, 0xf395aac4, 0xc437c46e, 0x0f061b03, 0x030c0318, 0x13acdc56, 0x5645568a, 0x49885e44, 0x440d441a, 0x9efea07f, 0x7fe17fdf, 0x374f88a9, 0xa99ea921, 0x8254672a, 0x2aa82a4d, 0x6d6b0abb, 0xbbd6bbb1, 0xe29f87c1, 0xc123c146, 0x02a6f153, 0x535153a2, 0x8ba572dc, 0xdc57dcae, 0x2716530b, 0x0b2c0b58, 0xd327019d, 0x9d4e9d9c, 0xc1d82b6c, 0x6cad6c47, 0xf562a431, 0x31c43195, 0xb9e8f374, 0x74cd7487, 0x09f115f6, 0xf6fff6e3, 0x438c4c46, 0x4605460a, 0x2645a5ac, 0xac8aac09, 0x970fb589, 0x891e893c, 0x4428b414, 0x145014a0, 0x42dfbae1, 0xe1a3e15b, 0x4e2ca616, 0x165816b0, 0xd274f73a, 0x3ae83acd, 0xd0d20669, 0x69b9696f, 0x2d124109, 0x09240948, 0xade0d770, 0x70dd70a7, 0x54716fb6, 0xb6e2b6d9, 0xb7bd1ed0, 0xd067d0ce, 0x7ec7d6ed, 0xed93ed3b, 0xdb85e2cc, 0xcc17cc2e, 0x57846842, 0x4215422a, 0xc22d2c98, 0x985a98b4, 0x0e55eda4, 0xa4aaa449, 0x88507528, 0x28a0285d, 0x31b8865c, 0x5c6d5cda, 0x3fed6bf8, 0xf8c7f893, 0xa411c286, 0x86228644]);
  var C4 = new Uint32Array([0xc07830d8, 0x18186018, 0x05af4626, 0x23238c23, 0x7ef991b8, 0xc6c63fc6, 0x136fcdfb, 0xe8e887e8, 0x4ca113cb, 0x87872687, 0xa9626d11, 0xb8b8dab8, 0x08050209, 0x01010401, 0x426e9e0d, 0x4f4f214f, 0xadee6c9b, 0x3636d836, 0x590451ff, 0xa6a6a2a6, 0xdebdb90c, 0xd2d26fd2, 0xfb06f70e, 0xf5f5f3f5, 0xef80f296, 0x7979f979, 0x5fcede30, 0x6f6fa16f, 0xfcef3f6d, 0x91917e91, 0xaa07a4f8, 0x52525552, 0x27fdc047, 0x60609d60, 0x89766535, 0xbcbccabc, 0xaccd2b37, 0x9b9b569b, 0x048c018a, 0x8e8e028e, 0x71155bd2, 0xa3a3b6a3, 0x603c186c, 0x0c0c300c, 0xff8af684, 0x7b7bf17b, 0xb5e16a80, 0x3535d435, 0xe8693af5, 0x1d1d741d, 0x5347ddb3, 0xe0e0a7e0, 0xf6acb321, 0xd7d77bd7, 0x5eed999c, 0xc2c22fc2, 0x6d965c43, 0x2e2eb82e, 0x627a9629, 0x4b4b314b, 0xa321e15d, 0xfefedffe, 0x8216aed5, 0x57574157, 0xa8412abd, 0x15155415, 0x9fb6eee8, 0x7777c177, 0xa5eb6e92, 0x3737dc37, 0x7b56d79e, 0xe5e5b3e5, 0x8cd92313, 0x9f9f469f, 0xd317fd23, 0xf0f0e7f0, 0x6a7f9420, 0x4a4a354a, 0x9e95a944, 0xdada4fda, 0xfa25b0a2, 0x58587d58, 0x06ca8fcf, 0xc9c903c9, 0x558d527c, 0x2929a429, 0x5022145a, 0x0a0a280a, 0xe14f7f50, 0xb1b1feb1, 0x691a5dc9, 0xa0a0baa0, 0x7fdad614, 0x6b6bb16b, 0x5cab17d9, 0x85852e85, 0x8173673c, 0xbdbdcebd, 0xd234ba8f, 0x5d5d695d, 0x80502090, 0x10104010, 0xf303f507, 0xf4f4f7f4, 0x16c08bdd, 0xcbcb0bcb, 0xedc67cd3, 0x3e3ef83e, 0x28110a2d, 0x05051405, 0x1fe6ce78, 0x67678167, 0x7353d597, 0xe4e4b7e4, 0x25bb4e02, 0x27279c27, 0x32588273, 0x41411941, 0x2c9d0ba7, 0x8b8b168b, 0x510153f6, 0xa7a7a6a7, 0xcf94fab2, 0x7d7de97d, 0xdcfb3749, 0x95956e95, 0x8e9fad56, 0xd8d847d8, 0x8b30eb70, 0xfbfbcbfb, 0x2371c1cd, 0xeeee9fee, 0xc791f8bb, 0x7c7ced7c, 0x17e3cc71, 0x66668566, 0xa68ea77b, 0xdddd53dd, 0xb84b2eaf, 0x17175c17, 0x02468e45, 0x47470147, 0x84dc211a, 0x9e9e429e, 0x1ec589d4, 0xcaca0fca, 0x75995a58, 0x2d2db42d, 0x9179632e, 0xbfbfc6bf, 0x381b0e3f, 0x07071c07, 0x012347ac, 0xadad8ead, 0xea2fb4b0, 0x5a5a755a, 0x6cb51bef, 0x83833683, 0x85ff66b6, 0x3333cc33, 0x3ff2c65c, 0x63639163, 0x100a0412, 0x02020802, 0x39384993, 0xaaaa92aa, 0xafa8e2de, 0x7171d971, 0x0ecf8dc6, 0xc8c807c8, 0xc87d32d1, 0x19196419, 0x7270923b, 0x49493949, 0x869aaf5f, 0xd9d943d9, 0xc31df931, 0xf2f2eff2, 0x4b48dba8, 0xe3e3abe3, 0xe22ab6b9, 0x5b5b715b, 0x34920dbc, 0x88881a88, 0xa4c8293e, 0x9a9a529a, 0x2dbe4c0b, 0x26269826, 0x8dfa64bf, 0x3232c832, 0xe94a7d59, 0xb0b0fab0, 0x1b6acff2, 0xe9e983e9, 0x78331e77, 0x0f0f3c0f, 0xe6a6b733, 0xd5d573d5, 0x74ba1df4, 0x80803a80, 0x997c6127, 0xbebec2be, 0x26de87eb, 0xcdcd13cd, 0xbde46889, 0x3434d034, 0x7a759032, 0x48483d48, 0xab24e354, 0xffffdbff, 0xf78ff48d, 0x7a7af57a, 0xf4ea3d64, 0x90907a90, 0xc23ebe9d, 0x5f5f615f, 0x1da0403d, 0x20208020, 0x67d5d00f, 0x6868bd68, 0xd07234ca, 0x1a1a681a, 0x192c41b7, 0xaeae82ae, 0xc95e757d, 0xb4b4eab4, 0x9a19a8ce, 0x54544d54, 0xece53b7f, 0x93937693, 0x0daa442f, 0x22228822, 0x07e9c863, 0x64648d64, 0xdb12ff2a, 0xf1f1e3f1, 0xbfa2e6cc, 0x7373d173, 0x905a2482, 0x12124812, 0x3a5d807a, 0x40401d40, 0x40281048, 0x08082008, 0x56e89b95, 0xc3c32bc3, 0x337bc5df, 0xecec97ec, 0x9690ab4d, 0xdbdb4bdb, 0x611f5fc0, 0xa1a1bea1, 0x1c830791, 0x8d8d0e8d, 0xf5c97ac8, 0x3d3df43d, 0xccf1335b, 0x97976697, 0x00000000, 0x00000000, 0x36d483f9, 0xcfcf1bcf, 0x4587566e, 0x2b2bac2b, 0x97b3ece1, 0x7676c576, 0x64b019e6, 0x82823282, 0xfea9b128, 0xd6d67fd6, 0xd87736c3, 0x1b1b6c1b, 0xc15b7774, 0xb5b5eeb5, 0x112943be, 0xafaf86af, 0x77dfd41d, 0x6a6ab56a, 0xba0da0ea, 0x50505d50, 0x124c8a57, 0x45450945, 0xcb18fb38, 0xf3f3ebf3, 0x9df060ad, 0x3030c030, 0x2b74c3c4, 0xefef9bef, 0xe5c37eda, 0x3f3ffc3f, 0x921caac7, 0x55554955, 0x791059db, 0xa2a2b2a2, 0x0365c9e9, 0xeaea8fea, 0x0fecca6a, 0x65658965, 0xb9686903, 0xbabad2ba, 0x65935e4a, 0x2f2fbc2f, 0x4ee79d8e, 0xc0c027c0, 0xbe81a160, 0xdede5fde, 0xe06c38fc, 0x1c1c701c, 0xbb2ee746, 0xfdfdd3fd, 0x52649a1f, 0x4d4d294d, 0xe4e03976, 0x92927292, 0x8fbceafa, 0x7575c975, 0x301e0c36, 0x06061806, 0x249809ae, 0x8a8a128a, 0xf940794b, 0xb2b2f2b2, 0x6359d185, 0xe6e6bfe6, 0x70361c7e, 0x0e0e380e, 0xf8633ee7, 0x1f1f7c1f, 0x37f7c455, 0x62629562, 0xeea3b53a, 0xd4d477d4, 0x29324d81, 0xa8a89aa8, 0xc4f43152, 0x96966296, 0x9b3aef62, 0xf9f9c3f9, 0x66f697a3, 0xc5c533c5, 0x35b14a10, 0x25259425, 0xf220b2ab, 0x59597959, 0x54ae15d0, 0x84842a84, 0xb7a7e4c5, 0x7272d572, 0xd5dd72ec, 0x3939e439, 0x5a619816, 0x4c4c2d4c, 0xca3bbc94, 0x5e5e655e, 0xe785f09f, 0x7878fd78, 0xddd870e5, 0x3838e038, 0x14860598, 0x8c8c0a8c, 0xc6b2bf17, 0xd1d163d1, 0x410b57e4, 0xa5a5aea5, 0x434dd9a1, 0xe2e2afe2, 0x2ff8c24e, 0x61619961, 0xf1457b42, 0xb3b3f6b3, 0x15a54234, 0x21218421, 0x94d62508, 0x9c9c4a9c, 0xf0663cee, 0x1e1e781e, 0x22528661, 0x43431143, 0x76fc93b1, 0xc7c73bc7, 0xb32be54f, 0xfcfcd7fc, 0x20140824, 0x04041004, 0xb208a2e3, 0x51515951, 0xbcc72f25, 0x99995e99, 0x4fc4da22, 0x6d6da96d, 0x68391a65, 0x0d0d340d, 0x8335e979, 0xfafacffa, 0xb684a369, 0xdfdf5bdf, 0xd79bfca9, 0x7e7ee57e, 0x3db44819, 0x24249024, 0xc5d776fe, 0x3b3bec3b, 0x313d4b9a, 0xabab96ab, 0x3ed181f0, 0xcece1fce, 0x88552299, 0x11114411, 0x0c890383, 0x8f8f068f, 0x4a6b9c04, 0x4e4e254e, 0xd1517366, 0xb7b7e6b7, 0x0b60cbe0, 0xebeb8beb, 0xfdcc78c1, 0x3c3cf03c, 0x7cbf1ffd, 0x81813e81, 0xd4fe3540, 0x94946a94, 0xeb0cf31c, 0xf7f7fbf7, 0xa1676f18, 0xb9b9deb9, 0x985f268b, 0x13134c13, 0x7d9c5851, 0x2c2cb02c, 0xd6b8bb05, 0xd3d36bd3, 0x6b5cd38c, 0xe7e7bbe7, 0x57cbdc39, 0x6e6ea56e, 0x6ef395aa, 0xc4c437c4, 0x180f061b, 0x03030c03, 0x8a13acdc, 0x56564556, 0x1a49885e, 0x44440d44, 0xdf9efea0, 0x7f7fe17f, 0x21374f88, 0xa9a99ea9, 0x4d825467, 0x2a2aa82a, 0xb16d6b0a, 0xbbbbd6bb, 0x46e29f87, 0xc1c123c1, 0xa202a6f1, 0x53535153, 0xae8ba572, 0xdcdc57dc, 0x58271653, 0x0b0b2c0b, 0x9cd32701, 0x9d9d4e9d, 0x47c1d82b, 0x6c6cad6c, 0x95f562a4, 0x3131c431, 0x87b9e8f3, 0x7474cd74, 0xe309f115, 0xf6f6fff6, 0x0a438c4c, 0x46460546, 0x092645a5, 0xacac8aac, 0x3c970fb5, 0x89891e89, 0xa04428b4, 0x14145014, 0x5b42dfba, 0xe1e1a3e1, 0xb04e2ca6, 0x16165816, 0xcdd274f7, 0x3a3ae83a, 0x6fd0d206, 0x6969b969, 0x482d1241, 0x09092409, 0xa7ade0d7, 0x7070dd70, 0xd954716f, 0xb6b6e2b6, 0xceb7bd1e, 0xd0d067d0, 0x3b7ec7d6, 0xeded93ed, 0x2edb85e2, 0xcccc17cc, 0x2a578468, 0x42421542, 0xb4c22d2c, 0x98985a98, 0x490e55ed, 0xa4a4aaa4, 0x5d885075, 0x2828a028, 0xda31b886, 0x5c5c6d5c, 0x933fed6b, 0xf8f8c7f8, 0x44a411c2, 0x86862286]);
  var C5 = new Uint32Array([0x18c07830, 0xd8181860, 0x2305af46, 0x2623238c, 0xc67ef991, 0xb8c6c63f, 0xe8136fcd, 0xfbe8e887, 0x874ca113, 0xcb878726, 0xb8a9626d, 0x11b8b8da, 0x01080502, 0x09010104, 0x4f426e9e, 0x0d4f4f21, 0x36adee6c, 0x9b3636d8, 0xa6590451, 0xffa6a6a2, 0xd2debdb9, 0x0cd2d26f, 0xf5fb06f7, 0x0ef5f5f3, 0x79ef80f2, 0x967979f9, 0x6f5fcede, 0x306f6fa1, 0x91fcef3f, 0x6d91917e, 0x52aa07a4, 0xf8525255, 0x6027fdc0, 0x4760609d, 0xbc897665, 0x35bcbcca, 0x9baccd2b, 0x379b9b56, 0x8e048c01, 0x8a8e8e02, 0xa371155b, 0xd2a3a3b6, 0x0c603c18, 0x6c0c0c30, 0x7bff8af6, 0x847b7bf1, 0x35b5e16a, 0x803535d4, 0x1de8693a, 0xf51d1d74, 0xe05347dd, 0xb3e0e0a7, 0xd7f6acb3, 0x21d7d77b, 0xc25eed99, 0x9cc2c22f, 0x2e6d965c, 0x432e2eb8, 0x4b627a96, 0x294b4b31, 0xfea321e1, 0x5dfefedf, 0x578216ae, 0xd5575741, 0x15a8412a, 0xbd151554, 0x779fb6ee, 0xe87777c1, 0x37a5eb6e, 0x923737dc, 0xe57b56d7, 0x9ee5e5b3, 0x9f8cd923, 0x139f9f46, 0xf0d317fd, 0x23f0f0e7, 0x4a6a7f94, 0x204a4a35, 0xda9e95a9, 0x44dada4f, 0x58fa25b0, 0xa258587d, 0xc906ca8f, 0xcfc9c903, 0x29558d52, 0x7c2929a4, 0x0a502214, 0x5a0a0a28, 0xb1e14f7f, 0x50b1b1fe, 0xa0691a5d, 0xc9a0a0ba, 0x6b7fdad6, 0x146b6bb1, 0x855cab17, 0xd985852e, 0xbd817367, 0x3cbdbdce, 0x5dd234ba, 0x8f5d5d69, 0x10805020, 0x90101040, 0xf4f303f5, 0x07f4f4f7, 0xcb16c08b, 0xddcbcb0b, 0x3eedc67c, 0xd33e3ef8, 0x0528110a, 0x2d050514, 0x671fe6ce, 0x78676781, 0xe47353d5, 0x97e4e4b7, 0x2725bb4e, 0x0227279c, 0x41325882, 0x73414119, 0x8b2c9d0b, 0xa78b8b16, 0xa7510153, 0xf6a7a7a6, 0x7dcf94fa, 0xb27d7de9, 0x95dcfb37, 0x4995956e, 0xd88e9fad, 0x56d8d847, 0xfb8b30eb, 0x70fbfbcb, 0xee2371c1, 0xcdeeee9f, 0x7cc791f8, 0xbb7c7ced, 0x6617e3cc, 0x71666685, 0xdda68ea7, 0x7bdddd53, 0x17b84b2e, 0xaf17175c, 0x4702468e, 0x45474701, 0x9e84dc21, 0x1a9e9e42, 0xca1ec589, 0xd4caca0f, 0x2d75995a, 0x582d2db4, 0xbf917963, 0x2ebfbfc6, 0x07381b0e, 0x3f07071c, 0xad012347, 0xacadad8e, 0x5aea2fb4, 0xb05a5a75, 0x836cb51b, 0xef838336, 0x3385ff66, 0xb63333cc, 0x633ff2c6, 0x5c636391, 0x02100a04, 0x12020208, 0xaa393849, 0x93aaaa92, 0x71afa8e2, 0xde7171d9, 0xc80ecf8d, 0xc6c8c807, 0x19c87d32, 0xd1191964, 0x49727092, 0x3b494939, 0xd9869aaf, 0x5fd9d943, 0xf2c31df9, 0x31f2f2ef, 0xe34b48db, 0xa8e3e3ab, 0x5be22ab6, 0xb95b5b71, 0x8834920d, 0xbc88881a, 0x9aa4c829, 0x3e9a9a52, 0x262dbe4c, 0x0b262698, 0x328dfa64, 0xbf3232c8, 0xb0e94a7d, 0x59b0b0fa, 0xe91b6acf, 0xf2e9e983, 0x0f78331e, 0x770f0f3c, 0xd5e6a6b7, 0x33d5d573, 0x8074ba1d, 0xf480803a, 0xbe997c61, 0x27bebec2, 0xcd26de87, 0xebcdcd13, 0x34bde468, 0x893434d0, 0x487a7590, 0x3248483d, 0xffab24e3, 0x54ffffdb, 0x7af78ff4, 0x8d7a7af5, 0x90f4ea3d, 0x6490907a, 0x5fc23ebe, 0x9d5f5f61, 0x201da040, 0x3d202080, 0x6867d5d0, 0x0f6868bd, 0x1ad07234, 0xca1a1a68, 0xae192c41, 0xb7aeae82, 0xb4c95e75, 0x7db4b4ea, 0x549a19a8, 0xce54544d, 0x93ece53b, 0x7f939376, 0x220daa44, 0x2f222288, 0x6407e9c8, 0x6364648d, 0xf1db12ff, 0x2af1f1e3, 0x73bfa2e6, 0xcc7373d1, 0x12905a24, 0x82121248, 0x403a5d80, 0x7a40401d, 0x08402810, 0x48080820, 0xc356e89b, 0x95c3c32b, 0xec337bc5, 0xdfecec97, 0xdb9690ab, 0x4ddbdb4b, 0xa1611f5f, 0xc0a1a1be, 0x8d1c8307, 0x918d8d0e, 0x3df5c97a, 0xc83d3df4, 0x97ccf133, 0x5b979766, 0x00000000, 0x00000000, 0xcf36d483, 0xf9cfcf1b, 0x2b458756, 0x6e2b2bac, 0x7697b3ec, 0xe17676c5, 0x8264b019, 0xe6828232, 0xd6fea9b1, 0x28d6d67f, 0x1bd87736, 0xc31b1b6c, 0xb5c15b77, 0x74b5b5ee, 0xaf112943, 0xbeafaf86, 0x6a77dfd4, 0x1d6a6ab5, 0x50ba0da0, 0xea50505d, 0x45124c8a, 0x57454509, 0xf3cb18fb, 0x38f3f3eb, 0x309df060, 0xad3030c0, 0xef2b74c3, 0xc4efef9b, 0x3fe5c37e, 0xda3f3ffc, 0x55921caa, 0xc7555549, 0xa2791059, 0xdba2a2b2, 0xea0365c9, 0xe9eaea8f, 0x650fecca, 0x6a656589, 0xbab96869, 0x03babad2, 0x2f65935e, 0x4a2f2fbc, 0xc04ee79d, 0x8ec0c027, 0xdebe81a1, 0x60dede5f, 0x1ce06c38, 0xfc1c1c70, 0xfdbb2ee7, 0x46fdfdd3, 0x4d52649a, 0x1f4d4d29, 0x92e4e039, 0x76929272, 0x758fbcea, 0xfa7575c9, 0x06301e0c, 0x36060618, 0x8a249809, 0xae8a8a12, 0xb2f94079, 0x4bb2b2f2, 0xe66359d1, 0x85e6e6bf, 0x0e70361c, 0x7e0e0e38, 0x1ff8633e, 0xe71f1f7c, 0x6237f7c4, 0x55626295, 0xd4eea3b5, 0x3ad4d477, 0xa829324d, 0x81a8a89a, 0x96c4f431, 0x52969662, 0xf99b3aef, 0x62f9f9c3, 0xc566f697, 0xa3c5c533, 0x2535b14a, 0x10252594, 0x59f220b2, 0xab595979, 0x8454ae15, 0xd084842a, 0x72b7a7e4, 0xc57272d5, 0x39d5dd72, 0xec3939e4, 0x4c5a6198, 0x164c4c2d, 0x5eca3bbc, 0x945e5e65, 0x78e785f0, 0x9f7878fd, 0x38ddd870, 0xe53838e0, 0x8c148605, 0x988c8c0a, 0xd1c6b2bf, 0x17d1d163, 0xa5410b57, 0xe4a5a5ae, 0xe2434dd9, 0xa1e2e2af, 0x612ff8c2, 0x4e616199, 0xb3f1457b, 0x42b3b3f6, 0x2115a542, 0x34212184, 0x9c94d625, 0x089c9c4a, 0x1ef0663c, 0xee1e1e78, 0x43225286, 0x61434311, 0xc776fc93, 0xb1c7c73b, 0xfcb32be5, 0x4ffcfcd7, 0x04201408, 0x24040410, 0x51b208a2, 0xe3515159, 0x99bcc72f, 0x2599995e, 0x6d4fc4da, 0x226d6da9, 0x0d68391a, 0x650d0d34, 0xfa8335e9, 0x79fafacf, 0xdfb684a3, 0x69dfdf5b, 0x7ed79bfc, 0xa97e7ee5, 0x243db448, 0x19242490, 0x3bc5d776, 0xfe3b3bec, 0xab313d4b, 0x9aabab96, 0xce3ed181, 0xf0cece1f, 0x11885522, 0x99111144, 0x8f0c8903, 0x838f8f06, 0x4e4a6b9c, 0x044e4e25, 0xb7d15173, 0x66b7b7e6, 0xeb0b60cb, 0xe0ebeb8b, 0x3cfdcc78, 0xc13c3cf0, 0x817cbf1f, 0xfd81813e, 0x94d4fe35, 0x4094946a, 0xf7eb0cf3, 0x1cf7f7fb, 0xb9a1676f, 0x18b9b9de, 0x13985f26, 0x8b13134c, 0x2c7d9c58, 0x512c2cb0, 0xd3d6b8bb, 0x05d3d36b, 0xe76b5cd3, 0x8ce7e7bb, 0x6e57cbdc, 0x396e6ea5, 0xc46ef395, 0xaac4c437, 0x03180f06, 0x1b03030c, 0x568a13ac, 0xdc565645, 0x441a4988, 0x5e44440d, 0x7fdf9efe, 0xa07f7fe1, 0xa921374f, 0x88a9a99e, 0x2a4d8254, 0x672a2aa8, 0xbbb16d6b, 0x0abbbbd6, 0xc146e29f, 0x87c1c123, 0x53a202a6, 0xf1535351, 0xdcae8ba5, 0x72dcdc57, 0x0b582716, 0x530b0b2c, 0x9d9cd327, 0x019d9d4e, 0x6c47c1d8, 0x2b6c6cad, 0x3195f562, 0xa43131c4, 0x7487b9e8, 0xf37474cd, 0xf6e309f1, 0x15f6f6ff, 0x460a438c, 0x4c464605, 0xac092645, 0xa5acac8a, 0x893c970f, 0xb589891e, 0x14a04428, 0xb4141450, 0xe15b42df, 0xbae1e1a3, 0x16b04e2c, 0xa6161658, 0x3acdd274, 0xf73a3ae8, 0x696fd0d2, 0x066969b9, 0x09482d12, 0x41090924, 0x70a7ade0, 0xd77070dd, 0xb6d95471, 0x6fb6b6e2, 0xd0ceb7bd, 0x1ed0d067, 0xed3b7ec7, 0xd6eded93, 0xcc2edb85, 0xe2cccc17, 0x422a5784, 0x68424215, 0x98b4c22d, 0x2c98985a, 0xa4490e55, 0xeda4a4aa, 0x285d8850, 0x752828a0, 0x5cda31b8, 0x865c5c6d, 0xf8933fed, 0x6bf8f8c7, 0x8644a411, 0xc2868622]);
  var C6 = new Uint32Array([0x6018c078, 0x30d81818, 0x8c2305af, 0x46262323, 0x3fc67ef9, 0x91b8c6c6, 0x87e8136f, 0xcdfbe8e8, 0x26874ca1, 0x13cb8787, 0xdab8a962, 0x6d11b8b8, 0x04010805, 0x02090101, 0x214f426e, 0x9e0d4f4f, 0xd836adee, 0x6c9b3636, 0xa2a65904, 0x51ffa6a6, 0x6fd2debd, 0xb90cd2d2, 0xf3f5fb06, 0xf70ef5f5, 0xf979ef80, 0xf2967979, 0xa16f5fce, 0xde306f6f, 0x7e91fcef, 0x3f6d9191, 0x5552aa07, 0xa4f85252, 0x9d6027fd, 0xc0476060, 0xcabc8976, 0x6535bcbc, 0x569baccd, 0x2b379b9b, 0x028e048c, 0x018a8e8e, 0xb6a37115, 0x5bd2a3a3, 0x300c603c, 0x186c0c0c, 0xf17bff8a, 0xf6847b7b, 0xd435b5e1, 0x6a803535, 0x741de869, 0x3af51d1d, 0xa7e05347, 0xddb3e0e0, 0x7bd7f6ac, 0xb321d7d7, 0x2fc25eed, 0x999cc2c2, 0xb82e6d96, 0x5c432e2e, 0x314b627a, 0x96294b4b, 0xdffea321, 0xe15dfefe, 0x41578216, 0xaed55757, 0x5415a841, 0x2abd1515, 0xc1779fb6, 0xeee87777, 0xdc37a5eb, 0x6e923737, 0xb3e57b56, 0xd79ee5e5, 0x469f8cd9, 0x23139f9f, 0xe7f0d317, 0xfd23f0f0, 0x354a6a7f, 0x94204a4a, 0x4fda9e95, 0xa944dada, 0x7d58fa25, 0xb0a25858, 0x03c906ca, 0x8fcfc9c9, 0xa429558d, 0x527c2929, 0x280a5022, 0x145a0a0a, 0xfeb1e14f, 0x7f50b1b1, 0xbaa0691a, 0x5dc9a0a0, 0xb16b7fda, 0xd6146b6b, 0x2e855cab, 0x17d98585, 0xcebd8173, 0x673cbdbd, 0x695dd234, 0xba8f5d5d, 0x40108050, 0x20901010, 0xf7f4f303, 0xf507f4f4, 0x0bcb16c0, 0x8bddcbcb, 0xf83eedc6, 0x7cd33e3e, 0x14052811, 0x0a2d0505, 0x81671fe6, 0xce786767, 0xb7e47353, 0xd597e4e4, 0x9c2725bb, 0x4e022727, 0x19413258, 0x82734141, 0x168b2c9d, 0x0ba78b8b, 0xa6a75101, 0x53f6a7a7, 0xe97dcf94, 0xfab27d7d, 0x6e95dcfb, 0x37499595, 0x47d88e9f, 0xad56d8d8, 0xcbfb8b30, 0xeb70fbfb, 0x9fee2371, 0xc1cdeeee, 0xed7cc791, 0xf8bb7c7c, 0x856617e3, 0xcc716666, 0x53dda68e, 0xa77bdddd, 0x5c17b84b, 0x2eaf1717, 0x01470246, 0x8e454747, 0x429e84dc, 0x211a9e9e, 0x0fca1ec5, 0x89d4caca, 0xb42d7599, 0x5a582d2d, 0xc6bf9179, 0x632ebfbf, 0x1c07381b, 0x0e3f0707, 0x8ead0123, 0x47acadad, 0x755aea2f, 0xb4b05a5a, 0x36836cb5, 0x1bef8383, 0xcc3385ff, 0x66b63333, 0x91633ff2, 0xc65c6363, 0x0802100a, 0x04120202, 0x92aa3938, 0x4993aaaa, 0xd971afa8, 0xe2de7171, 0x07c80ecf, 0x8dc6c8c8, 0x6419c87d, 0x32d11919, 0x39497270, 0x923b4949, 0x43d9869a, 0xaf5fd9d9, 0xeff2c31d, 0xf931f2f2, 0xabe34b48, 0xdba8e3e3, 0x715be22a, 0xb6b95b5b, 0x1a883492, 0x0dbc8888, 0x529aa4c8, 0x293e9a9a, 0x98262dbe, 0x4c0b2626, 0xc8328dfa, 0x64bf3232, 0xfab0e94a, 0x7d59b0b0, 0x83e91b6a, 0xcff2e9e9, 0x3c0f7833, 0x1e770f0f, 0x73d5e6a6, 0xb733d5d5, 0x3a8074ba, 0x1df48080, 0xc2be997c, 0x6127bebe, 0x13cd26de, 0x87ebcdcd, 0xd034bde4, 0x68893434, 0x3d487a75, 0x90324848, 0xdbffab24, 0xe354ffff, 0xf57af78f, 0xf48d7a7a, 0x7a90f4ea, 0x3d649090, 0x615fc23e, 0xbe9d5f5f, 0x80201da0, 0x403d2020, 0xbd6867d5, 0xd00f6868, 0x681ad072, 0x34ca1a1a, 0x82ae192c, 0x41b7aeae, 0xeab4c95e, 0x757db4b4, 0x4d549a19, 0xa8ce5454, 0x7693ece5, 0x3b7f9393, 0x88220daa, 0x442f2222, 0x8d6407e9, 0xc8636464, 0xe3f1db12, 0xff2af1f1, 0xd173bfa2, 0xe6cc7373, 0x4812905a, 0x24821212, 0x1d403a5d, 0x807a4040, 0x20084028, 0x10480808, 0x2bc356e8, 0x9b95c3c3, 0x97ec337b, 0xc5dfecec, 0x4bdb9690, 0xab4ddbdb, 0xbea1611f, 0x5fc0a1a1, 0x0e8d1c83, 0x07918d8d, 0xf43df5c9, 0x7ac83d3d, 0x6697ccf1, 0x335b9797, 0x00000000, 0x00000000, 0x1bcf36d4, 0x83f9cfcf, 0xac2b4587, 0x566e2b2b, 0xc57697b3, 0xece17676, 0x328264b0, 0x19e68282, 0x7fd6fea9, 0xb128d6d6, 0x6c1bd877, 0x36c31b1b, 0xeeb5c15b, 0x7774b5b5, 0x86af1129, 0x43beafaf, 0xb56a77df, 0xd41d6a6a, 0x5d50ba0d, 0xa0ea5050, 0x0945124c, 0x8a574545, 0xebf3cb18, 0xfb38f3f3, 0xc0309df0, 0x60ad3030, 0x9bef2b74, 0xc3c4efef, 0xfc3fe5c3, 0x7eda3f3f, 0x4955921c, 0xaac75555, 0xb2a27910, 0x59dba2a2, 0x8fea0365, 0xc9e9eaea, 0x89650fec, 0xca6a6565, 0xd2bab968, 0x6903baba, 0xbc2f6593, 0x5e4a2f2f, 0x27c04ee7, 0x9d8ec0c0, 0x5fdebe81, 0xa160dede, 0x701ce06c, 0x38fc1c1c, 0xd3fdbb2e, 0xe746fdfd, 0x294d5264, 0x9a1f4d4d, 0x7292e4e0, 0x39769292, 0xc9758fbc, 0xeafa7575, 0x1806301e, 0x0c360606, 0x128a2498, 0x09ae8a8a, 0xf2b2f940, 0x794bb2b2, 0xbfe66359, 0xd185e6e6, 0x380e7036, 0x1c7e0e0e, 0x7c1ff863, 0x3ee71f1f, 0x956237f7, 0xc4556262, 0x77d4eea3, 0xb53ad4d4, 0x9aa82932, 0x4d81a8a8, 0x6296c4f4, 0x31529696, 0xc3f99b3a, 0xef62f9f9, 0x33c566f6, 0x97a3c5c5, 0x942535b1, 0x4a102525, 0x7959f220, 0xb2ab5959, 0x2a8454ae, 0x15d08484, 0xd572b7a7, 0xe4c57272, 0xe439d5dd, 0x72ec3939, 0x2d4c5a61, 0x98164c4c, 0x655eca3b, 0xbc945e5e, 0xfd78e785, 0xf09f7878, 0xe038ddd8, 0x70e53838, 0x0a8c1486, 0x05988c8c, 0x63d1c6b2, 0xbf17d1d1, 0xaea5410b, 0x57e4a5a5, 0xafe2434d, 0xd9a1e2e2, 0x99612ff8, 0xc24e6161, 0xf6b3f145, 0x7b42b3b3, 0x842115a5, 0x42342121, 0x4a9c94d6, 0x25089c9c, 0x781ef066, 0x3cee1e1e, 0x11432252, 0x86614343, 0x3bc776fc, 0x93b1c7c7, 0xd7fcb32b, 0xe54ffcfc, 0x10042014, 0x08240404, 0x5951b208, 0xa2e35151, 0x5e99bcc7, 0x2f259999, 0xa96d4fc4, 0xda226d6d, 0x340d6839, 0x1a650d0d, 0xcffa8335, 0xe979fafa, 0x5bdfb684, 0xa369dfdf, 0xe57ed79b, 0xfca97e7e, 0x90243db4, 0x48192424, 0xec3bc5d7, 0x76fe3b3b, 0x96ab313d, 0x4b9aabab, 0x1fce3ed1, 0x81f0cece, 0x44118855, 0x22991111, 0x068f0c89, 0x03838f8f, 0x254e4a6b, 0x9c044e4e, 0xe6b7d151, 0x7366b7b7, 0x8beb0b60, 0xcbe0ebeb, 0xf03cfdcc, 0x78c13c3c, 0x3e817cbf, 0x1ffd8181, 0x6a94d4fe, 0x35409494, 0xfbf7eb0c, 0xf31cf7f7, 0xdeb9a167, 0x6f18b9b9, 0x4c13985f, 0x268b1313, 0xb02c7d9c, 0x58512c2c, 0x6bd3d6b8, 0xbb05d3d3, 0xbbe76b5c, 0xd38ce7e7, 0xa56e57cb, 0xdc396e6e, 0x37c46ef3, 0x95aac4c4, 0x0c03180f, 0x061b0303, 0x45568a13, 0xacdc5656, 0x0d441a49, 0x885e4444, 0xe17fdf9e, 0xfea07f7f, 0x9ea92137, 0x4f88a9a9, 0xa82a4d82, 0x54672a2a, 0xd6bbb16d, 0x6b0abbbb, 0x23c146e2, 0x9f87c1c1, 0x5153a202, 0xa6f15353, 0x57dcae8b, 0xa572dcdc, 0x2c0b5827, 0x16530b0b, 0x4e9d9cd3, 0x27019d9d, 0xad6c47c1, 0xd82b6c6c, 0xc43195f5, 0x62a43131, 0xcd7487b9, 0xe8f37474, 0xfff6e309, 0xf115f6f6, 0x05460a43, 0x8c4c4646, 0x8aac0926, 0x45a5acac, 0x1e893c97, 0x0fb58989, 0x5014a044, 0x28b41414, 0xa3e15b42, 0xdfbae1e1, 0x5816b04e, 0x2ca61616, 0xe83acdd2, 0x74f73a3a, 0xb9696fd0, 0xd2066969, 0x2409482d, 0x12410909, 0xdd70a7ad, 0xe0d77070, 0xe2b6d954, 0x716fb6b6, 0x67d0ceb7, 0xbd1ed0d0, 0x93ed3b7e, 0xc7d6eded, 0x17cc2edb, 0x85e2cccc, 0x15422a57, 0x84684242, 0x5a98b4c2, 0x2d2c9898, 0xaaa4490e, 0x55eda4a4, 0xa0285d88, 0x50752828, 0x6d5cda31, 0xb8865c5c, 0xc7f8933f, 0xed6bf8f8, 0x228644a4, 0x11c28686]);
  var C7 = new Uint32Array([0x186018c0, 0x7830d818, 0x238c2305, 0xaf462623, 0xc63fc67e, 0xf991b8c6, 0xe887e813, 0x6fcdfbe8, 0x8726874c, 0xa113cb87, 0xb8dab8a9, 0x626d11b8, 0x01040108, 0x05020901, 0x4f214f42, 0x6e9e0d4f, 0x36d836ad, 0xee6c9b36, 0xa6a2a659, 0x0451ffa6, 0xd26fd2de, 0xbdb90cd2, 0xf5f3f5fb, 0x06f70ef5, 0x79f979ef, 0x80f29679, 0x6fa16f5f, 0xcede306f, 0x917e91fc, 0xef3f6d91, 0x525552aa, 0x07a4f852, 0x609d6027, 0xfdc04760, 0xbccabc89, 0x766535bc, 0x9b569bac, 0xcd2b379b, 0x8e028e04, 0x8c018a8e, 0xa3b6a371, 0x155bd2a3, 0x0c300c60, 0x3c186c0c, 0x7bf17bff, 0x8af6847b, 0x35d435b5, 0xe16a8035, 0x1d741de8, 0x693af51d, 0xe0a7e053, 0x47ddb3e0, 0xd77bd7f6, 0xacb321d7, 0xc22fc25e, 0xed999cc2, 0x2eb82e6d, 0x965c432e, 0x4b314b62, 0x7a96294b, 0xfedffea3, 0x21e15dfe, 0x57415782, 0x16aed557, 0x155415a8, 0x412abd15, 0x77c1779f, 0xb6eee877, 0x37dc37a5, 0xeb6e9237, 0xe5b3e57b, 0x56d79ee5, 0x9f469f8c, 0xd923139f, 0xf0e7f0d3, 0x17fd23f0, 0x4a354a6a, 0x7f94204a, 0xda4fda9e, 0x95a944da, 0x587d58fa, 0x25b0a258, 0xc903c906, 0xca8fcfc9, 0x29a42955, 0x8d527c29, 0x0a280a50, 0x22145a0a, 0xb1feb1e1, 0x4f7f50b1, 0xa0baa069, 0x1a5dc9a0, 0x6bb16b7f, 0xdad6146b, 0x852e855c, 0xab17d985, 0xbdcebd81, 0x73673cbd, 0x5d695dd2, 0x34ba8f5d, 0x10401080, 0x50209010, 0xf4f7f4f3, 0x03f507f4, 0xcb0bcb16, 0xc08bddcb, 0x3ef83eed, 0xc67cd33e, 0x05140528, 0x110a2d05, 0x6781671f, 0xe6ce7867, 0xe4b7e473, 0x53d597e4, 0x279c2725, 0xbb4e0227, 0x41194132, 0x58827341, 0x8b168b2c, 0x9d0ba78b, 0xa7a6a751, 0x0153f6a7, 0x7de97dcf, 0x94fab27d, 0x956e95dc, 0xfb374995, 0xd847d88e, 0x9fad56d8, 0xfbcbfb8b, 0x30eb70fb, 0xee9fee23, 0x71c1cdee, 0x7ced7cc7, 0x91f8bb7c, 0x66856617, 0xe3cc7166, 0xdd53dda6, 0x8ea77bdd, 0x175c17b8, 0x4b2eaf17, 0x47014702, 0x468e4547, 0x9e429e84, 0xdc211a9e, 0xca0fca1e, 0xc589d4ca, 0x2db42d75, 0x995a582d, 0xbfc6bf91, 0x79632ebf, 0x071c0738, 0x1b0e3f07, 0xad8ead01, 0x2347acad, 0x5a755aea, 0x2fb4b05a, 0x8336836c, 0xb51bef83, 0x33cc3385, 0xff66b633, 0x6391633f, 0xf2c65c63, 0x02080210, 0x0a041202, 0xaa92aa39, 0x384993aa, 0x71d971af, 0xa8e2de71, 0xc807c80e, 0xcf8dc6c8, 0x196419c8, 0x7d32d119, 0x49394972, 0x70923b49, 0xd943d986, 0x9aaf5fd9, 0xf2eff2c3, 0x1df931f2, 0xe3abe34b, 0x48dba8e3, 0x5b715be2, 0x2ab6b95b, 0x881a8834, 0x920dbc88, 0x9a529aa4, 0xc8293e9a, 0x2698262d, 0xbe4c0b26, 0x32c8328d, 0xfa64bf32, 0xb0fab0e9, 0x4a7d59b0, 0xe983e91b, 0x6acff2e9, 0x0f3c0f78, 0x331e770f, 0xd573d5e6, 0xa6b733d5, 0x803a8074, 0xba1df480, 0xbec2be99, 0x7c6127be, 0xcd13cd26, 0xde87ebcd, 0x34d034bd, 0xe4688934, 0x483d487a, 0x75903248, 0xffdbffab, 0x24e354ff, 0x7af57af7, 0x8ff48d7a, 0x907a90f4, 0xea3d6490, 0x5f615fc2, 0x3ebe9d5f, 0x2080201d, 0xa0403d20, 0x68bd6867, 0xd5d00f68, 0x1a681ad0, 0x7234ca1a, 0xae82ae19, 0x2c41b7ae, 0xb4eab4c9, 0x5e757db4, 0x544d549a, 0x19a8ce54, 0x937693ec, 0xe53b7f93, 0x2288220d, 0xaa442f22, 0x648d6407, 0xe9c86364, 0xf1e3f1db, 0x12ff2af1, 0x73d173bf, 0xa2e6cc73, 0x12481290, 0x5a248212, 0x401d403a, 0x5d807a40, 0x08200840, 0x28104808, 0xc32bc356, 0xe89b95c3, 0xec97ec33, 0x7bc5dfec, 0xdb4bdb96, 0x90ab4ddb, 0xa1bea161, 0x1f5fc0a1, 0x8d0e8d1c, 0x8307918d, 0x3df43df5, 0xc97ac83d, 0x976697cc, 0xf1335b97, 0x00000000, 0x00000000, 0xcf1bcf36, 0xd483f9cf, 0x2bac2b45, 0x87566e2b, 0x76c57697, 0xb3ece176, 0x82328264, 0xb019e682, 0xd67fd6fe, 0xa9b128d6, 0x1b6c1bd8, 0x7736c31b, 0xb5eeb5c1, 0x5b7774b5, 0xaf86af11, 0x2943beaf, 0x6ab56a77, 0xdfd41d6a, 0x505d50ba, 0x0da0ea50, 0x45094512, 0x4c8a5745, 0xf3ebf3cb, 0x18fb38f3, 0x30c0309d, 0xf060ad30, 0xef9bef2b, 0x74c3c4ef, 0x3ffc3fe5, 0xc37eda3f, 0x55495592, 0x1caac755, 0xa2b2a279, 0x1059dba2, 0xea8fea03, 0x65c9e9ea, 0x6589650f, 0xecca6a65, 0xbad2bab9, 0x686903ba, 0x2fbc2f65, 0x935e4a2f, 0xc027c04e, 0xe79d8ec0, 0xde5fdebe, 0x81a160de, 0x1c701ce0, 0x6c38fc1c, 0xfdd3fdbb, 0x2ee746fd, 0x4d294d52, 0x649a1f4d, 0x927292e4, 0xe0397692, 0x75c9758f, 0xbceafa75, 0x06180630, 0x1e0c3606, 0x8a128a24, 0x9809ae8a, 0xb2f2b2f9, 0x40794bb2, 0xe6bfe663, 0x59d185e6, 0x0e380e70, 0x361c7e0e, 0x1f7c1ff8, 0x633ee71f, 0x62956237, 0xf7c45562, 0xd477d4ee, 0xa3b53ad4, 0xa89aa829, 0x324d81a8, 0x966296c4, 0xf4315296, 0xf9c3f99b, 0x3aef62f9, 0xc533c566, 0xf697a3c5, 0x25942535, 0xb14a1025, 0x597959f2, 0x20b2ab59, 0x842a8454, 0xae15d084, 0x72d572b7, 0xa7e4c572, 0x39e439d5, 0xdd72ec39, 0x4c2d4c5a, 0x6198164c, 0x5e655eca, 0x3bbc945e, 0x78fd78e7, 0x85f09f78, 0x38e038dd, 0xd870e538, 0x8c0a8c14, 0x8605988c, 0xd163d1c6, 0xb2bf17d1, 0xa5aea541, 0x0b57e4a5, 0xe2afe243, 0x4dd9a1e2, 0x6199612f, 0xf8c24e61, 0xb3f6b3f1, 0x457b42b3, 0x21842115, 0xa5423421, 0x9c4a9c94, 0xd625089c, 0x1e781ef0, 0x663cee1e, 0x43114322, 0x52866143, 0xc73bc776, 0xfc93b1c7, 0xfcd7fcb3, 0x2be54ffc, 0x04100420, 0x14082404, 0x515951b2, 0x08a2e351, 0x995e99bc, 0xc72f2599, 0x6da96d4f, 0xc4da226d, 0x0d340d68, 0x391a650d, 0xfacffa83, 0x35e979fa, 0xdf5bdfb6, 0x84a369df, 0x7ee57ed7, 0x9bfca97e, 0x2490243d, 0xb4481924, 0x3bec3bc5, 0xd776fe3b, 0xab96ab31, 0x3d4b9aab, 0xce1fce3e, 0xd181f0ce, 0x11441188, 0x55229911, 0x8f068f0c, 0x8903838f, 0x4e254e4a, 0x6b9c044e, 0xb7e6b7d1, 0x517366b7, 0xeb8beb0b, 0x60cbe0eb, 0x3cf03cfd, 0xcc78c13c, 0x813e817c, 0xbf1ffd81, 0x946a94d4, 0xfe354094, 0xf7fbf7eb, 0x0cf31cf7, 0xb9deb9a1, 0x676f18b9, 0x134c1398, 0x5f268b13, 0x2cb02c7d, 0x9c58512c, 0xd36bd3d6, 0xb8bb05d3, 0xe7bbe76b, 0x5cd38ce7, 0x6ea56e57, 0xcbdc396e, 0xc437c46e, 0xf395aac4, 0x030c0318, 0x0f061b03, 0x5645568a, 0x13acdc56, 0x440d441a, 0x49885e44, 0x7fe17fdf, 0x9efea07f, 0xa99ea921, 0x374f88a9, 0x2aa82a4d, 0x8254672a, 0xbbd6bbb1, 0x6d6b0abb, 0xc123c146, 0xe29f87c1, 0x535153a2, 0x02a6f153, 0xdc57dcae, 0x8ba572dc, 0x0b2c0b58, 0x2716530b, 0x9d4e9d9c, 0xd327019d, 0x6cad6c47, 0xc1d82b6c, 0x31c43195, 0xf562a431, 0x74cd7487, 0xb9e8f374, 0xf6fff6e3, 0x09f115f6, 0x4605460a, 0x438c4c46, 0xac8aac09, 0x2645a5ac, 0x891e893c, 0x970fb589, 0x145014a0, 0x4428b414, 0xe1a3e15b, 0x42dfbae1, 0x165816b0, 0x4e2ca616, 0x3ae83acd, 0xd274f73a, 0x69b9696f, 0xd0d20669, 0x09240948, 0x2d124109, 0x70dd70a7, 0xade0d770, 0xb6e2b6d9, 0x54716fb6, 0xd067d0ce, 0xb7bd1ed0, 0xed93ed3b, 0x7ec7d6ed, 0xcc17cc2e, 0xdb85e2cc, 0x4215422a, 0x57846842, 0x985a98b4, 0xc22d2c98, 0xa4aaa449, 0x0e55eda4, 0x28a0285d, 0x88507528, 0x5c6d5cda, 0x31b8865c, 0xf8c7f893, 0x3fed6bf8, 0x86228644, 0xa411c286]);
  /**
   * Whirlpool
   */

  var Whirlpool = /*#__PURE__*/function () {
    function Whirlpool() {
      _classCallCheck__default['default'](this, Whirlpool);

      this.state = new Uint32Array(16);
      this.msg = new Uint32Array(16);
      this.block = Buffer.alloc(64);
      this.size = FINALIZED$c;
    }

    _createClass__default['default'](Whirlpool, [{
      key: "init",
      value: function init() {
        for (var i = 0; i < 16; i++) {
          this.state[i] = 0;
        }

        this.size = 0;
        return this;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert_1$1(Buffer.isBuffer(data));

        this._update(data, data.length);

        return this;
      }
    }, {
      key: "final",
      value: function final() {
        return this._final(Buffer.alloc(64));
      }
    }, {
      key: "_update",
      value: function _update(data, len) {
        assert_1$1(this.size !== FINALIZED$c, 'Context is not initialized.');
        var pos = this.size & 63;
        var off = 0;
        this.size += len;

        if (pos > 0) {
          var want = 64 - pos;
          if (want > len) want = len;
          data.copy(this.block, pos, off, off + want);
          pos += want;
          len -= want;
          off += want;
          if (pos < 64) return;

          this._transform(this.block, 0);
        }

        while (len >= 64) {
          this._transform(data, off);

          off += 64;
          len -= 64;
        }

        if (len > 0) data.copy(this.block, 0, off, off + len);
      }
    }, {
      key: "_final",
      value: function _final(out) {
        assert_1$1(this.size !== FINALIZED$c, 'Context is not initialized.');
        var pos = this.size & 63;
        var len = this.size * 8;
        writeU32$m(DESC$7, len * (1 / 0x100000000) >>> 0, 24);
        writeU32$m(DESC$7, len >>> 0, 28);

        this._update(PADDING$9, 1 + (95 - pos & 63));

        this._update(DESC$7, 32);

        for (var i = 0; i < 16; i++) {
          writeU32$m(out, this.state[i], i * 4);
          this.state[i] = 0;
        }

        for (var _i = 0; _i < 16; _i++) {
          this.msg[_i] = 0;
        }

        for (var _i2 = 0; _i2 < 64; _i2++) {
          this.block[_i2] = 0;
        }

        this.size = FINALIZED$c;
        return out;
      }
    }, {
      key: "_transform",
      value: function _transform(chunk, pos) {
        var block = this.msg;

        for (var i = 0; i < 16; i++) {
          block[i] = readU32$p(chunk, pos + i * 4);
        }

        var K = new Uint32Array(16);
        var L = new Uint32Array(16);
        var state = new Uint32Array(16);

        for (var _i3 = 0; _i3 < 16; _i3++) {
          K[_i3] = this.state[_i3];
          state[_i3] = block[_i3] ^ K[_i3];
        }

        for (var r = 1; r < 10 + 1; r++) {
          for (var _i4 = 0; _i4 < 8; _i4++) {
            L[_i4 * 2 + 0] = 0 ^ C0[(K[(0 + _i4) % 8 * 2 + 0] >>> 24 & 0xff) * 2 + 0] ^ C1[(K[(7 + _i4) % 8 * 2 + 0] >>> 16 & 0xff) * 2 + 0] ^ C2[(K[(6 + _i4) % 8 * 2 + 0] >>> 8 & 0xff) * 2 + 0] ^ C3[(K[(5 + _i4) % 8 * 2 + 0] >>> 0 & 0xff) * 2 + 0] ^ C4[(K[(4 + _i4) % 8 * 2 + 1] >>> 24 & 0xff) * 2 + 0] ^ C5[(K[(3 + _i4) % 8 * 2 + 1] >>> 16 & 0xff) * 2 + 0] ^ C6[(K[(2 + _i4) % 8 * 2 + 1] >>> 8 & 0xff) * 2 + 0] ^ C7[(K[(1 + _i4) % 8 * 2 + 1] >>> 0 & 0xff) * 2 + 0] ^ (_i4 === 0 ? RC[r * 2 + 0] : 0);
            L[_i4 * 2 + 1] = 0 ^ C0[(K[(0 + _i4) % 8 * 2 + 0] >>> 24 & 0xff) * 2 + 1] ^ C1[(K[(7 + _i4) % 8 * 2 + 0] >>> 16 & 0xff) * 2 + 1] ^ C2[(K[(6 + _i4) % 8 * 2 + 0] >>> 8 & 0xff) * 2 + 1] ^ C3[(K[(5 + _i4) % 8 * 2 + 0] >>> 0 & 0xff) * 2 + 1] ^ C4[(K[(4 + _i4) % 8 * 2 + 1] >>> 24 & 0xff) * 2 + 1] ^ C5[(K[(3 + _i4) % 8 * 2 + 1] >>> 16 & 0xff) * 2 + 1] ^ C6[(K[(2 + _i4) % 8 * 2 + 1] >>> 8 & 0xff) * 2 + 1] ^ C7[(K[(1 + _i4) % 8 * 2 + 1] >>> 0 & 0xff) * 2 + 1] ^ (_i4 === 0 ? RC[r * 2 + 1] : 0);
          }

          for (var _i5 = 0; _i5 < 16; _i5++) {
            K[_i5] = L[_i5];
          }

          for (var _i6 = 0; _i6 < 8; _i6++) {
            L[_i6 * 2 + 0] = 0 ^ C0[(state[(0 + _i6) % 8 * 2 + 0] >>> 24 & 0xff) * 2 + 0] ^ C1[(state[(7 + _i6) % 8 * 2 + 0] >>> 16 & 0xff) * 2 + 0] ^ C2[(state[(6 + _i6) % 8 * 2 + 0] >>> 8 & 0xff) * 2 + 0] ^ C3[(state[(5 + _i6) % 8 * 2 + 0] >>> 0 & 0xff) * 2 + 0] ^ C4[(state[(4 + _i6) % 8 * 2 + 1] >>> 24 & 0xff) * 2 + 0] ^ C5[(state[(3 + _i6) % 8 * 2 + 1] >>> 16 & 0xff) * 2 + 0] ^ C6[(state[(2 + _i6) % 8 * 2 + 1] >>> 8 & 0xff) * 2 + 0] ^ C7[(state[(1 + _i6) % 8 * 2 + 1] >>> 0 & 0xff) * 2 + 0] ^ K[_i6 * 2 + 0];
            L[_i6 * 2 + 1] = 0 ^ C0[(state[(0 + _i6) % 8 * 2 + 0] >>> 24 & 0xff) * 2 + 1] ^ C1[(state[(7 + _i6) % 8 * 2 + 0] >>> 16 & 0xff) * 2 + 1] ^ C2[(state[(6 + _i6) % 8 * 2 + 0] >>> 8 & 0xff) * 2 + 1] ^ C3[(state[(5 + _i6) % 8 * 2 + 0] >>> 0 & 0xff) * 2 + 1] ^ C4[(state[(4 + _i6) % 8 * 2 + 1] >>> 24 & 0xff) * 2 + 1] ^ C5[(state[(3 + _i6) % 8 * 2 + 1] >>> 16 & 0xff) * 2 + 1] ^ C6[(state[(2 + _i6) % 8 * 2 + 1] >>> 8 & 0xff) * 2 + 1] ^ C7[(state[(1 + _i6) % 8 * 2 + 1] >>> 0 & 0xff) * 2 + 1] ^ K[_i6 * 2 + 1];
          }

          for (var _i7 = 0; _i7 < 16; _i7++) {
            state[_i7] = L[_i7];
          }
        }

        for (var _i8 = 0; _i8 < 16; _i8++) {
          this.state[_i8] ^= state[_i8] ^ block[_i8];
        }
      }
    }], [{
      key: "hash",
      value: function hash() {
        return new Whirlpool();
      }
    }, {
      key: "hmac",
      value: function hmac$1() {
        return new hmac(Whirlpool, 64);
      }
    }, {
      key: "digest",
      value: function digest(data) {
        return Whirlpool.ctx.init().update(data).final();
      }
    }, {
      key: "root",
      value: function root(left, right) {
        assert_1$1(Buffer.isBuffer(left) && left.length === 64);
        assert_1$1(Buffer.isBuffer(right) && right.length === 64);
        return Whirlpool.ctx.init().update(left).update(right).final();
      }
    }, {
      key: "multi",
      value: function multi(x, y, z) {
        var ctx = Whirlpool.ctx;
        ctx.init();
        ctx.update(x);
        ctx.update(y);
        if (z) ctx.update(z);
        return ctx.final();
      }
    }, {
      key: "mac",
      value: function mac(data, key) {
        return Whirlpool.hmac().init(key).update(data).final();
      }
    }]);

    return Whirlpool;
  }();
  /*
   * Static
   */


  Whirlpool.native = 0;
  Whirlpool.id = 'WHIRLPOOL';
  Whirlpool.size = 64;
  Whirlpool.bits = 512;
  Whirlpool.blockSize = 64;
  Whirlpool.zero = Buffer.alloc(64, 0x00);
  Whirlpool.ctx = new Whirlpool();
  /*
   * Helpers
   */

  function readU32$p(data, off) {
    return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];
  }

  function writeU32$m(data, num, off) {
    data[off++] = num >>> 24;
    data[off++] = num >>> 16;
    data[off++] = num >>> 8;
    data[off++] = num;
    return off;
  }
  /*
   * Expose
   */


  var whirlpool = Whirlpool;

  var whirlpoolBrowser = whirlpool;

  /*
   * Expose
   */


  var x448 = new ecdh('X448', 'ED448');

  var x448Browser = x448;

  var bcrypto = createCommonjsModule(function (module, exports) {

    exports.AEAD = aeadBrowser;
    exports.aes = aesBrowser;
    exports.ARC4 = arc4Browser;
    exports.bcrypt = bcryptBrowser;
    exports.BLAKE2b = blake2bBrowser;
    exports.BLAKE2b160 = blake2b160;
    exports.BLAKE2b256 = blake2b256;
    exports.BLAKE2b384 = blake2b384;
    exports.BLAKE2b512 = blake2b512;
    exports.BLAKE2s = blake2sBrowser;
    exports.BLAKE2s128 = blake2s128;
    exports.BLAKE2s160 = blake2s160;
    exports.BLAKE2s224 = blake2s224;
    exports.BLAKE2s256 = blake2s256;
    exports.BN = bnBrowser;
    exports.box = box_1;
    exports.ChaCha20 = chacha20Browser;
    exports.cipher = cipherBrowser;
    exports.cleanse = cleanseBrowser;
    exports.CSHAKE = cshake;
    exports.CSHAKE128 = cshake128;
    exports.CSHAKE256 = cshake256;
    exports.CtrDRBG = ctrDrbgBrowser;
    exports.dsa = dsaBrowser;
    exports.dsaies = dsaies;
    exports.eb2k = eb2kBrowser;
    exports.ecies = ecies;
    exports.ed25519 = ed25519Browser;
    exports.ed448 = ed448Browser;
    exports.encoding = encoding$1;
    exports.GOST94 = gost94Browser;
    exports.Hash160 = hash160Browser;
    exports.Hash256 = hash256Browser;
    exports.HashDRBG = hashDrbgBrowser;
    exports.hkdf = hkdfBrowser;
    exports.HmacDRBG = hmacDrbgBrowser;
    exports.Keccak = keccakBrowser;
    exports.Keccak224 = keccak224;
    exports.Keccak256 = keccak256;
    exports.Keccak384 = keccak384;
    exports.Keccak512 = keccak512;
    exports.KMAC = kmac;
    exports.KMAC128 = kmac128;
    exports.KMAC256 = kmac256;
    exports.MD2 = md2Browser;
    exports.MD4 = md4Browser;
    exports.MD5 = md5Browser;
    exports.MD5SHA1 = md5sha1Browser;
    exports.merkle = merkle;
    exports.mrkl = mrkl;
    exports.murmur3 = murmur3Browser;
    exports.p192 = p192Browser;
    exports.p224 = p224Browser;
    exports.p256 = p256Browser;
    exports.p384 = p384Browser;
    exports.p521 = p521Browser;
    exports.pbkdf2 = pbkdf2Browser;
    exports.pgp = pgp;
    exports.Poly1305 = poly1305Browser;
    exports.random = randomBrowser;
    exports.RIPEMD160 = ripemd160Browser;
    exports.rsa = rsaBrowser;
    exports.rsaies = rsaies;
    exports.safe = safe;
    exports.Salsa20 = salsa20Browser;
    exports.schnorr = schnorrBrowser;
    exports.scrypt = scryptBrowser;
    exports.secp256k1 = secp256k1Browser;
    exports.secretbox = secretboxBrowser;
    exports.ssh = ssh;
    exports.SHA1 = sha1Browser;
    exports.SHA224 = sha224Browser;
    exports.SHA256 = sha256Browser;
    exports.SHA384 = sha384Browser;
    exports.SHA512 = sha512Browser;
    exports.SHA3 = sha3Browser;
    exports.SHA3_224 = sha3224;
    exports.SHA3_256 = sha3256;
    exports.SHA3_384 = sha3384;
    exports.SHA3_512 = sha3512;
    exports.SHAKE = shake;
    exports.SHAKE128 = shake128;
    exports.SHAKE256 = shake256;
    exports.siphash = siphashBrowser;
    exports.Whirlpool = whirlpoolBrowser;
    exports.x25519 = x25519Browser;
    exports.x448 = x448Browser;
    exports.version = '5.3.0';
    exports.native = exports.SHA256.native;
  });

  function _createForOfIteratorHelper$h(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$h(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$h(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$h(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(o, minLen); }

  function _arrayLikeToArray$h(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var HashAlgorithms = /*#__PURE__*/function () {
    function HashAlgorithms() {
      _classCallCheck__default['default'](this, HashAlgorithms);
    }

    _createClass__default['default'](HashAlgorithms, null, [{
      key: "ripemd160",
      value: function ripemd160(buffer) {
        return bcrypto.RIPEMD160.digest(this.bufferize(buffer));
      }
    }, {
      key: "sha1",
      value: function sha1(buffer) {
        return bcrypto.SHA1.digest(this.bufferize(buffer));
      }
    }, {
      key: "sha256",
      value: function sha256(buffer) {
        if (Array.isArray(buffer)) {
          var sha256 = bcrypto.SHA256.ctx;
          sha256.init();

          var _iterator = _createForOfIteratorHelper$h(buffer),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var element = _step.value;
              sha256 = sha256.update(element);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return sha256.final();
        }

        return bcrypto.SHA256.digest(this.bufferize(buffer));
      }
    }, {
      key: "hash160",
      value: function hash160(buffer) {
        return bcrypto.Hash160.digest(this.bufferize(buffer));
      }
    }, {
      key: "hash256",
      value: function hash256(buffer) {
        return bcrypto.Hash256.digest(this.bufferize(buffer));
      }
    }, {
      key: "bufferize",
      value: function bufferize(buffer) {
        return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
      }
    }]);

    return HashAlgorithms;
  }();

  var encodeCheck = function encodeCheck(buffer) {
    var checksum = HashAlgorithms.hash256(buffer);
    return base58.encode(Buffer.concat([buffer, checksum], buffer.length + 4));
  };

  var decodeCheck = function decodeCheck(address) {
    var buffer = base58.decode(address);
    var payload = buffer.slice(0, -4);
    var checksum = HashAlgorithms.hash256(payload);

    if (checksum.readUInt32LE(0) !== buffer.slice(-4).readUInt32LE(0)) {
      throw new InvalidBase58ChecksumError();
    }

    return payload;
  };

  var Base58 = {
    encodeCheck: src(encodeCheck),
    decodeCheck: src(decodeCheck)
  };

  var numberToHex = function numberToHex(num) {
    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    var indexHex = Number(num).toString(16);
    return "0".repeat(padding - indexHex.length) + indexHex;
  };

  var safeBuffer = createCommonjsModule(function (module, exports) {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

    /* eslint-disable node/no-deprecated-api */
    var Buffer = bufferEs6.Buffer; // alternative to using Object.keys for old browsers

    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }

    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = bufferEs6;
    } else {
      // Copy properties from require('buffer')
      copyProps(bufferEs6, exports);
      exports.Buffer = SafeBuffer;
    }

    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length);
    }

    SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

    copyProps(Buffer, SafeBuffer);

    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
      }

      return Buffer(arg, encodingOrOffset, length);
    };

    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      var buf = Buffer(size);

      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }

      return buf;
    };

    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return Buffer(size);
    };

    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return bufferEs6.SlowBuffer(size);
    };
  });

  var domain; // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).

  function EventHandlers() {}

  EventHandlers.prototype = Object.create(null);

  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  // require('events') === require('events').EventEmitter

  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.usingDomains = false;
  EventEmitter.prototype.domain = undefined;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.

  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function () {
    this.domain = null;

    if (EventEmitter.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain.active ) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  }; // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.


  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  }; // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.


  function emitNone(handler, isFn, self) {
    if (isFn) handler.call(self);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) {
        listeners[i].call(self);
      }
    }
  }

  function emitOne(handler, isFn, self, arg1) {
    if (isFn) handler.call(self, arg1);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) {
        listeners[i].call(self, arg1);
      }
    }
  }

  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn) handler.call(self, arg1, arg2);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) {
        listeners[i].call(self, arg1, arg2);
      }
    }
  }

  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn) handler.call(self, arg1, arg2, arg3);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) {
        listeners[i].call(self, arg1, arg2, arg3);
      }
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn) handler.apply(self, args);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) {
        listeners[i].apply(self, args);
      }
    }
  }

  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events, domain;
    var doError = type === 'error';
    events = this._events;
    if (events) doError = doError && events.error == null;else if (!doError) return false;
    domain = this.domain; // If there is no 'error' event listener then throw.

    if (doError) {
      er = arguments[1];

      if (domain) {
        if (!er) er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }

      return false;
    }

    handler = events[type];
    if (!handler) return false;
    var isFn = typeof handler === 'function';
    len = arguments.length;

    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;

      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;

      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;

      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower

      default:
        args = new Array(len - 1);

        for (i = 1; i < len; i++) {
          args[i - 1] = arguments[i];
        }

        emitMany(handler, isFn, this, args);
    }
    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    events = target._events;

    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object

        events = target._events;
      }

      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      } // Check for listener leak


      if (!existing.warned) {
        m = $getMaxListeners(target);

        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }

  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }

  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };

  function _onceWrap(target, type, listener) {
    var fired = false;

    function g() {
      target.removeListener(type, g);

      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }

    g.listener = listener;
    return g;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  }; // emits a 'removeListener' event iff the listener was removed


  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    events = this._events;
    if (!events) return this;
    list = events[type];
    if (!list) return this;

    if (list === listener || list.listener && list.listener === listener) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();else {
        delete events[type];
        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
      }
    } else if (typeof list !== 'function') {
      position = -1;

      for (i = list.length; i-- > 0;) {
        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }

      if (position < 0) return this;

      if (list.length === 1) {
        list[0] = undefined;

        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events[type];
        }
      } else {
        spliceOne(list, position);
      }

      if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events;
    events = this._events;
    if (!events) return this; // not listening for removeListener, no need to emit

    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
      }

      return this;
    } // emit removeListener for all listeners on all events


    if (arguments.length === 0) {
      var keys = Object.keys(events);

      for (var i = 0, key; i < keys.length; ++i) {
        key = keys[i];
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }

      this.removeAllListeners('removeListener');
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }

    listeners = events[type];

    if (typeof listeners === 'function') {
      this.removeListener(type, listeners);
    } else if (listeners) {
      // LIFO order
      do {
        this.removeListener(type, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }

    return this;
  };

  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;
    if (!events) ret = [];else {
      evlistener = events[type];
      if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
    }
    return ret;
  };

  EventEmitter.listenerCount = function (emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount;

  function listenerCount(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  }; // About 1.5x faster than the two-arg version of Array#splice().


  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
      list[i] = list[k];
    }

    list.pop();
  }

  function arrayClone(arr, i) {
    var copy = new Array(i);

    while (i--) {
      copy[i] = arr[i];
    }

    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);

    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }

    return ret;
  }

  var streamBrowser = EventEmitter.EventEmitter;

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _nodeResolve_empty
  });

  var debugUtil = getCjsExportFromNamespace(_nodeResolve_empty$1);

  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys$1(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$1(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var Buffer$2 = bufferEs6.Buffer;
  var inspect$1 = debugUtil.inspect;
  var custom$5 = inspect$1 && inspect$1.custom || 'inspect';

  function copyBuffer(src, target, offset) {
    Buffer$2.prototype.copy.call(src, target, offset);
  }

  var buffer_list = /*#__PURE__*/function () {
    function BufferList() {
      _classCallCheck(this, BufferList);

      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0) return '';
        var p = this.head;
        var ret = '' + p.data;

        while (p = p.next) {
          ret += s + p.data;
        }

        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer$2.alloc(0);
        var ret = Buffer$2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;

        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }

        return ret;
      } // Consumes a specified amount of bytes or characters from the buffered data.

    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;

        if (n < this.head.data.length) {
          // `slice` is the same for buffers and strings.
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          // First chunk is a perfect match.
          ret = this.shift();
        } else {
          // Result spans more than one buffer.
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }

        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      } // Consumes a specified amount of characters from the buffered data.

    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;

        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;else ret += str.slice(0, n);
          n -= nb;

          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }

            break;
          }

          ++c;
        }

        this.length -= c;
        return ret;
      } // Consumes a specified amount of bytes from the buffered data.

    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer$2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;

        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;

          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }

            break;
          }

          ++c;
        }

        this.length -= c;
        return ret;
      } // Make sure the linked list only shows the minimal necessary information.

    }, {
      key: custom$5,
      value: function value(_, options) {
        return inspect$1(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);

    return BufferList;
  }();

  function destroy(err, cb) {
    var _this = this;

    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;

    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }

      return this;
    } // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks


    if (this._readableState) {
      this._readableState.destroyed = true;
    } // if this is a duplex stream mark the writable part as destroyed as well


    if (this._writableState) {
      this._writableState.destroyed = true;
    }

    this._destroy(err || null, function (err) {
      if (!cb && err) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });

    return this;
  }

  function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
  }

  function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit('close');
  }

  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }

    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }

  function emitErrorNT(self, err) {
    self.emit('error', err);
  }

  function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
  }

  var destroy_1 = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
  };

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var codes = {};

  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }

    function getMessage(arg1, arg2, arg3) {
      if (typeof message === 'string') {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }

    var NodeError = /*#__PURE__*/function (_Base) {
      _inheritsLoose(NodeError, _Base);

      function NodeError(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }

      return NodeError;
    }(Base);

    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function (i) {
        return String(i);
      });

      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


  function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }

    return str.substring(this_len - search.length, this_len) === search;
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


  function includes(str, search, start) {
    if (typeof start !== 'number') {
      start = 0;
    }

    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }

  createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;

    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
      determiner = 'must not be';
      expected = expected.replace(/^not /, '');
    } else {
      determiner = 'must be';
    }

    var msg;

    if (endsWith(name, ' argument')) {
      // For cases like 'first argument'
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    } else {
      var type = includes(name, '.') ? 'property' : 'argument';
      msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    }

    msg += ". Received type ".concat(_typeof__default['default'](actual));
    return msg;
  }, TypeError);
  createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
  createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
    return 'The ' + name + ' method is not implemented';
  });
  createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
  createErrorType('ERR_STREAM_DESTROYED', function (name) {
    return 'Cannot call ' + name + ' after a stream was destroyed';
  });
  createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
  createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
  createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
  createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
  createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
    return 'Unknown encoding: ' + arg;
  }, TypeError);
  createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
  var codes_1 = codes;
  var errorsBrowser = {
    codes: codes_1
  };

  var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;

  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }

  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : 'highWaterMark';
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }

      return Math.floor(hwm);
    } // Default value


    return state.objectMode ? 16 : 16 * 1024;
  }

  var state = {
    getHighWaterMark: getHighWaterMark
  };

  /**
   * Module exports.
   */

  var browser$1 = deprecate;
  /**
   * Mark that a method should not be used.
   * Returns a modified function which warns once by default.
   *
   * If `localStorage.noDeprecation = true` is set, then it is a no-op.
   *
   * If `localStorage.throwDeprecation = true` is set, then deprecated functions
   * will throw an Error when invoked.
   *
   * If `localStorage.traceDeprecation = true` is set, then deprecated functions
   * will invoke `console.trace()` instead of `console.error()`.
   *
   * @param {Function} fn - the function to deprecate
   * @param {String} msg - the string to print to the console when `fn` is invoked
   * @returns {Function} a new "deprecated" version of `fn`
   * @api public
   */

  function deprecate(fn, msg) {
    if (config$1('noDeprecation')) {
      return fn;
    }

    var warned = false;

    function deprecated() {
      if (!warned) {
        if (config$1('throwDeprecation')) {
          throw new Error(msg);
        } else if (config$1('traceDeprecation')) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }

        warned = true;
      }

      return fn.apply(this, arguments);
    }

    return deprecated;
  }
  /**
   * Checks `localStorage` for boolean values for the given `name`.
   *
   * @param {String} name
   * @returns {Boolean}
   * @api private
   */


  function config$1(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
      if (!commonjsGlobal.localStorage) return false;
    } catch (_) {
      return false;
    }

    var val = commonjsGlobal.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === 'true';
  }

  var _stream_writable = Writable;
  // there will be only 2 of these for each stream


  function CorkedRequest(state) {
    var _this = this;

    this.next = null;
    this.entry = null;

    this.finish = function () {
      onCorkedFinish(_this, state);
    };
  }
  /* </replacement> */

  /*<replacement>*/


  var Duplex;
  /*</replacement>*/

  Writable.WritableState = WritableState;
  /*<replacement>*/

  var internalUtil = {
    deprecate: browser$1
  };
  /*</replacement>*/

  /*<replacement>*/

  /*</replacement>*/

  var Buffer$3 = bufferEs6.Buffer;

  var OurUint8Array = commonjsGlobal.Uint8Array || function () {};

  function _uint8ArrayToBuffer(chunk) {
    return Buffer$3.from(chunk);
  }

  function _isUint8Array(obj) {
    return Buffer$3.isBuffer(obj) || obj instanceof OurUint8Array;
  }

  var getHighWaterMark$1 = state.getHighWaterMark;
  var _require$codes = errorsBrowser.codes,
      ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
      ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy$1 = destroy_1.errorOrDestroy;
  inherits_browser(Writable, streamBrowser);

  function nop() {}

  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || _stream_duplex;
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
    // contains buffers or objects.

    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()

    this.highWaterMark = getHighWaterMark$1(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

    this.finalCalled = false; // drain event flag.

    this.needDrain = false; // at the start of calling end()

    this.ending = false; // when end() has been called, and returned

    this.ended = false; // when 'finish' is emitted

    this.finished = false; // has it been destroyed

    this.destroyed = false; // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.

    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.

    this.length = 0; // a flag to see when we're in the middle of a write.

    this.writing = false; // when true all writes will be buffered until .uncork() call

    this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.

    this.sync = true; // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.

    this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

    this.onwrite = function (er) {
      onwrite(stream, er);
    }; // the callback that the user supplies to write(chunk,encoding,cb)


    this.writecb = null; // the amount that is being written when _write is called.

    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted

    this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams

    this.prefinished = false; // True if the error was already emitted and should not be thrown again

    this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

    this.autoDestroy = !!options.autoDestroy; // count buffered requests

    this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two

    this.corkedRequestsFree = new CorkedRequest(this);
  }

  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];

    while (current) {
      out.push(current);
      current = current.next;
    }

    return out;
  };

  (function () {
    try {
      Object.defineProperty(WritableState.prototype, 'buffer', {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
      });
    } catch (_) {}
  })(); // Test _writableState for inheritance to account for Duplex streams,
  // whose prototype chain only points to Readable.


  var realHasInstance;

  if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }

  function Writable(options) {
    Duplex = Duplex || _stream_duplex; // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5

    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex); // legacy.

    this.writable = true;

    if (options) {
      if (typeof options.write === 'function') this._write = options.write;
      if (typeof options.writev === 'function') this._writev = options.writev;
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
      if (typeof options.final === 'function') this._final = options.final;
    }

    streamBrowser.call(this);
  } // Otherwise people can pipe Writable streams, which is just wrong.


  Writable.prototype.pipe = function () {
    errorOrDestroy$1(this, new ERR_STREAM_CANNOT_PIPE());
  };

  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

    errorOrDestroy$1(stream, er);
    process.nextTick(cb, er);
  } // Checks that a user-supplied chunk is valid, especially for the particular
  // mode the stream is in. Currently this means that `null` is never accepted
  // and undefined/non-string values are only allowed in object mode.


  function validChunk(stream, state, chunk, cb) {
    var er;

    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== 'string' && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
    }

    if (er) {
      errorOrDestroy$1(stream, er);
      process.nextTick(cb, er);
      return false;
    }

    return true;
  }

  Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;

    var isBuf = !state.objectMode && _isUint8Array(chunk);

    if (isBuf && !Buffer$3.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }

    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== 'function') cb = nop;
    if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };

  Writable.prototype.cork = function () {
    this._writableState.corked++;
  };

  Writable.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };

  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  Object.defineProperty(Writable.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });

  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = Buffer$3.from(chunk, encoding);
    }

    return chunk;
  }

  Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  }); // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.

  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);

      if (chunk !== newChunk) {
        isBuf = true;
        encoding = 'buffer';
        chunk = newChunk;
      }
    }

    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

    if (!ret) state.needDrain = true;

    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk: chunk,
        encoding: encoding,
        isBuf: isBuf,
        callback: cb,
        next: null
      };

      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }

      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }

    return ret;
  }

  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;

    if (sync) {
      // defer the callback if we are being called synchronously
      // to avoid piling up things on the stack
      process.nextTick(cb, er); // this can emit finish, and it will always happen
      // after error

      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy$1(stream, er);
    } else {
      // the caller expect this to happen before if
      // it is async
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy$1(stream, er); // this can emit finish, but finish must
      // always follow error

      finishMaybe(stream, state);
    }
  }

  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }

  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish(state) || stream.destroyed;

      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }

      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }

  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  } // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.


  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  } // if there's something in the buffer waiting, then process it


  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;

    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;

      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }

      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite

      state.pendingcb++;
      state.lastBufferedRequest = null;

      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }

      state.bufferedRequestCount = 0;
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.

        if (state.writing) {
          break;
        }
      }

      if (entry === null) state.lastBufferedRequest = null;
    }

    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }

  Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
  };

  Writable.prototype._writev = null;

  Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

    if (state.corked) {
      state.corked = 1;
      this.uncork();
    } // ignore unnecessary end() calls.


    if (!state.ending) endWritable(this, state, cb);
    return this;
  };

  Object.defineProperty(Writable.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });

  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }

  function callFinal(stream, state) {
    stream._final(function (err) {
      state.pendingcb--;

      if (err) {
        errorOrDestroy$1(stream, err);
      }

      state.prefinished = true;
      stream.emit('prefinish');
      finishMaybe(stream, state);
    });
  }

  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === 'function' && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
  }

  function finishMaybe(stream, state) {
    var need = needFinish(state);

    if (need) {
      prefinish(stream, state);

      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit('finish');

        if (state.autoDestroy) {
          // In case of duplex streams we need a way to detect
          // if the readable side is ready for autoDestroy as well
          var rState = stream._readableState;

          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }

    return need;
  }

  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);

    if (cb) {
      if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
    }

    state.ended = true;
    stream.writable = false;
  }

  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;

    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    } // reuse the free corkReq.


    state.corkedRequestsFree.next = corkReq;
  }

  Object.defineProperty(Writable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }

      return this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._writableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroy_1.destroy;
  Writable.prototype._undestroy = destroy_1.undestroy;

  Writable.prototype._destroy = function (err, cb) {
    cb(err);
  };

  /*<replacement>*/


  var objectKeys$1 = Object.keys || function (obj) {
    var keys = [];

    for (var key in obj) {
      keys.push(key);
    }

    return keys;
  };
  /*</replacement>*/


  var _stream_duplex = Duplex$1;
  inherits_browser(Duplex$1, _stream_readable);
  {
    // Allow the keys array to be GC'ed.
    var keys = objectKeys$1(_stream_writable.prototype);

    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex$1.prototype[method]) Duplex$1.prototype[method] = _stream_writable.prototype[method];
    }
  }

  function Duplex$1(options) {
    if (!(this instanceof Duplex$1)) return new Duplex$1(options);
    _stream_readable.call(this, options);
    _stream_writable.call(this, options);
    this.allowHalfOpen = true;

    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;

      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once('end', onend);
      }
    }
  }

  Object.defineProperty(Duplex$1.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex$1.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex$1.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  }); // the no-half-open enforcer

  function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return; // no more data can be written.
    // But allow more writes to happen in this tick.

    process.nextTick(onEndNT, this);
  }

  function onEndNT(self) {
    self.end();
  }

  Object.defineProperty(Duplex$1.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }

      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });

  /*<replacement>*/


  var Buffer$4 = safeBuffer.Buffer;
  /*</replacement>*/

  var isEncoding$1 = Buffer$4.isEncoding || function (encoding) {
    encoding = '' + encoding;

    switch (encoding && encoding.toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
      case 'raw':
        return true;

      default:
        return false;
    }
  };

  function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;

    while (true) {
      switch (enc) {
        case 'utf8':
        case 'utf-8':
          return 'utf8';

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return 'utf16le';

        case 'latin1':
        case 'binary':
          return 'latin1';

        case 'base64':
        case 'ascii':
        case 'hex':
          return enc;

        default:
          if (retried) return; // undefined

          enc = ('' + enc).toLowerCase();
          retried = true;
      }
    }
  }
  // modules monkey-patch it to support additional encodings

  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);

    if (typeof nenc !== 'string' && (Buffer$4.isEncoding === isEncoding$1 || !isEncoding$1(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
  } // StringDecoder provides an interface for efficiently splitting a series of
  // buffers into a series of JS strings without breaking apart multi-byte
  // characters.


  var StringDecoder_1 = StringDecoder;

  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;

    switch (this.encoding) {
      case 'utf16le':
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;

      case 'utf8':
        this.fillLast = utf8FillLast;
        nb = 4;
        break;

      case 'base64':
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;

      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }

    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer$4.allocUnsafe(nb);
  }

  StringDecoder.prototype.write = function (buf) {
    if (buf.length === 0) return '';
    var r;
    var i;

    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined) return '';
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }

    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
  };

  StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

  StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

  StringDecoder.prototype.fillLast = function (buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }

    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
  // continuation byte. If an invalid byte is detected, -2 is returned.


  function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
  } // Checks at most 3 bytes at the end of a Buffer in order to detect an
  // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
  // needed to complete the UTF-8 character (if applicable) are returned.


  function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);

    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 1;
      return nb;
    }

    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);

    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 2;
      return nb;
    }

    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);

    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
      }

      return nb;
    }

    return 0;
  } // Validates as many continuation bytes for a multi-byte UTF-8 character as
  // needed or are available. If we see a non-continuation byte where we expect
  // one, we "replace" the validated continuation bytes we've seen so far with
  // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
  // behavior. The continuation byte check is included three times in the case
  // where all of the continuation bytes for a character exist in the same buffer.
  // It is also done this way as a slight performance increase instead of using a
  // loop.


  function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
      self.lastNeed = 0;
      return "\uFFFD";
    }

    if (self.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 0xC0) !== 0x80) {
        self.lastNeed = 1;
        return "\uFFFD";
      }

      if (self.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 0xC0) !== 0x80) {
          self.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  } // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;

    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }

    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  } // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
  // partial character, the character's bytes are buffered until the required
  // number of bytes are available.


  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
  } // For UTF-8, a replacement character is added when ending on a partial
  // character.


  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + "\uFFFD";
    return r;
  } // UTF-16LE typically needs two bytes per character, but even if we have an even
  // number of bytes available, we need to check if we end on a leading/high
  // surrogate. In that case, we need to wait for the next two bytes in order to
  // decode the last character properly.


  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString('utf16le', i);

      if (r) {
        var c = r.charCodeAt(r.length - 1);

        if (c >= 0xD800 && c <= 0xDBFF) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }

      return r;
    }

    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
  } // For UTF-16LE we do not explicitly append special replacement characters if we
  // end on a partial character, we simply let v8 handle that.


  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';

    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString('utf16le', 0, end);
    }

    return r;
  }

  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;

    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }

    return buf.toString('base64', i, buf.length - n);
  }

  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
  } // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }

  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
  }

  var string_decoder = {
    StringDecoder: StringDecoder_1
  };

  var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;

  function once$1(callback) {
    var called = false;
    return function () {
      if (called) return;
      called = true;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      callback.apply(this, args);
    };
  }

  function noop$1() {}

  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
  }

  function eos(stream, opts, callback) {
    if (typeof opts === 'function') return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once$1(callback || noop$1);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;

    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable) onfinish();
    };

    var writableEnded = stream._writableState && stream._writableState.finished;

    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };

    var readableEnded = stream._readableState && stream._readableState.endEmitted;

    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };

    var onerror = function onerror(err) {
      callback.call(stream, err);
    };

    var onclose = function onclose() {
      var err;

      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }

      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };

    var onrequest = function onrequest() {
      stream.req.on('finish', onfinish);
    };

    if (isRequest(stream)) {
      stream.on('complete', onfinish);
      stream.on('abort', onclose);
      if (stream.req) onrequest();else stream.on('request', onrequest);
    } else if (writable && !stream._writableState) {
      // legacy streams
      stream.on('end', onlegacyfinish);
      stream.on('close', onlegacyfinish);
    }

    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false) stream.on('error', onerror);
    stream.on('close', onclose);
    return function () {
      stream.removeListener('complete', onfinish);
      stream.removeListener('abort', onclose);
      stream.removeListener('request', onrequest);
      if (stream.req) stream.req.removeListener('finish', onfinish);
      stream.removeListener('end', onlegacyfinish);
      stream.removeListener('close', onlegacyfinish);
      stream.removeListener('finish', onfinish);
      stream.removeListener('end', onend);
      stream.removeListener('error', onerror);
      stream.removeListener('close', onclose);
    };
  }

  var endOfStream = eos;

  var _Object$setPrototypeO;

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var kLastResolve = Symbol('lastResolve');
  var kLastReject = Symbol('lastReject');
  var kError = Symbol('error');
  var kEnded = Symbol('ended');
  var kLastPromise = Symbol('lastPromise');
  var kHandlePromise = Symbol('handlePromise');
  var kStream = Symbol('stream');

  function createIterResult(value, done) {
    return {
      value: value,
      done: done
    };
  }

  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];

    if (resolve !== null) {
      var data = iter[kStream].read(); // we defer if data is null
      // we can be expecting either 'end' or
      // 'error'

      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }

  function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
  }

  function wrapForNext(lastPromise, iter) {
    return function (resolve, reject) {
      lastPromise.then(function () {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }

        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }

  var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },

    next: function next() {
      var _this = this; // if we have detected an error in the meanwhile
      // reject straight away


      var error = this[kError];

      if (error !== null) {
        return Promise.reject(error);
      }

      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }

      if (this[kStream].destroyed) {
        // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function (resolve, reject) {
          process.nextTick(function () {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      } // if we have multiple next() calls
      // we will wait for the previous Promise to finish
      // this logic is optimized to support for await loops,
      // where next() is only called once at a time


      var lastPromise = this[kLastPromise];
      var promise;

      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        // fast path needed to support multiple this.push()
        // without triggering the next() queue
        var data = this[kStream].read();

        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }

        promise = new Promise(this[kHandlePromise]);
      }

      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty$1(_Object$setPrototypeO, Symbol.asyncIterator, function () {
    return this;
  }), _defineProperty$1(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this; // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to


    return new Promise(function (resolve, reject) {
      _this2[kStream].destroy(null, function (err) {
        if (err) {
          reject(err);
          return;
        }

        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);

  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;

    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty$1(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty$1(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty$1(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty$1(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty$1(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty$1(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();

        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    endOfStream(stream, function (err) {
      if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
        var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
        // returned by next() and store the error

        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }

        iterator[kError] = err;
        return;
      }

      var resolve = iterator[kLastResolve];

      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }

      iterator[kEnded] = true;
    });
    stream.on('readable', onReadable.bind(null, iterator));
    return iterator;
  };

  var async_iterator = createReadableStreamAsyncIterator;

  var fromBrowser = function fromBrowser() {
    throw new Error('Readable.from is not available in the browser');
  };

  var _stream_readable = Readable;
  /*<replacement>*/

  var Duplex$2;
  /*</replacement>*/

  Readable.ReadableState = ReadableState;

  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  /*</replacement>*/

  /*<replacement>*/

  /*</replacement>*/


  var Buffer$5 = bufferEs6.Buffer;

  var OurUint8Array$1 = commonjsGlobal.Uint8Array || function () {};

  function _uint8ArrayToBuffer$1(chunk) {
    return Buffer$5.from(chunk);
  }

  function _isUint8Array$1(obj) {
    return Buffer$5.isBuffer(obj) || obj instanceof OurUint8Array$1;
  }
  /*<replacement>*/


  var debug;

  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog('stream');
  } else {
    debug = function debug() {};
  }
  /*</replacement>*/


  var getHighWaterMark$2 = state.getHighWaterMark;
  var _require$codes$1 = errorsBrowser.codes,
      ERR_INVALID_ARG_TYPE$1 = _require$codes$1.ERR_INVALID_ARG_TYPE,
      ERR_STREAM_PUSH_AFTER_EOF = _require$codes$1.ERR_STREAM_PUSH_AFTER_EOF,
      ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$1.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.

  var StringDecoder$1;
  var createReadableStreamAsyncIterator$1;
  var from$2;
  inherits_browser(Readable, streamBrowser);
  var errorOrDestroy$2 = destroy_1.errorOrDestroy;
  var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

  function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.

    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }

  function ReadableState(options, stream, isDuplex) {
    Duplex$2 = Duplex$2 || _stream_duplex;
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.

    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex$2; // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away

    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"

    this.highWaterMark = getHighWaterMark$2(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()

    this.buffer = new buffer_list();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.

    this.sync = true; // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.

    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true; // Should close be emitted on destroy. Defaults to true.

    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

    this.autoDestroy = !!options.autoDestroy; // has it been destroyed

    this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

    this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;

    if (options.encoding) {
      if (!StringDecoder$1) StringDecoder$1 = string_decoder.StringDecoder;
      this.decoder = new StringDecoder$1(options.encoding);
      this.encoding = options.encoding;
    }
  }

  function Readable(options) {
    Duplex$2 = Duplex$2 || _stream_duplex;
    if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5

    var isDuplex = this instanceof Duplex$2;
    this._readableState = new ReadableState(options, this, isDuplex); // legacy

    this.readable = true;

    if (options) {
      if (typeof options.read === 'function') this._read = options.read;
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
    }

    streamBrowser.call(this);
  }

  Object.defineProperty(Readable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }

      return this._readableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._readableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroy_1.destroy;
  Readable.prototype._undestroy = destroy_1.undestroy;

  Readable.prototype._destroy = function (err, cb) {
    cb(err);
  }; // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.


  Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;

    if (!state.objectMode) {
      if (typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;

        if (encoding !== state.encoding) {
          chunk = Buffer$5.from(chunk, encoding);
          encoding = '';
        }

        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }

    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  }; // Unshift should *always* be something directly out of read()


  Readable.prototype.unshift = function (chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };

  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug('readableAddChunk', chunk);
    var state = stream._readableState;

    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state, chunk);

      if (er) {
        errorOrDestroy$2(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer$5.prototype) {
          chunk = _uint8ArrayToBuffer$1(chunk);
        }

        if (addToFront) {
          if (state.endEmitted) errorOrDestroy$2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy$2(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;

          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    } // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.


    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }

  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit('data', chunk);
    } else {
      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
      if (state.needReadable) emitReadable(stream);
    }

    maybeReadMore(stream, state);
  }

  function chunkInvalid(state, chunk) {
    var er;

    if (!_isUint8Array$1(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE$1('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
    }

    return er;
  }

  Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  }; // backwards compatibility.


  Readable.prototype.setEncoding = function (enc) {
    if (!StringDecoder$1) StringDecoder$1 = string_decoder.StringDecoder;
    var decoder = new StringDecoder$1(enc);
    this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

    this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

    var p = this._readableState.buffer.head;
    var content = '';

    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }

    this._readableState.buffer.clear();

    if (content !== '') this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  }; // Don't raise the hwm > 1GB


  var MAX_HWM = 0x40000000;

  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
      n = MAX_HWM;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }

    return n;
  } // This function is designed to be inlinable, so please take care when making
  // changes to the function body.


  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;

    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    } // If we're asking for more than the current hwm, then raise the hwm.


    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n; // Don't have enough

    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }

    return state.length;
  } // you can override either this method, or the async _read(n) below.


  Readable.prototype.read = function (n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.

    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
      return null;
    }

    n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.


    var doRead = state.needReadable;
    debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug('length less than watermark', doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.


    if (state.ended || state.reading) {
      doRead = false;
      debug('reading or ended', doRead);
    } else if (doRead) {
      debug('do read');
      state.reading = true;
      state.sync = true; // if the length is currently zero, then we *need* a readable event.

      if (state.length === 0) state.needReadable = true; // call internal read method

      this._read(state.highWaterMark);

      state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.

      if (!state.reading) n = howMuchToRead(nOrig, state);
    }

    var ret;
    if (n > 0) ret = fromList(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

      if (nOrig !== n && state.ended) endReadable(this);
    }

    if (ret !== null) this.emit('data', ret);
    return ret;
  };

  function onEofChunk(stream, state) {
    debug('onEofChunk');
    if (state.ended) return;

    if (state.decoder) {
      var chunk = state.decoder.end();

      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }

    state.ended = true;

    if (state.sync) {
      // if we are sync, wait until next tick to emit the data.
      // Otherwise we risk emitting data in the flow()
      // the readable code triggers during a read() call
      emitReadable(stream);
    } else {
      // emit 'readable' now to make sure it gets picked up.
      state.needReadable = false;

      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  } // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.


  function emitReadable(stream) {
    var state = stream._readableState;
    debug('emitReadable', state.needReadable, state.emittedReadable);
    state.needReadable = false;

    if (!state.emittedReadable) {
      debug('emitReadable', state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }

  function emitReadable_(stream) {
    var state = stream._readableState;
    debug('emitReadable_', state.destroyed, state.length, state.ended);

    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit('readable');
      state.emittedReadable = false;
    } // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.


    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  } // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.


  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }

  function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length) // didn't get any data, stop spinning.
        break;
    }

    state.readingMore = false;
  } // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.


  Readable.prototype._read = function (n) {
    errorOrDestroy$2(this, new ERR_METHOD_NOT_IMPLEMENTED$1('_read()'));
  };

  Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;

      case 1:
        state.pipes = [state.pipes, dest];
        break;

      default:
        state.pipes.push(dest);
        break;
    }

    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
    dest.on('unpipe', onunpipe);

    function onunpipe(readable, unpipeInfo) {
      debug('onunpipe');

      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }

    function onend() {
      debug('onend');
      dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.


    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;

    function cleanup() {
      debug('cleanup'); // cleanup event handlers once the pipe is broken

      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', unpipe);
      src.removeListener('data', ondata);
      cleanedUp = true; // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.

      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }

    src.on('data', ondata);

    function ondata(chunk) {
      debug('ondata');
      var ret = dest.write(chunk);
      debug('dest.write', ret);

      if (ret === false) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug('false write response, pause', state.awaitDrain);
          state.awaitDrain++;
        }

        src.pause();
      }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.


    function onerror(er) {
      debug('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (EElistenerCount(dest, 'error') === 0) errorOrDestroy$2(dest, er);
    } // Make sure our error handler is attached before userland ones.


    prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }

    dest.once('close', onclose);

    function onfinish() {
      debug('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }

    dest.once('finish', onfinish);

    function unpipe() {
      debug('unpipe');
      src.unpipe(dest);
    } // tell the dest that it's being piped to


    dest.emit('pipe', src); // start the flow if it hasn't been started already.

    if (!state.flowing) {
      debug('pipe resume');
      src.resume();
    }

    return dest;
  };

  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;

      if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
        state.flowing = true;
        flow(src);
      }
    };
  }

  Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    }; // if we're not piping anywhere, then do nothing.

    if (state.pipesCount === 0) return this; // just one destination.  most common case.

    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes; // got a match.

      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this, unpipeInfo);
      return this;
    } // slow case. multiple pipe destinations.


    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var i = 0; i < len; i++) {
        dests[i].emit('unpipe', this, {
          hasUnpiped: false
        });
      }

      return this;
    } // try to find the right one.


    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit('unpipe', this, unpipeInfo);
    return this;
  }; // set up data events if they are asked for
  // Ensure readable listeners eventually get something


  Readable.prototype.on = function (ev, fn) {
    var res = streamBrowser.prototype.on.call(this, ev, fn);
    var state = this._readableState;

    if (ev === 'data') {
      // update readableListening so that resume() may be a no-op
      // a few lines down. This is needed to support once('readable').
      state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

      if (state.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug('on readable', state.length, state.reading);

        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }

    return res;
  };

  Readable.prototype.addListener = Readable.prototype.on;

  Readable.prototype.removeListener = function (ev, fn) {
    var res = streamBrowser.prototype.removeListener.call(this, ev, fn);

    if (ev === 'readable') {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      process.nextTick(updateReadableListening, this);
    }

    return res;
  };

  Readable.prototype.removeAllListeners = function (ev) {
    var res = streamBrowser.prototype.removeAllListeners.apply(this, arguments);

    if (ev === 'readable' || ev === undefined) {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      process.nextTick(updateReadableListening, this);
    }

    return res;
  };

  function updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount('readable') > 0;

    if (state.resumeScheduled && !state.paused) {
      // flowing needs to be set to true now, otherwise
      // the upcoming resume will not flow.
      state.flowing = true; // crude way to check if we should resume
    } else if (self.listenerCount('data') > 0) {
      self.resume();
    }
  }

  function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
  } // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.


  Readable.prototype.resume = function () {
    var state = this._readableState;

    if (!state.flowing) {
      debug('resume'); // we flow only if there is no one listening
      // for readable, but we still have to call
      // resume()

      state.flowing = !state.readableListening;
      resume(this, state);
    }

    state.paused = false;
    return this;
  };

  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }

  function resume_(stream, state) {
    debug('resume', state.reading);

    if (!state.reading) {
      stream.read(0);
    }

    state.resumeScheduled = false;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }

  Readable.prototype.pause = function () {
    debug('call pause flowing=%j', this._readableState.flowing);

    if (this._readableState.flowing !== false) {
      debug('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }

    this._readableState.paused = true;
    return this;
  };

  function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);

    while (state.flowing && stream.read() !== null) {
    }
  } // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.


  Readable.prototype.wrap = function (stream) {
    var _this = this;

    var state = this._readableState;
    var paused = false;
    stream.on('end', function () {
      debug('wrapped end');

      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }

      _this.push(null);
    });
    stream.on('data', function (chunk) {
      debug('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

      var ret = _this.push(chunk);

      if (!ret) {
        paused = true;
        stream.pause();
      }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.

    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    } // proxy certain important events.


    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    } // when we try to consume some more bytes, simply unpause the
    // underlying stream.


    this._read = function (n) {
      debug('wrapped _read', n);

      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return this;
  };

  if (typeof Symbol === 'function') {
    Readable.prototype[Symbol.asyncIterator] = function () {
      if (createReadableStreamAsyncIterator$1 === undefined) {
        createReadableStreamAsyncIterator$1 = async_iterator;
      }

      return createReadableStreamAsyncIterator$1(this);
    };
  }

  Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, 'readableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, 'readableFlowing', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  }); // exposed for testing purposes only.

  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, 'readableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  }); // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.

  function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }

  function endReadable(stream) {
    var state = stream._readableState;
    debug('endReadable', state.endEmitted);

    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }

  function endReadableNT(state, stream) {
    debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the writable side is ready for autoDestroy as well
        var wState = stream._writableState;

        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }

  if (typeof Symbol === 'function') {
    Readable.from = function (iterable, opts) {
      if (from$2 === undefined) {
        from$2 = fromBrowser;
      }

      return from$2(Readable, iterable, opts);
    };
  }

  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }

    return -1;
  }

  var _stream_transform = Transform;
  var _require$codes$2 = errorsBrowser.codes,
      ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK$1 = _require$codes$2.ERR_MULTIPLE_CALLBACK,
      ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$2.ERR_TRANSFORM_ALREADY_TRANSFORMING,
      ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$2.ERR_TRANSFORM_WITH_LENGTH_0;
  inherits_browser(Transform, _stream_duplex);

  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;

    if (cb === null) {
      return this.emit('error', new ERR_MULTIPLE_CALLBACK$1());
    }

    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;

    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }

  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    _stream_duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }; // start out asking for a readable event once data is transformed.

    this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.

    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;
      if (typeof options.flush === 'function') this._flush = options.flush;
    } // When the writable side finishes, then flush out anything remaining.


    this.on('prefinish', prefinish$1);
  }

  function prefinish$1() {
    var _this = this;

    if (typeof this._flush === 'function' && !this._readableState.destroyed) {
      this._flush(function (er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }

  Transform.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return _stream_duplex.prototype.push.call(this, chunk, encoding);
  }; // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.


  Transform.prototype._transform = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED$2('_transform()'));
  };

  Transform.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;

    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  }; // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.


  Transform.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;

      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  Transform.prototype._destroy = function (err, cb) {
    _stream_duplex.prototype._destroy.call(this, err, function (err2) {
      cb(err2);
    });
  };

  function done(stream, er, data) {
    if (er) return stream.emit('error', er);
    if (data != null) // single equals check for both `null` and `undefined`
      stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided

    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }

  var _stream_passthrough = PassThrough;
  inherits_browser(PassThrough, _stream_transform);

  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    _stream_transform.call(this, options);
  }

  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  var eos$1;

  function once$2(callback) {
    var called = false;
    return function () {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }

  var _require$codes$3 = errorsBrowser.codes,
      ERR_MISSING_ARGS = _require$codes$3.ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED$1 = _require$codes$3.ERR_STREAM_DESTROYED;

  function noop$2(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
  }

  function isRequest$1(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
  }

  function destroyer(stream, reading, writing, callback) {
    callback = once$2(callback);
    var closed = false;
    stream.on('close', function () {
      closed = true;
    });
    if (eos$1 === undefined) eos$1 = endOfStream;
    eos$1(stream, {
      readable: reading,
      writable: writing
    }, function (err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function (err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true; // request.destroy just do .end - .abort is what we want

      if (isRequest$1(stream)) return stream.abort();
      if (typeof stream.destroy === 'function') return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED$1('pipe'));
    };
  }

  function call(fn) {
    fn();
  }

  function pipe(from, to) {
    return from.pipe(to);
  }

  function popCallback(streams) {
    if (!streams.length) return noop$2;
    if (typeof streams[streams.length - 1] !== 'function') return noop$2;
    return streams.pop();
  }

  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }

    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];

    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS('streams');
    }

    var error;
    var destroys = streams.map(function (stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function (err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }

  var pipeline_1 = pipeline;

  var readableBrowser = createCommonjsModule(function (module, exports) {
    exports = module.exports = _stream_readable;
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = _stream_writable;
    exports.Duplex = _stream_duplex;
    exports.Transform = _stream_transform;
    exports.PassThrough = _stream_passthrough;
    exports.finished = endOfStream;
    exports.pipeline = pipeline_1;
  });

  var Buffer$6 = safeBuffer.Buffer;
  var Transform$1 = readableBrowser.Transform;

  function throwIfNotStringOrBuffer(val, prefix) {
    if (!Buffer$6.isBuffer(val) && typeof val !== 'string') {
      throw new TypeError(prefix + ' must be a string or a buffer');
    }
  }

  function HashBase(blockSize) {
    Transform$1.call(this);
    this._block = Buffer$6.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [0, 0, 0, 0];
    this._finalized = false;
  }

  inherits_browser(HashBase, Transform$1);

  HashBase.prototype._transform = function (chunk, encoding, callback) {
    var error = null;

    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }

    callback(error);
  };

  HashBase.prototype._flush = function (callback) {
    var error = null;

    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }

    callback(error);
  };

  HashBase.prototype.update = function (data, encoding) {
    throwIfNotStringOrBuffer(data, 'Data');
    if (this._finalized) throw new Error('Digest already called');
    if (!Buffer$6.isBuffer(data)) data = Buffer$6.from(data, encoding); // consume data

    var block = this._block;
    var offset = 0;

    while (this._blockOffset + data.length - offset >= this._blockSize) {
      for (var i = this._blockOffset; i < this._blockSize;) {
        block[i++] = data[offset++];
      }

      this._update();

      this._blockOffset = 0;
    }

    while (offset < data.length) {
      block[this._blockOffset++] = data[offset++];
    } // update length


    for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
      this._length[j] += carry;
      carry = this._length[j] / 0x0100000000 | 0;
      if (carry > 0) this._length[j] -= 0x0100000000 * carry;
    }

    return this;
  };

  HashBase.prototype._update = function () {
    throw new Error('_update is not implemented');
  };

  HashBase.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error('Digest already called');
    this._finalized = true;

    var digest = this._digest();

    if (encoding !== undefined) digest = digest.toString(encoding); // reset state

    this._block.fill(0);

    this._blockOffset = 0;

    for (var i = 0; i < 4; ++i) {
      this._length[i] = 0;
    }

    return digest;
  };

  HashBase.prototype._digest = function () {
    throw new Error('_digest is not implemented');
  };

  var hashBase = HashBase;

  var Buffer$7 = safeBuffer.Buffer;
  var ARRAY16 = new Array(16);

  function MD5$1() {
    hashBase.call(this, 64); // state

    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
  }

  inherits_browser(MD5$1, hashBase);

  MD5$1.prototype._update = function () {
    var M = ARRAY16;

    for (var i = 0; i < 16; ++i) {
      M[i] = this._block.readInt32LE(i * 4);
    }

    var a = this._a;
    var b = this._b;
    var c = this._c;
    var d = this._d;
    a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
    d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
    c = fnF(c, d, a, b, M[2], 0x242070db, 17);
    b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
    a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
    d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
    c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
    b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
    a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
    d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
    c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
    b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
    a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
    d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
    c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
    b = fnF(b, c, d, a, M[15], 0x49b40821, 22);
    a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
    d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
    c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
    b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
    a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
    d = fnG(d, a, b, c, M[10], 0x02441453, 9);
    c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
    b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
    a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
    d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
    c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
    b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
    a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
    d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
    c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
    b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);
    a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
    d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
    c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
    b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
    a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
    d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
    c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
    b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
    a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
    d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
    c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
    b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
    a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
    d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
    c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
    b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);
    a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
    d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
    c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
    b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
    a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
    d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
    c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
    b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
    a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
    d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
    c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
    b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
    a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
    d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
    c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
    b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);
    this._a = this._a + a | 0;
    this._b = this._b + b | 0;
    this._c = this._c + c | 0;
    this._d = this._d + d | 0;
  };

  MD5$1.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80;

    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);

      this._update();

      this._blockOffset = 0;
    }

    this._block.fill(0, this._blockOffset, 56);

    this._block.writeUInt32LE(this._length[0], 56);

    this._block.writeUInt32LE(this._length[1], 60);

    this._update(); // produce result


    var buffer = Buffer$7.allocUnsafe(16);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    return buffer;
  };

  function rotl$1(x, n) {
    return x << n | x >>> 32 - n;
  }

  function fnF(a, b, c, d, m, k, s) {
    return rotl$1(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
  }

  function fnG(a, b, c, d, m, k, s) {
    return rotl$1(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
  }

  function fnH(a, b, c, d, m, k, s) {
    return rotl$1(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
  }

  function fnI(a, b, c, d, m, k, s) {
    return rotl$1(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
  }

  var md5_js = MD5$1;

  var Buffer$8 = bufferEs6.Buffer;
  var ARRAY16$1 = new Array(16);
  var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
  var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

  function RIPEMD160$1() {
    hashBase.call(this, 64); // state

    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
  }

  inherits_browser(RIPEMD160$1, hashBase);

  RIPEMD160$1.prototype._update = function () {
    var words = ARRAY16$1;

    for (var j = 0; j < 16; ++j) {
      words[j] = this._block.readInt32LE(j * 4);
    }

    var al = this._a | 0;
    var bl = this._b | 0;
    var cl = this._c | 0;
    var dl = this._d | 0;
    var el = this._e | 0;
    var ar = this._a | 0;
    var br = this._b | 0;
    var cr = this._c | 0;
    var dr = this._d | 0;
    var er = this._e | 0; // computation

    for (var i = 0; i < 80; i += 1) {
      var tl;
      var tr;

      if (i < 16) {
        tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
        tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
      } else if (i < 32) {
        tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
        tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
      } else if (i < 48) {
        tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
        tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
      } else if (i < 64) {
        tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
        tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
      } else {
        // if (i<80) {
        tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
        tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
      }

      al = el;
      el = dl;
      dl = rotl$2(cl, 10);
      cl = bl;
      bl = tl;
      ar = er;
      er = dr;
      dr = rotl$2(cr, 10);
      cr = br;
      br = tr;
    } // update state


    var t = this._b + cl + dr | 0;
    this._b = this._c + dl + er | 0;
    this._c = this._d + el + ar | 0;
    this._d = this._e + al + br | 0;
    this._e = this._a + bl + cr | 0;
    this._a = t;
  };

  RIPEMD160$1.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80;

    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);

      this._update();

      this._blockOffset = 0;
    }

    this._block.fill(0, this._blockOffset, 56);

    this._block.writeUInt32LE(this._length[0], 56);

    this._block.writeUInt32LE(this._length[1], 60);

    this._update(); // produce result


    var buffer = Buffer$8.alloc ? Buffer$8.alloc(20) : new Buffer$8(20);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    buffer.writeInt32LE(this._e, 16);
    return buffer;
  };

  function rotl$2(x, n) {
    return x << n | x >>> 32 - n;
  }

  function fn1(a, b, c, d, e, m, k, s) {
    return rotl$2(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
  }

  function fn2(a, b, c, d, e, m, k, s) {
    return rotl$2(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
  }

  function fn3(a, b, c, d, e, m, k, s) {
    return rotl$2(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
  }

  function fn4(a, b, c, d, e, m, k, s) {
    return rotl$2(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
  }

  function fn5(a, b, c, d, e, m, k, s) {
    return rotl$2(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
  }

  var ripemd160$1 = RIPEMD160$1;

  var Buffer$9 = safeBuffer.Buffer; // prototype class for hash functions

  function Hash$1(blockSize, finalSize) {
    this._block = Buffer$9.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
  }

  Hash$1.prototype.update = function (data, enc) {
    if (typeof data === 'string') {
      enc = enc || 'utf8';
      data = Buffer$9.from(data, enc);
    }

    var block = this._block;
    var blockSize = this._blockSize;
    var length = data.length;
    var accum = this._len;

    for (var offset = 0; offset < length;) {
      var assigned = accum % blockSize;
      var remainder = Math.min(length - offset, blockSize - assigned);

      for (var i = 0; i < remainder; i++) {
        block[assigned + i] = data[offset + i];
      }

      accum += remainder;
      offset += remainder;

      if (accum % blockSize === 0) {
        this._update(block);
      }
    }

    this._len += length;
    return this;
  };

  Hash$1.prototype.digest = function (enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 0x80; // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
    // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize

    this._block.fill(0, rem + 1);

    if (rem >= this._finalSize) {
      this._update(this._block);

      this._block.fill(0);
    }

    var bits = this._len * 8; // uint32

    if (bits <= 0xffffffff) {
      this._block.writeUInt32BE(bits, this._blockSize - 4); // uint64

    } else {
      var lowBits = (bits & 0xffffffff) >>> 0;
      var highBits = (bits - lowBits) / 0x100000000;

      this._block.writeUInt32BE(highBits, this._blockSize - 8);

      this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }

    this._update(this._block);

    var hash = this._hash();

    return enc ? hash.toString(enc) : hash;
  };

  Hash$1.prototype._update = function () {
    throw new Error('_update must be implemented by subclass');
  };

  var hash = Hash$1;

  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
   * in FIPS PUB 180-1
   * This source code is derived from sha1.js of the same repository.
   * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
   * operation was added.
   */

  var Buffer$a = safeBuffer.Buffer;
  var K$6 = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
  var W = new Array(80);

  function Sha() {
    this.init();
    this._w = W;
    hash.call(this, 64, 56);
  }

  inherits_browser(Sha, hash);

  Sha.prototype.init = function () {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
  };

  function rotl5(num) {
    return num << 5 | num >>> 27;
  }

  function rotl30(num) {
    return num << 30 | num >>> 2;
  }

  function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }

  Sha.prototype._update = function (M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;

    for (var i = 0; i < 16; ++i) {
      W[i] = M.readInt32BE(i * 4);
    }

    for (; i < 80; ++i) {
      W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
    }

    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K$6[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t;
    }

    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };

  Sha.prototype._hash = function () {
    var H = Buffer$a.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };

  var sha = Sha;

  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
   * in FIPS PUB 180-1
   * Version 2.1a Copyright Paul Johnston 2000 - 2002.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   * Distributed under the BSD License
   * See http://pajhome.org.uk/crypt/md5 for details.
   */

  var Buffer$b = safeBuffer.Buffer;
  var K$7 = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
  var W$1 = new Array(80);

  function Sha1() {
    this.init();
    this._w = W$1;
    hash.call(this, 64, 56);
  }

  inherits_browser(Sha1, hash);

  Sha1.prototype.init = function () {
    this._a = 0x67452301;
    this._b = 0xefcdab89;
    this._c = 0x98badcfe;
    this._d = 0x10325476;
    this._e = 0xc3d2e1f0;
    return this;
  };

  function rotl1(num) {
    return num << 1 | num >>> 31;
  }

  function rotl5$1(num) {
    return num << 5 | num >>> 27;
  }

  function rotl30$1(num) {
    return num << 30 | num >>> 2;
  }

  function ft$1(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }

  Sha1.prototype._update = function (M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;

    for (var i = 0; i < 16; ++i) {
      W[i] = M.readInt32BE(i * 4);
    }

    for (; i < 80; ++i) {
      W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
    }

    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5$1(a) + ft$1(s, b, c, d) + e + W[j] + K$7[s] | 0;
      e = d;
      d = c;
      c = rotl30$1(b);
      b = a;
      a = t;
    }

    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };

  Sha1.prototype._hash = function () {
    var H = Buffer$b.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };

  var sha1$1 = Sha1;

  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */

  var Buffer$c = safeBuffer.Buffer;
  var K$8 = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
  var W$2 = new Array(64);

  function Sha256() {
    this.init();
    this._w = W$2; // new Array(64)

    hash.call(this, 64, 56);
  }

  inherits_browser(Sha256, hash);

  Sha256.prototype.init = function () {
    this._a = 0x6a09e667;
    this._b = 0xbb67ae85;
    this._c = 0x3c6ef372;
    this._d = 0xa54ff53a;
    this._e = 0x510e527f;
    this._f = 0x9b05688c;
    this._g = 0x1f83d9ab;
    this._h = 0x5be0cd19;
    return this;
  };

  function ch(x, y, z) {
    return z ^ x & (y ^ z);
  }

  function maj(x, y, z) {
    return x & y | z & (x | y);
  }

  function sigma0$1(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }

  function sigma1$1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }

  function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }

  function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }

  Sha256.prototype._update = function (M) {
    var W = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f = this._f | 0;
    var g = this._g | 0;
    var h = this._h | 0;

    for (var i = 0; i < 16; ++i) {
      W[i] = M.readInt32BE(i * 4);
    }

    for (; i < 64; ++i) {
      W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
    }

    for (var j = 0; j < 64; ++j) {
      var T1 = h + sigma1$1(e) + ch(e, f, g) + K$8[j] + W[j] | 0;
      var T2 = sigma0$1(a) + maj(a, b, c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + T1 | 0;
      d = c;
      c = b;
      b = a;
      a = T1 + T2 | 0;
    }

    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f + this._f | 0;
    this._g = g + this._g | 0;
    this._h = h + this._h | 0;
  };

  Sha256.prototype._hash = function () {
    var H = Buffer$c.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
  };

  var sha256$1 = Sha256;

  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */

  var Buffer$d = safeBuffer.Buffer;
  var W$3 = new Array(64);

  function Sha224() {
    this.init();
    this._w = W$3; // new Array(64)

    hash.call(this, 64, 56);
  }

  inherits_browser(Sha224, sha256$1);

  Sha224.prototype.init = function () {
    this._a = 0xc1059ed8;
    this._b = 0x367cd507;
    this._c = 0x3070dd17;
    this._d = 0xf70e5939;
    this._e = 0xffc00b31;
    this._f = 0x68581511;
    this._g = 0x64f98fa7;
    this._h = 0xbefa4fa4;
    return this;
  };

  Sha224.prototype._hash = function () {
    var H = Buffer$d.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
  };

  var sha224$1 = Sha224;

  var Buffer$e = safeBuffer.Buffer;
  var K$9 = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
  var W$4 = new Array(160);

  function Sha512() {
    this.init();
    this._w = W$4;
    hash.call(this, 128, 112);
  }

  inherits_browser(Sha512, hash);

  Sha512.prototype.init = function () {
    this._ah = 0x6a09e667;
    this._bh = 0xbb67ae85;
    this._ch = 0x3c6ef372;
    this._dh = 0xa54ff53a;
    this._eh = 0x510e527f;
    this._fh = 0x9b05688c;
    this._gh = 0x1f83d9ab;
    this._hh = 0x5be0cd19;
    this._al = 0xf3bcc908;
    this._bl = 0x84caa73b;
    this._cl = 0xfe94f82b;
    this._dl = 0x5f1d36f1;
    this._el = 0xade682d1;
    this._fl = 0x2b3e6c1f;
    this._gl = 0xfb41bd6b;
    this._hl = 0x137e2179;
    return this;
  };

  function Ch$1(x, y, z) {
    return z ^ x & (y ^ z);
  }

  function maj$1(x, y, z) {
    return x & y | z & (x | y);
  }

  function sigma0$2(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
  }

  function sigma1$2(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
  }

  function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
  }

  function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
  }

  function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
  }

  function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
  }

  function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
  }

  Sha512.prototype._update = function (M) {
    var W = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;

    for (var i = 0; i < 32; i += 2) {
      W[i] = M.readInt32BE(i * 4);
      W[i + 1] = M.readInt32BE(i * 4 + 4);
    }

    for (; i < 160; i += 2) {
      var xh = W[i - 15 * 2];
      var xl = W[i - 15 * 2 + 1];
      var gamma0 = Gamma0(xh, xl);
      var gamma0l = Gamma0l(xl, xh);
      xh = W[i - 2 * 2];
      xl = W[i - 2 * 2 + 1];
      var gamma1 = Gamma1(xh, xl);
      var gamma1l = Gamma1l(xl, xh); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]

      var Wi7h = W[i - 7 * 2];
      var Wi7l = W[i - 7 * 2 + 1];
      var Wi16h = W[i - 16 * 2];
      var Wi16l = W[i - 16 * 2 + 1];
      var Wil = gamma0l + Wi7l | 0;
      var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
      Wil = Wil + gamma1l | 0;
      Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
      Wil = Wil + Wi16l | 0;
      Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
      W[i] = Wih;
      W[i + 1] = Wil;
    }

    for (var j = 0; j < 160; j += 2) {
      Wih = W[j];
      Wil = W[j + 1];
      var majh = maj$1(ah, bh, ch);
      var majl = maj$1(al, bl, cl);
      var sigma0h = sigma0$2(ah, al);
      var sigma0l = sigma0$2(al, ah);
      var sigma1h = sigma1$2(eh, el);
      var sigma1l = sigma1$2(el, eh); // t1 = h + sigma1 + ch + K[j] + W[j]

      var Kih = K$9[j];
      var Kil = K$9[j + 1];
      var chh = Ch$1(eh, fh, gh);
      var chl = Ch$1(el, fl, gl);
      var t1l = hl + sigma1l | 0;
      var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
      t1l = t1l + chl | 0;
      t1h = t1h + chh + getCarry(t1l, chl) | 0;
      t1l = t1l + Kil | 0;
      t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
      t1l = t1l + Wil | 0;
      t1h = t1h + Wih + getCarry(t1l, Wil) | 0; // t2 = sigma0 + maj

      var t2l = sigma0l + majl | 0;
      var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = dl + t1l | 0;
      eh = dh + t1h + getCarry(el, dl) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = t1l + t2l | 0;
      ah = t1h + t2h + getCarry(al, t1l) | 0;
    }

    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
  };

  Sha512.prototype._hash = function () {
    var H = Buffer$e.allocUnsafe(64);

    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }

    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
  };

  var sha512$1 = Sha512;

  var Buffer$f = safeBuffer.Buffer;
  var W$5 = new Array(160);

  function Sha384() {
    this.init();
    this._w = W$5;
    hash.call(this, 128, 112);
  }

  inherits_browser(Sha384, sha512$1);

  Sha384.prototype.init = function () {
    this._ah = 0xcbbb9d5d;
    this._bh = 0x629a292a;
    this._ch = 0x9159015a;
    this._dh = 0x152fecd8;
    this._eh = 0x67332667;
    this._fh = 0x8eb44a87;
    this._gh = 0xdb0c2e0d;
    this._hh = 0x47b5481d;
    this._al = 0xc1059ed8;
    this._bl = 0x367cd507;
    this._cl = 0x3070dd17;
    this._dl = 0xf70e5939;
    this._el = 0xffc00b31;
    this._fl = 0x68581511;
    this._gl = 0x64f98fa7;
    this._hl = 0xbefa4fa4;
    return this;
  };

  Sha384.prototype._hash = function () {
    var H = Buffer$f.allocUnsafe(48);

    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }

    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
  };

  var sha384$1 = Sha384;

  var sha_js = createCommonjsModule(function (module) {
    var exports = module.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports[algorithm];
      if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');
      return new Algorithm();
    };

    exports.sha = sha;
    exports.sha1 = sha1$1;
    exports.sha224 = sha224$1;
    exports.sha256 = sha256$1;
    exports.sha384 = sha384$1;
    exports.sha512 = sha512$1;
  });

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js
  function defaultSetTimout$1() {
    throw new Error('setTimeout has not been defined');
  }

  function defaultClearTimeout$1() {
    throw new Error('clearTimeout has not been defined');
  }

  var cachedSetTimeout$1 = defaultSetTimout$1;
  var cachedClearTimeout$1 = defaultClearTimeout$1;

  if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout$1 = setTimeout;
  }

  if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout$1 = clearTimeout;
  }

  function runTimeout$1(fun) {
    if (cachedSetTimeout$1 === setTimeout) {
      //normal enviroments in sane situations
      return setTimeout(fun, 0);
    } // if setTimeout wasn't available but was latter defined


    if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
      cachedSetTimeout$1 = setTimeout;
      return setTimeout(fun, 0);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedSetTimeout$1(fun, 0);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
        return cachedSetTimeout$1.call(null, fun, 0);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
        return cachedSetTimeout$1.call(this, fun, 0);
      }
    }
  }

  function runClearTimeout$1(marker) {
    if (cachedClearTimeout$1 === clearTimeout) {
      //normal enviroments in sane situations
      return clearTimeout(marker);
    } // if clearTimeout wasn't available but was latter defined


    if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
      cachedClearTimeout$1 = clearTimeout;
      return clearTimeout(marker);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedClearTimeout$1(marker);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
        return cachedClearTimeout$1.call(null, marker);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
        return cachedClearTimeout$1.call(this, marker);
      }
    }
  }

  var queue$1 = [];
  var draining$1 = false;
  var currentQueue$1;
  var queueIndex$1 = -1;

  function cleanUpNextTick$1() {
    if (!draining$1 || !currentQueue$1) {
      return;
    }

    draining$1 = false;

    if (currentQueue$1.length) {
      queue$1 = currentQueue$1.concat(queue$1);
    } else {
      queueIndex$1 = -1;
    }

    if (queue$1.length) {
      drainQueue$1();
    }
  }

  function drainQueue$1() {
    if (draining$1) {
      return;
    }

    var timeout = runTimeout$1(cleanUpNextTick$1);
    draining$1 = true;
    var len = queue$1.length;

    while (len) {
      currentQueue$1 = queue$1;
      queue$1 = [];

      while (++queueIndex$1 < len) {
        if (currentQueue$1) {
          currentQueue$1[queueIndex$1].run();
        }
      }

      queueIndex$1 = -1;
      len = queue$1.length;
    }

    currentQueue$1 = null;
    draining$1 = false;
    runClearTimeout$1(timeout);
  }

  function nextTick$1(fun) {
    var args = new Array(arguments.length - 1);

    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }

    queue$1.push(new Item$1(fun, args));

    if (queue$1.length === 1 && !draining$1) {
      runTimeout$1(drainQueue$1);
    }
  } // v8 likes predictible objects


  function Item$1(fun, array) {
    this.fun = fun;
    this.array = array;
  }

  Item$1.prototype.run = function () {
    this.fun.apply(null, this.array);
  };


  var performance$1 = global$1.performance || {};

  var performanceNow$1 = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function () {
    return new Date().getTime();
  }; // generate timestamp or delta

  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function (v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function (v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function () {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function () {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function (s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function (n) {
    if (this.length === 0) return Buffer$1.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer$1.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      p.data.copy(ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  // Copyright Joyent, Inc. and other Node contributors.

  var isBufferEncoding = Buffer$1.isEncoding || function (encoding) {
    switch (encoding && encoding.toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
      case 'raw':
        return true;

      default:
        return false;
    }
  };

  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
      throw new Error('Unknown encoding: ' + encoding);
    }
  } // StringDecoder provides an interface for efficiently splitting a series of
  // buffers into a series of JS strings without breaking apart multi-byte
  // characters. CESU-8 is handled as part of the UTF-8 encoding.
  //
  // @TODO Handling all encodings inside a single object makes it very difficult
  // to reason about this code, so it should be split up in the future.
  // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
  // points as used by CESU-8.


  function StringDecoder$2(encoding) {
    this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
    assertEncoding(encoding);

    switch (this.encoding) {
      case 'utf8':
        // CESU-8 represents each of Surrogate Pair by 3-bytes
        this.surrogateSize = 3;
        break;

      case 'ucs2':
      case 'utf16le':
        // UTF-16 represents each of Surrogate Pair by 2-bytes
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;

      case 'base64':
        // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;

      default:
        this.write = passThroughWrite;
        return;
    } // Enough space to store all bytes of a single character. UTF-8 needs 4
    // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).


    this.charBuffer = new Buffer$1(6); // Number of bytes received for the current incomplete multi-byte character.

    this.charReceived = 0; // Number of bytes expected for the current incomplete multi-byte character.

    this.charLength = 0;
  }
  // guaranteed to not contain any partial multi-byte characters. Any partial
  // character found at the end of the buffer is buffered up, and will be
  // returned when calling write again with the remaining bytes.
  //
  // Note: Converting a Buffer containing an orphan surrogate to a String
  // currently works, but converting a String to a Buffer (via `new Buffer`, or
  // Buffer#write) will replace incomplete surrogates with the unicode
  // replacement character. See https://codereview.chromium.org/121173009/ .

  StringDecoder$2.prototype.write = function (buffer) {
    var charStr = ''; // if our last write ended with an incomplete multibyte character

    while (this.charLength) {
      // determine how many remaining bytes this buffer has to offer for this char
      var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length; // add the new bytes to the char buffer

      buffer.copy(this.charBuffer, this.charReceived, 0, available);
      this.charReceived += available;

      if (this.charReceived < this.charLength) {
        // still not enough chars in this buffer? wait for more ...
        return '';
      } // remove bytes belonging to the current character from the buffer


      buffer = buffer.slice(available, buffer.length); // get the character that was split

      charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character

      var charCode = charStr.charCodeAt(charStr.length - 1);

      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        this.charLength += this.surrogateSize;
        charStr = '';
        continue;
      }

      this.charReceived = this.charLength = 0; // if there are no more bytes in this buffer, just emit our char

      if (buffer.length === 0) {
        return charStr;
      }

      break;
    } // determine and set charLength / charReceived


    this.detectIncompleteChar(buffer);
    var end = buffer.length;

    if (this.charLength) {
      // buffer the incomplete character bytes we got
      buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
      end -= this.charReceived;
    }

    charStr += buffer.toString(this.encoding, 0, end);
    var end = charStr.length - 1;
    var charCode = charStr.charCodeAt(end); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character

    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      var size = this.surrogateSize;
      this.charLength += size;
      this.charReceived += size;
      this.charBuffer.copy(this.charBuffer, size, 0, size);
      buffer.copy(this.charBuffer, 0, 0, size);
      return charStr.substring(0, end);
    } // or just emit the charStr


    return charStr;
  }; // detectIncompleteChar determines if there is an incomplete UTF-8 character at
  // the end of the given buffer. If so, it sets this.charLength to the byte
  // length that character, and sets this.charReceived to the number of bytes
  // that are available for this character.


  StringDecoder$2.prototype.detectIncompleteChar = function (buffer) {
    // determine how many bytes we have to check at the end of this buffer
    var i = buffer.length >= 3 ? 3 : buffer.length; // Figure out if one of the last i bytes of our buffer announces an
    // incomplete char.

    for (; i > 0; i--) {
      var c = buffer[buffer.length - i]; // See http://en.wikipedia.org/wiki/UTF-8#Description
      // 110XXXXX

      if (i == 1 && c >> 5 == 0x06) {
        this.charLength = 2;
        break;
      } // 1110XXXX


      if (i <= 2 && c >> 4 == 0x0E) {
        this.charLength = 3;
        break;
      } // 11110XXX


      if (i <= 3 && c >> 3 == 0x1E) {
        this.charLength = 4;
        break;
      }
    }

    this.charReceived = i;
  };

  StringDecoder$2.prototype.end = function (buffer) {
    var res = '';
    if (buffer && buffer.length) res = this.write(buffer);

    if (this.charReceived) {
      var cr = this.charReceived;
      var buf = this.charBuffer;
      var enc = this.encoding;
      res += buf.slice(0, cr).toString(enc);
    }

    return res;
  };

  function passThroughWrite(buffer) {
    return buffer.toString(this.encoding);
  }

  function utf16DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }

  function base64DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }

  var stringDecoder = /*#__PURE__*/Object.freeze({
    __proto__: null,
    StringDecoder: StringDecoder$2
  });

  Readable$1.ReadableState = ReadableState$1;
  var debug$1 = util.debuglog('stream');
  util.inherits(Readable$1, EventEmitter);

  function prependListener$1(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') {
      return emitter.prependListener(event, fn);
    } else {
      // This is a hack to make sure that our error handler is attached before any
      // userland ones.  NEVER DO THIS. This is here only because this code needs
      // to continue to work with older versions of Node.js that do not include
      // the prependListener() method. The goal is to eventually remove this hack.
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
    }
  }

  function listenerCount$1(emitter, type) {
    return emitter.listeners(type).length;
  }

  function ReadableState$1(options, stream) {
    options = options || {}; // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away

    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex$3) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"

    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.

    this.highWaterMark = ~~this.highWaterMark; // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()

    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.

    this.sync = true; // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.

    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || 'utf8'; // when piping, we only care about 'readable' events that happen
    // after read()ing all the bytes and not getting any pushback.

    this.ranOut = false; // the number of writers that are awaiting a drain event in .pipe()s

    this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;

    if (options.encoding) {
      this.decoder = new StringDecoder$2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable$1(options) {
    if (!(this instanceof Readable$1)) return new Readable$1(options);
    this._readableState = new ReadableState$1(options, this); // legacy

    this.readable = true;
    if (options && typeof options.read === 'function') this._read = options.read;
    EventEmitter.call(this);
  } // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.

  Readable$1.prototype.push = function (chunk, encoding) {
    var state = this._readableState;

    if (!state.objectMode && typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
    }

    return readableAddChunk$1(this, state, chunk, encoding, false);
  }; // Unshift should *always* be something directly out of read()


  Readable$1.prototype.unshift = function (chunk) {
    var state = this._readableState;
    return readableAddChunk$1(this, state, chunk, '', true);
  };

  Readable$1.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  };

  function readableAddChunk$1(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid$1(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk$1(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error('stream.push() after EOF');
        stream.emit('error', e);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error('stream.unshift() after end event');

        stream.emit('error', _e);
      } else {
        var skipAdd;

        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }

        if (!addToFront) state.reading = false; // Don't add to the buffer if we've decoded to an empty string chunk and
        // we're not in object mode

        if (!skipAdd) {
          // if we want the data now, just emit it.
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
            if (state.needReadable) emitReadable$1(stream);
          }
        }

        maybeReadMore$1(stream, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }

    return needMoreData(state);
  } // if it's past the high water mark, we can push in some more.
  // Also, if we have no data yet, we can stand some
  // more bytes.  This is to work around cases where hwm=0,
  // such as the repl.  Also, if the push() triggered a
  // readable event, and the user called read(largeNumber) such that
  // needReadable was set, then we ought to push more, so that another
  // 'readable' event will be triggered.


  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  } // backwards compatibility.


  Readable$1.prototype.setEncoding = function (enc) {
    this._readableState.decoder = new StringDecoder$2(enc);
    this._readableState.encoding = enc;
    return this;
  }; // Don't raise the hwm > 8MB


  var MAX_HWM$1 = 0x800000;

  function computeNewHighWaterMark$1(n) {
    if (n >= MAX_HWM$1) {
      n = MAX_HWM$1;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }

    return n;
  } // This function is designed to be inlinable, so please take care when making
  // changes to the function body.


  function howMuchToRead$1(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;

    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    } // If we're asking for more than the current hwm, then raise the hwm.


    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark$1(n);
    if (n <= state.length) return n; // Don't have enough

    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }

    return state.length;
  } // you can override either this method, or the async _read(n) below.


  Readable$1.prototype.read = function (n) {
    debug$1('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.

    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug$1('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable$1(this);else emitReadable$1(this);
      return null;
    }

    n = howMuchToRead$1(n, state); // if we've ended, and we're now clear, then finish it up.

    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable$1(this);
      return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.


    var doRead = state.needReadable;
    debug$1('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug$1('length less than watermark', doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.


    if (state.ended || state.reading) {
      doRead = false;
      debug$1('reading or ended', doRead);
    } else if (doRead) {
      debug$1('do read');
      state.reading = true;
      state.sync = true; // if the length is currently zero, then we *need* a readable event.

      if (state.length === 0) state.needReadable = true; // call internal read method

      this._read(state.highWaterMark);

      state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.

      if (!state.reading) n = howMuchToRead$1(nOrig, state);
    }

    var ret;
    if (n > 0) ret = fromList$1(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

      if (nOrig !== n && state.ended) endReadable$1(this);
    }

    if (ret !== null) this.emit('data', ret);
    return ret;
  };

  function chunkInvalid$1(state, chunk) {
    var er = null;

    if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }

    return er;
  }

  function onEofChunk$1(stream, state) {
    if (state.ended) return;

    if (state.decoder) {
      var chunk = state.decoder.end();

      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }

    state.ended = true; // emit 'readable' now to make sure it gets picked up.

    emitReadable$1(stream);
  } // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.


  function emitReadable$1(stream) {
    var state = stream._readableState;
    state.needReadable = false;

    if (!state.emittedReadable) {
      debug$1('emitReadable', state.flowing);
      state.emittedReadable = true;
      if (state.sync) nextTick$1(emitReadable_$1, stream);else emitReadable_$1(stream);
    }
  }

  function emitReadable_$1(stream) {
    debug$1('emit readable');
    stream.emit('readable');
    flow$1(stream);
  } // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.


  function maybeReadMore$1(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick$1(maybeReadMore_$1, stream, state);
    }
  }

  function maybeReadMore_$1(stream, state) {
    var len = state.length;

    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug$1('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length) // didn't get any data, stop spinning.
        break;else len = state.length;
    }

    state.readingMore = false;
  } // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.


  Readable$1.prototype._read = function (n) {
    this.emit('error', new Error('not implemented'));
  };

  Readable$1.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;

      case 1:
        state.pipes = [state.pipes, dest];
        break;

      default:
        state.pipes.push(dest);
        break;
    }

    state.pipesCount += 1;
    debug$1('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = !pipeOpts || pipeOpts.end !== false;
    var endFn = doEnd ? onend : cleanup;
    if (state.endEmitted) nextTick$1(endFn);else src.once('end', endFn);
    dest.on('unpipe', onunpipe);

    function onunpipe(readable) {
      debug$1('onunpipe');

      if (readable === src) {
        cleanup();
      }
    }

    function onend() {
      debug$1('onend');
      dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.


    var ondrain = pipeOnDrain$1(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;

    function cleanup() {
      debug$1('cleanup'); // cleanup event handlers once the pipe is broken

      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', cleanup);
      src.removeListener('data', ondata);
      cleanedUp = true; // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.

      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    } // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.


    var increasedAwaitDrain = false;
    src.on('data', ondata);

    function ondata(chunk) {
      debug$1('ondata');
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);

      if (false === ret && !increasedAwaitDrain) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf$1(state.pipes, dest) !== -1) && !cleanedUp) {
          debug$1('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }

        src.pause();
      }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.


    function onerror(er) {
      debug$1('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (listenerCount$1(dest, 'error') === 0) dest.emit('error', er);
    } // Make sure our error handler is attached before userland ones.


    prependListener$1(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }

    dest.once('close', onclose);

    function onfinish() {
      debug$1('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }

    dest.once('finish', onfinish);

    function unpipe() {
      debug$1('unpipe');
      src.unpipe(dest);
    } // tell the dest that it's being piped to


    dest.emit('pipe', src); // start the flow if it hasn't been started already.

    if (!state.flowing) {
      debug$1('pipe resume');
      src.resume();
    }

    return dest;
  };

  function pipeOnDrain$1(src) {
    return function () {
      var state = src._readableState;
      debug$1('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;

      if (state.awaitDrain === 0 && src.listeners('data').length) {
        state.flowing = true;
        flow$1(src);
      }
    };
  }

  Readable$1.prototype.unpipe = function (dest) {
    var state = this._readableState; // if we're not piping anywhere, then do nothing.

    if (state.pipesCount === 0) return this; // just one destination.  most common case.

    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes; // got a match.

      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this);
      return this;
    } // slow case. multiple pipe destinations.


    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var _i = 0; _i < len; _i++) {
        dests[_i].emit('unpipe', this);
      }

      return this;
    } // try to find the right one.


    var i = indexOf$1(state.pipes, dest);
    if (i === -1) return this;
    state.pipes.splice(i, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit('unpipe', this);
    return this;
  }; // set up data events if they are asked for
  // Ensure readable listeners eventually get something


  Readable$1.prototype.on = function (ev, fn) {
    var res = EventEmitter.prototype.on.call(this, ev, fn);

    if (ev === 'data') {
      // Start flowing on next tick if stream isn't explicitly paused
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      var state = this._readableState;

      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;

        if (!state.reading) {
          nextTick$1(nReadingNextTick$1, this);
        } else if (state.length) {
          emitReadable$1(this);
        }
      }
    }

    return res;
  };

  Readable$1.prototype.addListener = Readable$1.prototype.on;

  function nReadingNextTick$1(self) {
    debug$1('readable nexttick read 0');
    self.read(0);
  } // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.


  Readable$1.prototype.resume = function () {
    var state = this._readableState;

    if (!state.flowing) {
      debug$1('resume');
      state.flowing = true;
      resume$1(this, state);
    }

    return this;
  };

  function resume$1(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick$1(resume_$1, stream, state);
    }
  }

  function resume_$1(stream, state) {
    if (!state.reading) {
      debug$1('resume read 0');
      stream.read(0);
    }

    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit('resume');
    flow$1(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }

  Readable$1.prototype.pause = function () {
    debug$1('call pause flowing=%j', this._readableState.flowing);

    if (false !== this._readableState.flowing) {
      debug$1('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }

    return this;
  };

  function flow$1(stream) {
    var state = stream._readableState;
    debug$1('flow', state.flowing);

    while (state.flowing && stream.read() !== null) {}
  } // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.


  Readable$1.prototype.wrap = function (stream) {
    var state = this._readableState;
    var paused = false;
    var self = this;
    stream.on('end', function () {
      debug$1('wrapped end');

      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) self.push(chunk);
      }

      self.push(null);
    });
    stream.on('data', function (chunk) {
      debug$1('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
      var ret = self.push(chunk);

      if (!ret) {
        paused = true;
        stream.pause();
      }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.

    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function (method) {
          return function () {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    } // proxy certain important events.


    var events = ['error', 'close', 'destroy', 'pause', 'resume'];
    forEach(events, function (ev) {
      stream.on(ev, self.emit.bind(self, ev));
    }); // when we try to consume some more bytes, simply unpause the
    // underlying stream.

    self._read = function (n) {
      debug$1('wrapped _read', n);

      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return self;
  }; // exposed for testing purposes only.


  Readable$1._fromList = fromList$1; // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.

  function fromList$1(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  } // Extracts only enough buffered data to satisfy the amount requested.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.


  function fromListPartial(n, list, hasStrings) {
    var ret;

    if (n < list.head.data.length) {
      // slice is the same for buffers and strings
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      // first chunk is a perfect match
      ret = list.shift();
    } else {
      // result spans more than one buffer
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }

    return ret;
  } // Copies a specified amount of characters from the list of buffered data
  // chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.


  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;

    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;

      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }

        break;
      }

      ++c;
    }

    list.length -= c;
    return ret;
  } // Copies a specified amount of bytes from the list of buffered data chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.


  function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;

    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;

      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }

        break;
      }

      ++c;
    }

    list.length -= c;
    return ret;
  }

  function endReadable$1(stream) {
    var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.

    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

    if (!state.endEmitted) {
      state.ended = true;
      nextTick$1(endReadableNT$1, state, stream);
    }
  }

  function endReadableNT$1(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');
    }
  }

  function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
      f(xs[i], i);
    }
  }

  function indexOf$1(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }

    return -1;
  }

  // A bit simpler than readable streams.
  Writable$1.WritableState = WritableState$1;
  util.inherits(Writable$1, EventEmitter);

  function nop$1() {}

  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }

  function WritableState$1(options, stream) {
    Object.defineProperty(this, 'buffer', {
      get: util.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
    options = options || {}; // object stream flag to indicate whether or not this stream
    // contains buffers or objects.

    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex$3) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()

    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.

    this.highWaterMark = ~~this.highWaterMark;
    this.needDrain = false; // at the start of calling end()

    this.ending = false; // when end() has been called, and returned

    this.ended = false; // when 'finish' is emitted

    this.finished = false; // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.

    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.

    this.length = 0; // a flag to see when we're in the middle of a write.

    this.writing = false; // when true all writes will be buffered until .uncork() call

    this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.

    this.sync = true; // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.

    this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

    this.onwrite = function (er) {
      onwrite$1(stream, er);
    }; // the callback that the user supplies to write(chunk,encoding,cb)


    this.writecb = null; // the amount that is being written when _write is called.

    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted

    this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams

    this.prefinished = false; // True if the error was already emitted and should not be thrown again

    this.errorEmitted = false; // count buffered requests

    this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two

    this.corkedRequestsFree = new CorkedRequest$1(this);
  }

  WritableState$1.prototype.getBuffer = function writableStateGetBuffer() {
    var current = this.bufferedRequest;
    var out = [];

    while (current) {
      out.push(current);
      current = current.next;
    }

    return out;
  };
  function Writable$1(options) {
    // Writable ctor is applied to Duplexes, though they're not
    // instanceof Writable, they're instanceof Readable.
    if (!(this instanceof Writable$1) && !(this instanceof Duplex$3)) return new Writable$1(options);
    this._writableState = new WritableState$1(options, this); // legacy.

    this.writable = true;

    if (options) {
      if (typeof options.write === 'function') this._write = options.write;
      if (typeof options.writev === 'function') this._writev = options.writev;
    }

    EventEmitter.call(this);
  } // Otherwise people can pipe Writable streams, which is just wrong.

  Writable$1.prototype.pipe = function () {
    this.emit('error', new Error('Cannot pipe, not readable'));
  };

  function writeAfterEnd$1(stream, cb) {
    var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

    stream.emit('error', er);
    nextTick$1(cb, er);
  } // If we get something that is not a buffer, string, null, or undefined,
  // and we're not in objectMode, then that's an error.
  // Otherwise stream chunks are all considered to be of length=1, and the
  // watermarks determine how many objects to keep in the buffer, rather than
  // how many bytes or characters.


  function validChunk$1(stream, state, chunk, cb) {
    var valid = true;
    var er = false; // Always throw error if a null is written
    // if we are not in object mode then throw
    // if it is not a buffer, string, or undefined.

    if (chunk === null) {
      er = new TypeError('May not write null values to stream');
    } else if (!Buffer$1.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }

    if (er) {
      stream.emit('error', er);
      nextTick$1(cb, er);
      valid = false;
    }

    return valid;
  }

  Writable$1.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;

    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== 'function') cb = nop$1;
    if (state.ended) writeAfterEnd$1(this, cb);else if (validChunk$1(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer$1(this, state, chunk, encoding, cb);
    }
    return ret;
  };

  Writable$1.prototype.cork = function () {
    var state = this._writableState;
    state.corked++;
  };

  Writable$1.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer$1(this, state);
    }
  };

  Writable$1.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  function decodeChunk$1(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = Buffer$1.from(chunk, encoding);
    }

    return chunk;
  } // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.


  function writeOrBuffer$1(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk$1(state, chunk, encoding);
    if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

    if (!ret) state.needDrain = true;

    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);

      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }

      state.bufferedRequestCount += 1;
    } else {
      doWrite$1(stream, state, false, len, chunk, encoding, cb);
    }

    return ret;
  }

  function doWrite$1(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  function onwriteError$1(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) nextTick$1(cb, er);else cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  }

  function onwriteStateUpdate$1(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }

  function onwrite$1(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate$1(state);
    if (er) onwriteError$1(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish$1(state);

      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer$1(stream, state);
      }

      if (sync) {
        /*<replacement>*/
        nextTick$1(afterWrite$1, stream, state, finished, cb);
        /*</replacement>*/
      } else {
        afterWrite$1(stream, state, finished, cb);
      }
    }
  }

  function afterWrite$1(stream, state, finished, cb) {
    if (!finished) onwriteDrain$1(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe$1(stream, state);
  } // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.


  function onwriteDrain$1(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  } // if there's something in the buffer waiting, then process it


  function clearBuffer$1(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;

    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;

      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }

      doWrite$1(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite

      state.pendingcb++;
      state.lastBufferedRequest = null;

      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest$1(state);
      }
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite$1(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next; // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.

        if (state.writing) {
          break;
        }
      }

      if (entry === null) state.lastBufferedRequest = null;
    }

    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }

  Writable$1.prototype._write = function (chunk, encoding, cb) {
    cb(new Error('not implemented'));
  };

  Writable$1.prototype._writev = null;

  Writable$1.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

    if (state.corked) {
      state.corked = 1;
      this.uncork();
    } // ignore unnecessary end() calls.


    if (!state.ending && !state.finished) endWritable$1(this, state, cb);
  };

  function needFinish$1(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }

  function prefinish$2(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }

  function finishMaybe$1(stream, state) {
    var need = needFinish$1(state);

    if (need) {
      if (state.pendingcb === 0) {
        prefinish$2(stream, state);
        state.finished = true;
        stream.emit('finish');
      } else {
        prefinish$2(stream, state);
      }
    }

    return need;
  }

  function endWritable$1(stream, state, cb) {
    state.ending = true;
    finishMaybe$1(stream, state);

    if (cb) {
      if (state.finished) nextTick$1(cb);else stream.once('finish', cb);
    }

    state.ended = true;
    stream.writable = false;
  } // It seems a linked list but it is not
  // there will be only 2 of these for each stream


  function CorkedRequest$1(state) {
    var _this = this;

    this.next = null;
    this.entry = null;

    this.finish = function (err) {
      var entry = _this.entry;
      _this.entry = null;

      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }

      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }

  util.inherits(Duplex$3, Readable$1);
  var keys$1 = Object.keys(Writable$1.prototype);

  for (var v$1 = 0; v$1 < keys$1.length; v$1++) {
    var method$1 = keys$1[v$1];
    if (!Duplex$3.prototype[method$1]) Duplex$3.prototype[method$1] = Writable$1.prototype[method$1];
  }
  function Duplex$3(options) {
    if (!(this instanceof Duplex$3)) return new Duplex$3(options);
    Readable$1.call(this, options);
    Writable$1.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once('end', onend$1);
  } // the no-half-open enforcer

  function onend$1() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
    // But allow more writes to happen in this tick.

    nextTick$1(onEndNT$1, this);
  }

  function onEndNT$1(self) {
    self.end();
  }

  // a transform stream is a readable/writable stream where you do
  util.inherits(Transform$2, Duplex$3);

  function TransformState(stream) {
    this.afterTransform = function (er, data) {
      return afterTransform$1(stream, er, data);
    };

    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }

  function afterTransform$1(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
    ts.writechunk = null;
    ts.writecb = null;
    if (data !== null && data !== undefined) stream.push(data);
    cb(er);
    var rs = stream._readableState;
    rs.reading = false;

    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  }
  function Transform$2(options) {
    if (!(this instanceof Transform$2)) return new Transform$2(options);
    Duplex$3.call(this, options);
    this._transformState = new TransformState(this); // when the writable side finishes, then flush out anything remaining.

    var stream = this; // start out asking for a readable event once data is transformed.

    this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.

    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;
      if (typeof options.flush === 'function') this._flush = options.flush;
    }

    this.once('prefinish', function () {
      if (typeof this._flush === 'function') this._flush(function (er) {
        done$1(stream, er);
      });else done$1(stream);
    });
  }

  Transform$2.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex$3.prototype.push.call(this, chunk, encoding);
  }; // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.


  Transform$2.prototype._transform = function (chunk, encoding, cb) {
    throw new Error('Not implemented');
  };

  Transform$2.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;

    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  }; // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.


  Transform$2.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;

      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  function done$1(stream, er) {
    if (er) return stream.emit('error', er); // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided

    var ws = stream._writableState;
    var ts = stream._transformState;
    if (ws.length) throw new Error('Calling transform done when ws.length != 0');
    if (ts.transforming) throw new Error('Calling transform done when still transforming');
    return stream.push(null);
  }

  util.inherits(PassThrough$1, Transform$2);
  function PassThrough$1(options) {
    if (!(this instanceof PassThrough$1)) return new PassThrough$1(options);
    Transform$2.call(this, options);
  }

  PassThrough$1.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  util.inherits(Stream$1, EventEmitter);
  Stream$1.Readable = Readable$1;
  Stream$1.Writable = Writable$1;
  Stream$1.Duplex = Duplex$3;
  Stream$1.Transform = Transform$2;
  Stream$1.PassThrough = PassThrough$1; // Backwards-compat with node 0.4.x

  Stream$1.Stream = Stream$1;
  // part of this class) is overridden in the Readable class.

  function Stream$1() {
    EventEmitter.call(this);
  }

  Stream$1.prototype.pipe = function (dest, options) {
    var source = this;

    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }

    source.on('data', ondata);

    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }

    dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.

    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }

    var didOnEnd = false;

    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }

    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === 'function') dest.destroy();
    } // don't leave dangling pipes when there are errors.


    function onerror(er) {
      cleanup();

      if (EventEmitter.listenerCount(this, 'error') === 0) {
        throw er; // Unhandled stream error in pipe.
      }
    }

    source.on('error', onerror);
    dest.on('error', onerror); // remove all the event listeners that were added.

    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);
      source.removeListener('end', onend);
      source.removeListener('close', onclose);
      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);
      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);
      dest.removeListener('close', cleanup);
    }

    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

    return dest;
  };

  var Buffer$g = safeBuffer.Buffer;
  var Transform$3 = Stream$1.Transform;
  var StringDecoder$3 = stringDecoder.StringDecoder;

  function CipherBase$1(hashMode) {
    Transform$3.call(this);
    this.hashMode = typeof hashMode === 'string';

    if (this.hashMode) {
      this[hashMode] = this._finalOrDigest;
    } else {
      this.final = this._finalOrDigest;
    }

    if (this._final) {
      this.__final = this._final;
      this._final = null;
    }

    this._decoder = null;
    this._encoding = null;
  }

  inherits_browser(CipherBase$1, Transform$3);

  CipherBase$1.prototype.update = function (data, inputEnc, outputEnc) {
    if (typeof data === 'string') {
      data = Buffer$g.from(data, inputEnc);
    }

    var outData = this._update(data);

    if (this.hashMode) return this;

    if (outputEnc) {
      outData = this._toString(outData, outputEnc);
    }

    return outData;
  };

  CipherBase$1.prototype.setAutoPadding = function () {};

  CipherBase$1.prototype.getAuthTag = function () {
    throw new Error('trying to get auth tag in unsupported state');
  };

  CipherBase$1.prototype.setAuthTag = function () {
    throw new Error('trying to set auth tag in unsupported state');
  };

  CipherBase$1.prototype.setAAD = function () {
    throw new Error('trying to set aad in unsupported state');
  };

  CipherBase$1.prototype._transform = function (data, _, next) {
    var err;

    try {
      if (this.hashMode) {
        this._update(data);
      } else {
        this.push(this._update(data));
      }
    } catch (e) {
      err = e;
    } finally {
      next(err);
    }
  };

  CipherBase$1.prototype._flush = function (done) {
    var err;

    try {
      this.push(this.__final());
    } catch (e) {
      err = e;
    }

    done(err);
  };

  CipherBase$1.prototype._finalOrDigest = function (outputEnc) {
    var outData = this.__final() || Buffer$g.alloc(0);

    if (outputEnc) {
      outData = this._toString(outData, outputEnc, true);
    }

    return outData;
  };

  CipherBase$1.prototype._toString = function (value, enc, fin) {
    if (!this._decoder) {
      this._decoder = new StringDecoder$3(enc);
      this._encoding = enc;
    }

    if (this._encoding !== enc) throw new Error('can\'t switch encodings');

    var out = this._decoder.write(value);

    if (fin) {
      out += this._decoder.end();
    }

    return out;
  };

  var cipherBase = CipherBase$1;

  function Hash$2(hash) {
    cipherBase.call(this, 'digest');
    this._hash = hash;
  }

  inherits_browser(Hash$2, cipherBase);

  Hash$2.prototype._update = function (data) {
    this._hash.update(data);
  };

  Hash$2.prototype._final = function () {
    return this._hash.digest();
  };

  var browser$2 = function createHash(alg) {
    alg = alg.toLowerCase();
    if (alg === 'md5') return new md5_js();
    if (alg === 'rmd160' || alg === 'ripemd160') return new ripemd160$1();
    return new Hash$2(sha_js(alg));
  };

  // Copyright (c) 2018 base-x contributors
  // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
  // Distributed under the MIT software license, see the accompanying
  // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
  // @ts-ignore


  var _Buffer = safeBuffer.Buffer;

  function base(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError('Alphabet too long');
    }

    var BASE_MAP = new Uint8Array(256);

    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }

    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);

      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + ' is ambiguous');
      }

      BASE_MAP[xc] = i;
    }

    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up

    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up

    function encode(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }

      if (!_Buffer.isBuffer(source)) {
        throw new TypeError('Expected Buffer');
      }

      if (source.length === 0) {
        return '';
      } // Skip & count leading zeroes.


      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;

      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      } // Allocate enough space in big-endian base58 representation.


      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size); // Process the bytes.

      while (pbegin !== pend) {
        var carry = source[pbegin]; // Apply "b58 = b58 * 256 + ch".

        var i = 0;

        for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }

        if (carry !== 0) {
          throw new Error('Non-zero carry');
        }

        length = i;
        pbegin++;
      } // Skip leading zeroes in base58 result.


      var it2 = size - length;

      while (it2 !== size && b58[it2] === 0) {
        it2++;
      } // Translate the result into a string.


      var str = LEADER.repeat(zeroes);

      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }

      return str;
    }

    function decodeUnsafe(source) {
      if (typeof source !== 'string') {
        throw new TypeError('Expected String');
      }

      if (source.length === 0) {
        return _Buffer.alloc(0);
      }

      var psz = 0; // Skip leading spaces.

      if (source[psz] === ' ') {
        return;
      } // Skip and count leading '1's.


      var zeroes = 0;
      var length = 0;

      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      } // Allocate enough space in big-endian base256 representation.


      var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.

      var b256 = new Uint8Array(size); // Process the characters.

      while (source[psz]) {
        // Decode character
        var carry = BASE_MAP[source.charCodeAt(psz)]; // Invalid character

        if (carry === 255) {
          return;
        }

        var i = 0;

        for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }

        if (carry !== 0) {
          throw new Error('Non-zero carry');
        }

        length = i;
        psz++;
      } // Skip trailing spaces.


      if (source[psz] === ' ') {
        return;
      } // Skip leading zeroes in b256.


      var it4 = size - length;

      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }

      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));

      vch.fill(0x00, 0, zeroes);
      var j = zeroes;

      while (it4 !== size) {
        vch[j++] = b256[it4++];
      }

      return vch;
    }

    function decode(string) {
      var buffer = decodeUnsafe(string);

      if (buffer) {
        return buffer;
      }

      throw new Error('Non-base' + BASE + ' character');
    }

    return {
      encode: encode,
      decodeUnsafe: decodeUnsafe,
      decode: decode
    };
  }

  var src$1 = base;

  var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  var bs58 = src$1(ALPHABET);

  var Buffer$h = safeBuffer.Buffer;

  var base$1 = function base(checksumFn) {
    // Encode a buffer as a base58-check encoded string
    function encode(payload) {
      var checksum = checksumFn(payload);
      return bs58.encode(Buffer$h.concat([payload, checksum], payload.length + 4));
    }

    function decodeRaw(buffer) {
      var payload = buffer.slice(0, -4);
      var checksum = buffer.slice(-4);
      var newChecksum = checksumFn(payload);
      if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
      return payload;
    } // Decode a base58-check encoded string to a buffer, no result if checksum is wrong


    function decodeUnsafe(string) {
      var buffer = bs58.decodeUnsafe(string);
      if (!buffer) return;
      return decodeRaw(buffer);
    }

    function decode(string) {
      var buffer = bs58.decode(string);
      var payload = decodeRaw(buffer);
      if (!payload) throw new Error('Invalid checksum');
      return payload;
    }

    return {
      encode: encode,
      decode: decode,
      decodeUnsafe: decodeUnsafe
    };
  };

  function sha256x2(buffer) {
    var tmp = browser$2('sha256').update(buffer).digest();
    return browser$2('sha256').update(tmp).digest();
  }

  var bs58check = base$1(sha256x2);

  function decodeRaw(buffer, version) {
    // check version only if defined
    if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version'); // uncompressed

    if (buffer.length === 33) {
      return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: false
      };
    } // invalid length


    if (buffer.length !== 34) throw new Error('Invalid WIF length'); // invalid compression flag

    if (buffer[33] !== 0x01) throw new Error('Invalid compression flag');
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: true
    };
  }

  function encodeRaw(version, privateKey, compressed) {
    var result = new Buffer(compressed ? 34 : 33);
    result.writeUInt8(version, 0);
    privateKey.copy(result, 1);

    if (compressed) {
      result[33] = 0x01;
    }

    return result;
  }

  function decode$9(string, version) {
    return decodeRaw(bs58check.decode(string), version);
  }

  function encode$9(version, privateKey, compressed) {
    if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed));
    return bs58check.encode(encodeRaw(version.version, version.privateKey, version.compressed));
  }

  var wif = {
    decode: decode$9,
    decodeRaw: decodeRaw,
    encode: encode$9,
    encodeRaw: encodeRaw
  };

  var Keys = /*#__PURE__*/function () {
    function Keys() {
      _classCallCheck__default['default'](this, Keys);
    }

    _createClass__default['default'](Keys, null, [{
      key: "fromPassphrase",
      value: function fromPassphrase(passphrase) {
        var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return Keys.fromPrivateKey(HashAlgorithms.sha256(Buffer.from(passphrase, "utf8")), compressed);
      }
    }, {
      key: "fromPrivateKey",
      value: function fromPrivateKey(privateKey) {
        var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        privateKey = privateKey instanceof Buffer ? privateKey : Buffer.from(privateKey, "hex");
        return {
          publicKey: bcrypto.secp256k1.publicKeyCreate(privateKey, compressed).toString("hex"),
          privateKey: privateKey.toString("hex"),
          compressed: compressed
        };
      }
    }, {
      key: "fromWIF",
      value: function fromWIF(wif$1, options) {
        var _WIF$decode = wif.decode(wif$1, options.wif),
            version = _WIF$decode.version,
            compressed = _WIF$decode.compressed,
            privateKey = _WIF$decode.privateKey;

        if (version !== options.wif) {
          throw new NetworkVersionError(options.wif, version);
        }

        return {
          publicKey: bcrypto.secp256k1.publicKeyCreate(privateKey, compressed).toString("hex"),
          privateKey: privateKey.toString("hex"),
          compressed: compressed
        };
      }
    }]);

    return Keys;
  }();

  function _createForOfIteratorHelper$i(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$i(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray$i(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$i(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(o, minLen); }

  function _arrayLikeToArray$i(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var PublicKey = /*#__PURE__*/function () {
    function PublicKey() {
      _classCallCheck__default['default'](this, PublicKey);
    }

    _createClass__default['default'](PublicKey, null, [{
      key: "fromPassphrase",
      value: function fromPassphrase(passphrase) {
        return Keys.fromPassphrase(passphrase).publicKey;
      }
    }, {
      key: "fromWIF",
      value: function fromWIF(wif, options) {
        return Keys.fromWIF(wif, options).publicKey;
      }
    }, {
      key: "fromMultiSignatureAsset",
      value: function fromMultiSignatureAsset(asset) {
        var min = asset.min,
            publicKeys = asset.publicKeys;

        var _iterator = _createForOfIteratorHelper$i(publicKeys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var publicKey = _step.value;

            if (!this.verify(publicKey)) {
              throw new PublicKeyError(publicKey);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (min < 1 || min > publicKeys.length) {
          throw new InvalidMultiSignatureAssetError();
        }

        var minKey = PublicKey.fromPassphrase(numberToHex(min));
        var keys = [minKey].concat(_toConsumableArray__default['default'](publicKeys));
        return bcrypto.secp256k1.publicKeyCombine(keys.map(function (publicKey) {
          return Buffer.from(publicKey, "hex");
        })).toString("hex");
      }
    }, {
      key: "verify",
      value: function verify(publicKey) {
        return bcrypto.secp256k1.publicKeyVerify(Buffer.from(publicKey, "hex"));
      }
    }]);

    return PublicKey;
  }();

  var Address = /*#__PURE__*/function () {
    function Address() {
      _classCallCheck__default['default'](this, Address);
    }

    _createClass__default['default'](Address, null, [{
      key: "fromPassphrase",
      value: function fromPassphrase(passphrase, options) {
        return Address.fromPublicKey(PublicKey.fromPassphrase(passphrase), options);
      }
    }, {
      key: "fromPublicKey",
      value: function fromPublicKey(publicKey, options) {
        if (!PublicKey.verify(publicKey)) {
          throw new PublicKeyError(publicKey);
        }

        var buffer = HashAlgorithms.ripemd160(Buffer.from(publicKey, "hex"));
        var payload = Buffer.alloc(21);
        payload.writeUInt8(options.pubKeyHash, 0);
        buffer.copy(payload, 1);
        return this.fromBuffer(payload);
      }
    }, {
      key: "fromWIF",
      value: function fromWIF(wif, options) {
        return Address.fromPublicKey(PublicKey.fromWIF(wif, options), options);
      }
    }, {
      key: "fromMultiSignatureAsset",
      value: function fromMultiSignatureAsset(asset, options) {
        return this.fromPublicKey(PublicKey.fromMultiSignatureAsset(asset), options);
      }
    }, {
      key: "fromPrivateKey",
      value: function fromPrivateKey(privateKey, options) {
        return Address.fromPublicKey(privateKey.publicKey, options);
      }
    }, {
      key: "fromBuffer",
      value: function fromBuffer(buffer) {
        return Base58.encodeCheck(buffer);
      }
    }, {
      key: "toBuffer",
      value: function toBuffer(address, options) {
        var buffer = Base58.decodeCheck(address);
        var result = {
          addressBuffer: buffer
        };

        if (buffer[0] !== options.pubKeyHash) {
          result.addressError = "Expected address network byte ".concat(options.pubKeyHash, ", but got ").concat(buffer[0], ".");
        }

        return result;
      }
    }, {
      key: "validate",
      value: function validate(address, options) {
        try {
          return Base58.decodeCheck(address)[0] === options.pubKeyHash;
        } catch (err) {
          return false;
        }
      }
    }]);

    return Address;
  }();

  var contracts = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  var PrivateKey = /*#__PURE__*/function () {
    function PrivateKey() {
      _classCallCheck__default['default'](this, PrivateKey);
    }

    _createClass__default['default'](PrivateKey, null, [{
      key: "fromPassphrase",
      value: function fromPassphrase(passphrase) {
        return Keys.fromPassphrase(passphrase).privateKey;
      }
    }, {
      key: "fromWIF",
      value: function fromWIF(wif, options) {
        return Keys.fromWIF(wif, options).privateKey;
      }
    }]);

    return PrivateKey;
  }();

  var WIF = /*#__PURE__*/function () {
    function WIF() {
      _classCallCheck__default['default'](this, WIF);
    }

    _createClass__default['default'](WIF, null, [{
      key: "fromPassphrase",
      value: function fromPassphrase(passphrase, options) {
        var _Keys$fromPassphrase = Keys.fromPassphrase(passphrase),
            compressed = _Keys$fromPassphrase.compressed,
            privateKey = _Keys$fromPassphrase.privateKey;

        return wif.encode(options.wif, Buffer.from(privateKey, "hex"), compressed);
      }
    }, {
      key: "fromKeys",
      value: function fromKeys(keys, options) {
        return wif.encode(options.wif, Buffer.from(keys.privateKey, "hex"), keys.compressed);
      }
    }]);

    return WIF;
  }();

  exports.Address = Address;
  exports.Contracts = contracts;
  exports.Errors = errors;
  exports.Keys = Keys;
  exports.PrivateKey = PrivateKey;
  exports.PublicKey = PublicKey;
  exports.WIF = WIF;

  return exports;

}({}, _classCallCheck$1, _createClass$1, _regeneratorRuntime, _toConsumableArray, _asyncToGenerator, _typeof, _assertThisInitialized, _inherits, _possibleConstructorReturn, _getPrototypeOf, _wrapNativeSuper, _slicedToArray, _get, _construct, _defineProperty$2));
