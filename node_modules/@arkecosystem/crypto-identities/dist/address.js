"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Address = void 0;
const base58_1 = require("./base58");
const errors_1 = require("./errors");
const hash_algorithms_1 = require("./hash-algorithms");
const public_key_1 = require("./public-key");
class Address {
    static fromPassphrase(passphrase, options) {
        return Address.fromPublicKey(public_key_1.PublicKey.fromPassphrase(passphrase), options);
    }
    static fromPublicKey(publicKey, options) {
        if (!public_key_1.PublicKey.verify(publicKey)) {
            throw new errors_1.PublicKeyError(publicKey);
        }
        const buffer = hash_algorithms_1.HashAlgorithms.ripemd160(Buffer.from(publicKey, "hex"));
        const payload = Buffer.alloc(21);
        payload.writeUInt8(options.pubKeyHash, 0);
        buffer.copy(payload, 1);
        return this.fromBuffer(payload);
    }
    static fromWIF(wif, options) {
        return Address.fromPublicKey(public_key_1.PublicKey.fromWIF(wif, options), options);
    }
    static fromMultiSignatureAsset(asset, options) {
        return this.fromPublicKey(public_key_1.PublicKey.fromMultiSignatureAsset(asset), options);
    }
    static fromPrivateKey(privateKey, options) {
        return Address.fromPublicKey(privateKey.publicKey, options);
    }
    static fromBuffer(buffer) {
        return base58_1.Base58.encodeCheck(buffer);
    }
    static toBuffer(address, options) {
        const buffer = base58_1.Base58.decodeCheck(address);
        const result = {
            addressBuffer: buffer,
        };
        if (buffer[0] !== options.pubKeyHash) {
            result.addressError = `Expected address network byte ${options.pubKeyHash}, but got ${buffer[0]}.`;
        }
        return result;
    }
    static validate(address, options) {
        try {
            return base58_1.Base58.decodeCheck(address)[0] === options.pubKeyHash;
        }
        catch (err) {
            return false;
        }
    }
}
exports.Address = Address;
//# sourceMappingURL=address.js.map