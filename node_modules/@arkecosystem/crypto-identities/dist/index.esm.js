import { base58 } from 'bstring';
import moize from 'fast-memoize';
import { RIPEMD160, SHA1, SHA256, Hash160, Hash256, secp256k1 } from 'bcrypto';
import wif from 'wif';

class CryptoError extends Error {
    constructor(message) {
        super(message);
        Object.defineProperty(this, "message", {
            enumerable: false,
            value: message,
        });
        Object.defineProperty(this, "name", {
            enumerable: false,
            value: this.constructor.name,
        });
        Error.captureStackTrace(this, this.constructor);
    }
}
class NetworkVersionError extends CryptoError {
    constructor(expected, given) {
        super(`Expected version to be ${expected}, but got ${given}.`);
    }
}
class PrivateKeyLengthError extends CryptoError {
    constructor(expected, given) {
        super(`Expected length to be ${expected}, but got ${given}.`);
    }
}
class PublicKeyError extends CryptoError {
    constructor(given) {
        super(`Expected ${given} to be a valid public key.`);
    }
}
class AddressNetworkError extends CryptoError {
    constructor(what) {
        super(what);
    }
}
class InvalidMultiSignatureAssetError extends CryptoError {
    constructor() {
        super(`The multi signature asset is invalid.`);
    }
}
class InvalidBase58ChecksumError extends CryptoError {
    constructor() {
        super("Invalid checksum for base58 string.");
    }
}

var errors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CryptoError: CryptoError,
    NetworkVersionError: NetworkVersionError,
    PrivateKeyLengthError: PrivateKeyLengthError,
    PublicKeyError: PublicKeyError,
    AddressNetworkError: AddressNetworkError,
    InvalidMultiSignatureAssetError: InvalidMultiSignatureAssetError,
    InvalidBase58ChecksumError: InvalidBase58ChecksumError
});

class HashAlgorithms {
    static ripemd160(buffer) {
        return RIPEMD160.digest(this.bufferize(buffer));
    }
    static sha1(buffer) {
        return SHA1.digest(this.bufferize(buffer));
    }
    static sha256(buffer) {
        if (Array.isArray(buffer)) {
            let sha256 = SHA256.ctx;
            sha256.init();
            for (const element of buffer) {
                sha256 = sha256.update(element);
            }
            return sha256.final();
        }
        return SHA256.digest(this.bufferize(buffer));
    }
    static hash160(buffer) {
        return Hash160.digest(this.bufferize(buffer));
    }
    static hash256(buffer) {
        return Hash256.digest(this.bufferize(buffer));
    }
    static bufferize(buffer) {
        return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
    }
}

const encodeCheck = (buffer) => {
    const checksum = HashAlgorithms.hash256(buffer);
    return base58.encode(Buffer.concat([buffer, checksum], buffer.length + 4));
};
const decodeCheck = (address) => {
    const buffer = base58.decode(address);
    const payload = buffer.slice(0, -4);
    const checksum = HashAlgorithms.hash256(payload);
    if (checksum.readUInt32LE(0) !== buffer.slice(-4).readUInt32LE(0)) {
        throw new InvalidBase58ChecksumError();
    }
    return payload;
};
const Base58 = {
    encodeCheck: moize(encodeCheck),
    decodeCheck: moize(decodeCheck),
};

const numberToHex = (num, padding = 2) => {
    const indexHex = Number(num).toString(16);
    return "0".repeat(padding - indexHex.length) + indexHex;
};

class Keys {
    static fromPassphrase(passphrase, compressed = true) {
        return Keys.fromPrivateKey(HashAlgorithms.sha256(Buffer.from(passphrase, "utf8")), compressed);
    }
    static fromPrivateKey(privateKey, compressed = true) {
        privateKey = privateKey instanceof Buffer ? privateKey : Buffer.from(privateKey, "hex");
        return {
            publicKey: secp256k1.publicKeyCreate(privateKey, compressed).toString("hex"),
            privateKey: privateKey.toString("hex"),
            compressed,
        };
    }
    static fromWIF(wif$1, options) {
        const { version, compressed, privateKey } = wif.decode(wif$1, options.wif);
        if (version !== options.wif) {
            throw new NetworkVersionError(options.wif, version);
        }
        return {
            publicKey: secp256k1.publicKeyCreate(privateKey, compressed).toString("hex"),
            privateKey: privateKey.toString("hex"),
            compressed,
        };
    }
}

class PublicKey {
    static fromPassphrase(passphrase) {
        return Keys.fromPassphrase(passphrase).publicKey;
    }
    static fromWIF(wif, options) {
        return Keys.fromWIF(wif, options).publicKey;
    }
    static fromMultiSignatureAsset(asset) {
        const { min, publicKeys } = asset;
        for (const publicKey of publicKeys) {
            if (!this.verify(publicKey)) {
                throw new PublicKeyError(publicKey);
            }
        }
        if (min < 1 || min > publicKeys.length) {
            throw new InvalidMultiSignatureAssetError();
        }
        const minKey = PublicKey.fromPassphrase(numberToHex(min));
        const keys = [minKey, ...publicKeys];
        return secp256k1
            .publicKeyCombine(keys.map((publicKey) => Buffer.from(publicKey, "hex")))
            .toString("hex");
    }
    static verify(publicKey) {
        return secp256k1.publicKeyVerify(Buffer.from(publicKey, "hex"));
    }
}

class Address {
    static fromPassphrase(passphrase, options) {
        return Address.fromPublicKey(PublicKey.fromPassphrase(passphrase), options);
    }
    static fromPublicKey(publicKey, options) {
        if (!PublicKey.verify(publicKey)) {
            throw new PublicKeyError(publicKey);
        }
        const buffer = HashAlgorithms.ripemd160(Buffer.from(publicKey, "hex"));
        const payload = Buffer.alloc(21);
        payload.writeUInt8(options.pubKeyHash, 0);
        buffer.copy(payload, 1);
        return this.fromBuffer(payload);
    }
    static fromWIF(wif, options) {
        return Address.fromPublicKey(PublicKey.fromWIF(wif, options), options);
    }
    static fromMultiSignatureAsset(asset, options) {
        return this.fromPublicKey(PublicKey.fromMultiSignatureAsset(asset), options);
    }
    static fromPrivateKey(privateKey, options) {
        return Address.fromPublicKey(privateKey.publicKey, options);
    }
    static fromBuffer(buffer) {
        return Base58.encodeCheck(buffer);
    }
    static toBuffer(address, options) {
        const buffer = Base58.decodeCheck(address);
        const result = {
            addressBuffer: buffer,
        };
        if (buffer[0] !== options.pubKeyHash) {
            result.addressError = `Expected address network byte ${options.pubKeyHash}, but got ${buffer[0]}.`;
        }
        return result;
    }
    static validate(address, options) {
        try {
            return Base58.decodeCheck(address)[0] === options.pubKeyHash;
        }
        catch (err) {
            return false;
        }
    }
}

var contracts = /*#__PURE__*/Object.freeze({
    __proto__: null
});

class PrivateKey {
    static fromPassphrase(passphrase) {
        return Keys.fromPassphrase(passphrase).privateKey;
    }
    static fromWIF(wif, options) {
        return Keys.fromWIF(wif, options).privateKey;
    }
}

// @ts-ignore
class WIF {
    static fromPassphrase(passphrase, options) {
        const { compressed, privateKey } = Keys.fromPassphrase(passphrase);
        return wif.encode(options.wif, Buffer.from(privateKey, "hex"), compressed);
    }
    static fromKeys(keys, options) {
        return wif.encode(options.wif, Buffer.from(keys.privateKey, "hex"), keys.compressed);
    }
}

export { Address, contracts as Contracts, errors as Errors, Keys, PrivateKey, PublicKey, WIF };
