import assert from 'assert';
import { secp256k1, RIPEMD160, SHA1, SHA256, Hash160, Hash256 } from 'bcrypto';
import aes from 'browserify-aes';
import crypto from 'crypto';
import { Address as Address$1, Keys as Keys$1, PrivateKey as PrivateKey$1, PublicKey as PublicKey$1, WIF as WIF$1 } from '@arkecosystem/crypto-identities';
import deepmerge from 'deepmerge';
import get from 'lodash.get';
import set from 'lodash.set';
import * as networks$1 from '@arkecosystem/crypto-networks';
import { devnet } from '@arkecosystem/crypto-networks';
import { base58 } from 'bstring';
import moize from 'fast-memoize';
import { fromSeed, fromPrivateKey } from 'bip32';
import { mnemonicToSeedSync } from 'bip39';
import dayjs from 'dayjs';
import { BigNumber } from '@arkecosystem/utils';
import { parse, process } from 'ipaddr.js';
import os from 'os';
import Ajv from 'ajv';
import ajvKeywords from 'ajv-keywords';
import ByteBuffer from 'bytebuffer';

var inplace = function xorInplace (a, b) {
  var length = Math.min(a.length, b.length);

  for (var i = 0; i < length; ++i) {
    a[i] = a[i] ^ b[i];
  }

  return a
};

class CryptoError extends Error {
    constructor(message) {
        super(message);
        Object.defineProperty(this, "message", {
            enumerable: false,
            value: message,
        });
        Object.defineProperty(this, "name", {
            enumerable: false,
            value: this.constructor.name,
        });
        Error.captureStackTrace(this, this.constructor);
    }
}
class Bip38CompressionError extends CryptoError {
    constructor(expected, given) {
        super(`Expected flag to be ${expected}, but got ${given}.`);
    }
}
class Bip38LengthError extends CryptoError {
    constructor(expected, given) {
        super(`Expected length to be ${expected}, but got ${given}.`);
    }
}
class Bip38PrefixError extends CryptoError {
    constructor(expected, given) {
        super(`Expected prefix to be ${expected}, but got ${given}.`);
    }
}
class Bip38TypeError extends CryptoError {
    constructor(expected, given) {
        super(`Expected type to be ${expected}, but got ${given}.`);
    }
}
class NetworkVersionError extends CryptoError {
    constructor(expected, given) {
        super(`Expected version to be ${expected}, but got ${given}.`);
    }
}
class NotImplemented extends CryptoError {
    constructor() {
        super(`Feature is not available.`);
    }
}
class PrivateKeyLengthError extends CryptoError {
    constructor(expected, given) {
        super(`Expected length to be ${expected}, but got ${given}.`);
    }
}
class PublicKeyError extends CryptoError {
    constructor(given) {
        super(`Expected ${given} to be a valid public key.`);
    }
}
class AddressNetworkError extends CryptoError {
    constructor(what) {
        super(what);
    }
}
class TransactionTypeError extends CryptoError {
    constructor(given) {
        super(`Type ${given} not supported.`);
    }
}
class InvalidTransactionBytesError extends CryptoError {
    constructor(message) {
        super(`Failed to deserialize transaction, encountered invalid bytes: ${message}`);
    }
}
class TransactionSchemaError extends CryptoError {
    constructor(what) {
        super(what);
    }
}
class TransactionVersionError extends CryptoError {
    constructor(given) {
        super(`Version ${given} not supported.`);
    }
}
class UnkownTransactionError extends CryptoError {
    constructor(given) {
        super(`Unknown transaction type: ${given}`);
    }
}
class TransactionAlreadyRegisteredError extends CryptoError {
    constructor(name) {
        super(`Transaction type ${name} is already registered.`);
    }
}
class TransactionKeyAlreadyRegisteredError extends CryptoError {
    constructor(name) {
        super(`Transaction key ${name} is already registered.`);
    }
}
class TransactionVersionAlreadyRegisteredError extends CryptoError {
    constructor(name, version) {
        super(`Transaction type ${name} is already registered in version ${version}.`);
    }
}
class CoreTransactionTypeGroupImmutableError extends CryptoError {
    constructor() {
        super(`The Core transaction type group is immutable.`);
    }
}
class MissingMilestoneFeeError extends CryptoError {
    constructor(name) {
        super(`Missing milestone fee for '${name}'.`);
    }
}
class MaximumPaymentCountExceededError extends CryptoError {
    constructor(limit) {
        super(`Number of payments exceeded the allowed maximum of ${limit}.`);
    }
}
class MinimumPaymentCountSubceededError extends CryptoError {
    constructor() {
        super(`Number of payments subceeded the required minimum of 2.`);
    }
}
class VendorFieldLengthExceededError extends CryptoError {
    constructor(limit) {
        super(`Length of vendor field exceeded the allowed maximum ${limit}.`);
    }
}
class MissingTransactionSignatureError extends CryptoError {
    constructor() {
        super(`Expected the transaction to be signed.`);
    }
}
class BlockSchemaError extends CryptoError {
    constructor(height, what) {
        super(`Height (${height}): ${what}`);
    }
}
class PreviousBlockIdFormatError extends CryptoError {
    constructor(thisBlockHeight, previousBlockId) {
        super(`The config denotes that the block at height ${thisBlockHeight - 1} ` +
            `must use full SHA256 block id, but the next block (at ${thisBlockHeight}) ` +
            `contains previous block id "${previousBlockId}"`);
    }
}
class InvalidMilestoneConfigurationError extends CryptoError {
    constructor(message) {
        super(message);
    }
}
class InvalidMultiSignatureAssetError extends CryptoError {
    constructor() {
        super(`The multi signature asset is invalid.`);
    }
}
class DuplicateParticipantInMultiSignatureError extends CryptoError {
    constructor() {
        super(`Invalid multi signature, because duplicate participant found.`);
    }
}

var errors = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CryptoError: CryptoError,
  Bip38CompressionError: Bip38CompressionError,
  Bip38LengthError: Bip38LengthError,
  Bip38PrefixError: Bip38PrefixError,
  Bip38TypeError: Bip38TypeError,
  NetworkVersionError: NetworkVersionError,
  NotImplemented: NotImplemented,
  PrivateKeyLengthError: PrivateKeyLengthError,
  PublicKeyError: PublicKeyError,
  AddressNetworkError: AddressNetworkError,
  TransactionTypeError: TransactionTypeError,
  InvalidTransactionBytesError: InvalidTransactionBytesError,
  TransactionSchemaError: TransactionSchemaError,
  TransactionVersionError: TransactionVersionError,
  UnkownTransactionError: UnkownTransactionError,
  TransactionAlreadyRegisteredError: TransactionAlreadyRegisteredError,
  TransactionKeyAlreadyRegisteredError: TransactionKeyAlreadyRegisteredError,
  TransactionVersionAlreadyRegisteredError: TransactionVersionAlreadyRegisteredError,
  CoreTransactionTypeGroupImmutableError: CoreTransactionTypeGroupImmutableError,
  MissingMilestoneFeeError: MissingMilestoneFeeError,
  MaximumPaymentCountExceededError: MaximumPaymentCountExceededError,
  MinimumPaymentCountSubceededError: MinimumPaymentCountSubceededError,
  VendorFieldLengthExceededError: VendorFieldLengthExceededError,
  MissingTransactionSignatureError: MissingTransactionSignatureError,
  BlockSchemaError: BlockSchemaError,
  PreviousBlockIdFormatError: PreviousBlockIdFormatError,
  InvalidMilestoneConfigurationError: InvalidMilestoneConfigurationError,
  InvalidMultiSignatureAssetError: InvalidMultiSignatureAssetError,
  DuplicateParticipantInMultiSignatureError: DuplicateParticipantInMultiSignatureError
});

var networks = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), networks$1));

class ConfigManager {
    constructor() {
        this.setConfig(devnet);
    }
    setConfig(config) {
        this.config = {
            network: config.network,
            exceptions: config.exceptions,
            milestones: config.milestones,
            genesisBlock: config.genesisBlock,
        };
        this.validateMilestones();
        this.buildConstants();
    }
    setFromPreset(network) {
        this.setConfig(this.getPreset(network));
    }
    getPreset(network) {
        return networks[network.toLowerCase()];
    }
    all() {
        return this.config;
    }
    set(key, value) {
        if (!this.config) {
            throw new Error();
        }
        set(this.config, key, value);
    }
    get(key) {
        return get(this.config, key);
    }
    setHeight(value) {
        this.height = value;
    }
    getHeight() {
        return this.height;
    }
    isNewMilestone(height) {
        height = height || this.height;
        if (!this.milestones) {
            throw new Error();
        }
        return this.milestones.some((milestone) => milestone.height === height);
    }
    getMilestone(height) {
        if (!this.milestone || !this.milestones) {
            throw new Error();
        }
        if (!height && this.height) {
            height = this.height;
        }
        if (!height) {
            height = 1;
        }
        while (this.milestone.index < this.milestones.length - 1 &&
            height >= this.milestones[this.milestone.index + 1].height) {
            this.milestone.index++;
            this.milestone.data = this.milestones[this.milestone.index];
        }
        while (height < this.milestones[this.milestone.index].height) {
            this.milestone.index--;
            this.milestone.data = this.milestones[this.milestone.index];
        }
        return this.milestone.data;
    }
    getNextMilestoneWithNewKey(previousMilestone, key) {
        if (!this.milestones || !this.milestones.length) {
            throw new Error(`Attempted to get next milestone but none were set`);
        }
        for (let i = 0; i < this.milestones.length; i++) {
            const milestone = this.milestones[i];
            if (milestone[key] &&
                milestone[key] !== this.getMilestone(previousMilestone)[key] &&
                milestone.height > previousMilestone) {
                return {
                    found: true,
                    height: milestone.height,
                    data: milestone[key],
                };
            }
        }
        return {
            found: false,
            height: previousMilestone,
            data: null,
        };
    }
    getMilestones() {
        return this.milestones;
    }
    buildConstants() {
        if (!this.config) {
            throw new Error();
        }
        this.milestones = this.config.milestones.sort((a, b) => a.height - b.height);
        this.milestone = {
            index: 0,
            data: this.milestones[0],
        };
        let lastMerged = 0;
        const overwriteMerge = (dest, source, options) => source;
        while (lastMerged < this.milestones.length - 1) {
            this.milestones[lastMerged + 1] = deepmerge(this.milestones[lastMerged], this.milestones[lastMerged + 1], {
                arrayMerge: overwriteMerge,
            });
            lastMerged++;
        }
    }
    validateMilestones() {
        if (!this.config) {
            throw new Error();
        }
        const delegateMilestones = this.config.milestones
            .sort((a, b) => a.height - b.height)
            .filter((milestone) => milestone.activeDelegates);
        for (let i = 1; i < delegateMilestones.length; i++) {
            const previous = delegateMilestones[i - 1];
            const current = delegateMilestones[i];
            if (previous.activeDelegates === current.activeDelegates) {
                continue;
            }
            if ((current.height - previous.height) % previous.activeDelegates !== 0) {
                throw new InvalidMilestoneConfigurationError(`Bad milestone at height: ${current.height}. The number of delegates can only be changed at the beginning of a new round.`);
            }
        }
    }
}
const configManager = new ConfigManager();

class NetworkManager {
    static all() {
        // @ts-ignore - the newly generated unitnet doesn't match the old configs because it has things like a nonce field
        return networks;
    }
    static findByName(name) {
        return networks[name.toLowerCase()];
    }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  configManager: configManager,
  NetworkManager: NetworkManager
});

const getWifFromNetwork = (network) => network ? network.wif : configManager.get("network.wif");
const getPubKeyHashFromNetwork = (network) => network ? network.pubKeyHash : configManager.get("network.pubKeyHash");
const getPubKeyHash = (networkVersion) => networkVersion || configManager.get("network.pubKeyHash");

class Address {
    static fromPassphrase(passphrase, networkVersion) {
        return Address$1.fromPassphrase(passphrase, { pubKeyHash: getPubKeyHash(networkVersion) });
    }
    static fromPublicKey(publicKey, networkVersion) {
        return Address$1.fromPublicKey(publicKey, { pubKeyHash: getPubKeyHash(networkVersion) });
    }
    static fromWIF(wif, network) {
        return Address$1.fromWIF(wif, {
            pubKeyHash: getPubKeyHashFromNetwork(network),
            wif: getWifFromNetwork(network),
        });
    }
    static fromMultiSignatureAsset(asset, networkVersion) {
        return Address$1.fromMultiSignatureAsset(asset, { pubKeyHash: getPubKeyHash(networkVersion) });
    }
    static fromPrivateKey(privateKey, networkVersion) {
        return Address$1.fromPrivateKey(privateKey, { pubKeyHash: getPubKeyHash(networkVersion) });
    }
    static fromBuffer(buffer) {
        return Address$1.fromBuffer(buffer);
    }
    static toBuffer(address, networkVersion) {
        return Address$1.toBuffer(address, { pubKeyHash: getPubKeyHash(networkVersion) });
    }
    static validate(address, networkVersion) {
        return Address$1.validate(address, { pubKeyHash: getPubKeyHash(networkVersion) });
    }
}

class Keys {
    static fromPassphrase(passphrase, compressed = true) {
        return Keys$1.fromPassphrase(passphrase, compressed);
    }
    static fromPrivateKey(privateKey, compressed = true) {
        return Keys$1.fromPrivateKey(privateKey, compressed);
    }
    static fromWIF(wifKey, network) {
        return Keys$1.fromWIF(wifKey, { wif: getWifFromNetwork(network) });
    }
}

class PrivateKey {
    static fromPassphrase(passphrase) {
        return PrivateKey$1.fromPassphrase(passphrase);
    }
    static fromWIF(wif, network) {
        return PrivateKey$1.fromWIF(wif, { wif: getWifFromNetwork(network) });
    }
}

class PublicKey {
    static fromPassphrase(passphrase) {
        return PublicKey$1.fromPassphrase(passphrase);
    }
    static fromWIF(wif, network) {
        return PublicKey$1.fromWIF(wif, { wif: getWifFromNetwork(network) });
    }
    static fromMultiSignatureAsset(asset) {
        return PublicKey$1.fromMultiSignatureAsset(asset);
    }
    static verify(publicKey) {
        return PublicKey$1.verify(publicKey);
    }
}

class WIF {
    static fromPassphrase(passphrase, network) {
        return WIF$1.fromPassphrase(passphrase, { wif: getWifFromNetwork(network) });
    }
    static fromKeys(keys, network) {
        return WIF$1.fromKeys(keys, { wif: getWifFromNetwork(network) });
    }
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Address: Address,
  Keys: Keys,
  PrivateKey: PrivateKey,
  PublicKey: PublicKey,
  WIF: WIF
});

const encodeCheck = (buffer) => {
    const checksum = HashAlgorithms.hash256(buffer);
    return base58.encode(Buffer.concat([buffer, checksum], buffer.length + 4));
};
const decodeCheck = (address) => {
    const buffer = base58.decode(address);
    const payload = buffer.slice(0, -4);
    const checksum = HashAlgorithms.hash256(payload);
    if (checksum.readUInt32LE(0) !== buffer.slice(-4).readUInt32LE(0)) {
        throw new Error("Invalid checksum");
    }
    return payload;
};
const Base58 = {
    encodeCheck: moize(encodeCheck),
    decodeCheck: moize(decodeCheck),
};

/**
 * Based on: https://github.com/bitcoinjs/bip38 @ 8e3a2cc6f7391782f3012129924a73bb632a3d4d
 */
const SCRYPT_PARAMS = {
    N: 16384,
    r: 8,
    p: 8,
};
const NULL = Buffer.alloc(0);
const getPublicKey = (buffer, compressed) => {
    return Buffer.from(Keys.fromPrivateKey(buffer, compressed).publicKey, "hex");
};
const getAddressPrivate = (privateKey, compressed) => {
    const publicKey = getPublicKey(privateKey, compressed);
    const buffer = HashAlgorithms.hash160(publicKey);
    const payload = Buffer.alloc(21);
    payload.writeUInt8(0x00, 0);
    buffer.copy(payload, 1);
    return Base58.encodeCheck(payload);
};
const verify = (bip38) => {
    let decoded;
    try {
        decoded = Base58.decodeCheck(bip38);
    }
    catch (_a) {
        return false;
    }
    if (!decoded) {
        return false;
    }
    if (decoded.length !== 39) {
        return false;
    }
    if (decoded.readUInt8(0) !== 0x01) {
        return false;
    }
    const type = decoded.readUInt8(1);
    const flag = decoded.readUInt8(2);
    // encrypted WIF
    if (type === 0x42) {
        if (flag !== 0xc0 && flag !== 0xe0) {
            return false;
        }
        // EC mult
    }
    else if (type === 0x43) {
        if (flag & ~0x24) {
            return false;
        }
    }
    else {
        return false;
    }
    return true;
};
const encryptRaw = (buffer, compressed, passphrase) => {
    if (buffer.length !== 32) {
        throw new PrivateKeyLengthError(32, buffer.length);
    }
    const address = getAddressPrivate(buffer, compressed);
    const secret = Buffer.from(passphrase, "utf8");
    const salt = HashAlgorithms.hash256(address).slice(0, 4);
    const scryptBuf = crypto.scryptSync(secret, salt, 64, SCRYPT_PARAMS);
    const derivedHalf1 = scryptBuf.slice(0, 32);
    const derivedHalf2 = scryptBuf.slice(32, 64);
    const xorBuf = inplace(derivedHalf1, buffer);
    const cipher = aes.createCipheriv("aes-256-ecb", derivedHalf2, NULL);
    cipher.setAutoPadding(false);
    cipher.end(xorBuf);
    const cipherText = cipher.read();
    // 0x01 | 0x42 | flagByte | salt (4) | cipherText (32)
    const result = Buffer.allocUnsafe(7 + 32);
    result.writeUInt8(0x01, 0);
    result.writeUInt8(0x42, 1);
    result.writeUInt8(compressed ? 0xe0 : 0xc0, 2);
    salt.copy(result, 3);
    cipherText.copy(result, 7);
    return result;
};
const decryptECMult = (buffer, passphrase) => {
    buffer = buffer.slice(1);
    const flag = buffer.readUInt8(1);
    const compressed = (flag & 0x20) !== 0;
    const hasLotSeq = (flag & 0x04) !== 0;
    assert.strictEqual(flag & 0x24, flag, "Invalid private key.");
    const addressHash = buffer.slice(2, 6);
    const ownerEntropy = buffer.slice(6, 14);
    let ownerSalt;
    // 4 bytes ownerSalt if 4 bytes lot/sequence
    if (hasLotSeq) {
        ownerSalt = ownerEntropy.slice(0, 4);
        // else, 8 bytes ownerSalt
    }
    else {
        ownerSalt = ownerEntropy;
    }
    const encryptedPart1 = buffer.slice(14, 22); // First 8 bytes
    const encryptedPart2 = buffer.slice(22, 38); // 16 bytes
    const preFactor = crypto.scryptSync(passphrase, ownerSalt, 32, SCRYPT_PARAMS);
    let passFactor;
    if (hasLotSeq) {
        const hashTarget = Buffer.concat([preFactor, ownerEntropy]);
        passFactor = HashAlgorithms.hash256(hashTarget);
    }
    else {
        passFactor = preFactor;
    }
    const publicKey = getPublicKey(passFactor, true);
    const seedBPass = crypto.scryptSync(publicKey, Buffer.concat([addressHash, ownerEntropy]), 64, {
        N: 1024,
        r: 1,
        p: 1,
    });
    const derivedHalf1 = seedBPass.slice(0, 32);
    const derivedHalf2 = seedBPass.slice(32, 64);
    const decipher = aes.createDecipheriv("aes-256-ecb", derivedHalf2, Buffer.alloc(0));
    decipher.setAutoPadding(false);
    decipher.end(encryptedPart2);
    const decryptedPart2 = decipher.read();
    const tmp = inplace(decryptedPart2, derivedHalf1.slice(16, 32));
    const seedBPart2 = tmp.slice(8, 16);
    const decipher2 = aes.createDecipheriv("aes-256-ecb", derivedHalf2, Buffer.alloc(0));
    decipher2.setAutoPadding(false);
    decipher2.write(encryptedPart1); // first 8 bytes
    decipher2.end(tmp.slice(0, 8)); // last 8 bytes
    const seedBPart1 = inplace(decipher2.read(), derivedHalf1.slice(0, 16));
    const seedB = Buffer.concat([seedBPart1, seedBPart2], 24);
    const privateKey = secp256k1.privateKeyTweakMul(HashAlgorithms.hash256(seedB), passFactor);
    return {
        privateKey,
        compressed,
    };
};
// some of the techniques borrowed from: https://github.com/pointbiz/bitaddress.org
const decryptRaw = (buffer, passphrase) => {
    // 39 bytes: 2 bytes prefix, 37 bytes payload
    if (buffer.length !== 39) {
        throw new Bip38LengthError(39, buffer.length);
    }
    if (buffer.readUInt8(0) !== 0x01) {
        throw new Bip38PrefixError(0x01, buffer.readUInt8(0));
    }
    // check if BIP38 EC multiply
    const type = buffer.readUInt8(1);
    if (type === 0x43) {
        return decryptECMult(buffer, passphrase);
    }
    if (type !== 0x42) {
        throw new Bip38TypeError(0x42, type);
    }
    const flagByte = buffer.readUInt8(2);
    const compressed = flagByte === 0xe0;
    if (!compressed && flagByte !== 0xc0) {
        throw new Bip38CompressionError(0xc0, flagByte);
    }
    const salt = buffer.slice(3, 7);
    const scryptBuf = crypto.scryptSync(passphrase, salt, 64, SCRYPT_PARAMS);
    const derivedHalf1 = scryptBuf.slice(0, 32);
    const derivedHalf2 = scryptBuf.slice(32, 64);
    const privKeyBuf = buffer.slice(7, 7 + 32);
    const decipher = aes.createDecipheriv("aes-256-ecb", derivedHalf2, NULL);
    decipher.setAutoPadding(false);
    decipher.end(privKeyBuf);
    const plainText = decipher.read();
    const privateKey = inplace(derivedHalf1, plainText);
    // verify salt matches address
    const address = getAddressPrivate(privateKey, compressed);
    const checksum = HashAlgorithms.hash256(address).slice(0, 4);
    assert.deepEqual(salt, checksum);
    return {
        privateKey,
        compressed,
    };
};
const encrypt = (privateKey, compressed, passphrase) => {
    return Base58.encodeCheck(encryptRaw(privateKey, compressed, passphrase));
};
const decrypt = (bip38, passphrase) => {
    return decryptRaw(Base58.decodeCheck(bip38), passphrase);
};

var bip38 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  verify: verify,
  encrypt: encrypt,
  decrypt: decrypt
});

class Hash {
    static signECDSA(hash, keys) {
        return secp256k1.signatureExport(secp256k1.sign(hash, Buffer.from(keys.privateKey, "hex"))).toString("hex");
    }
    static verifyECDSA(hash, signature, publicKey) {
        const bufferSignature = signature instanceof Buffer ? signature : Buffer.from(signature, "hex");
        const signatureRS = secp256k1.signatureImport(bufferSignature);
        if (!secp256k1.isLowS(signatureRS)) {
            return false;
        }
        // check that global signature length matches R and S length, see DER format :
        // <header byte><signature length><integer marker><R length><R><integer marker><S length><S>
        const signatureLength = bufferSignature.readUInt8(1);
        const rLength = bufferSignature.readUInt8(3);
        const sLength = bufferSignature.readUInt8(4 + rLength + 1);
        if (bufferSignature.length !== 4 + rLength + 2 + sLength || signatureLength !== 2 + rLength + 2 + sLength) {
            return false;
        }
        // check that first byte is positive, if it is then the whole R / S will be positive as required
        const rFirstByte = bufferSignature.readInt8(4);
        const sFirstByte = bufferSignature.readInt8(4 + rLength + 2);
        if (rFirstByte < 0 || sFirstByte < 0) {
            return false;
        }
        // if first byte is zero it is to make R/S positive, so second byte should be negative
        if ((rFirstByte === 0 && bufferSignature.readInt8(4 + 1) >= 0) ||
            (sFirstByte === 0 && bufferSignature.readInt8(4 + rLength + 2 + 1) >= 0)) {
            return false;
        }
        return secp256k1.verify(hash, signatureRS, publicKey instanceof Buffer ? publicKey : Buffer.from(publicKey, "hex"));
    }
    static signSchnorr(hash, keys) {
        return secp256k1.schnorrSign(hash, Buffer.from(keys.privateKey, "hex")).toString("hex");
    }
    static verifySchnorr(hash, signature, publicKey) {
        return secp256k1.schnorrVerify(hash, signature instanceof Buffer ? signature : Buffer.from(signature, "hex"), publicKey instanceof Buffer ? publicKey : Buffer.from(publicKey, "hex"));
    }
}

class HashAlgorithms {
    static ripemd160(buffer) {
        return RIPEMD160.digest(this.bufferize(buffer));
    }
    static sha1(buffer) {
        return SHA1.digest(this.bufferize(buffer));
    }
    static sha256(buffer) {
        if (Array.isArray(buffer)) {
            let sha256 = SHA256.ctx;
            sha256.init();
            for (const element of buffer) {
                sha256 = sha256.update(element);
            }
            return sha256.final();
        }
        return SHA256.digest(this.bufferize(buffer));
    }
    static hash160(buffer) {
        return Hash160.digest(this.bufferize(buffer));
    }
    static hash256(buffer) {
        return Hash256.digest(this.bufferize(buffer));
    }
    static bufferize(buffer) {
        return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
    }
}

class HDWallet {
    /**
     * Get root node from the given mnemonic with an optional passphrase.
     */
    static fromMnemonic(mnemonic, passphrase) {
        return fromSeed(mnemonicToSeedSync(mnemonic, passphrase), configManager.get("network"));
    }
    /**
     * Get bip32 node from keys.
     */
    static fromKeys(keys, chainCode) {
        if (!keys.compressed) {
            throw new TypeError("BIP32 only allows compressed keys.");
        }
        return fromPrivateKey(Buffer.from(keys.privateKey, "hex"), chainCode, configManager.get("network"));
    }
    /**
     * Get key pair from the given node.
     */
    static getKeys(node) {
        if (!node.privateKey) {
            throw new Error();
        }
        return {
            publicKey: node.publicKey.toString("hex"),
            privateKey: node.privateKey.toString("hex"),
            compressed: true,
        };
    }
    /**
     * Derives a node from the coin type as specified by slip44.
     */
    static deriveSlip44(root, hardened = true) {
        return root.derivePath(`m/44'/${this.slip44}${hardened ? "'" : ""}`);
    }
    /**
     * Derives a node from the network as specified by AIP20.
     */
    static deriveNetwork(root) {
        return this.deriveSlip44(root).deriveHardened(configManager.get("network.aip20") || 1);
    }
}
HDWallet.slip44 = 111;

class Message {
    static sign(message, passphrase) {
        const keys = Keys.fromPassphrase(passphrase);
        return {
            publicKey: keys.publicKey,
            signature: Hash.signECDSA(this.createHash(message), keys),
            message,
        };
    }
    static signWithWif(message, wif, network) {
        if (!network) {
            network = configManager.get("network");
        }
        const keys = Keys.fromWIF(wif, network);
        return {
            publicKey: keys.publicKey,
            signature: Hash.signECDSA(this.createHash(message), keys),
            message,
        };
    }
    static verify({ message, publicKey, signature }) {
        return Hash.verifyECDSA(this.createHash(message), signature, publicKey);
    }
    static createHash(message) {
        return HashAlgorithms.sha256(message);
    }
}

const isNewBlockTime = (height) => {
    if (height === 1)
        return true;
    const milestones = configManager.get("milestones");
    let milestone;
    for (let i = milestones.length - 1; i >= 0; i--) {
        const temp = milestones[i];
        if (temp.height > height) {
            continue;
        }
        if (!milestone || temp.blocktime === milestone.blocktime) {
            if (temp.blocktime) {
                milestone = temp;
            }
        }
        else {
            break;
        }
    }
    if (!milestone)
        return false;
    return height - milestone.height === 0;
};
const calculateBlockTime = (height) => {
    const milestones = configManager.get("milestones");
    for (let i = milestones.length - 1; i >= 0; i--) {
        const milestone = milestones[i];
        if (milestone.height <= height) {
            if (milestone.blocktime) {
                return milestone.blocktime;
            }
        }
    }
    throw new Error(`No milestones specifying any height were found`);
};

class Slots {
    static getTime(time) {
        if (time === undefined) {
            time = dayjs().valueOf();
        }
        const start = dayjs(configManager.getMilestone(1).epoch).valueOf();
        return Math.floor((time - start) / 1000);
    }
    static getTimeInMsUntilNextSlot(getTimeStampForBlock) {
        const nextSlotTime = this.getSlotTime(getTimeStampForBlock, this.getNextSlot(getTimeStampForBlock));
        const now = this.getTime();
        return (nextSlotTime - now) * 1000;
    }
    static getSlotNumber(getTimeStampForBlock, timestamp, height) {
        if (timestamp === undefined) {
            timestamp = this.getTime();
        }
        const latestHeight = this.getLatestHeight(height);
        return this.getSlotInfo(getTimeStampForBlock, timestamp, latestHeight).slotNumber;
    }
    static getSlotTime(getTimeStampForBlock, slot, height) {
        const latestHeight = this.getLatestHeight(height);
        return this.calculateSlotTime(slot, latestHeight, getTimeStampForBlock);
    }
    static getNextSlot(getTimeStampForBlock) {
        return this.getSlotNumber(getTimeStampForBlock) + 1;
    }
    static isForgingAllowed(getTimeStampForBlock, timestamp, height) {
        if (timestamp === undefined) {
            timestamp = this.getTime();
        }
        const latestHeight = this.getLatestHeight(height);
        return this.getSlotInfo(getTimeStampForBlock, timestamp, latestHeight).forgingStatus;
    }
    static getSlotInfo(getTimeStampForBlock, timestamp, height) {
        if (timestamp === undefined) {
            timestamp = this.getTime();
        }
        height = this.getLatestHeight(height);
        let blockTime = calculateBlockTime(1);
        let totalSlotsFromLastSpan = 0;
        let lastSpanEndTime = 0;
        let previousMilestoneHeight = 1;
        let nextMilestone = configManager.getNextMilestoneWithNewKey(1, "blocktime");
        for (let i = 0; i < this.getMilestonesWhichAffectBlockTimes().length - 1; i++) {
            if (height < nextMilestone.height) {
                break;
            }
            const spanStartTimestamp = getTimeStampForBlock(previousMilestoneHeight);
            lastSpanEndTime = getTimeStampForBlock(nextMilestone.height - 1) + blockTime;
            totalSlotsFromLastSpan += Math.floor((lastSpanEndTime - spanStartTimestamp) / blockTime);
            blockTime = nextMilestone.data;
            previousMilestoneHeight = nextMilestone.height;
            nextMilestone = configManager.getNextMilestoneWithNewKey(nextMilestone.height, "blocktime");
        }
        const slotNumberUpUntilThisTimestamp = Math.floor((timestamp - lastSpanEndTime) / blockTime);
        const slotNumber = totalSlotsFromLastSpan + slotNumberUpUntilThisTimestamp;
        const startTime = lastSpanEndTime + slotNumberUpUntilThisTimestamp * blockTime;
        const endTime = startTime + blockTime - 1;
        const forgingStatus = timestamp < startTime + Math.floor(blockTime / 2);
        return {
            blockTime,
            startTime,
            endTime,
            slotNumber,
            forgingStatus,
        };
    }
    static getMilestonesWhichAffectBlockTimes() {
        const milestones = [
            {
                found: true,
                height: 1,
                data: configManager.getMilestone(1).blocktime,
            },
        ];
        let nextMilestone = configManager.getNextMilestoneWithNewKey(1, "blocktime");
        while (nextMilestone.found) {
            milestones.push(nextMilestone);
            nextMilestone = configManager.getNextMilestoneWithNewKey(nextMilestone.height, "blocktime");
        }
        return milestones;
    }
    static calculateSlotTime(slotNumber, height, getTimeStampForBlock) {
        let blockTime = calculateBlockTime(1);
        let totalSlotsFromLastSpan = 0;
        let milestoneHeight = 1;
        let lastSpanEndTime = 0;
        let nextMilestone = configManager.getNextMilestoneWithNewKey(1, "blocktime");
        for (let i = 0; i < this.getMilestonesWhichAffectBlockTimes().length - 1; i++) {
            if (height < nextMilestone.height) {
                break;
            }
            const spanStartTimestamp = getTimeStampForBlock(milestoneHeight);
            lastSpanEndTime = getTimeStampForBlock(nextMilestone.height - 1) + blockTime;
            totalSlotsFromLastSpan += Math.floor((lastSpanEndTime - spanStartTimestamp) / blockTime);
            blockTime = nextMilestone.data;
            milestoneHeight = nextMilestone.height;
            nextMilestone = configManager.getNextMilestoneWithNewKey(nextMilestone.height, "blocktime");
        }
        return lastSpanEndTime + (slotNumber - totalSlotsFromLastSpan) * blockTime;
    }
    static getLatestHeight(height) {
        if (!height) {
            // TODO: is the config manager the best way to retrieve most recent height?
            // Or should this class maintain its own cache?
            const configConfiguredHeight = configManager.getHeight();
            if (configConfiguredHeight) {
                return configConfiguredHeight;
            }
            else {
                return 1;
            }
        }
        return height;
    }
}

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bip38: bip38,
  Hash: Hash,
  HashAlgorithms: HashAlgorithms,
  HDWallet: HDWallet,
  Message: Message,
  Slots: Slots
});

const SATOSHI = 1e8;
const ARKTOSHI = SATOSHI;

var constants = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SATOSHI: SATOSHI,
  ARKTOSHI: ARKTOSHI
});

// todo: review the implementation of all methods
const isLocalHost = (ip, includeNetworkInterfaces = true) => {
    try {
        const parsed = parse(ip);
        if (parsed.range() === "loopback" || ip.startsWith("0") || ["127.0.0.1", "::ffff:127.0.0.1"].includes(ip)) {
            return true;
        }
        if (includeNetworkInterfaces) {
            const interfaces = os.networkInterfaces();
            return Object.keys(interfaces).some((ifname) => interfaces[ifname].some((iface) => iface.address === ip));
        }
        return false;
    }
    catch (error) {
        return false;
    }
};
const sanitizeRemoteAddress = (ip) => {
    try {
        return process(ip).toString();
    }
    catch (error) {
        return undefined;
    }
};
const isValidPeer = (peer, includeNetworkInterfaces = true) => {
    const sanitizedAddress = sanitizeRemoteAddress(peer.ip);
    if (!sanitizedAddress) {
        return false;
    }
    peer.ip = sanitizedAddress;
    if (isLocalHost(peer.ip, includeNetworkInterfaces)) {
        return false;
    }
    return true;
};

let genesisTransactions;
let whitelistedBlockAndTransactionIds;
let currentNetwork;
/**
 * Get human readable string from satoshis
 */
const formatSatoshi = (amount) => {
    const localeString = (+amount / SATOSHI).toLocaleString("en", {
        minimumFractionDigits: 0,
        maximumFractionDigits: 8,
    });
    return `${localeString} ${configManager.get("network.client.symbol")}`;
};
/**
 * Check if the given block or transaction id is an exception.
 */
const isIdException = (id) => {
    if (!id) {
        return false;
    }
    const network = configManager.get("network.pubKeyHash");
    if (!whitelistedBlockAndTransactionIds || currentNetwork !== network) {
        currentNetwork = network;
        whitelistedBlockAndTransactionIds = [
            ...(configManager.get("exceptions.blocks") || []),
            ...(configManager.get("exceptions.transactions") || []),
        ].reduce((acc, curr) => Object.assign(acc, { [curr]: true }), {});
    }
    return !!whitelistedBlockAndTransactionIds[id];
};
const isException = (blockOrTransaction) => {
    if (typeof blockOrTransaction.id !== "string") {
        return false;
    }
    if (blockOrTransaction.id.length < 64) {
        // old block ids, we check that the transactions inside the block are correct
        const blockExceptionTxIds = (configManager.get("exceptions.blocksTransactions") || {})[blockOrTransaction.id];
        const blockTransactions = blockOrTransaction.transactions || [];
        if (!blockExceptionTxIds || blockExceptionTxIds.length !== blockTransactions.length) {
            return false;
        }
        blockExceptionTxIds.sort();
        const blockToCheckTxIds = blockTransactions.map((tx) => tx.id).sort();
        for (let i = 0; i < blockExceptionTxIds.length; i++) {
            if (blockToCheckTxIds[i] !== blockExceptionTxIds[i]) {
                return false;
            }
        }
    }
    return isIdException(blockOrTransaction.id);
};
const isGenesisTransaction = (id) => {
    const network = configManager.get("network.pubKeyHash");
    if (!genesisTransactions || currentNetwork !== network) {
        currentNetwork = network;
        genesisTransactions = configManager
            .get("genesisBlock.transactions")
            .reduce((acc, curr) => Object.assign(acc, { [curr.id]: true }), {});
    }
    return genesisTransactions[id];
};
const numberToHex = (num, padding = 2) => {
    const indexHex = Number(num).toString(16);
    return "0".repeat(padding - indexHex.length) + indexHex;
};
const maxVendorFieldLength = (height) => configManager.getMilestone(height).vendorFieldLength;
const isSupportedTransactionVersion = (version) => {
    const aip11 = configManager.getMilestone().aip11;
    if (aip11 && version !== 2) {
        return false;
    }
    if (!aip11 && version !== 1) {
        return false;
    }
    return true;
};

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  formatSatoshi: formatSatoshi,
  isIdException: isIdException,
  isException: isException,
  isGenesisTransaction: isGenesisTransaction,
  numberToHex: numberToHex,
  maxVendorFieldLength: maxVendorFieldLength,
  isSupportedTransactionVersion: isSupportedTransactionVersion,
  Base58: Base58,
  BigNumber: BigNumber,
  isValidPeer: isValidPeer,
  isLocalHost: isLocalHost,
  calculateBlockTime: calculateBlockTime,
  isNewBlockTime: isNewBlockTime
});

var TransactionType;
(function (TransactionType) {
    TransactionType[TransactionType["Transfer"] = 0] = "Transfer";
    TransactionType[TransactionType["SecondSignature"] = 1] = "SecondSignature";
    TransactionType[TransactionType["DelegateRegistration"] = 2] = "DelegateRegistration";
    TransactionType[TransactionType["Vote"] = 3] = "Vote";
    TransactionType[TransactionType["MultiSignature"] = 4] = "MultiSignature";
    TransactionType[TransactionType["Ipfs"] = 5] = "Ipfs";
    TransactionType[TransactionType["MultiPayment"] = 6] = "MultiPayment";
    TransactionType[TransactionType["DelegateResignation"] = 7] = "DelegateResignation";
    TransactionType[TransactionType["HtlcLock"] = 8] = "HtlcLock";
    TransactionType[TransactionType["HtlcClaim"] = 9] = "HtlcClaim";
    TransactionType[TransactionType["HtlcRefund"] = 10] = "HtlcRefund";
})(TransactionType || (TransactionType = {}));
var TransactionTypeGroup;
(function (TransactionTypeGroup) {
    TransactionTypeGroup[TransactionTypeGroup["Test"] = 0] = "Test";
    TransactionTypeGroup[TransactionTypeGroup["Core"] = 1] = "Core";
    // Everything above is available to anyone
    TransactionTypeGroup[TransactionTypeGroup["Reserved"] = 1000] = "Reserved";
})(TransactionTypeGroup || (TransactionTypeGroup = {}));
var HtlcLockExpirationType;
(function (HtlcLockExpirationType) {
    HtlcLockExpirationType[HtlcLockExpirationType["EpochTimestamp"] = 1] = "EpochTimestamp";
    HtlcLockExpirationType[HtlcLockExpirationType["BlockHeight"] = 2] = "BlockHeight";
})(HtlcLockExpirationType || (HtlcLockExpirationType = {}));

var enums = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get TransactionType () { return TransactionType; },
  get TransactionTypeGroup () { return TransactionTypeGroup; },
  get HtlcLockExpirationType () { return HtlcLockExpirationType; }
});

const signedTransaction = {
    anyOf: [
        { required: ["id", "signature"] },
        { required: ["id", "signature", "signatures"] },
        { required: ["id", "signatures"] },
    ],
};
const strictTransaction = {
    additionalProperties: false,
};
const transactionBaseSchema = {
    $id: undefined,
    type: "object",
    if: { properties: { version: { anyOf: [{ type: "null" }, { const: 1 }] } } },
    then: { required: ["type", "senderPublicKey", "fee", "amount", "timestamp"] },
    else: { required: ["type", "senderPublicKey", "fee", "amount", "nonce"] },
    properties: {
        id: { anyOf: [{ $ref: "transactionId" }, { type: "null" }] },
        version: { enum: [1, 2] },
        network: { $ref: "networkByte" },
        timestamp: { type: "integer", minimum: 0 },
        nonce: { bignumber: { minimum: 0 } },
        typeGroup: { type: "integer", minimum: 0 },
        amount: { bignumber: { minimum: 1, bypassGenesis: true } },
        fee: { bignumber: { minimum: 0, bypassGenesis: true } },
        senderPublicKey: { $ref: "publicKey" },
        signature: { $ref: "alphanumeric" },
        secondSignature: { $ref: "alphanumeric" },
        signSignature: { $ref: "alphanumeric" },
        signatures: {
            type: "array",
            minItems: 1,
            maxItems: 16,
            additionalItems: false,
            uniqueItems: true,
            items: { allOf: [{ minLength: 130, maxLength: 130 }, { $ref: "alphanumeric" }] },
        },
    },
};
const extend = (parent, properties) => {
    return deepmerge(parent, properties);
};
const signedSchema = (schema) => {
    const signed = extend(schema, signedTransaction);
    signed.$id = `${schema.$id}Signed`;
    return signed;
};
const strictSchema = (schema) => {
    const signed = signedSchema(schema);
    const strict = extend(signed, strictTransaction);
    strict.$id = `${schema.$id}Strict`;
    return strict;
};
const transfer = extend(transactionBaseSchema, {
    $id: "transfer",
    required: ["recipientId"],
    properties: {
        type: { transactionType: TransactionType.Transfer },
        fee: { bignumber: { minimum: 1, bypassGenesis: true } },
        vendorField: { anyOf: [{ type: "null" }, { type: "string", format: "vendorField" }] },
        recipientId: { $ref: "address" },
        expiration: { type: "integer", minimum: 0 },
    },
});
const secondSignature = extend(transactionBaseSchema, {
    $id: "secondSignature",
    required: ["asset"],
    properties: {
        type: { transactionType: TransactionType.SecondSignature },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 1 } },
        secondSignature: { type: "null" },
        asset: {
            type: "object",
            required: ["signature"],
            properties: {
                signature: {
                    type: "object",
                    required: ["publicKey"],
                    properties: {
                        publicKey: {
                            $ref: "publicKey",
                        },
                    },
                },
            },
        },
    },
});
const delegateRegistration = extend(transactionBaseSchema, {
    $id: "delegateRegistration",
    required: ["asset"],
    properties: {
        type: { transactionType: TransactionType.DelegateRegistration },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 1, bypassGenesis: true } },
        asset: {
            type: "object",
            required: ["delegate"],
            properties: {
                delegate: {
                    type: "object",
                    required: ["username"],
                    properties: {
                        username: { $ref: "delegateUsername" },
                    },
                },
            },
        },
    },
});
const vote = extend(transactionBaseSchema, {
    $id: "vote",
    required: ["asset"],
    properties: {
        type: { transactionType: TransactionType.Vote },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 1 } },
        recipientId: { $ref: "address" },
        asset: {
            type: "object",
            required: ["votes"],
            properties: {
                votes: {
                    type: "array",
                    minItems: 1,
                    maxItems: 2,
                    additionalItems: false,
                    items: { $ref: "walletVote" },
                },
            },
        },
    },
});
const multiSignature = extend(transactionBaseSchema, {
    $id: "multiSignature",
    required: ["asset", "signatures"],
    properties: {
        type: { transactionType: TransactionType.MultiSignature },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 1 } },
        asset: {
            type: "object",
            required: ["multiSignature"],
            properties: {
                multiSignature: {
                    type: "object",
                    required: ["min", "publicKeys"],
                    properties: {
                        min: {
                            type: "integer",
                            minimum: 1,
                            maximum: { $data: "1/publicKeys/length" },
                        },
                        publicKeys: {
                            type: "array",
                            minItems: 1,
                            maxItems: 16,
                            additionalItems: false,
                            uniqueItems: true,
                            items: { $ref: "publicKey" },
                        },
                    },
                },
            },
        },
        signatures: {
            type: "array",
            minItems: { $data: "1/asset/multiSignature/min" },
            maxItems: { $data: "1/asset/multiSignature/publicKeys/length" },
            additionalItems: false,
            uniqueItems: true,
            items: { allOf: [{ minLength: 130, maxLength: 130 }, { $ref: "alphanumeric" }] },
        },
    },
});
// Multisignature legacy transactions have a different signatures property.
// Then we delete the "signatures" property definition to implement our own.
const transactionBaseSchemaNoSignatures = extend(transactionBaseSchema, {});
delete transactionBaseSchemaNoSignatures.properties.signatures;
const multiSignatureLegacy = extend(transactionBaseSchemaNoSignatures, {
    $id: "multiSignatureLegacy",
    required: ["asset"],
    properties: {
        version: { anyOf: [{ type: "null" }, { const: 1 }] },
        type: { transactionType: TransactionType.MultiSignature },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 1 } },
        asset: {
            type: "object",
            required: ["multiSignatureLegacy"],
            properties: {
                multiSignatureLegacy: {
                    type: "object",
                    required: ["keysgroup", "min", "lifetime"],
                    properties: {
                        min: {
                            type: "integer",
                            minimum: 1,
                            maximum: { $data: "1/keysgroup/length" },
                        },
                        lifetime: {
                            type: "integer",
                            minimum: 1,
                            maximum: 72,
                        },
                        keysgroup: {
                            type: "array",
                            minItems: 1,
                            maxItems: 16,
                            additionalItems: false,
                            items: {
                                allOf: [{ type: "string", minimum: 67, maximum: 67, transform: ["toLowerCase"] }],
                            },
                        },
                    },
                },
            },
        },
        signatures: {
            type: "array",
            minItems: 1,
            maxItems: 1,
            additionalItems: false,
            items: { $ref: "alphanumeric" },
        },
    },
});
const ipfs = extend(transactionBaseSchema, {
    $id: "ipfs",
    properties: {
        type: { transactionType: TransactionType.Ipfs },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 1 } },
        asset: {
            type: "object",
            required: ["ipfs"],
            properties: {
                ipfs: {
                    allOf: [{ minLength: 2, maxLength: 90 }, { $ref: "base58" }],
                },
            },
        },
    },
});
const htlcLock = extend(transactionBaseSchema, {
    $id: "htlcLock",
    properties: {
        type: { transactionType: TransactionType.HtlcLock },
        amount: { bignumber: { minimum: 1 } },
        fee: { bignumber: { minimum: 1 } },
        recipientId: { $ref: "address" },
        vendorField: { anyOf: [{ type: "null" }, { type: "string", format: "vendorField" }] },
        asset: {
            type: "object",
            required: ["lock"],
            properties: {
                lock: {
                    type: "object",
                    required: ["secretHash", "expiration"],
                    properties: {
                        secretHash: { allOf: [{ minLength: 64, maxLength: 64 }, { $ref: "hex" }] },
                        expiration: {
                            type: "object",
                            required: ["type", "value"],
                            properties: {
                                type: { enum: [1, 2] },
                                value: { type: "integer", minimum: 0 },
                            },
                        },
                    },
                },
            },
        },
    },
});
const htlcClaim = extend(transactionBaseSchema, {
    $id: "htlcClaim",
    properties: {
        type: { transactionType: TransactionType.HtlcClaim },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 0, maximum: 0 } },
        asset: {
            type: "object",
            required: ["claim"],
            properties: {
                claim: {
                    type: "object",
                    required: ["lockTransactionId", "unlockSecret"],
                    properties: {
                        lockTransactionId: { $ref: "transactionId" },
                        unlockSecret: { allOf: [{ minLength: 64, maxLength: 64 }, { $ref: "hex" }] },
                    },
                },
            },
        },
    },
});
const htlcRefund = extend(transactionBaseSchema, {
    $id: "htlcRefund",
    properties: {
        type: { transactionType: TransactionType.HtlcRefund },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 0, maximum: 0 } },
        asset: {
            type: "object",
            required: ["refund"],
            properties: {
                refund: {
                    type: "object",
                    required: ["lockTransactionId"],
                    properties: {
                        lockTransactionId: { $ref: "transactionId" },
                    },
                },
            },
        },
    },
});
const multiPayment = extend(transactionBaseSchema, {
    $id: "multiPayment",
    properties: {
        type: { transactionType: TransactionType.MultiPayment },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 1 } },
        vendorField: { anyOf: [{ type: "null" }, { type: "string", format: "vendorField" }] },
        asset: {
            type: "object",
            required: ["payments"],
            properties: {
                payments: {
                    type: "array",
                    minItems: 2,
                    additionalItems: false,
                    uniqueItems: false,
                    items: {
                        type: "object",
                        required: ["amount", "recipientId"],
                        properties: {
                            amount: { bignumber: { minimum: 1 } },
                            recipientId: { $ref: "address" },
                        },
                    },
                },
            },
        },
    },
});
const delegateResignation = extend(transactionBaseSchema, {
    $id: "delegateResignation",
    properties: {
        type: { transactionType: TransactionType.DelegateResignation },
        amount: { bignumber: { minimum: 0, maximum: 0 } },
        fee: { bignumber: { minimum: 1 } },
    },
});

var schemas = /*#__PURE__*/Object.freeze({
  __proto__: null,
  transactionBaseSchema: transactionBaseSchema,
  extend: extend,
  signedSchema: signedSchema,
  strictSchema: strictSchema,
  transfer: transfer,
  secondSignature: secondSignature,
  delegateRegistration: delegateRegistration,
  vote: vote,
  multiSignature: multiSignature,
  multiSignatureLegacy: multiSignatureLegacy,
  ipfs: ipfs,
  htlcLock: htlcLock,
  htlcClaim: htlcClaim,
  htlcRefund: htlcRefund,
  multiPayment: multiPayment,
  delegateResignation: delegateResignation
});

const vendorField = (ajv) => {
    ajv.addFormat("vendorField", (data) => {
        try {
            return Buffer.from(data, "utf8").length <= maxVendorFieldLength();
        }
        catch (_a) {
            return false;
        }
    });
};
const validPeer = (ajv) => {
    ajv.addFormat("peer", (ip) => {
        try {
            return isValidPeer({ ip }, false);
        }
        catch (_a) {
            return false;
        }
    });
};
const formats = [vendorField, validPeer];

const maxBytes = (ajv) => {
    ajv.addKeyword("maxBytes", {
        type: "string",
        compile(schema, parentSchema) {
            return (data) => {
                if (parentSchema.type !== "string") {
                    return false;
                }
                return Buffer.from(data, "utf8").byteLength <= schema;
            };
        },
        errors: false,
        metaSchema: {
            type: "integer",
            minimum: 0,
        },
    });
};
const transactionType = (ajv) => {
    ajv.addKeyword("transactionType", {
        // @ts-ignore
        compile(schema) {
            return (data, dataPath, parentObject) => {
                // Impose dynamic multipayment limit based on milestone
                if (data === TransactionType.MultiPayment &&
                    parentObject &&
                    (!parentObject.typeGroup || parentObject.typeGroup === 1)) {
                    if (parentObject.asset && parentObject.asset.payments) {
                        const limit = configManager.getMilestone().multiPaymentLimit || 256;
                        return parentObject.asset.payments.length <= limit;
                    }
                }
                return data === schema;
            };
        },
        errors: false,
        metaSchema: {
            type: "integer",
            minimum: 0,
        },
    });
};
const network = (ajv) => {
    ajv.addKeyword("network", {
        compile(schema) {
            return (data) => {
                return schema && data === configManager.get("network.pubKeyHash");
            };
        },
        errors: false,
        metaSchema: {
            type: "boolean",
        },
    });
};
const bignumber = (ajv) => {
    const instanceOf = ajvKeywords.get("instanceof").definition;
    instanceOf.CONSTRUCTORS.BigNumber = BigNumber;
    ajv.addKeyword("bignumber", {
        compile(schema) {
            return (data, dataPath, parentObject, property) => {
                const minimum = typeof schema.minimum !== "undefined" ? schema.minimum : 0;
                const maximum = typeof schema.maximum !== "undefined" ? schema.maximum : "9223372036854775807"; // 8 byte maximum
                if (data !== 0 && !data) {
                    return false;
                }
                let bignum;
                try {
                    bignum = BigNumber.make(data);
                }
                catch (_a) {
                    return false;
                }
                if (parentObject && property) {
                    parentObject[property] = bignum;
                }
                let bypassGenesis = false;
                if (schema.bypassGenesis) {
                    if (parentObject.id) {
                        if (schema.block) {
                            bypassGenesis = parentObject.height === 1;
                        }
                        else {
                            bypassGenesis = isGenesisTransaction(parentObject.id);
                        }
                    }
                }
                if (bignum.isLessThan(minimum) && !(bignum.isZero() && bypassGenesis)) {
                    return false;
                }
                if (bignum.isGreaterThan(maximum) && !bypassGenesis) {
                    return false;
                }
                return true;
            };
        },
        errors: false,
        modifying: true,
        metaSchema: {
            type: "object",
            properties: {
                minimum: { type: "integer" },
                maximum: { type: "integer" },
                bypassGenesis: { type: "boolean" },
                block: { type: "boolean" },
            },
            additionalItems: false,
        },
    });
};
const blockId = (ajv) => {
    ajv.addKeyword("blockId", {
        compile(schema) {
            return (data, dataPath, parentObject) => {
                if (parentObject && parentObject.height === 1 && schema.allowNullWhenGenesis) {
                    if (!data || Number(data) === 0) {
                        return true;
                    }
                }
                if (typeof data !== "string") {
                    return false;
                }
                // Partial SHA256 block id (old/legacy), before the switch to full SHA256.
                // 8 byte integer either decimal without leading zeros or hex with leading zeros.
                const isPartial = /^[0-9]{1,20}$/.test(data) || /^[0-9a-f]{16}$/i.test(data);
                const isFullSha256 = /^[0-9a-f]{64}$/i.test(data);
                if (parentObject && parentObject.height) {
                    const height = schema.isPreviousBlock ? parentObject.height - 1 : parentObject.height;
                    const constants = configManager.getMilestone(height !== null && height !== void 0 ? height : 1); // if height === 0 set it to 1
                    return constants.block.idFullSha256 ? isFullSha256 : isPartial;
                }
                return isPartial || isFullSha256;
            };
        },
        errors: false,
        metaSchema: {
            type: "object",
            properties: {
                allowNullWhenGenesis: { type: "boolean" },
                isPreviousBlock: { type: "boolean" },
            },
            additionalItems: false,
        },
    });
};
const keywords = [bignumber, blockId, maxBytes, network, transactionType];

const schemas$1 = {
    hex: {
        $id: "hex",
        type: "string",
        pattern: "^[0123456789A-Fa-f]+$",
    },
    base58: {
        $id: "base58",
        type: "string",
        pattern: "^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$",
    },
    alphanumeric: {
        $id: "alphanumeric",
        type: "string",
        pattern: "^[a-zA-Z0-9]+$",
    },
    transactionId: {
        $id: "transactionId",
        allOf: [{ minLength: 64, maxLength: 64 }, { $ref: "hex" }],
    },
    networkByte: {
        $id: "networkByte",
        network: true,
    },
    address: {
        $id: "address",
        allOf: [{ minLength: 34, maxLength: 34 }, { $ref: "base58" }],
    },
    publicKey: {
        $id: "publicKey",
        allOf: [{ minLength: 66, maxLength: 66 }, { $ref: "hex" }, { transform: ["toLowerCase"] }],
    },
    walletVote: {
        $id: "walletVote",
        allOf: [{ type: "string", pattern: "^[+|-][a-zA-Z0-9]{66}$" }, { transform: ["toLowerCase"] }],
    },
    username: {
        $id: "delegateUsername",
        allOf: [
            { type: "string", pattern: "^[a-z0-9!@$&_.]+$" },
            { minLength: 1, maxLength: 20 },
            { transform: ["toLowerCase"] },
        ],
    },
    genericName: {
        $id: "genericName",
        allOf: [
            { type: "string", pattern: "^[a-zA-Z0-9]+(( - |[ ._-])[a-zA-Z0-9]+)*[.]?$" },
            { minLength: 1, maxLength: 40 },
        ],
    },
    uri: {
        $id: "uri",
        allOf: [{ format: "uri" }, { minLength: 4, maxLength: 80 }],
    },
    blockHeader: {
        $id: "blockHeader",
        type: "object",
        required: [
            "id",
            "timestamp",
            "previousBlock",
            "height",
            "totalAmount",
            "totalFee",
            "reward",
            "generatorPublicKey",
            "blockSignature",
        ],
        properties: {
            id: { blockId: {} },
            idHex: { blockId: {} },
            version: { type: "integer", minimum: 0 },
            timestamp: { type: "integer", minimum: 0 },
            previousBlock: { blockId: { allowNullWhenGenesis: true, isPreviousBlock: true } },
            previousBlockHex: { blockId: { allowNullWhenGenesis: true, isPreviousBlock: true } },
            height: { type: "integer", minimum: 1 },
            numberOfTransactions: { type: "integer" },
            totalAmount: { bignumber: { minimum: 0, bypassGenesis: true, block: true } },
            totalFee: { bignumber: { minimum: 0, bypassGenesis: true, block: true } },
            reward: { bignumber: { minimum: 0 } },
            payloadLength: { type: "integer", minimum: 0 },
            payloadHash: { $ref: "hex" },
            generatorPublicKey: { $ref: "publicKey" },
            blockSignature: { $ref: "hex" },
        },
    },
    block: {
        $id: "block",
        $ref: "blockHeader",
        properties: {
            transactions: {
                $ref: "transactions",
                minItems: { $data: "1/numberOfTransactions" },
                maxItems: { $data: "1/numberOfTransactions" },
            },
        },
    },
};

class Validator {
    constructor(options) {
        this.transactionSchemas = new Map();
        this.ajv = this.instantiateAjv(options);
    }
    static make(options = {}) {
        return new Validator(options);
    }
    getInstance() {
        return this.ajv;
    }
    validate(schemaKeyRef, data) {
        return this.validateSchema(this.ajv, schemaKeyRef, data);
    }
    validateException(schemaKeyRef, data) {
        const ajv = this.instantiateAjv({ allErrors: true, verbose: true });
        for (const schema of this.transactionSchemas.values()) {
            this.extendTransactionSchema(ajv, schema);
        }
        return this.validateSchema(ajv, schemaKeyRef, data);
    }
    addFormat(name, format) {
        this.ajv.addFormat(name, format);
    }
    addKeyword(keyword, definition) {
        this.ajv.addKeyword(keyword, definition);
    }
    addSchema(schema, key) {
        this.ajv.addSchema(schema, key);
    }
    removeKeyword(keyword) {
        this.ajv.removeKeyword(keyword);
    }
    removeSchema(schemaKeyRef) {
        this.ajv.removeSchema(schemaKeyRef);
    }
    extendTransaction(schema, remove) {
        this.extendTransactionSchema(this.ajv, schema, remove);
    }
    validateSchema(ajv, schemaKeyRef, data) {
        try {
            ajv.validate(schemaKeyRef, data);
            const error = ajv.errors ? ajv.errorsText() : undefined;
            return { value: data, error, errors: ajv.errors || undefined };
        }
        catch (error) {
            return { value: undefined, error: error.stack, errors: [] };
        }
    }
    instantiateAjv(options) {
        const ajv = new Ajv(Object.assign({
            $data: true,
            schemas: schemas$1,
            removeAdditional: true,
            extendRefs: true,
        }, options));
        ajvKeywords(ajv);
        for (const addKeyword of keywords) {
            addKeyword(ajv);
        }
        for (const addFormat of formats) {
            addFormat(ajv);
        }
        return ajv;
    }
    extendTransactionSchema(ajv, schema, remove) {
        if (ajv.getSchema(schema.$id)) {
            remove = true;
        }
        if (remove) {
            this.transactionSchemas.delete(schema.$id);
            ajv.removeSchema(schema.$id);
            ajv.removeSchema(`${schema.$id}Signed`);
            ajv.removeSchema(`${schema.$id}Strict`);
        }
        this.transactionSchemas.set(schema.$id, schema);
        ajv.addSchema(schema);
        ajv.addSchema(signedSchema(schema));
        ajv.addSchema(strictSchema(schema));
        this.updateTransactionArray(ajv);
    }
    updateTransactionArray(ajv) {
        ajv.removeSchema("block");
        ajv.removeSchema("transactions");
        ajv.addSchema({
            $id: "transactions",
            type: "array",
            additionalItems: false,
            items: { anyOf: [...this.transactionSchemas.keys()].map((schema) => ({ $ref: `${schema}Signed` })) },
        });
        ajv.addSchema(schemas$1.block);
    }
}
const validator = Validator.make();

var index$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Validator: Validator,
  validator: validator
});

class InternalTransactionType {
    constructor(type, typeGroup) {
        this.type = type;
        this.typeGroup = typeGroup;
    }
    static from(type, typeGroup) {
        if (typeGroup === undefined) {
            typeGroup = TransactionTypeGroup.Core;
        }
        const compositeType = `${typeGroup}-${type}`;
        if (!this.types.has(compositeType)) {
            this.types.set(compositeType, new InternalTransactionType(type, typeGroup));
        }
        return this.types.get(compositeType);
    }
    toString() {
        if (this.typeGroup === TransactionTypeGroup.Core) {
            return `Core/${this.type}`;
        }
        return `${this.typeGroup}/${this.type}`;
    }
}
InternalTransactionType.types = new Map();

class TransactionTypeFactory {
    static initialize(transactionTypes) {
        this.transactionTypes = transactionTypes;
    }
    static create(data) {
        const instance = new (this.get(data.type, data.typeGroup, data.version))();
        instance.data = data;
        instance.data.version = data.version || 1;
        return instance;
    }
    static get(type, typeGroup, version) {
        var _a;
        const internalType = InternalTransactionType.from(type, typeGroup);
        if (!this.transactionTypes.has(internalType)) {
            throw new UnkownTransactionError(internalType.toString());
        }
        // Either there is a match for the provided version or use the first available constructor as a fallback
        const constructor = (_a = this.transactionTypes
            .get(internalType)) === null || _a === void 0 ? void 0 : _a.get(version || 1);
        return constructor !== null && constructor !== void 0 ? constructor : [...this.transactionTypes.get(internalType).values()][0];
    }
}

// Reference: https://github.com/ArkEcosystem/AIPs/blob/master/AIPS/aip-11.md
class Serializer {
    static getBytes(transaction, options = {}) {
        const version = transaction.version || 1;
        if (options.acceptLegacyVersion || options.disableVersionCheck || isSupportedTransactionVersion(version)) {
            if (version === 1) {
                return this.getBytesV1(transaction, options);
            }
            return this.serialize(TransactionTypeFactory.create(transaction), options);
        }
        else {
            throw new TransactionVersionError(version);
        }
    }
    /**
     * Serializes the given transaction according to AIP11.
     */
    static serialize(transaction, options = {}) {
        const buffer = new ByteBuffer(512, true);
        this.serializeCommon(transaction.data, buffer);
        this.serializeVendorField(transaction, buffer);
        const serialized = transaction.serialize(options);
        if (!serialized) {
            throw new Error();
        }
        const typeBuffer = serialized.flip();
        buffer.append(typeBuffer);
        this.serializeSignatures(transaction.data, buffer, options);
        const flippedBuffer = buffer.flip().toBuffer();
        transaction.serialized = flippedBuffer;
        return flippedBuffer;
    }
    /**
     * Serializes the given transaction prior to AIP11 (legacy).
     */
    static getBytesV1(transaction, options = {}) {
        let assetSize = 0;
        let assetBytes;
        if (transaction.type === TransactionType.SecondSignature && transaction.asset) {
            const { signature } = transaction.asset;
            const bb = new ByteBuffer(33, true);
            if (signature && signature.publicKey) {
                const publicKeyBuffer = Buffer.from(signature.publicKey, "hex");
                for (const byte of publicKeyBuffer) {
                    bb.writeByte(byte);
                }
            }
            bb.flip();
            assetBytes = new Uint8Array(bb.toArrayBuffer());
            assetSize = assetBytes.length;
        }
        if (transaction.type === TransactionType.DelegateRegistration &&
            transaction.asset &&
            transaction.asset.delegate) {
            assetBytes = Buffer.from(transaction.asset.delegate.username, "utf8");
            assetSize = assetBytes.length;
        }
        if (transaction.type === TransactionType.Vote && transaction.asset && transaction.asset.votes) {
            assetBytes = Buffer.from(transaction.asset.votes.join(""), "utf8");
            assetSize = assetBytes.length;
        }
        if (transaction.type === TransactionType.MultiSignature &&
            transaction.asset &&
            transaction.asset.multiSignatureLegacy) {
            const keysgroupBuffer = Buffer.from(transaction.asset.multiSignatureLegacy.keysgroup.join(""), "utf8");
            const bb = new ByteBuffer(1 + 1 + keysgroupBuffer.length, true);
            bb.writeByte(transaction.asset.multiSignatureLegacy.min);
            bb.writeByte(transaction.asset.multiSignatureLegacy.lifetime);
            for (const byte of keysgroupBuffer) {
                bb.writeByte(byte);
            }
            bb.flip();
            assetBytes = bb.toBuffer();
            if (assetBytes) {
                assetSize = assetBytes.length;
            }
        }
        const bb = new ByteBuffer(1 + 4 + 32 + 8 + 8 + 21 + 64 + 64 + 64 + assetSize, true);
        bb.writeByte(transaction.type);
        bb.writeInt(transaction.timestamp);
        if (transaction.senderPublicKey) {
            const senderPublicKeyBuffer = Buffer.from(transaction.senderPublicKey, "hex");
            for (const byte of senderPublicKeyBuffer) {
                bb.writeByte(byte);
            }
            // Apply fix for broken type 1 and 4 transactions, which were
            // erroneously calculated with a recipient id.
            const { transactionIdFixTable } = configManager.get("exceptions");
            const isBrokenTransaction = transactionIdFixTable && Object.values(transactionIdFixTable).includes(transaction.id);
            if (isBrokenTransaction || (transaction.recipientId && transaction.type !== 1 && transaction.type !== 4)) {
                const recipientId = transaction.recipientId || Address.fromPublicKey(transaction.senderPublicKey, transaction.network);
                const recipient = Address.toBuffer(recipientId).addressBuffer;
                for (const byte of recipient) {
                    bb.writeByte(byte);
                }
            }
            else {
                for (let i = 0; i < 21; i++) {
                    bb.writeByte(0);
                }
            }
        }
        if (transaction.vendorField) {
            const vf = Buffer.from(transaction.vendorField);
            const fillstart = vf.length;
            for (let i = 0; i < fillstart; i++) {
                bb.writeByte(vf[i]);
            }
            for (let i = fillstart; i < 64; i++) {
                bb.writeByte(0);
            }
        }
        else {
            for (let i = 0; i < 64; i++) {
                bb.writeByte(0);
            }
        }
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        bb.writeInt64(transaction.amount.toString());
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        bb.writeInt64(transaction.fee.toString());
        if (assetSize > 0 && assetBytes) {
            for (let i = 0; i < assetSize; i++) {
                bb.writeByte(assetBytes[i]);
            }
        }
        if (!options.excludeSignature && transaction.signature) {
            const signatureBuffer = Buffer.from(transaction.signature, "hex");
            for (const byte of signatureBuffer) {
                bb.writeByte(byte);
            }
        }
        if (!options.excludeSecondSignature && transaction.secondSignature) {
            const signSignatureBuffer = Buffer.from(transaction.secondSignature, "hex");
            for (const byte of signSignatureBuffer) {
                bb.writeByte(byte);
            }
        }
        bb.flip();
        const arrayBuffer = new Uint8Array(bb.toArrayBuffer());
        const buffer = [];
        for (let i = 0; i < arrayBuffer.length; i++) {
            buffer[i] = arrayBuffer[i];
        }
        return Buffer.from(buffer);
    }
    static serializeCommon(transaction, buffer) {
        transaction.version = transaction.version || 0x01;
        if (transaction.typeGroup === undefined) {
            transaction.typeGroup = TransactionTypeGroup.Core;
        }
        buffer.writeByte(0xff);
        buffer.writeByte(transaction.version);
        buffer.writeByte(transaction.network || configManager.get("network.pubKeyHash"));
        if (transaction.version === 1) {
            buffer.writeByte(transaction.type);
            buffer.writeUint32(transaction.timestamp);
        }
        else {
            buffer.writeUint32(transaction.typeGroup);
            buffer.writeUint16(transaction.type);
            if (transaction.nonce) {
                // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
                buffer.writeUint64(transaction.nonce.toString());
            }
        }
        if (transaction.senderPublicKey) {
            buffer.append(transaction.senderPublicKey, "hex");
        }
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        buffer.writeUint64(transaction.fee.toString());
    }
    static serializeVendorField(transaction, buffer) {
        if (transaction.hasVendorField()) {
            const { data } = transaction;
            if (data.vendorField) {
                const vf = Buffer.from(data.vendorField, "utf8");
                buffer.writeByte(vf.length);
                buffer.append(vf);
            }
            else {
                buffer.writeByte(0x00);
            }
        }
        else {
            buffer.writeByte(0x00);
        }
    }
    static serializeSignatures(transaction, buffer, options = {}) {
        if (transaction.signature && !options.excludeSignature) {
            buffer.append(transaction.signature, "hex");
        }
        const secondSignature = transaction.secondSignature || transaction.signSignature;
        if (secondSignature && !options.excludeSecondSignature) {
            buffer.append(secondSignature, "hex");
        }
        if (transaction.signatures) {
            if (transaction.version === 1 && isException(transaction)) {
                buffer.append("ff", "hex"); // 0xff separator to signal start of multi-signature transactions
                buffer.append(transaction.signatures.join(""), "hex");
            }
            else if (!options.excludeMultiSignature) {
                buffer.append(transaction.signatures.join(""), "hex");
            }
        }
    }
}

class Utils {
    static toBytes(data) {
        return Serializer.serialize(TransactionTypeFactory.create(data));
    }
    static toHash(transaction, options) {
        return HashAlgorithms.sha256(Serializer.getBytes(transaction, options));
    }
    static getId(transaction, options = {}) {
        const id = Utils.toHash(transaction, options).toString("hex");
        // WORKAROUND:
        // A handful of mainnet transactions have an invalid recipient. Due to a
        // refactor of the Address network byte validation it is no longer
        // trivially possible to handle them. If an invalid address is encountered
        // during transfer serialization, the error is bubbled up to defer the
        // `AddressNetworkByteError` until the actual id is available to call
        // `isException`.
        if (options.addressError && !isException({ id })) {
            throw new AddressNetworkError(options.addressError);
        }
        // Apply fix for broken type 1 and 4 transactions, which were
        // erroneously calculated with a recipient id.
        const { transactionIdFixTable } = configManager.get("exceptions");
        if (transactionIdFixTable && transactionIdFixTable[id]) {
            return transactionIdFixTable[id];
        }
        return id;
    }
}

class Verifier {
    static verify(data, options) {
        if (isException(data)) {
            return true;
        }
        if (configManager.getMilestone().aip11 && (!data.version || data.version === 1)) {
            return false;
        }
        return Verifier.verifyHash(data, options === null || options === void 0 ? void 0 : options.disableVersionCheck);
    }
    static verifySecondSignature(transaction, publicKey, options) {
        const secondSignature = transaction.secondSignature || transaction.signSignature;
        if (!secondSignature) {
            return false;
        }
        const hash = Utils.toHash(transaction, {
            disableVersionCheck: options === null || options === void 0 ? void 0 : options.disableVersionCheck,
            excludeSecondSignature: true,
        });
        return this.internalVerifySignature(hash, secondSignature, publicKey);
    }
    static verifySignatures(transaction, multiSignature) {
        if (!multiSignature) {
            throw new InvalidMultiSignatureAssetError();
        }
        const { publicKeys, min } = multiSignature;
        const { signatures } = transaction;
        const hash = Utils.toHash(transaction, {
            excludeSignature: true,
            excludeSecondSignature: true,
            excludeMultiSignature: true,
        });
        const publicKeyIndexes = {};
        let verified = false;
        let verifiedSignatures = 0;
        if (signatures) {
            for (let i = 0; i < signatures.length; i++) {
                const signature = signatures[i];
                const publicKeyIndex = parseInt(signature.slice(0, 2), 16);
                if (!publicKeyIndexes[publicKeyIndex]) {
                    publicKeyIndexes[publicKeyIndex] = true;
                }
                else {
                    throw new DuplicateParticipantInMultiSignatureError();
                }
                const partialSignature = signature.slice(2, 130);
                const publicKey = publicKeys[publicKeyIndex];
                if (Hash.verifySchnorr(hash, partialSignature, publicKey)) {
                    verifiedSignatures++;
                }
                if (verifiedSignatures === min) {
                    verified = true;
                    break;
                }
                else if (signatures.length - (i + 1 - verifiedSignatures) < min) {
                    break;
                }
            }
        }
        return verified;
    }
    static verifyHash(data, disableVersionCheck = false) {
        const { signature, senderPublicKey } = data;
        if (!signature || !senderPublicKey) {
            return false;
        }
        const hash = Utils.toHash(data, {
            disableVersionCheck,
            excludeSignature: true,
            excludeSecondSignature: true,
        });
        return this.internalVerifySignature(hash, signature, senderPublicKey);
    }
    static verifySchema(data, strict = true) {
        const transactionType = TransactionTypeFactory.get(data.type, data.typeGroup, data.version);
        if (!transactionType) {
            throw new Error();
        }
        const { $id } = transactionType.getSchema();
        return validator.validate(strict ? `${$id}Strict` : `${$id}`, data);
    }
    static internalVerifySignature(hash, signature, publicKey) {
        const isSchnorr = Buffer.from(signature, "hex").byteLength === 64;
        if (isSchnorr) {
            return Hash.verifySchnorr(hash, signature, publicKey);
        }
        return Hash.verifyECDSA(hash, signature, publicKey);
    }
}

class Transaction {
    constructor() {
        this.isVerified = false;
    }
    static getSchema() {
        throw new NotImplemented();
    }
    static staticFee(feeContext = {}) {
        const milestones = configManager.getMilestone(feeContext.height);
        if (milestones.fees && milestones.fees.staticFees && this.key) {
            const fee = milestones.fees.staticFees[this.key];
            if (fee !== undefined) {
                return BigNumber.make(fee);
            }
        }
        return this.defaultStaticFee;
    }
    verify(options) {
        return Verifier.verify(this.data, options);
    }
    verifySecondSignature(publicKey) {
        return Verifier.verifySecondSignature(this.data, publicKey);
    }
    verifySchema() {
        return Verifier.verifySchema(this.data);
    }
    toJson() {
        const data = JSON.parse(JSON.stringify(this.data));
        if (data.typeGroup === TransactionTypeGroup.Core) {
            delete data.typeGroup;
        }
        if (data.version === 1) {
            delete data.nonce;
        }
        else {
            delete data.timestamp;
        }
        return data;
    }
    toString() {
        const parts = [];
        if (this.data.senderPublicKey && this.data.nonce) {
            parts.push(`${Address.fromPublicKey(this.data.senderPublicKey)}#${this.data.nonce}`);
        }
        else if (this.data.senderPublicKey) {
            parts.push(`${Address.fromPublicKey(this.data.senderPublicKey)}`);
        }
        if (this.data.id) {
            parts.push(this.data.id.slice(-8));
        }
        parts.push(`${this.key[0].toUpperCase()}${this.key.slice(1)} v${this.data.version}`);
        return parts.join(" ");
    }
    hasVendorField() {
        return false;
    }
    get id() {
        return this.data.id;
    }
    get type() {
        return this.data.type;
    }
    get typeGroup() {
        return this.data.typeGroup;
    }
    get verified() {
        return this.isVerified;
    }
    get key() {
        return this.__proto__.constructor.key;
    }
    get staticFee() {
        return this.__proto__.constructor.staticFee({ data: this.data });
    }
}
Transaction.type = undefined;
Transaction.typeGroup = undefined;
Transaction.version = 1;
Transaction.key = undefined;
Transaction.defaultStaticFee = BigNumber.ZERO;

class TransferTransaction extends Transaction {
    static getSchema() {
        return transfer;
    }
    hasVendorField() {
        return true;
    }
    serialize(options) {
        const { data } = this;
        const buffer = new ByteBuffer(24, true);
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        buffer.writeUint64(data.amount.toString());
        buffer.writeUint32(data.expiration || 0);
        if (data.recipientId) {
            const { addressBuffer, addressError } = Address.toBuffer(data.recipientId);
            if (options) {
                options.addressError = addressError;
            }
            buffer.append(addressBuffer);
        }
        return buffer;
    }
    deserialize(buf) {
        const { data } = this;
        data.amount = BigNumber.make(buf.readUint64().toString());
        data.expiration = buf.readUint32();
        data.recipientId = Address.fromBuffer(buf.readBytes(21).toBuffer());
    }
}
TransferTransaction.typeGroup = TransactionTypeGroup.Core;
TransferTransaction.type = TransactionType.Transfer;
TransferTransaction.key = "transfer";
TransferTransaction.version = 1;
TransferTransaction.defaultStaticFee = BigNumber.make("10000000");

class SecondSignatureRegistrationTransaction extends Transaction {
    static getSchema() {
        return secondSignature;
    }
    serialize(options) {
        const { data } = this;
        const buffer = new ByteBuffer(33, true);
        if (data.asset && data.asset.signature) {
            buffer.append(data.asset.signature.publicKey, "hex");
        }
        return buffer;
    }
    deserialize(buf) {
        const { data } = this;
        data.asset = {
            signature: {
                publicKey: buf.readBytes(33).toString("hex"),
            },
        };
    }
}
SecondSignatureRegistrationTransaction.typeGroup = TransactionTypeGroup.Core;
SecondSignatureRegistrationTransaction.type = TransactionType.SecondSignature;
SecondSignatureRegistrationTransaction.key = "secondSignature";
SecondSignatureRegistrationTransaction.version = 1;
SecondSignatureRegistrationTransaction.defaultStaticFee = BigNumber.make("500000000");

class DelegateRegistrationTransaction extends Transaction {
    static getSchema() {
        return delegateRegistration;
    }
    serialize(options) {
        const { data } = this;
        if (data.asset && data.asset.delegate) {
            const delegateBytes = Buffer.from(data.asset.delegate.username, "utf8");
            const buffer = new ByteBuffer(delegateBytes.length, true);
            buffer.writeByte(delegateBytes.length);
            buffer.append(delegateBytes, "hex");
            return buffer;
        }
        return undefined;
    }
    deserialize(buf) {
        const { data } = this;
        const usernamelength = buf.readUint8();
        data.asset = {
            delegate: {
                username: buf.readString(usernamelength),
            },
        };
    }
}
DelegateRegistrationTransaction.typeGroup = TransactionTypeGroup.Core;
DelegateRegistrationTransaction.type = TransactionType.DelegateRegistration;
DelegateRegistrationTransaction.key = "delegateRegistration";
DelegateRegistrationTransaction.version = 1;
DelegateRegistrationTransaction.defaultStaticFee = BigNumber.make("2500000000");

class VoteTransaction extends Transaction {
    static getSchema() {
        return vote;
    }
    serialize(options) {
        const { data } = this;
        const buffer = new ByteBuffer(24, true);
        if (data.asset && data.asset.votes) {
            const voteBytes = data.asset.votes
                .map((vote) => (vote.startsWith("+") ? "01" : "00") + vote.slice(1))
                .join("");
            buffer.writeByte(data.asset.votes.length);
            buffer.append(voteBytes, "hex");
        }
        return buffer;
    }
    deserialize(buf) {
        const { data } = this;
        const votelength = buf.readUint8();
        data.asset = { votes: [] };
        for (let i = 0; i < votelength; i++) {
            let vote = buf.readBytes(34).toString("hex");
            vote = (vote[1] === "1" ? "+" : "-") + vote.slice(2);
            if (data.asset && data.asset.votes) {
                data.asset.votes.push(vote);
            }
        }
    }
}
VoteTransaction.typeGroup = TransactionTypeGroup.Core;
VoteTransaction.type = TransactionType.Vote;
VoteTransaction.key = "vote";
VoteTransaction.version = 1;
VoteTransaction.defaultStaticFee = BigNumber.make("100000000");

class MultiSignatureRegistrationTransaction extends Transaction {
    static getSchema() {
        return multiSignatureLegacy;
    }
    static staticFee(feeContext = {}) {
        var _a, _b;
        if ((_b = (_a = feeContext.data) === null || _a === void 0 ? void 0 : _a.asset) === null || _b === void 0 ? void 0 : _b.multiSignatureLegacy) {
            return super.staticFee(feeContext).times(feeContext.data.asset.multiSignatureLegacy.keysgroup.length + 1);
        }
        return super.staticFee(feeContext);
    }
    verify() {
        return isException(this.data);
    }
    serialize(options) {
        const { data } = this;
        const legacyAsset = data.asset.multiSignatureLegacy;
        const joined = legacyAsset.keysgroup.map((k) => (k.startsWith("+") ? k.slice(1) : k)).join("");
        const keysgroupBuffer = Buffer.from(joined, "hex");
        const buffer = new ByteBuffer(keysgroupBuffer.length + 3, true);
        buffer.writeByte(legacyAsset.min);
        buffer.writeByte(legacyAsset.keysgroup.length);
        buffer.writeByte(legacyAsset.lifetime);
        buffer.append(keysgroupBuffer, "hex");
        return buffer;
    }
    deserialize(buf) {
        const { data } = this;
        const multiSignatureLegacy = { keysgroup: [], lifetime: 0, min: 0 };
        multiSignatureLegacy.min = buf.readUint8();
        const num = buf.readUint8();
        multiSignatureLegacy.lifetime = buf.readUint8();
        for (let index = 0; index < num; index++) {
            const key = buf.readBytes(33).toString("hex");
            multiSignatureLegacy.keysgroup.push(key);
        }
        data.asset = { multiSignatureLegacy };
    }
}
MultiSignatureRegistrationTransaction.typeGroup = TransactionTypeGroup.Core;
MultiSignatureRegistrationTransaction.type = TransactionType.MultiSignature;
MultiSignatureRegistrationTransaction.key = "multiSignature";
MultiSignatureRegistrationTransaction.version = 1;
MultiSignatureRegistrationTransaction.defaultStaticFee = BigNumber.make("500000000");

var index$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TransferTransaction: TransferTransaction,
  SecondSignatureRegistrationTransaction: SecondSignatureRegistrationTransaction,
  DelegateRegistrationTransaction: DelegateRegistrationTransaction,
  VoteTransaction: VoteTransaction,
  MultiSignatureRegistrationTransaction: MultiSignatureRegistrationTransaction
});

class TransferTransaction$1 extends TransferTransaction {
}
TransferTransaction$1.version = 2;

class SecondSignatureRegistrationTransaction$1 extends SecondSignatureRegistrationTransaction {
}
SecondSignatureRegistrationTransaction$1.version = 2;

class DelegateRegistrationTransaction$1 extends DelegateRegistrationTransaction {
}
DelegateRegistrationTransaction$1.version = 2;

class VoteTransaction$1 extends VoteTransaction {
}
VoteTransaction$1.version = 2;

class MultiSignatureRegistrationTransaction$1 extends Transaction {
    static getSchema() {
        return multiSignature;
    }
    static staticFee(feeContext = {}) {
        var _a, _b;
        if ((_b = (_a = feeContext.data) === null || _a === void 0 ? void 0 : _a.asset) === null || _b === void 0 ? void 0 : _b.multiSignature) {
            return super.staticFee(feeContext).times(feeContext.data.asset.multiSignature.publicKeys.length + 1);
        }
        return super.staticFee(feeContext);
    }
    verify() {
        return configManager.getMilestone().aip11 && super.verify();
    }
    serialize(options) {
        const { data } = this;
        const { min, publicKeys } = data.asset.multiSignature;
        const buffer = new ByteBuffer(2 + publicKeys.length * 33);
        buffer.writeUint8(min);
        buffer.writeUint8(publicKeys.length);
        for (const publicKey of publicKeys) {
            buffer.append(publicKey, "hex");
        }
        return buffer;
    }
    deserialize(buf) {
        const { data } = this;
        const multiSignature = { publicKeys: [], min: 0 };
        multiSignature.min = buf.readUint8();
        const count = buf.readUint8();
        for (let i = 0; i < count; i++) {
            const publicKey = buf.readBytes(33).toString("hex");
            multiSignature.publicKeys.push(publicKey);
        }
        data.asset = { multiSignature };
    }
}
MultiSignatureRegistrationTransaction$1.typeGroup = TransactionTypeGroup.Core;
MultiSignatureRegistrationTransaction$1.type = TransactionType.MultiSignature;
MultiSignatureRegistrationTransaction$1.key = "multiSignature";
MultiSignatureRegistrationTransaction$1.version = 2;
MultiSignatureRegistrationTransaction$1.defaultStaticFee = BigNumber.make("500000000");

class IpfsTransaction extends Transaction {
    static getSchema() {
        return ipfs;
    }
    verify() {
        return configManager.getMilestone().aip11 && super.verify();
    }
    serialize(options) {
        const { data } = this;
        if (data.asset) {
            const ipfsBuffer = base58.decode(data.asset.ipfs);
            const buffer = new ByteBuffer(ipfsBuffer.length, true);
            buffer.append(ipfsBuffer, "hex");
            return buffer;
        }
        return undefined;
    }
    deserialize(buf) {
        const { data } = this;
        const hashFunction = buf.readUint8();
        const ipfsHashLength = buf.readUint8();
        const ipfsHash = buf.readBytes(ipfsHashLength).toBuffer();
        const buffer = Buffer.alloc(ipfsHashLength + 2);
        buffer.writeUInt8(hashFunction, 0);
        buffer.writeUInt8(ipfsHashLength, 1);
        buffer.fill(ipfsHash, 2);
        data.asset = {
            ipfs: base58.encode(buffer),
        };
    }
}
IpfsTransaction.typeGroup = TransactionTypeGroup.Core;
IpfsTransaction.type = TransactionType.Ipfs;
IpfsTransaction.key = "ipfs";
IpfsTransaction.version = 2;
IpfsTransaction.defaultStaticFee = BigNumber.make("500000000");

class MultiPaymentTransaction extends Transaction {
    static getSchema() {
        return multiPayment;
    }
    verify() {
        return configManager.getMilestone().aip11 && super.verify();
    }
    hasVendorField() {
        return true;
    }
    serialize(options = {}) {
        const { data } = this;
        if (data.asset && data.asset.payments) {
            const buffer = new ByteBuffer(2 + data.asset.payments.length * 29, true);
            buffer.writeUint16(data.asset.payments.length);
            for (const payment of data.asset.payments) {
                // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
                buffer.writeUint64(payment.amount.toString());
                const { addressBuffer, addressError } = Address.toBuffer(payment.recipientId);
                options.addressError = addressError || options.addressError;
                buffer.append(addressBuffer);
            }
            return buffer;
        }
        return undefined;
    }
    deserialize(buf) {
        const { data } = this;
        const payments = [];
        const total = buf.readUint16();
        for (let j = 0; j < total; j++) {
            payments.push({
                amount: BigNumber.make(buf.readUint64().toString()),
                recipientId: Address.fromBuffer(buf.readBytes(21).toBuffer()),
            });
        }
        data.amount = BigNumber.ZERO;
        data.asset = { payments };
    }
}
MultiPaymentTransaction.typeGroup = TransactionTypeGroup.Core;
MultiPaymentTransaction.type = TransactionType.MultiPayment;
MultiPaymentTransaction.key = "multiPayment";
MultiPaymentTransaction.version = 2;
MultiPaymentTransaction.defaultStaticFee = BigNumber.make("10000000");

class DelegateResignationTransaction extends Transaction {
    static getSchema() {
        return delegateResignation;
    }
    verify() {
        return configManager.getMilestone().aip11 && super.verify();
    }
    serialize(options) {
        return new ByteBuffer(0);
    }
    deserialize(buf) {
        return;
    }
}
DelegateResignationTransaction.typeGroup = TransactionTypeGroup.Core;
DelegateResignationTransaction.type = TransactionType.DelegateResignation;
DelegateResignationTransaction.key = "delegateResignation";
DelegateResignationTransaction.version = 2;
DelegateResignationTransaction.defaultStaticFee = BigNumber.make("2500000000");

class HtlcLockTransaction extends Transaction {
    static getSchema() {
        return htlcLock;
    }
    verify() {
        const milestone = configManager.getMilestone();
        return milestone.aip11 === true && milestone.htlcEnabled === true && super.verify();
    }
    hasVendorField() {
        return true;
    }
    serialize(options) {
        const { data } = this;
        const buffer = new ByteBuffer(8 + 32 + 1 + 4 + 21, true);
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        buffer.writeUint64(data.amount.toString());
        if (data.asset && data.asset.lock) {
            buffer.append(Buffer.from(data.asset.lock.secretHash, "hex"));
            buffer.writeUint8(data.asset.lock.expiration.type);
            buffer.writeUint32(data.asset.lock.expiration.value);
        }
        if (data.recipientId) {
            buffer.append(Address.toBuffer(data.recipientId).addressBuffer);
        }
        return buffer;
    }
    deserialize(buf) {
        const { data } = this;
        const amount = BigNumber.make(buf.readUint64().toString());
        const secretHash = buf.readBytes(32).toString("hex");
        const expirationType = buf.readUint8();
        const expirationValue = buf.readUint32();
        const recipientId = Address.fromBuffer(buf.readBytes(21).toBuffer());
        data.amount = amount;
        data.recipientId = recipientId;
        data.asset = {
            lock: {
                secretHash,
                expiration: {
                    type: expirationType,
                    value: expirationValue,
                },
            },
        };
    }
}
HtlcLockTransaction.typeGroup = TransactionTypeGroup.Core;
HtlcLockTransaction.type = TransactionType.HtlcLock;
HtlcLockTransaction.key = "htlcLock";
HtlcLockTransaction.version = 2;
HtlcLockTransaction.defaultStaticFee = BigNumber.make("10000000");

class HtlcClaimTransaction extends Transaction {
    static getSchema() {
        return htlcClaim;
    }
    verify() {
        const milestone = configManager.getMilestone();
        return milestone.aip11 === true && milestone.htlcEnabled === true && super.verify();
    }
    serialize(options) {
        const { data } = this;
        const buffer = new ByteBuffer(32 + 32, true);
        if (data.asset && data.asset.claim) {
            buffer.append(Buffer.from(data.asset.claim.lockTransactionId, "hex"));
            buffer.append(Buffer.from(data.asset.claim.unlockSecret, "hex"));
        }
        return buffer;
    }
    deserialize(buf) {
        const { data } = this;
        const lockTransactionId = buf.readBytes(32).toString("hex");
        const unlockSecret = buf.readBytes(32).toString("hex");
        data.asset = {
            claim: {
                lockTransactionId,
                unlockSecret,
            },
        };
    }
}
HtlcClaimTransaction.typeGroup = TransactionTypeGroup.Core;
HtlcClaimTransaction.type = TransactionType.HtlcClaim;
HtlcClaimTransaction.key = "htlcClaim";
HtlcClaimTransaction.version = 2;
HtlcClaimTransaction.defaultStaticFee = BigNumber.ZERO;

class HtlcRefundTransaction extends Transaction {
    static getSchema() {
        return htlcRefund;
    }
    verify() {
        const milestone = configManager.getMilestone();
        return milestone.aip11 === true && milestone.htlcEnabled === true && super.verify();
    }
    serialize(options) {
        const { data } = this;
        const buffer = new ByteBuffer(32, true);
        if (data.asset && data.asset.refund) {
            buffer.append(Buffer.from(data.asset.refund.lockTransactionId, "hex"));
        }
        return buffer;
    }
    deserialize(buf) {
        const { data } = this;
        const lockTransactionId = buf.readBytes(32).toString("hex");
        data.asset = {
            refund: {
                lockTransactionId,
            },
        };
    }
}
HtlcRefundTransaction.typeGroup = TransactionTypeGroup.Core;
HtlcRefundTransaction.type = TransactionType.HtlcRefund;
HtlcRefundTransaction.key = "htlcRefund";
HtlcRefundTransaction.version = 2;
HtlcRefundTransaction.defaultStaticFee = BigNumber.ZERO;

var index$6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TransferTransaction: TransferTransaction$1,
  SecondSignatureRegistrationTransaction: SecondSignatureRegistrationTransaction$1,
  DelegateRegistrationTransaction: DelegateRegistrationTransaction$1,
  VoteTransaction: VoteTransaction$1,
  MultiSignatureRegistrationTransaction: MultiSignatureRegistrationTransaction$1,
  IpfsTransaction: IpfsTransaction,
  MultiPaymentTransaction: MultiPaymentTransaction,
  DelegateResignationTransaction: DelegateResignationTransaction,
  HtlcLockTransaction: HtlcLockTransaction,
  HtlcClaimTransaction: HtlcClaimTransaction,
  HtlcRefundTransaction: HtlcRefundTransaction
});

class Signer {
    static sign(transaction, keys, options) {
        if (!options || (options.excludeSignature === undefined && options.excludeSecondSignature === undefined)) {
            options = Object.assign({ excludeSignature: true, excludeSecondSignature: true }, options);
        }
        const hash = Utils.toHash(transaction, options);
        const signature = transaction.version && transaction.version > 1 ? Hash.signSchnorr(hash, keys) : Hash.signECDSA(hash, keys);
        if (!transaction.signature && !options.excludeMultiSignature) {
            transaction.signature = signature;
        }
        return signature;
    }
    static secondSign(transaction, keys) {
        const hash = Utils.toHash(transaction, { excludeSecondSignature: true });
        const signature = transaction.version && transaction.version > 1 ? Hash.signSchnorr(hash, keys) : Hash.signECDSA(hash, keys);
        if (!transaction.secondSignature) {
            transaction.secondSignature = signature;
        }
        return signature;
    }
    static multiSign(transaction, keys, index = -1) {
        if (!transaction.signatures) {
            transaction.signatures = [];
        }
        index = index === -1 ? transaction.signatures.length : index;
        const hash = Utils.toHash(transaction, {
            excludeSignature: true,
            excludeSecondSignature: true,
            excludeMultiSignature: true,
        });
        const signature = Hash.signSchnorr(hash, keys);
        const indexedSignature = `${numberToHex(index)}${signature}`;
        transaction.signatures.push(indexedSignature);
        return indexedSignature;
    }
}

class TransactionBuilder {
    constructor() {
        this.signWithSenderAsRecipient = false;
        this.disableVersionCheck = false;
        this.data = {
            id: undefined,
            timestamp: Slots.getTime(),
            typeGroup: TransactionTypeGroup.Test,
            nonce: BigNumber.ZERO,
            version: configManager.getMilestone().aip11 ? 0x02 : 0x01,
        };
    }
    build(data = {}) {
        return TransactionFactory.fromData(Object.assign(Object.assign({}, this.data), data), false, {
            disableVersionCheck: this.disableVersionCheck,
        });
    }
    version(version) {
        this.data.version = version;
        this.disableVersionCheck = true;
        return this.instance();
    }
    typeGroup(typeGroup) {
        this.data.typeGroup = typeGroup;
        return this.instance();
    }
    nonce(nonce) {
        if (nonce) {
            this.data.nonce = BigNumber.make(nonce);
        }
        return this.instance();
    }
    network(network) {
        this.data.network = network;
        return this.instance();
    }
    fee(fee) {
        if (fee) {
            this.data.fee = BigNumber.make(fee);
        }
        return this.instance();
    }
    amount(amount) {
        this.data.amount = BigNumber.make(amount);
        return this.instance();
    }
    recipientId(recipientId) {
        this.data.recipientId = recipientId;
        return this.instance();
    }
    senderPublicKey(publicKey) {
        this.data.senderPublicKey = publicKey;
        return this.instance();
    }
    vendorField(vendorField) {
        const limit = maxVendorFieldLength();
        if (vendorField) {
            if (Buffer.from(vendorField).length > limit) {
                throw new VendorFieldLengthExceededError(limit);
            }
            this.data.vendorField = vendorField;
        }
        return this.instance();
    }
    sign(passphrase) {
        const keys = Keys.fromPassphrase(passphrase);
        return this.signWithKeyPair(keys);
    }
    signWithWif(wif, networkWif) {
        const keys = Keys.fromWIF(wif, {
            wif: networkWif || configManager.get("network.wif"),
        });
        return this.signWithKeyPair(keys);
    }
    secondSign(secondPassphrase) {
        return this.secondSignWithKeyPair(Keys.fromPassphrase(secondPassphrase));
    }
    secondSignWithWif(wif, networkWif) {
        const keys = Keys.fromWIF(wif, {
            wif: networkWif || configManager.get("network.wif"),
        });
        return this.secondSignWithKeyPair(keys);
    }
    multiSign(passphrase, index) {
        const keys = Keys.fromPassphrase(passphrase);
        return this.multiSignWithKeyPair(index, keys);
    }
    multiSignWithWif(index, wif, networkWif) {
        const keys = Keys.fromWIF(wif, {
            wif: networkWif || configManager.get("network.wif"),
        });
        return this.multiSignWithKeyPair(index, keys);
    }
    verify() {
        return Verifier.verifyHash(this.data, this.disableVersionCheck);
    }
    getStruct() {
        if (!this.data.senderPublicKey || (!this.data.signature && !this.data.signatures)) {
            throw new MissingTransactionSignatureError();
        }
        const struct = {
            id: Utils.getId(this.data).toString(),
            signature: this.data.signature,
            secondSignature: this.data.secondSignature,
            version: this.data.version,
            type: this.data.type,
            fee: this.data.fee,
            senderPublicKey: this.data.senderPublicKey,
            network: this.data.network,
        };
        if (this.data.version === 1) {
            struct.timestamp = this.data.timestamp;
        }
        else {
            struct.typeGroup = this.data.typeGroup;
            struct.nonce = this.data.nonce;
        }
        if (Array.isArray(this.data.signatures)) {
            struct.signatures = this.data.signatures;
        }
        return struct;
    }
    signWithKeyPair(keys) {
        this.data.senderPublicKey = keys.publicKey;
        if (this.signWithSenderAsRecipient) {
            this.data.recipientId = Address.fromPublicKey(keys.publicKey, this.data.network);
        }
        this.data.signature = Signer.sign(this.getSigningObject(), keys, {
            disableVersionCheck: this.disableVersionCheck,
        });
        return this.instance();
    }
    secondSignWithKeyPair(keys) {
        this.data.secondSignature = Signer.secondSign(this.getSigningObject(), keys);
        return this.instance();
    }
    multiSignWithKeyPair(index, keys) {
        if (!this.data.signatures) {
            this.data.signatures = [];
        }
        this.version(2);
        Signer.multiSign(this.getSigningObject(), keys, index);
        return this.instance();
    }
    getSigningObject() {
        const data = Object.assign({}, this.data);
        for (const key of Object.keys(data)) {
            if (["model", "network", "id"].includes(key)) {
                delete data[key];
            }
        }
        return data;
    }
}

class DelegateRegistrationBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = DelegateRegistrationTransaction$1.type;
        this.data.typeGroup = DelegateRegistrationTransaction$1.typeGroup;
        this.data.fee = DelegateRegistrationTransaction$1.staticFee();
        this.data.amount = BigNumber.ZERO;
        this.data.recipientId = undefined;
        this.data.senderPublicKey = undefined;
        this.data.asset = { delegate: {} };
    }
    usernameAsset(username) {
        if (this.data.asset && this.data.asset.delegate) {
            this.data.asset.delegate.username = username;
        }
        return this;
    }
    getStruct() {
        const struct = super.getStruct();
        struct.amount = this.data.amount;
        struct.recipientId = this.data.recipientId;
        struct.asset = this.data.asset;
        return struct;
    }
    instance() {
        return this;
    }
}

class DelegateResignationBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = DelegateResignationTransaction.type;
        this.data.typeGroup = DelegateResignationTransaction.typeGroup;
        this.data.version = 2;
        this.data.fee = DelegateResignationTransaction.staticFee();
        this.data.amount = BigNumber.ZERO;
        this.data.senderPublicKey = undefined;
    }
    getStruct() {
        const struct = super.getStruct();
        struct.amount = this.data.amount;
        return struct;
    }
    instance() {
        return this;
    }
}

class HtlcClaimBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = HtlcClaimTransaction.type;
        this.data.typeGroup = HtlcClaimTransaction.typeGroup;
        this.data.fee = HtlcClaimTransaction.staticFee();
        this.data.amount = BigNumber.ZERO;
        this.data.asset = {};
    }
    htlcClaimAsset(claimAsset) {
        this.data.asset = {
            claim: claimAsset,
        };
        return this;
    }
    getStruct() {
        const struct = super.getStruct();
        struct.amount = this.data.amount;
        struct.asset = this.data.asset;
        return struct;
    }
    instance() {
        return this;
    }
}

class HtlcLockBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = HtlcLockTransaction.type;
        this.data.typeGroup = HtlcLockTransaction.typeGroup;
        this.data.recipientId = undefined;
        this.data.amount = BigNumber.ZERO;
        this.data.fee = HtlcLockTransaction.staticFee();
        this.data.vendorField = undefined;
        this.data.asset = {};
    }
    htlcLockAsset(lockAsset) {
        this.data.asset = {
            lock: lockAsset,
        };
        return this;
    }
    getStruct() {
        const struct = super.getStruct();
        struct.recipientId = this.data.recipientId;
        struct.amount = this.data.amount;
        struct.vendorField = this.data.vendorField;
        struct.asset = this.data.asset;
        return struct;
    }
    expiration(expiration) {
        return this;
    }
    instance() {
        return this;
    }
}

class HtlcRefundBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = HtlcRefundTransaction.type;
        this.data.typeGroup = HtlcRefundTransaction.typeGroup;
        this.data.fee = HtlcRefundTransaction.staticFee();
        this.data.amount = BigNumber.ZERO;
        this.data.asset = {};
    }
    htlcRefundAsset(refundAsset) {
        this.data.asset = {
            refund: refundAsset,
        };
        return this;
    }
    getStruct() {
        const struct = super.getStruct();
        struct.amount = this.data.amount;
        struct.asset = this.data.asset;
        return struct;
    }
    instance() {
        return this;
    }
}

class IPFSBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = IpfsTransaction.type;
        this.data.typeGroup = IpfsTransaction.typeGroup;
        this.data.fee = IpfsTransaction.staticFee();
        this.data.amount = BigNumber.ZERO;
        this.data.asset = {};
    }
    ipfsAsset(ipfsId) {
        this.data.asset = {
            ipfs: ipfsId,
        };
        return this;
    }
    getStruct() {
        const struct = super.getStruct();
        struct.amount = this.data.amount;
        struct.asset = this.data.asset;
        return struct;
    }
    instance() {
        return this;
    }
}

class MultiPaymentBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = MultiPaymentTransaction.type;
        this.data.typeGroup = MultiPaymentTransaction.typeGroup;
        this.data.fee = MultiPaymentTransaction.staticFee();
        this.data.vendorField = undefined;
        this.data.asset = {
            payments: [],
        };
        this.data.amount = BigNumber.make(0);
    }
    addPayment(recipientId, amount) {
        if (this.data.asset && this.data.asset.payments) {
            const limit = configManager.getMilestone().multiPaymentLimit || 256;
            if (this.data.asset.payments.length >= limit) {
                throw new MaximumPaymentCountExceededError(limit);
            }
            this.data.asset.payments.push({
                amount: BigNumber.make(amount),
                recipientId,
            });
        }
        return this;
    }
    getStruct() {
        if (!this.data.asset ||
            !this.data.asset.payments ||
            !Array.isArray(this.data.asset.payments) ||
            this.data.asset.payments.length <= 1) {
            throw new MinimumPaymentCountSubceededError();
        }
        const struct = super.getStruct();
        struct.senderPublicKey = this.data.senderPublicKey;
        struct.vendorField = this.data.vendorField;
        struct.amount = this.data.amount;
        struct.asset = this.data.asset;
        return struct;
    }
    instance() {
        return this;
    }
}

class MultiSignatureBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = MultiSignatureRegistrationTransaction$1.type;
        this.data.typeGroup = MultiSignatureRegistrationTransaction$1.typeGroup;
        this.data.version = 2;
        this.data.fee = BigNumber.ZERO;
        this.data.amount = BigNumber.ZERO;
        this.data.recipientId = undefined;
        this.data.senderPublicKey = undefined;
        this.data.asset = { multiSignature: { min: 0, publicKeys: [] } };
    }
    participant(publicKey) {
        if (this.data.asset && this.data.asset.multiSignature) {
            const { publicKeys } = this.data.asset.multiSignature;
            if (publicKeys.length <= 16) {
                publicKeys.push(publicKey);
                this.data.fee = MultiSignatureRegistrationTransaction$1.staticFee({ data: this.data });
            }
        }
        return this;
    }
    min(min) {
        if (this.data.asset && this.data.asset.multiSignature) {
            this.data.asset.multiSignature.min = min;
        }
        return this;
    }
    multiSignatureAsset(multiSignature) {
        if (this.data.asset && this.data.asset.multiSignature) {
            this.data.asset.multiSignature = multiSignature;
            this.data.fee = MultiSignatureRegistrationTransaction$1.staticFee({ data: this.data });
        }
        return this;
    }
    getStruct() {
        const struct = super.getStruct();
        struct.amount = this.data.amount;
        struct.recipientId = this.data.recipientId;
        struct.asset = this.data.asset;
        return struct;
    }
    instance() {
        return this;
    }
}

class SecondSignatureBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = SecondSignatureRegistrationTransaction$1.type;
        this.data.typeGroup = SecondSignatureRegistrationTransaction$1.typeGroup;
        this.data.fee = SecondSignatureRegistrationTransaction$1.staticFee();
        this.data.amount = BigNumber.ZERO;
        this.data.recipientId = undefined;
        this.data.senderPublicKey = undefined;
        this.data.asset = { signature: {} };
    }
    signatureAsset(secondPassphrase) {
        if (this.data.asset && this.data.asset.signature) {
            this.data.asset.signature.publicKey = Keys.fromPassphrase(secondPassphrase).publicKey;
        }
        return this;
    }
    getStruct() {
        const struct = super.getStruct();
        struct.amount = this.data.amount;
        struct.recipientId = this.data.recipientId;
        struct.asset = this.data.asset;
        return struct;
    }
    instance() {
        return this;
    }
}

class TransferBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = TransferTransaction$1.type;
        this.data.typeGroup = TransferTransaction$1.typeGroup;
        this.data.fee = TransferTransaction$1.staticFee();
        this.data.amount = BigNumber.ZERO;
        this.data.recipientId = undefined;
        this.data.senderPublicKey = undefined;
        this.data.expiration = 0;
    }
    expiration(expiration) {
        this.data.expiration = expiration;
        return this.instance();
    }
    getStruct() {
        const struct = super.getStruct();
        struct.amount = this.data.amount;
        struct.recipientId = this.data.recipientId;
        struct.asset = this.data.asset;
        struct.vendorField = this.data.vendorField;
        struct.expiration = this.data.expiration;
        return struct;
    }
    instance() {
        return this;
    }
}

class VoteBuilder extends TransactionBuilder {
    constructor() {
        super();
        this.data.type = VoteTransaction$1.type;
        this.data.typeGroup = VoteTransaction$1.typeGroup;
        this.data.fee = VoteTransaction$1.staticFee();
        this.data.amount = BigNumber.ZERO;
        this.data.recipientId = undefined;
        this.data.senderPublicKey = undefined;
        this.data.asset = { votes: [] };
        this.signWithSenderAsRecipient = true;
    }
    votesAsset(votes) {
        if (this.data.asset && this.data.asset.votes) {
            this.data.asset.votes = votes;
        }
        return this;
    }
    getStruct() {
        const struct = super.getStruct();
        struct.amount = this.data.amount;
        struct.recipientId = this.data.recipientId;
        struct.asset = this.data.asset;
        return struct;
    }
    instance() {
        return this;
    }
}

class BuilderFactory {
    static transfer() {
        return new TransferBuilder();
    }
    static secondSignature() {
        return new SecondSignatureBuilder();
    }
    static delegateRegistration() {
        return new DelegateRegistrationBuilder();
    }
    static vote() {
        return new VoteBuilder();
    }
    static multiSignature() {
        return new MultiSignatureBuilder();
    }
    static ipfs() {
        return new IPFSBuilder();
    }
    static multiPayment() {
        return new MultiPaymentBuilder();
    }
    static delegateResignation() {
        return new DelegateResignationBuilder();
    }
    static htlcLock() {
        return new HtlcLockBuilder();
    }
    static htlcClaim() {
        return new HtlcClaimBuilder();
    }
    static htlcRefund() {
        return new HtlcRefundBuilder();
    }
}

// Reference: https://github.com/ArkEcosystem/AIPs/blob/master/AIPS/aip-11.md
class Deserializer {
    static applyV1Compatibility(transaction) {
        transaction.secondSignature = transaction.secondSignature || transaction.signSignature;
        transaction.typeGroup = TransactionTypeGroup.Core;
        if (transaction.type === TransactionType.Vote && transaction.senderPublicKey) {
            transaction.recipientId = Address.fromPublicKey(transaction.senderPublicKey, transaction.network);
        }
        else if (transaction.type === TransactionType.MultiSignature &&
            transaction.asset &&
            transaction.asset.multiSignatureLegacy) {
            transaction.asset.multiSignatureLegacy.keysgroup = transaction.asset.multiSignatureLegacy.keysgroup.map((k) => (k.startsWith("+") ? k : `+${k}`));
        }
    }
    static deserialize(serialized, options = {}) {
        const data = {};
        const buffer = this.getByteBuffer(serialized);
        this.deserializeCommon(data, buffer);
        const instance = TransactionTypeFactory.create(data);
        this.deserializeVendorField(instance, buffer);
        // Deserialize type specific parts
        instance.deserialize(buffer);
        this.deserializeSignatures(data, buffer);
        if (data.version) {
            if (options.acceptLegacyVersion ||
                options.disableVersionCheck ||
                isSupportedTransactionVersion(data.version)) {
                if (data.version === 1) {
                    this.applyV1Compatibility(data);
                }
            }
            else {
                throw new TransactionVersionError(data.version);
            }
        }
        instance.serialized = buffer.flip().toBuffer();
        return instance;
    }
    static deserializeCommon(transaction, buf) {
        buf.skip(1); // Skip 0xFF marker
        transaction.version = buf.readUint8();
        transaction.network = buf.readUint8();
        if (transaction.version === 1) {
            transaction.type = buf.readUint8();
            transaction.timestamp = buf.readUint32();
        }
        else {
            transaction.typeGroup = buf.readUint32();
            transaction.type = buf.readUint16();
            transaction.nonce = BigNumber.make(buf.readUint64().toString());
        }
        transaction.senderPublicKey = buf.readBytes(33).toString("hex");
        transaction.fee = BigNumber.make(buf.readUint64().toString());
        transaction.amount = BigNumber.ZERO;
    }
    static deserializeVendorField(transaction, buf) {
        const vendorFieldLength = buf.readUint8();
        if (vendorFieldLength > 0) {
            if (transaction.hasVendorField()) {
                const vendorFieldBuffer = buf.readBytes(vendorFieldLength).toBuffer();
                transaction.data.vendorField = vendorFieldBuffer.toString("utf8");
            }
            else {
                buf.skip(vendorFieldLength);
            }
        }
    }
    static deserializeSignatures(transaction, buf) {
        if (transaction.version === 1) {
            this.deserializeECDSA(transaction, buf);
        }
        else {
            this.deserializeSchnorrOrECDSA(transaction, buf);
        }
    }
    static deserializeSchnorrOrECDSA(transaction, buf) {
        if (this.detectSchnorr(buf)) {
            this.deserializeSchnorr(transaction, buf);
        }
        else {
            this.deserializeECDSA(transaction, buf);
        }
    }
    static deserializeECDSA(transaction, buf) {
        const currentSignatureLength = () => {
            buf.mark();
            const lengthHex = buf.skip(1).readBytes(1).toString("hex");
            buf.reset();
            return parseInt(lengthHex, 16) + 2;
        };
        // Signature
        if (buf.remaining()) {
            const signatureLength = currentSignatureLength();
            transaction.signature = buf.readBytes(signatureLength).toString("hex");
        }
        const beginningMultiSignature = () => {
            buf.mark();
            const marker = buf.readUint8();
            buf.reset();
            return marker === 255;
        };
        // Second Signature
        if (buf.remaining() && !beginningMultiSignature()) {
            const secondSignatureLength = currentSignatureLength();
            transaction.secondSignature = buf.readBytes(secondSignatureLength).toString("hex");
        }
        // Multi Signatures
        if (buf.remaining() && beginningMultiSignature()) {
            buf.skip(1);
            const multiSignature = buf.readBytes(buf.limit - buf.offset).toString("hex");
            transaction.signatures = [multiSignature];
        }
        if (buf.remaining()) {
            throw new InvalidTransactionBytesError("signature buffer not exhausted");
        }
    }
    static deserializeSchnorr(transaction, buf) {
        const canReadNonMultiSignature = () => {
            return buf.remaining() && (buf.remaining() % 64 === 0 || buf.remaining() % 65 !== 0);
        };
        if (canReadNonMultiSignature()) {
            transaction.signature = buf.readBytes(64).toString("hex");
        }
        if (canReadNonMultiSignature()) {
            transaction.secondSignature = buf.readBytes(64).toString("hex");
        }
        if (buf.remaining()) {
            if (buf.remaining() % 65 === 0) {
                transaction.signatures = [];
                const count = buf.remaining() / 65;
                const publicKeyIndexes = {};
                for (let i = 0; i < count; i++) {
                    const multiSignaturePart = buf.readBytes(65).toString("hex");
                    const publicKeyIndex = parseInt(multiSignaturePart.slice(0, 2), 16);
                    if (!publicKeyIndexes[publicKeyIndex]) {
                        publicKeyIndexes[publicKeyIndex] = true;
                    }
                    else {
                        throw new DuplicateParticipantInMultiSignatureError();
                    }
                    transaction.signatures.push(multiSignaturePart);
                }
            }
            else {
                throw new InvalidTransactionBytesError("signature buffer not exhausted");
            }
        }
    }
    static detectSchnorr(buf) {
        const remaining = buf.remaining();
        // `signature` / `secondSignature`
        if (remaining === 64 || remaining === 128) {
            return true;
        }
        // `signatures` of a multi signature transaction (type != 4)
        if (remaining % 65 === 0) {
            return true;
        }
        // only possiblity left is a type 4 transaction with and without a `secondSignature`.
        if ((remaining - 64) % 65 === 0 || (remaining - 128) % 65 === 0) {
            return true;
        }
        return false;
    }
    static getByteBuffer(serialized) {
        if (!(serialized instanceof Buffer)) {
            serialized = Buffer.from(serialized, "hex");
        }
        const buffer = new ByteBuffer(serialized.length, true);
        buffer.append(serialized);
        buffer.reset();
        return buffer;
    }
}

class TransactionFactory {
    static fromHex(hex) {
        return this.fromSerialized(hex);
    }
    static fromBytes(buffer, strict = true, options = {}) {
        return this.fromSerialized(buffer.toString("hex"), strict, options);
    }
    /**
     * Deserializes a transaction from `buffer` with the given `id`. It is faster
     * than `fromBytes` at the cost of vital safety checks (validation, verification and id calculation).
     *
     * NOTE: Only use this internally when it is safe to assume the buffer has already been
     * verified.
     */
    static fromBytesUnsafe(buffer, id) {
        try {
            const options = { acceptLegacyVersion: true };
            const transaction = Deserializer.deserialize(buffer, options);
            transaction.data.id = id || Utils.getId(transaction.data, options);
            transaction.isVerified = true;
            return transaction;
        }
        catch (error) {
            throw new InvalidTransactionBytesError(error.message);
        }
    }
    static fromJson(json) {
        const data = Object.assign({}, json);
        data.amount = BigNumber.make(data.amount);
        data.fee = BigNumber.make(data.fee);
        return this.fromData(data);
    }
    static fromData(data, strict = true, options = {}) {
        const { value, error } = Verifier.verifySchema(data, strict);
        if (error && !isException(value)) {
            throw new TransactionSchemaError(error);
        }
        const transaction = TransactionTypeFactory.create(value);
        const { version } = transaction.data;
        if (version === 1) {
            Deserializer.applyV1Compatibility(transaction.data);
        }
        Serializer.serialize(transaction);
        return this.fromBytes(transaction.serialized, strict, options);
    }
    static fromSerialized(serialized, strict = true, options = {}) {
        try {
            const transaction = Deserializer.deserialize(serialized, options);
            transaction.data.id = Utils.getId(transaction.data, options);
            const { value, error } = Verifier.verifySchema(transaction.data, strict);
            if (error && !isException(value)) {
                throw new TransactionSchemaError(error);
            }
            transaction.isVerified = transaction.verify(options);
            return transaction;
        }
        catch (error) {
            if (error instanceof TransactionVersionError ||
                error instanceof TransactionSchemaError ||
                error instanceof DuplicateParticipantInMultiSignatureError) {
                throw error;
            }
            throw new InvalidTransactionBytesError(error.message);
        }
    }
}

class TransactionRegistry {
    constructor() {
        this.transactionTypes = new Map();
        TransactionTypeFactory.initialize(this.transactionTypes);
        this.registerTransactionType(TransferTransaction);
        this.registerTransactionType(TransferTransaction$1);
        this.registerTransactionType(SecondSignatureRegistrationTransaction);
        this.registerTransactionType(SecondSignatureRegistrationTransaction$1);
        this.registerTransactionType(DelegateRegistrationTransaction);
        this.registerTransactionType(DelegateRegistrationTransaction$1);
        this.registerTransactionType(VoteTransaction);
        this.registerTransactionType(VoteTransaction$1);
        this.registerTransactionType(MultiSignatureRegistrationTransaction);
        this.registerTransactionType(MultiSignatureRegistrationTransaction$1);
        this.registerTransactionType(IpfsTransaction);
        this.registerTransactionType(MultiPaymentTransaction);
        this.registerTransactionType(DelegateResignationTransaction);
        this.registerTransactionType(HtlcLockTransaction);
        this.registerTransactionType(HtlcClaimTransaction);
        this.registerTransactionType(HtlcRefundTransaction);
    }
    registerTransactionType(constructor) {
        var _a;
        const { typeGroup, type } = constructor;
        if (typeof type === "undefined" || typeof typeGroup === "undefined") {
            throw new Error();
        }
        const internalType = InternalTransactionType.from(type, typeGroup);
        for (const registeredConstructors of this.transactionTypes.values()) {
            if (registeredConstructors.size) {
                const first = [...registeredConstructors.values()][0];
                if (first.key === constructor.key &&
                    InternalTransactionType.from(first.type, first.typeGroup) !== internalType) {
                    throw new TransactionKeyAlreadyRegisteredError(first.key);
                }
                for (const registeredConstructor of registeredConstructors.values()) {
                    if (registeredConstructor === constructor) {
                        throw new TransactionAlreadyRegisteredError(constructor.name);
                    }
                }
            }
        }
        if (!this.transactionTypes.has(internalType)) {
            this.transactionTypes.set(internalType, new Map());
        }
        else if ((_a = this.transactionTypes.get(internalType)) === null || _a === void 0 ? void 0 : _a.has(constructor.version)) {
            throw new TransactionVersionAlreadyRegisteredError(constructor.name, constructor.version);
        }
        this.transactionTypes.get(internalType).set(constructor.version, constructor);
        this.updateSchemas(constructor);
    }
    deregisterTransactionType(constructor) {
        const { typeGroup, type, version } = constructor;
        if (typeof type === "undefined" || typeof typeGroup === "undefined") {
            throw new Error();
        }
        const internalType = InternalTransactionType.from(type, typeGroup);
        if (!this.transactionTypes.has(internalType)) {
            throw new UnkownTransactionError(internalType.toString());
        }
        this.updateSchemas(constructor, true);
        const constructors = this.transactionTypes.get(internalType);
        if (!constructors.has(version)) {
            throw new UnkownTransactionError(internalType.toString());
        }
        constructors.delete(version);
        if (constructors.size === 0) {
            this.transactionTypes.delete(internalType);
        }
    }
    updateSchemas(transaction, remove) {
        validator.extendTransaction(transaction.getSchema(), remove);
    }
}
const transactionRegistry = new TransactionRegistry();

var index$7 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TransactionRegistry: transactionRegistry,
  TransactionBuilder: TransactionBuilder,
  BuilderFactory: BuilderFactory,
  Deserializer: Deserializer,
  TransactionFactory: TransactionFactory,
  Serializer: Serializer,
  Signer: Signer,
  One: index$5,
  schemas: schemas,
  Two: index$6,
  Transaction: Transaction,
  TransactionTypeFactory: TransactionTypeFactory,
  InternalTransactionType: InternalTransactionType,
  Utils: Utils,
  Verifier: Verifier
});

class Serializer$1 {
    static size(block) {
        let size = this.headerSize(block.data) + block.data.blockSignature.length / 2;
        for (const transaction of block.transactions) {
            size += 4 /* tx length */ + transaction.serialized.length;
        }
        return size;
    }
    static serializeWithTransactions(block) {
        const transactions = block.transactions || [];
        block.numberOfTransactions = block.numberOfTransactions || transactions.length;
        const serializedHeader = this.serialize(block);
        const buffer = new ByteBuffer(serializedHeader.length + transactions.length * 4, true)
            .append(serializedHeader)
            .skip(transactions.length * 4);
        for (let i = 0; i < transactions.length; i++) {
            const serialized = Utils.toBytes(transactions[i]);
            buffer.writeUint32(serialized.length, serializedHeader.length + i * 4);
            buffer.append(serialized);
        }
        return buffer.flip().toBuffer();
    }
    static serialize(block, includeSignature = true) {
        const buffer = new ByteBuffer(512, true);
        this.serializeHeader(block, buffer);
        if (includeSignature) {
            this.serializeSignature(block, buffer);
        }
        return buffer.flip().toBuffer();
    }
    static headerSize(block) {
        const constants = configManager.getMilestone(block.height - 1 || 1);
        return (4 + // version
            4 + // timestamp
            4 + // height
            (constants.block.idFullSha256 ? 32 : 8) + // previousBlock
            4 + // numberOfTransactions
            8 + // totalAmount
            8 + // totalFee
            8 + // reward
            4 + // payloadLength
            block.payloadHash.length / 2 +
            block.generatorPublicKey.length / 2);
    }
    static serializeHeader(block, buffer) {
        const constants = configManager.getMilestone(block.height - 1 || 1);
        if (constants.block.idFullSha256) {
            if (block.previousBlock.length !== 64) {
                throw new PreviousBlockIdFormatError(block.height, block.previousBlock);
            }
            block.previousBlockHex = block.previousBlock;
        }
        else {
            block.previousBlockHex = Block.toBytesHex(block.previousBlock);
        }
        buffer.writeUint32(block.version);
        buffer.writeUint32(block.timestamp);
        buffer.writeUint32(block.height);
        buffer.append(block.previousBlockHex, "hex");
        buffer.writeUint32(block.numberOfTransactions);
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        buffer.writeUint64(block.totalAmount.toString());
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        buffer.writeUint64(block.totalFee.toString());
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        buffer.writeUint64(block.reward.toString());
        buffer.writeUint32(block.payloadLength);
        buffer.append(block.payloadHash, "hex");
        buffer.append(block.generatorPublicKey, "hex");
        assert.strictEqual(buffer.offset, this.headerSize(block));
    }
    static serializeSignature(block, buffer) {
        if (block.blockSignature) {
            buffer.append(block.blockSignature, "hex");
        }
    }
}

class Block {
    constructor({ data, transactions, id }) {
        this.data = data;
        // TODO genesis block calculated id is wrong for some reason
        if (this.data.height === 1) {
            if (id) {
                this.applyGenesisBlockFix(id);
            }
            else if (data.id) {
                this.applyGenesisBlockFix(data.id);
            }
        }
        // fix on real timestamp, this is overloading transaction
        // timestamp with block timestamp for storage only
        // also add sequence to keep database sequence
        this.transactions = transactions.map((transaction, index) => {
            transaction.data.blockId = this.data.id;
            transaction.data.blockHeight = this.data.height;
            transaction.data.sequence = index;
            transaction.timestamp = this.data.timestamp;
            return transaction;
        });
        delete this.data.transactions;
        this.verification = this.verify();
        // Order of transactions messed up in mainnet V1
        const { wrongTransactionOrder } = configManager.get("exceptions");
        if (this.data.id && wrongTransactionOrder && wrongTransactionOrder[this.data.id]) {
            const fixedOrderIds = wrongTransactionOrder[this.data.id];
            this.transactions = fixedOrderIds.map((id) => this.transactions.find((transaction) => transaction.id === id));
        }
    }
    static applySchema(data) {
        let result = validator.validate("block", data);
        if (!result.error) {
            return result.value;
        }
        result = validator.validateException("block", data);
        if (!result.errors) {
            return result.value;
        }
        for (const err of result.errors) {
            let fatal = false;
            const match = err.dataPath.match(/\.transactions\[([0-9]+)\]/);
            if (match === null) {
                if (!isException(data)) {
                    fatal = true;
                }
            }
            else {
                const txIndex = match[1];
                if (data.transactions) {
                    const tx = data.transactions[txIndex];
                    if (tx.id === undefined || !isException(tx)) {
                        fatal = true;
                    }
                }
            }
            if (fatal) {
                throw new BlockSchemaError(data.height, `Invalid data${err.dataPath ? " at " + err.dataPath : ""}: ` +
                    `${err.message}: ${JSON.stringify(err.data)}`);
            }
        }
        return result.value;
    }
    static getIdHex(data) {
        const constants = configManager.getMilestone(data.height);
        const payloadHash = Serializer$1.serialize(data);
        const hash = HashAlgorithms.sha256(payloadHash);
        if (constants.block.idFullSha256) {
            return hash.toString("hex");
        }
        const temp = Buffer.alloc(8);
        for (let i = 0; i < 8; i++) {
            temp[i] = hash[7 - i];
        }
        return temp.toString("hex");
    }
    static toBytesHex(data) {
        const temp = data ? BigNumber.make(data).toString(16) : "";
        return "0".repeat(16 - temp.length) + temp;
    }
    static getId(data) {
        const constants = configManager.getMilestone(data.height);
        const idHex = Block.getIdHex(data);
        return constants.block.idFullSha256 ? idHex : BigNumber.make(`0x${idHex}`).toString();
    }
    getHeader() {
        const header = Object.assign({}, this.data);
        delete header.transactions;
        return header;
    }
    verifySignature() {
        const bytes = Serializer$1.serialize(this.data, false);
        const hash = HashAlgorithms.sha256(bytes);
        if (!this.data.blockSignature) {
            throw new Error();
        }
        return Hash.verifyECDSA(hash, this.data.blockSignature, this.data.generatorPublicKey);
    }
    toJson() {
        const data = JSON.parse(JSON.stringify(this.data));
        data.reward = this.data.reward.toString();
        data.totalAmount = this.data.totalAmount.toString();
        data.totalFee = this.data.totalFee.toString();
        data.transactions = this.transactions.map((transaction) => transaction.toJson());
        return data;
    }
    verify() {
        const block = this.data;
        const result = {
            verified: false,
            containsMultiSignatures: false,
            errors: [],
        };
        try {
            const constants = configManager.getMilestone(block.height);
            if (block.height !== 1) {
                if (!block.previousBlock) {
                    result.errors.push("Invalid previous block");
                }
            }
            if (!block.reward.isEqualTo(constants.reward)) {
                result.errors.push(["Invalid block reward:", block.reward, "expected:", constants.reward].join(" "));
            }
            const valid = this.verifySignature();
            if (!valid) {
                result.errors.push("Failed to verify block signature");
            }
            if (block.version !== constants.block.version) {
                result.errors.push("Invalid block version");
            }
            if (block.timestamp > Slots.getTime() + configManager.getMilestone(block.height).blocktime) {
                result.errors.push("Invalid block timestamp");
            }
            const size = Serializer$1.size(this);
            if (size > constants.block.maxPayload) {
                result.errors.push(`Payload is too large: ${size} > ${constants.block.maxPayload}`);
            }
            const invalidTransactions = this.transactions.filter((tx) => !tx.verified);
            if (invalidTransactions.length > 0) {
                result.errors.push("One or more transactions are not verified:");
                for (const invalidTransaction of invalidTransactions) {
                    result.errors.push(`=> ${invalidTransaction.serialized.toString("hex")}`);
                }
                result.containsMultiSignatures = invalidTransactions.some((tx) => !!tx.data.signatures);
            }
            if (this.transactions.length !== block.numberOfTransactions) {
                result.errors.push("Invalid number of transactions");
            }
            if (this.transactions.length > constants.block.maxTransactions) {
                if (block.height > 1) {
                    result.errors.push("Transactions length is too high");
                }
            }
            // Checking if transactions of the block adds up to block values.
            const appliedTransactions = {};
            let totalAmount = BigNumber.ZERO;
            let totalFee = BigNumber.ZERO;
            const payloadBuffers = [];
            for (const transaction of this.transactions) {
                if (!transaction.data || !transaction.data.id) {
                    throw new Error();
                }
                const bytes = Buffer.from(transaction.data.id, "hex");
                if (appliedTransactions[transaction.data.id]) {
                    result.errors.push(`Encountered duplicate transaction: ${transaction.data.id}`);
                }
                if (transaction.data.expiration &&
                    transaction.data.expiration > 0 &&
                    transaction.data.expiration <= this.data.height) {
                    const isException = configManager.get("network.name") === "devnet" && constants.ignoreExpiredTransactions;
                    if (!isException) {
                        result.errors.push(`Encountered expired transaction: ${transaction.data.id}`);
                    }
                }
                if (transaction.data.version === 1 && !constants.block.acceptExpiredTransactionTimestamps) {
                    const now = block.timestamp;
                    if (transaction.data.timestamp > now + 3600 + constants.blocktime) {
                        result.errors.push(`Encountered future transaction: ${transaction.data.id}`);
                    }
                    else if (now - transaction.data.timestamp > 21600) {
                        result.errors.push(`Encountered expired transaction: ${transaction.data.id}`);
                    }
                }
                appliedTransactions[transaction.data.id] = transaction.data;
                totalAmount = totalAmount.plus(transaction.data.amount);
                totalFee = totalFee.plus(transaction.data.fee);
                payloadBuffers.push(bytes);
            }
            if (!totalAmount.isEqualTo(block.totalAmount)) {
                result.errors.push("Invalid total amount");
            }
            if (!totalFee.isEqualTo(block.totalFee)) {
                result.errors.push("Invalid total fee");
            }
            if (HashAlgorithms.sha256(payloadBuffers).toString("hex") !== block.payloadHash) {
                result.errors.push("Invalid payload hash");
            }
        }
        catch (error) {
            result.errors.push(error);
        }
        result.verified = result.errors.length === 0;
        return result;
    }
    applyGenesisBlockFix(id) {
        this.data.id = id;
        this.data.idHex = id.length === 64 ? id : Block.toBytesHex(id); // if id.length is 64 it's already hex
    }
}

class Deserializer$1 {
    static deserialize(serialized, headerOnly = false, options = {}) {
        const block = {};
        let transactions = [];
        const buf = new ByteBuffer(serialized.length, true);
        buf.append(serialized);
        buf.reset();
        this.deserializeHeader(block, buf);
        headerOnly = headerOnly || buf.remaining() === 0;
        if (!headerOnly) {
            transactions = this.deserializeTransactions(block, buf, options.deserializeTransactionsUnchecked);
        }
        block.idHex = Block.getIdHex(block);
        block.id = Block.getId(block);
        const { outlookTable } = configManager.get("exceptions");
        if (outlookTable && outlookTable[block.id]) {
            const constants = configManager.getMilestone(block.height);
            if (constants.block.idFullSha256) {
                block.id = outlookTable[block.id];
                block.idHex = block.id;
            }
            else {
                block.id = outlookTable[block.id];
                block.idHex = Block.toBytesHex(block.id);
            }
        }
        return { data: block, transactions };
    }
    static deserializeHeader(block, buf) {
        block.version = buf.readUint32();
        block.timestamp = buf.readUint32();
        block.height = buf.readUint32();
        const constants = configManager.getMilestone(block.height - 1 || 1);
        if (constants.block.idFullSha256) {
            const previousBlockFullSha256 = buf.readBytes(32).toString("hex");
            block.previousBlockHex = previousBlockFullSha256;
            block.previousBlock = previousBlockFullSha256;
        }
        else {
            block.previousBlockHex = buf.readBytes(8).toString("hex");
            block.previousBlock = BigNumber.make(`0x${block.previousBlockHex}`).toString();
        }
        block.numberOfTransactions = buf.readUint32();
        block.totalAmount = BigNumber.make(buf.readUint64().toString());
        block.totalFee = BigNumber.make(buf.readUint64().toString());
        block.reward = BigNumber.make(buf.readUint64().toString());
        block.payloadLength = buf.readUint32();
        block.payloadHash = buf.readBytes(32).toString("hex");
        block.generatorPublicKey = buf.readBytes(33).toString("hex");
        const signatureLength = () => {
            buf.mark();
            const lengthHex = buf.skip(1).readBytes(1).toString("hex");
            buf.reset();
            return parseInt(lengthHex, 16) + 2;
        };
        block.blockSignature = buf.readBytes(signatureLength()).toString("hex");
    }
    static deserializeTransactions(block, buf, deserializeTransactionsUnchecked = false) {
        const transactionLengths = [];
        for (let i = 0; i < block.numberOfTransactions; i++) {
            transactionLengths.push(buf.readUint32());
        }
        const transactions = [];
        block.transactions = [];
        for (const length of transactionLengths) {
            const transactionBytes = buf.readBytes(length).toBuffer();
            const transaction = deserializeTransactionsUnchecked
                ? TransactionFactory.fromBytesUnsafe(transactionBytes)
                : TransactionFactory.fromBytes(transactionBytes);
            transactions.push(transaction);
            block.transactions.push(transaction.data);
        }
        return transactions;
    }
}

class BlockFactory {
    // @todo: add a proper type hint for data
    static make(data, keys) {
        data.generatorPublicKey = keys.publicKey;
        const payloadHash = Serializer$1.serialize(data, false);
        const hash = HashAlgorithms.sha256(payloadHash);
        data.blockSignature = Hash.signECDSA(hash, keys);
        data.id = Block.getId(data);
        return this.fromData(data);
    }
    static fromHex(hex) {
        return this.fromSerialized(Buffer.from(hex, "hex"));
    }
    static fromBytes(buffer) {
        return this.fromSerialized(buffer);
    }
    static fromJson(json) {
        // @ts-ignore
        const data = Object.assign({}, json);
        data.totalAmount = BigNumber.make(data.totalAmount);
        data.totalFee = BigNumber.make(data.totalFee);
        data.reward = BigNumber.make(data.reward);
        if (data.transactions) {
            for (const transaction of data.transactions) {
                transaction.amount = BigNumber.make(transaction.amount);
                transaction.fee = BigNumber.make(transaction.fee);
            }
        }
        return this.fromData(data);
    }
    static fromData(data, options = {}) {
        const block = Block.applySchema(data);
        if (block) {
            const serialized = Serializer$1.serializeWithTransactions(data);
            const block = new Block(Object.assign(Object.assign({}, Deserializer$1.deserialize(serialized, false, options)), { id: data.id }));
            block.serialized = serialized.toString("hex");
            return block;
        }
        return undefined;
    }
    static fromSerialized(serialized) {
        const deserialized = Deserializer$1.deserialize(serialized);
        const validated = Block.applySchema(deserialized.data);
        if (validated) {
            deserialized.data = validated;
        }
        const block = new Block(deserialized);
        block.serialized = serialized.toString("hex");
        return block;
    }
}

var index$8 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Block: Block,
  Deserializer: Deserializer$1,
  BlockFactory: BlockFactory,
  Serializer: Serializer$1
});

var index$9 = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var types = /*#__PURE__*/Object.freeze({
  __proto__: null
});

export { index$8 as Blocks, constants as Constants, index$2 as Crypto, enums as Enums, errors as Errors, index$1 as Identities, index$9 as Interfaces, index as Managers, networks as Networks, index$7 as Transactions, types as Types, index$3 as Utils, index$4 as Validation };
