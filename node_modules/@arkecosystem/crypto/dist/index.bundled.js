import { secp256k1, RIPEMD160, SHA1, SHA256, Hash160, Hash256 } from 'bcrypto';
import aes from 'browserify-aes';
import { Address as Address$1, Keys as Keys$1, PrivateKey as PrivateKey$1, PublicKey as PublicKey$1, WIF as WIF$1 } from '@arkecosystem/crypto-identities';
import deepmerge from 'deepmerge';
import get from 'lodash.get';
import set from 'lodash.set';
import * as networks$1 from '@arkecosystem/crypto-networks';
import { devnet } from '@arkecosystem/crypto-networks';
import { base58 } from 'bstring';
import moize from 'fast-memoize';
import { fromSeed, fromPrivateKey } from 'bip32';
import { mnemonicToSeedSync } from 'bip39';
import dayjs from 'dayjs';
import { BigNumber } from '@arkecosystem/utils';
import { parse, process as process$1 } from 'ipaddr.js';
import Ajv from 'ajv';
import ajvKeywords from 'ajv-keywords';
import ByteBuffer from 'bytebuffer';

var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;

function init() {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray(b64) {
  if (!inited) {
    init();
  }

  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice


  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

  arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  if (!inited) {
    init();
  }

  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);
  return parts.join('');
}

function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;
var isArray = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

var INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}
Buffer.isBuffer = isBuffer;

function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}

Buffer.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }

  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }

  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
} // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually


function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}

function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var byteLength_1 = byteLength$1;
var toByteArray_1 = toByteArray$1;
var fromByteArray_1 = fromByteArray$1;
var lookup$1 = [];
var revLookup$1 = [];
var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup$1[i] = code[i];
  revLookup$1[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup$1['-'.charCodeAt(0)] = 62;
revLookup$1['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength$1(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray$1(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr$1(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 18 | revLookup$1[b64.charCodeAt(i + 1)] << 12 | revLookup$1[b64.charCodeAt(i + 2)] << 6 | revLookup$1[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 2 | revLookup$1[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 10 | revLookup$1[b64.charCodeAt(i + 1)] << 4 | revLookup$1[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64$1(num) {
  return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F];
}

function encodeChunk$1(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64$1(tmp));
  }

  return output.join('');
}

function fromByteArray$1(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk$1(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup$1[tmp >> 2] + lookup$1[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup$1[tmp >> 10] + lookup$1[tmp >> 4 & 0x3F] + lookup$1[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

var base64Js = {
  byteLength: byteLength_1,
  toByteArray: toByteArray_1,
  fromByteArray: fromByteArray_1
};

var read$1 = function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

var write$1 = function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

var ieee754 = {
  read: read$1,
  write: write$1
};

var buffer = createCommonjsModule(function (module, exports) {

  var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : null;
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 0x7fffffff;
  exports.kMaxLength = K_MAX_LENGTH;
  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */

  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
  }

  function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function foo() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }

  Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function get() {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function get() {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.byteOffset;
    }
  });

  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    } // Return an augmented `Uint8Array` instance


    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */


  function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }

      return allocUnsafe(arg);
    }

    return from(arg, encodingOrOffset, length);
  } // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97


  if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true,
      enumerable: false,
      writable: false
    });
  }

  Buffer.poolSize = 8192; // not used by this implementation

  function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset);
    }

    if (ArrayBuffer.isView(value)) {
      return fromArrayLike(value);
    }

    if (value == null) {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
    }

    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }

    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }

    var valueOf = value.valueOf && value.valueOf();

    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }

    var b = fromObject(value);
    if (b) return b;

    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
      return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    }

    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
  }
  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/


  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148


  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }

  function alloc(size, fill, encoding) {
    assertSize(size);

    if (size <= 0) {
      return createBuffer(size);
    }

    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }

    return createBuffer(size);
  }
  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/


  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding);
  };

  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */


  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */


  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size);
  };

  function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual);
    }

    return buf;
  }

  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);

    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }

    return buf;
  }

  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }

    var buf;

    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array);
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    } // Return an augmented `Uint8Array` instance


    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }

  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);

      if (buf.length === 0) {
        return buf;
      }

      obj.copy(buf, 0, 0, len);
      return buf;
    }

    if (obj.length !== undefined) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }

      return fromArrayLike(obj);
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }

  function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }

    return length | 0;
  }

  function SlowBuffer(length) {
    if (+length != length) {
      // eslint-disable-line eqeqeq
      length = 0;
    }

    return Buffer.alloc(+length);
  }

  Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
  };

  Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (isInstance(buf, Uint8Array)) {
        buf = Buffer.from(buf);
      }

      if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      buf.copy(buffer, pos);
      pos += buf.length;
    }

    return buffer;
  };

  function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }

    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
    }

    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;

        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;

        case 'hex':
          return len >>> 1;

        case 'base64':
          return base64ToBytes(string).length;

        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
          }

          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

    if (start === undefined || start < 0) {
      start = 0;
    } // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.


    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154


  Buffer.prototype._isBuffer = true;

  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }

    return this;
  };

  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }

    return this;
  };

  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }

    return this;
  };

  Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.toLocaleString = Buffer.prototype.toString;

  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
  };

  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }

  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }

    if (!Buffer.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf


  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1; // Normalize byteOffset

    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }

    byteOffset = +byteOffset; // Coerce to Number.

    if (numberIsNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    } // Normalize byteOffset: negative offsets start from the end of the buffer


    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    } // Normalize val


    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    } // Finally, search either indexOf (if dir is true) or lastIndexOf


    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }

      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]

      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }

      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();

      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }

        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;

    if (dir) {
      var foundIndex = -1;

      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

      for (i = byteOffset; i >= 0; i--) {
        var found = true;

        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }

        if (found) return i;
      }
    }

    return -1;
  }

  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;

    if (!length) {
      length = remaining;
    } else {
      length = Number(length);

      if (length > remaining) {
        length = remaining;
      }
    }

    var strLen = string.length;

    if (length > strLen / 2) {
      length = strLen / 2;
    }

    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }

    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0; // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0; // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0;

      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64Js.fromByteArray(buf);
    } else {
      return base64Js.fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;

    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }

            break;

          case 2:
            secondByte = buf[i + 1];

            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }

        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety


  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;

    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    } // Decode in chunks to avoid "call stack size exceeded".


    var res = '';
    var i = 0;

    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }

    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }

    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }

    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';

    for (var i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }

    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';

    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }

    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };
  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */


  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }

    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;

    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }

    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;

    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end);
    } else if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (var i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }

    return len;
  }; // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])


  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } else if (typeof val === 'boolean') {
      val = Number(val);
    } // Invalid ranges are not set to a default, so can range check early.


    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      var len = bytes.length;

      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  }; // HELPER FUNCTIONS
  // ================


  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

    str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

    if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

    while (str.length % 4 !== 0) {
      str = str + '=';
    }

    return str;
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i); // is surrogate component

      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } // valid lead


          leadSurrogate = codePoint;
          continue;
        } // 2 leads in a row


        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        } // valid surrogate pair


        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null; // encode utf8

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }

    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return base64Js.toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  // the `instanceof` check but they should be treated as of that type.
  // See: https://github.com/feross/buffer/issues/166


  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }

  function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj; // eslint-disable-line no-self-compare
  } // Create lookup table for `toString('hex')`
  // See: https://github.com/feross/buffer/issues/219


  var hexSliceLookupTable = function () {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);

    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;

      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }

    return table;
  }();
});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;

if (typeof global$1.setTimeout === 'function') {
  cachedSetTimeout = setTimeout;
}

if (typeof global$1.clearTimeout === 'function') {
  cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

function nextTick(fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
} // v8 likes predictible objects

function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues

var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding(name) {
  throw new Error('process.binding is not supported');
}
function cwd() {
  return '/';
}
function chdir(dir) {
  throw new Error('process.chdir is not supported');
}
function umask() {
  return 0;
} // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js

var performance = global$1.performance || {};

var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
  return new Date().getTime();
}; // generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime


function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);

  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];

    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }

  return [seconds, nanoseconds];
}
var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}
var process = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var BigInteger = createCommonjsModule(function (module) {
  var bigInt = function (undefined$1) {

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
    var supportsNativeBigInt = typeof BigInt === "function";

    function Integer(v, radix, alphabet, caseSensitive) {
      if (typeof v === "undefined") return Integer[0];
      if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
      return parseValue(v);
    }

    function BigInteger(value, sign) {
      this.value = value;
      this.sign = sign;
      this.isSmall = false;
    }

    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
      this.value = value;
      this.sign = value < 0;
      this.isSmall = true;
    }

    SmallInteger.prototype = Object.create(Integer.prototype);

    function NativeBigInt(value) {
      this.value = value;
    }

    NativeBigInt.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
      return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) {
      // For performance reasons doesn't reference BASE, need to change this function if BASE changes
      if (n < 1e7) return [n];
      if (n < 1e14) return [n % 1e7, Math.floor(n / 1e7)];
      return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) {
      // If BASE changes this function may need to change
      trim(arr);
      var length = arr.length;

      if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
        switch (length) {
          case 0:
            return 0;

          case 1:
            return arr[0];

          case 2:
            return arr[0] + arr[1] * BASE;

          default:
            return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
        }
      }

      return arr;
    }

    function trim(v) {
      var i = v.length;

      while (v[--i] === 0) {
      }

      v.length = i + 1;
    }

    function createArray(length) {
      // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
      var x = new Array(length);
      var i = -1;

      while (++i < length) {
        x[i] = 0;
      }

      return x;
    }

    function truncate(n) {
      if (n > 0) return Math.floor(n);
      return Math.ceil(n);
    }

    function add(a, b) {
      // assumes a and b are arrays with a.length >= b.length
      var l_a = a.length,
          l_b = b.length,
          r = new Array(l_a),
          carry = 0,
          base = BASE,
          sum,
          i;

      for (i = 0; i < l_b; i++) {
        sum = a[i] + b[i] + carry;
        carry = sum >= base ? 1 : 0;
        r[i] = sum - carry * base;
      }

      while (i < l_a) {
        sum = a[i] + carry;
        carry = sum === base ? 1 : 0;
        r[i++] = sum - carry * base;
      }

      if (carry > 0) r.push(carry);
      return r;
    }

    function addAny(a, b) {
      if (a.length >= b.length) return add(a, b);
      return add(b, a);
    }

    function addSmall(a, carry) {
      // assumes a is array, carry is number with 0 <= carry < MAX_INT
      var l = a.length,
          r = new Array(l),
          base = BASE,
          sum,
          i;

      for (i = 0; i < l; i++) {
        sum = a[i] - base + carry;
        carry = Math.floor(sum / base);
        r[i] = sum - carry * base;
        carry += 1;
      }

      while (carry > 0) {
        r[i++] = carry % base;
        carry = Math.floor(carry / base);
      }

      return r;
    }

    BigInteger.prototype.add = function (v) {
      var n = parseValue(v);

      if (this.sign !== n.sign) {
        return this.subtract(n.negate());
      }

      var a = this.value,
          b = n.value;

      if (n.isSmall) {
        return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
      }

      return new BigInteger(addAny(a, b), this.sign);
    };

    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
      var n = parseValue(v);
      var a = this.value;

      if (a < 0 !== n.sign) {
        return this.subtract(n.negate());
      }

      var b = n.value;

      if (n.isSmall) {
        if (isPrecise(a + b)) return new SmallInteger(a + b);
        b = smallToArray(Math.abs(b));
      }

      return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };

    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    NativeBigInt.prototype.add = function (v) {
      return new NativeBigInt(this.value + parseValue(v).value);
    };

    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;

    function subtract(a, b) {
      // assumes a and b are arrays with a >= b
      var a_l = a.length,
          b_l = b.length,
          r = new Array(a_l),
          borrow = 0,
          base = BASE,
          i,
          difference;

      for (i = 0; i < b_l; i++) {
        difference = a[i] - borrow - b[i];

        if (difference < 0) {
          difference += base;
          borrow = 1;
        } else borrow = 0;

        r[i] = difference;
      }

      for (i = b_l; i < a_l; i++) {
        difference = a[i] - borrow;
        if (difference < 0) difference += base;else {
          r[i++] = difference;
          break;
        }
        r[i] = difference;
      }

      for (; i < a_l; i++) {
        r[i] = a[i];
      }

      trim(r);
      return r;
    }

    function subtractAny(a, b, sign) {
      var value;

      if (compareAbs(a, b) >= 0) {
        value = subtract(a, b);
      } else {
        value = subtract(b, a);
        sign = !sign;
      }

      value = arrayToSmall(value);

      if (typeof value === "number") {
        if (sign) value = -value;
        return new SmallInteger(value);
      }

      return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) {
      // assumes a is array, b is number with 0 <= b < MAX_INT
      var l = a.length,
          r = new Array(l),
          carry = -b,
          base = BASE,
          i,
          difference;

      for (i = 0; i < l; i++) {
        difference = a[i] + carry;
        carry = Math.floor(difference / base);
        difference %= base;
        r[i] = difference < 0 ? difference + base : difference;
      }

      r = arrayToSmall(r);

      if (typeof r === "number") {
        if (sign) r = -r;
        return new SmallInteger(r);
      }

      return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
      var n = parseValue(v);

      if (this.sign !== n.sign) {
        return this.add(n.negate());
      }

      var a = this.value,
          b = n.value;
      if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
      return subtractAny(a, b, this.sign);
    };

    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
      var n = parseValue(v);
      var a = this.value;

      if (a < 0 !== n.sign) {
        return this.add(n.negate());
      }

      var b = n.value;

      if (n.isSmall) {
        return new SmallInteger(a - b);
      }

      return subtractSmall(b, Math.abs(a), a >= 0);
    };

    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    NativeBigInt.prototype.subtract = function (v) {
      return new NativeBigInt(this.value - parseValue(v).value);
    };

    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;

    BigInteger.prototype.negate = function () {
      return new BigInteger(this.value, !this.sign);
    };

    SmallInteger.prototype.negate = function () {
      var sign = this.sign;
      var small = new SmallInteger(-this.value);
      small.sign = !sign;
      return small;
    };

    NativeBigInt.prototype.negate = function () {
      return new NativeBigInt(-this.value);
    };

    BigInteger.prototype.abs = function () {
      return new BigInteger(this.value, false);
    };

    SmallInteger.prototype.abs = function () {
      return new SmallInteger(Math.abs(this.value));
    };

    NativeBigInt.prototype.abs = function () {
      return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    };

    function multiplyLong(a, b) {
      var a_l = a.length,
          b_l = b.length,
          l = a_l + b_l,
          r = createArray(l),
          base = BASE,
          product,
          carry,
          i,
          a_i,
          b_j;

      for (i = 0; i < a_l; ++i) {
        a_i = a[i];

        for (var j = 0; j < b_l; ++j) {
          b_j = b[j];
          product = a_i * b_j + r[i + j];
          carry = Math.floor(product / base);
          r[i + j] = product - carry * base;
          r[i + j + 1] += carry;
        }
      }

      trim(r);
      return r;
    }

    function multiplySmall(a, b) {
      // assumes a is array, b is number with |b| < BASE
      var l = a.length,
          r = new Array(l),
          base = BASE,
          carry = 0,
          product,
          i;

      for (i = 0; i < l; i++) {
        product = a[i] * b + carry;
        carry = Math.floor(product / base);
        r[i] = product - carry * base;
      }

      while (carry > 0) {
        r[i++] = carry % base;
        carry = Math.floor(carry / base);
      }

      return r;
    }

    function shiftLeft(x, n) {
      var r = [];

      while (n-- > 0) {
        r.push(0);
      }

      return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
      var n = Math.max(x.length, y.length);
      if (n <= 30) return multiplyLong(x, y);
      n = Math.ceil(n / 2);
      var b = x.slice(n),
          a = x.slice(0, n),
          d = y.slice(n),
          c = y.slice(0, n);
      var ac = multiplyKaratsuba(a, c),
          bd = multiplyKaratsuba(b, d),
          abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
      var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
      trim(product);
      return product;
    } // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.


    function useKaratsuba(l1, l2) {
      return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
      var n = parseValue(v),
          a = this.value,
          b = n.value,
          sign = this.sign !== n.sign,
          abs;

      if (n.isSmall) {
        if (b === 0) return Integer[0];
        if (b === 1) return this;
        if (b === -1) return this.negate();
        abs = Math.abs(b);

        if (abs < BASE) {
          return new BigInteger(multiplySmall(a, abs), sign);
        }

        b = smallToArray(abs);
      }

      if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
        return new BigInteger(multiplyKaratsuba(a, b), sign);
      return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) {
      // a >= 0
      if (a < BASE) {
        return new BigInteger(multiplySmall(b, a), sign);
      }

      return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }

    SmallInteger.prototype._multiplyBySmall = function (a) {
      if (isPrecise(a.value * this.value)) {
        return new SmallInteger(a.value * this.value);
      }

      return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };

    BigInteger.prototype._multiplyBySmall = function (a) {
      if (a.value === 0) return Integer[0];
      if (a.value === 1) return this;
      if (a.value === -1) return this.negate();
      return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };

    SmallInteger.prototype.multiply = function (v) {
      return parseValue(v)._multiplyBySmall(this);
    };

    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    NativeBigInt.prototype.multiply = function (v) {
      return new NativeBigInt(this.value * parseValue(v).value);
    };

    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;

    function square(a) {
      //console.assert(2 * BASE * BASE < MAX_INT);
      var l = a.length,
          r = createArray(l + l),
          base = BASE,
          product,
          carry,
          i,
          a_i,
          a_j;

      for (i = 0; i < l; i++) {
        a_i = a[i];
        carry = 0 - a_i * a_i;

        for (var j = i; j < l; j++) {
          a_j = a[j];
          product = 2 * (a_i * a_j) + r[i + j] + carry;
          carry = Math.floor(product / base);
          r[i + j] = product - carry * base;
        }

        r[i + l] = carry;
      }

      trim(r);
      return r;
    }

    BigInteger.prototype.square = function () {
      return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
      var value = this.value * this.value;
      if (isPrecise(value)) return new SmallInteger(value);
      return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    NativeBigInt.prototype.square = function (v) {
      return new NativeBigInt(this.value * this.value);
    };

    function divMod1(a, b) {
      // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
      var a_l = a.length,
          b_l = b.length,
          base = BASE,
          result = createArray(b.length),
          divisorMostSignificantDigit = b[b_l - 1],
          // normalization
      lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
          remainder = multiplySmall(a, lambda),
          divisor = multiplySmall(b, lambda),
          quotientDigit,
          shift,
          carry,
          borrow,
          i,
          l,
          q;
      if (remainder.length <= a_l) remainder.push(0);
      divisor.push(0);
      divisorMostSignificantDigit = divisor[b_l - 1];

      for (shift = a_l - b_l; shift >= 0; shift--) {
        quotientDigit = base - 1;

        if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
          quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
        } // quotientDigit <= base - 1


        carry = 0;
        borrow = 0;
        l = divisor.length;

        for (i = 0; i < l; i++) {
          carry += quotientDigit * divisor[i];
          q = Math.floor(carry / base);
          borrow += remainder[shift + i] - (carry - q * base);
          carry = q;

          if (borrow < 0) {
            remainder[shift + i] = borrow + base;
            borrow = -1;
          } else {
            remainder[shift + i] = borrow;
            borrow = 0;
          }
        }

        while (borrow !== 0) {
          quotientDigit -= 1;
          carry = 0;

          for (i = 0; i < l; i++) {
            carry += remainder[shift + i] - base + divisor[i];

            if (carry < 0) {
              remainder[shift + i] = carry + base;
              carry = 0;
            } else {
              remainder[shift + i] = carry;
              carry = 1;
            }
          }

          borrow += carry;
        }

        result[shift] = quotientDigit;
      } // denormalization


      remainder = divModSmall(remainder, lambda)[0];
      return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) {
      // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
      // Performs faster than divMod1 on larger input sizes.
      var a_l = a.length,
          b_l = b.length,
          result = [],
          part = [],
          base = BASE,
          guess,
          xlen,
          highx,
          highy,
          check;

      while (a_l) {
        part.unshift(a[--a_l]);
        trim(part);

        if (compareAbs(part, b) < 0) {
          result.push(0);
          continue;
        }

        xlen = part.length;
        highx = part[xlen - 1] * base + part[xlen - 2];
        highy = b[b_l - 1] * base + b[b_l - 2];

        if (xlen > b_l) {
          highx = (highx + 1) * base;
        }

        guess = Math.ceil(highx / highy);

        do {
          check = multiplySmall(b, guess);
          if (compareAbs(check, part) <= 0) break;
          guess--;
        } while (guess);

        result.push(guess);
        part = subtract(part, check);
      }

      result.reverse();
      return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
      var length = value.length,
          quotient = createArray(length),
          base = BASE,
          i,
          q,
          remainder,
          divisor;
      remainder = 0;

      for (i = length - 1; i >= 0; --i) {
        divisor = remainder * base + value[i];
        q = truncate(divisor / lambda);
        remainder = divisor - q * lambda;
        quotient[i] = q | 0;
      }

      return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
      var value,
          n = parseValue(v);

      if (supportsNativeBigInt) {
        return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
      }

      var a = self.value,
          b = n.value;
      var quotient;
      if (b === 0) throw new Error("Cannot divide by zero");

      if (self.isSmall) {
        if (n.isSmall) {
          return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
        }

        return [Integer[0], self];
      }

      if (n.isSmall) {
        if (b === 1) return [self, Integer[0]];
        if (b == -1) return [self.negate(), Integer[0]];
        var abs = Math.abs(b);

        if (abs < BASE) {
          value = divModSmall(a, abs);
          quotient = arrayToSmall(value[0]);
          var remainder = value[1];
          if (self.sign) remainder = -remainder;

          if (typeof quotient === "number") {
            if (self.sign !== n.sign) quotient = -quotient;
            return [new SmallInteger(quotient), new SmallInteger(remainder)];
          }

          return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
        }

        b = smallToArray(abs);
      }

      var comparison = compareAbs(a, b);
      if (comparison === -1) return [Integer[0], self];
      if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]]; // divMod1 is faster on smaller input sizes

      if (a.length + b.length <= 200) value = divMod1(a, b);else value = divMod2(a, b);
      quotient = value[0];
      var qSign = self.sign !== n.sign,
          mod = value[1],
          mSign = self.sign;

      if (typeof quotient === "number") {
        if (qSign) quotient = -quotient;
        quotient = new SmallInteger(quotient);
      } else quotient = new BigInteger(quotient, qSign);

      if (typeof mod === "number") {
        if (mSign) mod = -mod;
        mod = new SmallInteger(mod);
      } else mod = new BigInteger(mod, mSign);

      return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
      var result = divModAny(this, v);
      return {
        quotient: result[0],
        remainder: result[1]
      };
    };

    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;

    BigInteger.prototype.divide = function (v) {
      return divModAny(this, v)[0];
    };

    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
      return new NativeBigInt(this.value / parseValue(v).value);
    };

    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
      return divModAny(this, v)[1];
    };

    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
      return new NativeBigInt(this.value % parseValue(v).value);
    };

    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
      var n = parseValue(v),
          a = this.value,
          b = n.value,
          value,
          x,
          y;
      if (b === 0) return Integer[1];
      if (a === 0) return Integer[0];
      if (a === 1) return Integer[1];
      if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];

      if (n.sign) {
        return Integer[0];
      }

      if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");

      if (this.isSmall) {
        if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
      }

      x = this;
      y = Integer[1];

      while (true) {
        if (b & 1 === 1) {
          y = y.times(x);
          --b;
        }

        if (b === 0) break;
        b /= 2;
        x = x.square();
      }

      return y;
    };

    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    NativeBigInt.prototype.pow = function (v) {
      var n = parseValue(v);
      var a = this.value,
          b = n.value;

      var _0 = BigInt(0),
          _1 = BigInt(1),
          _2 = BigInt(2);

      if (b === _0) return Integer[1];
      if (a === _0) return Integer[0];
      if (a === _1) return Integer[1];
      if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
      if (n.isNegative()) return new NativeBigInt(_0);
      var x = this;
      var y = Integer[1];

      while (true) {
        if ((b & _1) === _1) {
          y = y.times(x);
          --b;
        }

        if (b === _0) break;
        b /= _2;
        x = x.square();
      }

      return y;
    };

    BigInteger.prototype.modPow = function (exp, mod) {
      exp = parseValue(exp);
      mod = parseValue(mod);
      if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
      var r = Integer[1],
          base = this.mod(mod);

      if (exp.isNegative()) {
        exp = exp.multiply(Integer[-1]);
        base = base.modInv(mod);
      }

      while (exp.isPositive()) {
        if (base.isZero()) return Integer[0];
        if (exp.isOdd()) r = r.multiply(base).mod(mod);
        exp = exp.divide(2);
        base = base.square().mod(mod);
      }

      return r;
    };

    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
      if (a.length !== b.length) {
        return a.length > b.length ? 1 : -1;
      }

      for (var i = a.length - 1; i >= 0; i--) {
        if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
      }

      return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
      var n = parseValue(v),
          a = this.value,
          b = n.value;
      if (n.isSmall) return 1;
      return compareAbs(a, b);
    };

    SmallInteger.prototype.compareAbs = function (v) {
      var n = parseValue(v),
          a = Math.abs(this.value),
          b = n.value;

      if (n.isSmall) {
        b = Math.abs(b);
        return a === b ? 0 : a > b ? 1 : -1;
      }

      return -1;
    };

    NativeBigInt.prototype.compareAbs = function (v) {
      var a = this.value;
      var b = parseValue(v).value;
      a = a >= 0 ? a : -a;
      b = b >= 0 ? b : -b;
      return a === b ? 0 : a > b ? 1 : -1;
    };

    BigInteger.prototype.compare = function (v) {
      // See discussion about comparison with Infinity:
      // https://github.com/peterolson/BigInteger.js/issues/61
      if (v === Infinity) {
        return -1;
      }

      if (v === -Infinity) {
        return 1;
      }

      var n = parseValue(v),
          a = this.value,
          b = n.value;

      if (this.sign !== n.sign) {
        return n.sign ? 1 : -1;
      }

      if (n.isSmall) {
        return this.sign ? -1 : 1;
      }

      return compareAbs(a, b) * (this.sign ? -1 : 1);
    };

    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
      if (v === Infinity) {
        return -1;
      }

      if (v === -Infinity) {
        return 1;
      }

      var n = parseValue(v),
          a = this.value,
          b = n.value;

      if (n.isSmall) {
        return a == b ? 0 : a > b ? 1 : -1;
      }

      if (a < 0 !== n.sign) {
        return a < 0 ? -1 : 1;
      }

      return a < 0 ? 1 : -1;
    };

    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    NativeBigInt.prototype.compare = function (v) {
      if (v === Infinity) {
        return -1;
      }

      if (v === -Infinity) {
        return 1;
      }

      var a = this.value;
      var b = parseValue(v).value;
      return a === b ? 0 : a > b ? 1 : -1;
    };

    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;

    BigInteger.prototype.equals = function (v) {
      return this.compare(v) === 0;
    };

    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
      return this.compare(v) !== 0;
    };

    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
      return this.compare(v) > 0;
    };

    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
      return this.compare(v) < 0;
    };

    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
      return this.compare(v) >= 0;
    };

    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
      return this.compare(v) <= 0;
    };

    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
      return (this.value[0] & 1) === 0;
    };

    SmallInteger.prototype.isEven = function () {
      return (this.value & 1) === 0;
    };

    NativeBigInt.prototype.isEven = function () {
      return (this.value & BigInt(1)) === BigInt(0);
    };

    BigInteger.prototype.isOdd = function () {
      return (this.value[0] & 1) === 1;
    };

    SmallInteger.prototype.isOdd = function () {
      return (this.value & 1) === 1;
    };

    NativeBigInt.prototype.isOdd = function () {
      return (this.value & BigInt(1)) === BigInt(1);
    };

    BigInteger.prototype.isPositive = function () {
      return !this.sign;
    };

    SmallInteger.prototype.isPositive = function () {
      return this.value > 0;
    };

    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;

    BigInteger.prototype.isNegative = function () {
      return this.sign;
    };

    SmallInteger.prototype.isNegative = function () {
      return this.value < 0;
    };

    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;

    BigInteger.prototype.isUnit = function () {
      return false;
    };

    SmallInteger.prototype.isUnit = function () {
      return Math.abs(this.value) === 1;
    };

    NativeBigInt.prototype.isUnit = function () {
      return this.abs().value === BigInt(1);
    };

    BigInteger.prototype.isZero = function () {
      return false;
    };

    SmallInteger.prototype.isZero = function () {
      return this.value === 0;
    };

    NativeBigInt.prototype.isZero = function () {
      return this.value === BigInt(0);
    };

    BigInteger.prototype.isDivisibleBy = function (v) {
      var n = parseValue(v);
      if (n.isZero()) return false;
      if (n.isUnit()) return true;
      if (n.compareAbs(2) === 0) return this.isEven();
      return this.mod(n).isZero();
    };

    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
      var n = v.abs();
      if (n.isUnit()) return false;
      if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
      if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
      if (n.lesser(49)) return true; // we don't know if it's prime: let the other functions figure it out
    }

    function millerRabinTest(n, a) {
      var nPrev = n.prev(),
          b = nPrev,
          r = 0,
          d,
          i,
          x;

      while (b.isEven()) {
        b = b.divide(2), r++;
      }

      next: for (i = 0; i < a.length; i++) {
        if (n.lesser(a[i])) continue;
        x = bigInt(a[i]).modPow(b, n);
        if (x.isUnit() || x.equals(nPrev)) continue;

        for (d = r - 1; d != 0; d--) {
          x = x.square().mod(n);
          if (x.isUnit()) return false;
          if (x.equals(nPrev)) continue next;
        }

        return false;
      }

      return true;
    } // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2


    BigInteger.prototype.isPrime = function (strict) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined$1) return isPrime;
      var n = this.abs();
      var bits = n.bitLength();
      if (bits <= 64) return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      var logN = Math.log(2) * bits.toJSNumber();
      var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);

      for (var a = [], i = 0; i < t; i++) {
        a.push(bigInt(i + 2));
      }

      return millerRabinTest(n, a);
    };

    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations, rng) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined$1) return isPrime;
      var n = this.abs();
      var t = iterations === undefined$1 ? 5 : iterations;

      for (var a = [], i = 0; i < t; i++) {
        a.push(bigInt.randBetween(2, n.minus(2), rng));
      }

      return millerRabinTest(n, a);
    };

    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
      var t = bigInt.zero,
          newT = bigInt.one,
          r = parseValue(n),
          newR = this.abs(),
          q,
          lastT,
          lastR;

      while (!newR.isZero()) {
        q = r.divide(newR);
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT.subtract(q.multiply(newT));
        newR = lastR.subtract(q.multiply(newR));
      }

      if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");

      if (t.compare(0) === -1) {
        t = t.add(n);
      }

      if (this.isNegative()) {
        return t.negate();
      }

      return t;
    };

    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
      var value = this.value;

      if (this.sign) {
        return subtractSmall(value, 1, this.sign);
      }

      return new BigInteger(addSmall(value, 1), this.sign);
    };

    SmallInteger.prototype.next = function () {
      var value = this.value;
      if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
      return new BigInteger(MAX_INT_ARR, false);
    };

    NativeBigInt.prototype.next = function () {
      return new NativeBigInt(this.value + BigInt(1));
    };

    BigInteger.prototype.prev = function () {
      var value = this.value;

      if (this.sign) {
        return new BigInteger(addSmall(value, 1), true);
      }

      return subtractSmall(value, 1, this.sign);
    };

    SmallInteger.prototype.prev = function () {
      var value = this.value;
      if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
      return new BigInteger(MAX_INT_ARR, true);
    };

    NativeBigInt.prototype.prev = function () {
      return new NativeBigInt(this.value - BigInt(1));
    };

    var powersOfTwo = [1];

    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) {
      powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    }

    var powers2Length = powersOfTwo.length,
        highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
      return Math.abs(n) <= BASE;
    }

    BigInteger.prototype.shiftLeft = function (v) {
      var n = parseValue(v).toJSNumber();

      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }

      if (n < 0) return this.shiftRight(-n);
      var result = this;
      if (result.isZero()) return result;

      while (n >= powers2Length) {
        result = result.multiply(highestPower2);
        n -= powers2Length - 1;
      }

      return result.multiply(powersOfTwo[n]);
    };

    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (v) {
      var remQuo;
      var n = parseValue(v).toJSNumber();

      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }

      if (n < 0) return this.shiftLeft(-n);
      var result = this;

      while (n >= powers2Length) {
        if (result.isZero() || result.isNegative() && result.isUnit()) return result;
        remQuo = divModAny(result, highestPower2);
        result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        n -= powers2Length - 1;
      }

      remQuo = divModAny(result, powersOfTwo[n]);
      return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };

    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
      y = parseValue(y);
      var xSign = x.isNegative(),
          ySign = y.isNegative();
      var xRem = xSign ? x.not() : x,
          yRem = ySign ? y.not() : y;
      var xDigit = 0,
          yDigit = 0;
      var xDivMod = null,
          yDivMod = null;
      var result = [];

      while (!xRem.isZero() || !yRem.isZero()) {
        xDivMod = divModAny(xRem, highestPower2);
        xDigit = xDivMod[1].toJSNumber();

        if (xSign) {
          xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
        }

        yDivMod = divModAny(yRem, highestPower2);
        yDigit = yDivMod[1].toJSNumber();

        if (ySign) {
          yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
        }

        xRem = xDivMod[0];
        yRem = yDivMod[0];
        result.push(fn(xDigit, yDigit));
      }

      var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);

      for (var i = result.length - 1; i >= 0; i -= 1) {
        sum = sum.multiply(highestPower2).add(bigInt(result[i]));
      }

      return sum;
    }

    BigInteger.prototype.not = function () {
      return this.negate().prev();
    };

    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
      return bitwise(this, n, function (a, b) {
        return a & b;
      });
    };

    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
      return bitwise(this, n, function (a, b) {
        return a | b;
      });
    };

    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
      return bitwise(this, n, function (a, b) {
        return a ^ b;
      });
    };

    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
    var LOBMASK_I = 1 << 30,
        LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;

    function roughLOB(n) {
      // get lowestOneBit (rough)
      // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
      // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
      var v = n.value,
          x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
      return x & -x;
    }

    function integerLogarithm(value, base) {
      if (base.compareTo(value) <= 0) {
        var tmp = integerLogarithm(value, base.square(base));
        var p = tmp.p;
        var e = tmp.e;
        var t = p.multiply(base);
        return t.compareTo(value) <= 0 ? {
          p: t,
          e: e * 2 + 1
        } : {
          p: p,
          e: e * 2
        };
      }

      return {
        p: bigInt(1),
        e: 0
      };
    }

    BigInteger.prototype.bitLength = function () {
      var n = this;

      if (n.compareTo(bigInt(0)) < 0) {
        n = n.negate().subtract(bigInt(1));
      }

      if (n.compareTo(bigInt(0)) === 0) {
        return bigInt(0);
      }

      return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    };

    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;

    function max(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.greater(b) ? a : b;
    }

    function min(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.lesser(b) ? a : b;
    }

    function gcd(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      if (a.equals(b)) return a;
      if (a.isZero()) return b;
      if (b.isZero()) return a;
      var c = Integer[1],
          d,
          t;

      while (a.isEven() && b.isEven()) {
        d = min(roughLOB(a), roughLOB(b));
        a = a.divide(d);
        b = b.divide(d);
        c = c.multiply(d);
      }

      while (a.isEven()) {
        a = a.divide(roughLOB(a));
      }

      do {
        while (b.isEven()) {
          b = b.divide(roughLOB(b));
        }

        if (a.greater(b)) {
          t = b;
          b = a;
          a = t;
        }

        b = b.subtract(a);
      } while (!b.isZero());

      return c.isUnit() ? a : a.multiply(c);
    }

    function lcm(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      return a.divide(gcd(a, b)).multiply(b);
    }

    function randBetween(a, b, rng) {
      a = parseValue(a);
      b = parseValue(b);
      var usedRNG = rng || Math.random;
      var low = min(a, b),
          high = max(a, b);
      var range = high.subtract(low).add(1);
      if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
      var digits = toBase(range, BASE).value;
      var result = [],
          restricted = true;

      for (var i = 0; i < digits.length; i++) {
        var top = restricted ? digits[i] : BASE;
        var digit = truncate(usedRNG() * top);
        result.push(digit);
        if (digit < top) restricted = false;
      }

      return low.add(Integer.fromArray(result, BASE, false));
    }

    var parseBase = function parseBase(text, base, alphabet, caseSensitive) {
      alphabet = alphabet || DEFAULT_ALPHABET;
      text = String(text);

      if (!caseSensitive) {
        text = text.toLowerCase();
        alphabet = alphabet.toLowerCase();
      }

      var length = text.length;
      var i;
      var absBase = Math.abs(base);
      var alphabetValues = {};

      for (i = 0; i < alphabet.length; i++) {
        alphabetValues[alphabet[i]] = i;
      }

      for (i = 0; i < length; i++) {
        var c = text[i];
        if (c === "-") continue;

        if (c in alphabetValues) {
          if (alphabetValues[c] >= absBase) {
            if (c === "1" && absBase === 1) continue;
            throw new Error(c + " is not a valid digit in base " + base + ".");
          }
        }
      }

      base = parseValue(base);
      var digits = [];
      var isNegative = text[0] === "-";

      for (i = isNegative ? 1 : 0; i < text.length; i++) {
        var c = text[i];
        if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));else if (c === "<") {
          var start = i;

          do {
            i++;
          } while (text[i] !== ">" && i < text.length);

          digits.push(parseValue(text.slice(start + 1, i)));
        } else throw new Error(c + " is not a valid character");
      }

      return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
      var val = Integer[0],
          pow = Integer[1],
          i;

      for (i = digits.length - 1; i >= 0; i--) {
        val = val.add(digits[i].times(pow));
        pow = pow.times(base);
      }

      return isNegative ? val.negate() : val;
    }

    function stringify(digit, alphabet) {
      alphabet = alphabet || DEFAULT_ALPHABET;

      if (digit < alphabet.length) {
        return alphabet[digit];
      }

      return "<" + digit + ">";
    }

    function toBase(n, base) {
      base = bigInt(base);

      if (base.isZero()) {
        if (n.isZero()) return {
          value: [0],
          isNegative: false
        };
        throw new Error("Cannot convert nonzero numbers to base 0.");
      }

      if (base.equals(-1)) {
        if (n.isZero()) return {
          value: [0],
          isNegative: false
        };
        if (n.isNegative()) return {
          value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
          isNegative: false
        };
        var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
        arr.unshift([1]);
        return {
          value: [].concat.apply([], arr),
          isNegative: false
        };
      }

      var neg = false;

      if (n.isNegative() && base.isPositive()) {
        neg = true;
        n = n.abs();
      }

      if (base.isUnit()) {
        if (n.isZero()) return {
          value: [0],
          isNegative: false
        };
        return {
          value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
          isNegative: neg
        };
      }

      var out = [];
      var left = n,
          divmod;

      while (left.isNegative() || left.compareAbs(base) >= 0) {
        divmod = left.divmod(base);
        left = divmod.quotient;
        var digit = divmod.remainder;

        if (digit.isNegative()) {
          digit = base.minus(digit).abs();
          left = left.next();
        }

        out.push(digit.toJSNumber());
      }

      out.push(left.toJSNumber());
      return {
        value: out.reverse(),
        isNegative: neg
      };
    }

    function toBaseString(n, base, alphabet) {
      var arr = toBase(n, base);
      return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
        return stringify(x, alphabet);
      }).join('');
    }

    BigInteger.prototype.toArray = function (radix) {
      return toBase(this, radix);
    };

    SmallInteger.prototype.toArray = function (radix) {
      return toBase(this, radix);
    };

    NativeBigInt.prototype.toArray = function (radix) {
      return toBase(this, radix);
    };

    BigInteger.prototype.toString = function (radix, alphabet) {
      if (radix === undefined$1) radix = 10;
      if (radix !== 10) return toBaseString(this, radix, alphabet);
      var v = this.value,
          l = v.length,
          str = String(v[--l]),
          zeros = "0000000",
          digit;

      while (--l >= 0) {
        digit = String(v[l]);
        str += zeros.slice(digit.length) + digit;
      }

      var sign = this.sign ? "-" : "";
      return sign + str;
    };

    SmallInteger.prototype.toString = function (radix, alphabet) {
      if (radix === undefined$1) radix = 10;
      if (radix != 10) return toBaseString(this, radix, alphabet);
      return String(this.value);
    };

    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;

    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () {
      return this.toString();
    };

    BigInteger.prototype.valueOf = function () {
      return parseInt(this.toString(), 10);
    };

    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
      return this.value;
    };

    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;

    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
      return parseInt(this.toString(), 10);
    };

    function parseStringValue(v) {
      if (isPrecise(+v)) {
        var x = +v;
        if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
        throw new Error("Invalid integer: " + v);
      }

      var sign = v[0] === "-";
      if (sign) v = v.slice(1);
      var split = v.split(/e/i);
      if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));

      if (split.length === 2) {
        var exp = split[1];
        if (exp[0] === "+") exp = exp.slice(1);
        exp = +exp;
        if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
        var text = split[0];
        var decimalPlace = text.indexOf(".");

        if (decimalPlace >= 0) {
          exp -= text.length - decimalPlace - 1;
          text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
        }

        if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
        text += new Array(exp + 1).join("0");
        v = text;
      }

      var isValid = /^([0-9][0-9]*)$/.test(v);
      if (!isValid) throw new Error("Invalid integer: " + v);

      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(sign ? "-" + v : v));
      }

      var r = [],
          max = v.length,
          l = LOG_BASE,
          min = max - l;

      while (max > 0) {
        r.push(+v.slice(min, max));
        min -= l;
        if (min < 0) min = 0;
        max -= l;
      }

      trim(r);
      return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(v));
      }

      if (isPrecise(v)) {
        if (v !== truncate(v)) throw new Error(v + " is not an integer.");
        return new SmallInteger(v);
      }

      return parseStringValue(v.toString());
    }

    function parseValue(v) {
      if (typeof v === "number") {
        return parseNumberValue(v);
      }

      if (typeof v === "string") {
        return parseStringValue(v);
      }

      if (typeof v === "bigint") {
        return new NativeBigInt(v);
      }

      return v;
    } // Pre-define numbers in range [-999,999]


    for (var i = 0; i < 1000; i++) {
      Integer[i] = parseValue(i);
      if (i > 0) Integer[-i] = parseValue(-i);
    } // Backwards compatibility


    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;

    Integer.isInstance = function (x) {
      return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
    };

    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
      return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
  }(); // Node.js check


  if ( module.hasOwnProperty("exports")) {
    module.exports = bigInt;
  } //amd check
});

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
  if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
    return false;
  }

  return toStr.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
  if (isStandardArguments(value)) {
    return true;
  }

  return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value) !== '[object Array]' && toStr.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = function () {
  return isStandardArguments(arguments);
}();

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

var toStr$1 = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag$1 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var getProto = Object.getPrototypeOf;

var getGeneratorFunc = function getGeneratorFunc() {
  // eslint-disable-line consistent-return
  if (!hasToStringTag$1) {
    return false;
  }

  try {
    return Function('return function*() {}')();
  } catch (e) {}
};

var generatorFunc = getGeneratorFunc();
var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};

var isGeneratorFunction = function isGeneratorFunction(fn) {
  if (typeof fn !== 'function') {
    return false;
  }

  if (isFnRegex.test(fnToStr.call(fn))) {
    return true;
  }

  if (!hasToStringTag$1) {
    var str = toStr$1.call(fn);
    return str === '[object GeneratorFunction]';
  }

  return getProto(fn) === GeneratorFunction;
};

var hasOwn = Object.prototype.hasOwnProperty;
var toString$1 = Object.prototype.toString;

var foreach = function forEach(obj, fn, ctx) {
  if (toString$1.call(fn) !== '[object Function]') {
    throw new TypeError('iterator must be a function');
  }

  var l = obj.length;

  if (l === +l) {
    for (var i = 0; i < l; i++) {
      fn.call(ctx, obj[i], i, obj);
    }
  } else {
    for (var k in obj) {
      if (hasOwn.call(obj, k)) {
        fn.call(ctx, obj[k], k, obj);
      }
    }
  }
};

/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */
var arrayFilter = function arrayFilter(arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError();
  if ('function' != typeof fn) throw new TypeError();
  var ret = [];

  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn$1.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }

  return ret;
};

var hasOwn$1 = Object.prototype.hasOwnProperty;

var availableTypedArrays = function availableTypedArrays() {
  return arrayFilter(['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'], function (typedArray) {
    return typeof commonjsGlobal[typedArray] === 'function';
  });
};

/* eslint complexity: [2, 18], max-statements: [2, 33] */

var shams = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if (typeof Symbol.iterator === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax


  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};

var origSymbol = commonjsGlobal.Symbol;

var hasSymbols = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if (typeof origSymbol('foo') !== 'symbol') {
    return false;
  }

  if (typeof Symbol('bar') !== 'symbol') {
    return false;
  }

  return shams();
};

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr$2 = Object.prototype.toString;
var funcType = '[object Function]';

var implementation = function bind(that) {
  var target = this;

  if (typeof target !== 'function' || toStr$2.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }

  var args = slice.call(arguments, 1);
  var bound;

  var binder = function binder() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));

      if (Object(result) === result) {
        return result;
      }

      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };

  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];

  for (var i = 0; i < boundLength; i++) {
    boundArgs.push('$' + i);
  }

  bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

  if (target.prototype) {
    var Empty = function Empty() {};

    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }

  return bound;
};

var functionBind = Function.prototype.bind || implementation;

/* globals
	Atomics,
	SharedArrayBuffer,
*/


var undefined$1;
var $TypeError = TypeError;
var $gOPD = Object.getOwnPropertyDescriptor;

if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function throwTypeError() {
  throw new $TypeError();
};

var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = hasSymbols();

var getProto$1 = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto

var generatorFunction =  undefined$1;

var asyncFunction =  undefined$1;

var asyncGenFunction =  undefined$1;
var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
  '%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,
  '%ArrayIteratorPrototype%': hasSymbols$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  '%ArrayPrototype%': Array.prototype,
  '%ArrayProto_entries%': Array.prototype.entries,
  '%ArrayProto_forEach%': Array.prototype.forEach,
  '%ArrayProto_keys%': Array.prototype.keys,
  '%ArrayProto_values%': Array.prototype.values,
  '%AsyncFromSyncIteratorPrototype%': undefined$1,
  '%AsyncFunction%': asyncFunction,
  '%AsyncFunctionPrototype%':  undefined$1,
  '%AsyncGenerator%':  undefined$1,
  '%AsyncGeneratorFunction%': asyncGenFunction,
  '%AsyncGeneratorPrototype%':  undefined$1,
  '%AsyncIteratorPrototype%':  undefined$1,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
  '%Boolean%': Boolean,
  '%BooleanPrototype%': Boolean.prototype,
  '%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
  '%DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,
  '%Date%': Date,
  '%DatePrototype%': Date.prototype,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%ErrorPrototype%': Error.prototype,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%EvalErrorPrototype%': EvalError.prototype,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
  '%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
  '%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,
  '%Function%': Function,
  '%FunctionPrototype%': Function.prototype,
  '%Generator%':  undefined$1,
  '%GeneratorFunction%': generatorFunction,
  '%GeneratorPrototype%':  undefined$1,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
  '%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
  '%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
  '%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  '%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
  '%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined$1,
  '%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
  '%MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,
  '%Math%': Math,
  '%Number%': Number,
  '%NumberPrototype%': Number.prototype,
  '%Object%': Object,
  '%ObjectPrototype%': Object.prototype,
  '%ObjProto_toString%': Object.prototype.toString,
  '%ObjProto_valueOf%': Object.prototype.valueOf,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
  '%PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,
  '%PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,
  '%Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,
  '%Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,
  '%Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
  '%RangeError%': RangeError,
  '%RangeErrorPrototype%': RangeError.prototype,
  '%ReferenceError%': ReferenceError,
  '%ReferenceErrorPrototype%': ReferenceError.prototype,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
  '%RegExp%': RegExp,
  '%RegExpPrototype%': RegExp.prototype,
  '%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
  '%SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
  '%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols$1 ? getProto$1(''[Symbol.iterator]()) : undefined$1,
  '%StringPrototype%': String.prototype,
  '%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
  '%SymbolPrototype%': hasSymbols$1 ? Symbol.prototype : undefined$1,
  '%SyntaxError%': SyntaxError,
  '%SyntaxErrorPrototype%': SyntaxError.prototype,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,
  '%TypeError%': $TypeError,
  '%TypeErrorPrototype%': $TypeError.prototype,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
  '%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
  '%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
  '%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
  '%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,
  '%URIError%': URIError,
  '%URIErrorPrototype%': URIError.prototype,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
  '%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
  '%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype
};
var $replace = functionBind.call(Function.call, String.prototype.replace);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

var stringToPath = function stringToPath(string) {
  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  if (!(name in INTRINSICS)) {
    throw new SyntaxError('intrinsic ' + name + ' does not exist!');
  } // istanbul ignore if // hopefully this is impossible to test :-)


  if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
    throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
  }

  return INTRINSICS[name];
};

var GetIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new TypeError('"allowMissing" argument must be a boolean');
  }

  var parts = stringToPath(name);
  var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);

  for (var i = 1; i < parts.length; i += 1) {
    if (value != null) {
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, parts[i]);

        if (!allowMissing && !(parts[i] in value)) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }

        value = desc ? desc.get || desc.value : value[parts[i]];
      } else {
        value = value[parts[i]];
      }
    }
  }

  return value;
};

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || functionBind.call($call, $apply);

var callBind = function callBind() {
  return $reflectApply(functionBind, $call, arguments);
};

var apply = function applyBind() {
  return $reflectApply(functionBind, $apply, arguments);
};
callBind.apply = apply;

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

var callBound = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
    return callBind(intrinsic);
  }

  return intrinsic;
};

var $gOPD$1 = GetIntrinsic('%Object.getOwnPropertyDescriptor%');

if ($gOPD$1) {
  try {
    $gOPD$1([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD$1 = null;
  }
}

var getOwnPropertyDescriptor = $gOPD$1;

var $toString = callBound('Object.prototype.toString');
var hasSymbols$2 = hasSymbols();
var hasToStringTag$2 = hasSymbols$2 && typeof Symbol.toStringTag === 'symbol';
var typedArrays = availableTypedArrays();

var $indexOf$1 = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }

  return -1;
};

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

if (hasToStringTag$2 && getOwnPropertyDescriptor && getPrototypeOf) {
  foreach(typedArrays, function (typedArray) {
    var arr = new commonjsGlobal[typedArray]();

    if (!(Symbol.toStringTag in arr)) {
      throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
    }

    var proto = getPrototypeOf(arr);
    var descriptor = getOwnPropertyDescriptor(proto, Symbol.toStringTag);

    if (!descriptor) {
      var superProto = getPrototypeOf(proto);
      descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
    }

    toStrTags[typedArray] = descriptor.get;
  });
}

var tryTypedArrays = function tryAllTypedArrays(value) {
  var anyTrue = false;
  foreach(toStrTags, function (getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value) === typedArray;
      } catch (e) {
        /**/
      }
    }
  });
  return anyTrue;
};

var isTypedArray = function isTypedArray(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }

  if (!hasToStringTag$2) {
    var tag = $slice($toString(value), 8, -1);
    return $indexOf$1(typedArrays, tag) > -1;
  }

  if (!getOwnPropertyDescriptor) {
    return false;
  }

  return tryTypedArrays(value);
};

var $toString$1 = callBound('Object.prototype.toString');
var hasSymbols$3 = hasSymbols();
var hasToStringTag$3 = hasSymbols$3 && typeof Symbol.toStringTag === 'symbol';
var typedArrays$1 = availableTypedArrays();
var $slice$1 = callBound('String.prototype.slice');
var toStrTags$1 = {};
var getPrototypeOf$1 = Object.getPrototypeOf; // require('getprototypeof');

if (hasToStringTag$3 && getOwnPropertyDescriptor && getPrototypeOf$1) {
  foreach(typedArrays$1, function (typedArray) {
    if (typeof commonjsGlobal[typedArray] === 'function') {
      var arr = new commonjsGlobal[typedArray]();

      if (!(Symbol.toStringTag in arr)) {
        throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
      }

      var proto = getPrototypeOf$1(arr);
      var descriptor = getOwnPropertyDescriptor(proto, Symbol.toStringTag);

      if (!descriptor) {
        var superProto = getPrototypeOf$1(proto);
        descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
      }

      toStrTags$1[typedArray] = descriptor.get;
    }
  });
}

var tryTypedArrays$1 = function tryAllTypedArrays(value) {
  var foundName = false;
  foreach(toStrTags$1, function (getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value);

        if (name === typedArray) {
          foundName = name;
        }
      } catch (e) {}
    }
  });
  return foundName;
};

var whichTypedArray = function whichTypedArray(value) {
  if (!isTypedArray(value)) {
    return false;
  }

  if (!hasToStringTag$3) {
    return $slice$1($toString$1(value), 8, -1);
  }

  return tryTypedArrays$1(value);
};

var types = createCommonjsModule(function (module, exports) {

  function uncurryThis(f) {
    return f.call.bind(f);
  }

  var BigIntSupported = typeof BigInteger !== 'undefined';
  var SymbolSupported = typeof Symbol !== 'undefined';
  var ObjectToString = uncurryThis(Object.prototype.toString);
  var numberValue = uncurryThis(Number.prototype.valueOf);
  var stringValue = uncurryThis(String.prototype.valueOf);
  var booleanValue = uncurryThis(Boolean.prototype.valueOf);

  if (BigIntSupported) {
    var bigIntValue = uncurryThis(BigInteger.prototype.valueOf);
  }

  if (SymbolSupported) {
    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
  }

  function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== 'object') {
      return false;
    }

    try {
      prototypeValueOf(value);
      return true;
    } catch (e) {
      return false;
    }
  }

  exports.isArgumentsObject = isArguments;
  exports.isGeneratorFunction = isGeneratorFunction;
  exports.isTypedArray = isTypedArray; // Taken from here and modified for better browser support
  // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js

  function isPromise(input) {
    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
  }

  exports.isPromise = isPromise;

  function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
      return ArrayBuffer.isView(value);
    }

    return isTypedArray(value) || isDataView(value);
  }

  exports.isArrayBufferView = isArrayBufferView;

  function isUint8Array(value) {
    return whichTypedArray(value) === 'Uint8Array';
  }

  exports.isUint8Array = isUint8Array;

  function isUint8ClampedArray(value) {
    return whichTypedArray(value) === 'Uint8ClampedArray';
  }

  exports.isUint8ClampedArray = isUint8ClampedArray;

  function isUint16Array(value) {
    return whichTypedArray(value) === 'Uint16Array';
  }

  exports.isUint16Array = isUint16Array;

  function isUint32Array(value) {
    return whichTypedArray(value) === 'Uint32Array';
  }

  exports.isUint32Array = isUint32Array;

  function isInt8Array(value) {
    return whichTypedArray(value) === 'Int8Array';
  }

  exports.isInt8Array = isInt8Array;

  function isInt16Array(value) {
    return whichTypedArray(value) === 'Int16Array';
  }

  exports.isInt16Array = isInt16Array;

  function isInt32Array(value) {
    return whichTypedArray(value) === 'Int32Array';
  }

  exports.isInt32Array = isInt32Array;

  function isFloat32Array(value) {
    return whichTypedArray(value) === 'Float32Array';
  }

  exports.isFloat32Array = isFloat32Array;

  function isFloat64Array(value) {
    return whichTypedArray(value) === 'Float64Array';
  }

  exports.isFloat64Array = isFloat64Array;

  function isBigInt64Array(value) {
    return whichTypedArray(value) === 'BigInt64Array';
  }

  exports.isBigInt64Array = isBigInt64Array;

  function isBigUint64Array(value) {
    return whichTypedArray(value) === 'BigUint64Array';
  }

  exports.isBigUint64Array = isBigUint64Array;

  function isMapToString(value) {
    return ObjectToString(value) === '[object Map]';
  }

  isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());

  function isMap(value) {
    if (typeof Map === 'undefined') {
      return false;
    }

    return isMapToString.working ? isMapToString(value) : value instanceof Map;
  }

  exports.isMap = isMap;

  function isSetToString(value) {
    return ObjectToString(value) === '[object Set]';
  }

  isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());

  function isSet(value) {
    if (typeof Set === 'undefined') {
      return false;
    }

    return isSetToString.working ? isSetToString(value) : value instanceof Set;
  }

  exports.isSet = isSet;

  function isWeakMapToString(value) {
    return ObjectToString(value) === '[object WeakMap]';
  }

  isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());

  function isWeakMap(value) {
    if (typeof WeakMap === 'undefined') {
      return false;
    }

    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
  }

  exports.isWeakMap = isWeakMap;

  function isWeakSetToString(value) {
    return ObjectToString(value) === '[object WeakSet]';
  }

  isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());

  function isWeakSet(value) {
    return isWeakSetToString(value);
  }

  exports.isWeakSet = isWeakSet;

  function isArrayBufferToString(value) {
    return ObjectToString(value) === '[object ArrayBuffer]';
  }

  isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());

  function isArrayBuffer(value) {
    if (typeof ArrayBuffer === 'undefined') {
      return false;
    }

    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
  }

  exports.isArrayBuffer = isArrayBuffer;

  function isDataViewToString(value) {
    return ObjectToString(value) === '[object DataView]';
  }

  isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));

  function isDataView(value) {
    if (typeof DataView === 'undefined') {
      return false;
    }

    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
  }

  exports.isDataView = isDataView;

  function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === '[object SharedArrayBuffer]';
  }

  isSharedArrayBufferToString.working = typeof SharedArrayBuffer !== 'undefined' && isSharedArrayBufferToString(new SharedArrayBuffer());

  function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBuffer === 'undefined') {
      return false;
    }

    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBuffer;
  }

  exports.isSharedArrayBuffer = isSharedArrayBuffer;

  function isAsyncFunction(value) {
    return ObjectToString(value) === '[object AsyncFunction]';
  }

  exports.isAsyncFunction = isAsyncFunction;

  function isMapIterator(value) {
    return ObjectToString(value) === '[object Map Iterator]';
  }

  exports.isMapIterator = isMapIterator;

  function isSetIterator(value) {
    return ObjectToString(value) === '[object Set Iterator]';
  }

  exports.isSetIterator = isSetIterator;

  function isGeneratorObject(value) {
    return ObjectToString(value) === '[object Generator]';
  }

  exports.isGeneratorObject = isGeneratorObject;

  function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === '[object WebAssembly.Module]';
  }

  exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

  function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
  }

  exports.isNumberObject = isNumberObject;

  function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
  }

  exports.isStringObject = isStringObject;

  function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
  }

  exports.isBooleanObject = isBooleanObject;

  function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
  }

  exports.isBigIntObject = isBigIntObject;

  function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
  }

  exports.isSymbolObject = isSymbolObject;

  function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
  }

  exports.isBoxedPrimitive = isBoxedPrimitive;

  function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
  }

  exports.isAnyArrayBuffer = isAnyArrayBuffer;
  ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
    Object.defineProperty(exports, method, {
      enumerable: false,
      value: function value() {
        throw new Error(method + ' is not supported in userland');
      }
    });
  });
});

var isBufferBrowser = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

var inherits_browser = createCommonjsModule(function (module) {
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

var util = createCommonjsModule(function (module, exports) {
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};

    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }

    return descriptors;
  };

  var formatRegExp = /%[sdj%]/g;

  exports.format = function (f) {
    if (!isString(f)) {
      var objects = [];

      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }

      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') return '%';
      if (i >= len) return x;

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

        default:
          return x;
      }
    });

    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }

    return str;
  }; // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.


  exports.deprecate = function (fn, msg) {
    if (typeof process !== 'undefined' && process.noDeprecation === true) {
      return fn;
    } // Allow for deprecating things in the process of starting up.


    if (typeof process === 'undefined') {
      return function () {
        return exports.deprecate(fn, msg).apply(this, arguments);
      };
    }

    var warned = false;

    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }

        warned = true;
      }

      return fn.apply(this, arguments);
    }

    return deprecated;
  };

  var debugs = {};
  var debugEnvRegex = /^$/;

  if (process.env.NODE_DEBUG) {
    var debugEnv = process.env.NODE_DEBUG;
    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
  }

  exports.debuglog = function (set) {
    set = set.toUpperCase();

    if (!debugs[set]) {
      if (debugEnvRegex.test(set)) {
        var pid = process.pid;

        debugs[set] = function () {
          var msg = exports.format.apply(exports, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function () {};
      }
    }

    return debugs[set];
  };
  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */

  /* legacy: obj, showHidden, depth, colors*/


  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    }; // legacy...

    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];

    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      exports._extend(ctx, opts);
    } // set default options


    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }

  exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

  inspect.colors = {
    'bold': [1, 22],
    'italic': [3, 23],
    'underline': [4, 24],
    'inverse': [7, 27],
    'white': [37, 39],
    'grey': [90, 39],
    'black': [30, 39],
    'blue': [34, 39],
    'cyan': [36, 39],
    'green': [32, 39],
    'magenta': [35, 39],
    'red': [31, 39],
    'yellow': [33, 39]
  }; // Don't use 'blue' not visible on cmd.exe

  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };

  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }

  function stylizeNoColor(str, styleType) {
    return str;
  }

  function arrayToHash(array) {
    var hash = {};
    array.forEach(function (val, idx) {
      hash[val] = true;
    });
    return hash;
  }

  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);

      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    } // Primitive types cannot have properties


    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    } // Look up the keys of the object.


    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    } // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    } // Some type of object without properties can be shortcutted.


    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }

      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
        array = false,
        braces = ['{', '}']; // Make Array say that they are Array

    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    } // Make functions say that they are functions


    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    } // Make RegExps say that they are RegExps


    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    } // Make dates with properties first say the date


    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    } // Make error with message first say the error


    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function (key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }

    if (isNumber(value)) return ctx.stylize('' + value, 'number');
    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

    if (isNull(value)) return ctx.stylize('null', 'null');
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
      value: value[key]
    };

    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }

    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function (line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function (line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  } // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.


  exports.types = types;

  function isArray(ar) {
    return Array.isArray(ar);
  }

  exports.isArray = isArray;

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }

  exports.isBoolean = isBoolean;

  function isNull(arg) {
    return arg === null;
  }

  exports.isNull = isNull;

  function isNullOrUndefined(arg) {
    return arg == null;
  }

  exports.isNullOrUndefined = isNullOrUndefined;

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  exports.isNumber = isNumber;

  function isString(arg) {
    return typeof arg === 'string';
  }

  exports.isString = isString;

  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }

  exports.isSymbol = isSymbol;

  function isUndefined(arg) {
    return arg === void 0;
  }

  exports.isUndefined = isUndefined;

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }

  exports.isRegExp = isRegExp;
  exports.types.isRegExp = isRegExp;

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  exports.isObject = isObject;

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }

  exports.isDate = isDate;
  exports.types.isDate = isDate;

  function isError(e) {
    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
  }

  exports.isError = isError;
  exports.types.isNativeError = isError;

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  exports.isFunction = isFunction;

  function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
    typeof arg === 'undefined';
  }

  exports.isPrimitive = isPrimitive;
  exports.isBuffer = isBufferBrowser;

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }

  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }

  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  } // log is just a thin wrapper to console.log that prepends a timestamp


  exports.log = function () {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
  };
  /**
   * Inherit the prototype methods from one constructor into another.
   *
   * The Function.prototype.inherits from lang.js rewritten as a standalone
   * function (not on Function.prototype). NOTE: If this file is to be loaded
   * during bootstrapping this function needs to be rewritten using some native
   * functions as prototype setup using normal JavaScript does not work as
   * expected during bootstrapping (see mirror.js in r114903).
   *
   * @param {function} ctor Constructor function which needs to inherit the
   *     prototype.
   * @param {function} superCtor Constructor function to inherit prototype from.
   */


  exports.inherits = inherits_browser;

  exports._extend = function (origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;

    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }

    return origin;
  };

  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

  exports.promisify = function promisify(original) {
    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];

      if (typeof fn !== 'function') {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }

      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return fn;
    }

    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function (resolve, reject) {
        promiseResolve = resolve;
        promiseReject = reject;
      });
      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      args.push(function (err, value) {
        if (err) {
          promiseReject(err);
        } else {
          promiseResolve(value);
        }
      });

      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }

      return promise;
    }

    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
  };

  exports.promisify.custom = kCustomPromisifiedSymbol;

  function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
      var newReason = new Error('Promise was rejected with a falsy value');
      newReason.reason = reason;
      reason = newReason;
    }

    return cb(reason);
  }

  function callbackify(original) {
    if (typeof original !== 'function') {
      throw new TypeError('The "original" argument must be of type Function');
    } // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.


    function callbackified() {
      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      var maybeCb = args.pop();

      if (typeof maybeCb !== 'function') {
        throw new TypeError('The last argument must be of type Function');
      }

      var self = this;

      var cb = function cb() {
        return maybeCb.apply(self, arguments);
      }; // In true node style we process the callback on `nextTick` with all the
      // implications (stack, `uncaughtException`, `async_hooks`)


      original.apply(this, args).then(function (ret) {
        process.nextTick(cb.bind(null, null, ret));
      }, function (rej) {
        process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      });
    }

    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
  }

  exports.callbackify = callbackify;
});

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

var hasOwn$2 = Object.prototype.hasOwnProperty;

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    if (hasOwn$2.call(obj, key)) keys.push(key);
  }

  return keys;
}; // based on node assert, original notice:
var pSlice = Array.prototype.slice;

var _functionsHaveNames;

function functionsHaveNames() {
  if (typeof _functionsHaveNames !== 'undefined') {
    return _functionsHaveNames;
  }

  return _functionsHaveNames = function () {
    return function foo() {}.name === 'foo';
  }();
}

function pToString(obj) {
  return Object.prototype.toString.call(obj);
}

function isView(arrbuf) {
  if (buffer.isBuffer(arrbuf)) {
    return false;
  }

  if (typeof global$1.ArrayBuffer !== 'function') {
    return false;
  }

  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }

  if (!arrbuf) {
    return false;
  }

  if (arrbuf instanceof DataView) {
    return true;
  }

  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }

  return false;
} // 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.


function assert(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }

  if (functionsHaveNames()) {
    return func.name;
  }

  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}

assert.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;

  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }

  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();

    if (err.stack) {
      var out = err.stack; // try to strip useless frames

      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);

      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
} // assert.AssertionError instanceof Error

util.inherits(AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function inspect(something) {
  if (functionsHaveNames() || !util.isFunction(something)) {
    return util.inspect(something);
  }

  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}

function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
} // At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.


function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
} // EXTENSION! allows for well behaved errors defined elsewhere.

assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
assert.ok = ok;
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', equal);
} // 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', notEqual);
  }
} // 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', deepEqual);
  }
}
assert.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
  }
}

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (buffer.isBuffer(actual) && buffer.isBuffer(expected)) {
    return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (buffer.isBuffer(actual) !== buffer.isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);

    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments$1(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments$1(a);
  var bIsArgs = isArguments$1(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }

  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i; // having the same number of owned properties (keys incorporates
  // hasOwnProperty)

  if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

  ka.sort();
  kb.sort(); //~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  } //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test


  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }

  return true;
} // 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);


assert.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
  }
}
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
} // 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', strictEqual);
  }
} // 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', notStrictEqual);
  }
}

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;

  try {
    block();
  } catch (e) {
    error = e;
  }

  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
} // 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);


assert.throws = throws;
function throws(block,
/*optional*/
error,
/*optional*/
message) {
  _throws(true, block, error, message);
} // EXTENSION! This is annoying to write outside this module.

assert.doesNotThrow = doesNotThrow;
function doesNotThrow(block,
/*optional*/
error,
/*optional*/
message) {
  _throws(false, block, error, message);
}
assert.ifError = ifError;
function ifError(err) {
  if (err) throw err;
}

var inplace = function xorInplace(a, b) {
  var length = Math.min(a.length, b.length);

  for (var i = 0; i < length; ++i) {
    a[i] = a[i] ^ b[i];
  }

  return a;
};

var crypto = {};

class CryptoError extends Error {
  constructor(message) {
    super(message);
    Object.defineProperty(this, "message", {
      enumerable: false,
      value: message
    });
    Object.defineProperty(this, "name", {
      enumerable: false,
      value: this.constructor.name
    });
    Error.captureStackTrace(this, this.constructor);
  }

}
class Bip38CompressionError extends CryptoError {
  constructor(expected, given) {
    super("Expected flag to be ".concat(expected, ", but got ").concat(given, "."));
  }

}
class Bip38LengthError extends CryptoError {
  constructor(expected, given) {
    super("Expected length to be ".concat(expected, ", but got ").concat(given, "."));
  }

}
class Bip38PrefixError extends CryptoError {
  constructor(expected, given) {
    super("Expected prefix to be ".concat(expected, ", but got ").concat(given, "."));
  }

}
class Bip38TypeError extends CryptoError {
  constructor(expected, given) {
    super("Expected type to be ".concat(expected, ", but got ").concat(given, "."));
  }

}
class NetworkVersionError extends CryptoError {
  constructor(expected, given) {
    super("Expected version to be ".concat(expected, ", but got ").concat(given, "."));
  }

}
class NotImplemented extends CryptoError {
  constructor() {
    super("Feature is not available.");
  }

}
class PrivateKeyLengthError extends CryptoError {
  constructor(expected, given) {
    super("Expected length to be ".concat(expected, ", but got ").concat(given, "."));
  }

}
class PublicKeyError extends CryptoError {
  constructor(given) {
    super("Expected ".concat(given, " to be a valid public key."));
  }

}
class AddressNetworkError extends CryptoError {
  constructor(what) {
    super(what);
  }

}
class TransactionTypeError extends CryptoError {
  constructor(given) {
    super("Type ".concat(given, " not supported."));
  }

}
class InvalidTransactionBytesError extends CryptoError {
  constructor(message) {
    super("Failed to deserialize transaction, encountered invalid bytes: ".concat(message));
  }

}
class TransactionSchemaError extends CryptoError {
  constructor(what) {
    super(what);
  }

}
class TransactionVersionError extends CryptoError {
  constructor(given) {
    super("Version ".concat(given, " not supported."));
  }

}
class UnkownTransactionError extends CryptoError {
  constructor(given) {
    super("Unknown transaction type: ".concat(given));
  }

}
class TransactionAlreadyRegisteredError extends CryptoError {
  constructor(name) {
    super("Transaction type ".concat(name, " is already registered."));
  }

}
class TransactionKeyAlreadyRegisteredError extends CryptoError {
  constructor(name) {
    super("Transaction key ".concat(name, " is already registered."));
  }

}
class TransactionVersionAlreadyRegisteredError extends CryptoError {
  constructor(name, version) {
    super("Transaction type ".concat(name, " is already registered in version ").concat(version, "."));
  }

}
class CoreTransactionTypeGroupImmutableError extends CryptoError {
  constructor() {
    super("The Core transaction type group is immutable.");
  }

}
class MissingMilestoneFeeError extends CryptoError {
  constructor(name) {
    super("Missing milestone fee for '".concat(name, "'."));
  }

}
class MaximumPaymentCountExceededError extends CryptoError {
  constructor(limit) {
    super("Number of payments exceeded the allowed maximum of ".concat(limit, "."));
  }

}
class MinimumPaymentCountSubceededError extends CryptoError {
  constructor() {
    super("Number of payments subceeded the required minimum of 2.");
  }

}
class VendorFieldLengthExceededError extends CryptoError {
  constructor(limit) {
    super("Length of vendor field exceeded the allowed maximum ".concat(limit, "."));
  }

}
class MissingTransactionSignatureError extends CryptoError {
  constructor() {
    super("Expected the transaction to be signed.");
  }

}
class BlockSchemaError extends CryptoError {
  constructor(height, what) {
    super("Height (".concat(height, "): ").concat(what));
  }

}
class PreviousBlockIdFormatError extends CryptoError {
  constructor(thisBlockHeight, previousBlockId) {
    super("The config denotes that the block at height ".concat(thisBlockHeight - 1, " ") + "must use full SHA256 block id, but the next block (at ".concat(thisBlockHeight, ") ") + "contains previous block id \"".concat(previousBlockId, "\""));
  }

}
class InvalidMilestoneConfigurationError extends CryptoError {
  constructor(message) {
    super(message);
  }

}
class InvalidMultiSignatureAssetError extends CryptoError {
  constructor() {
    super("The multi signature asset is invalid.");
  }

}
class DuplicateParticipantInMultiSignatureError extends CryptoError {
  constructor() {
    super("Invalid multi signature, because duplicate participant found.");
  }

}

var errors = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CryptoError: CryptoError,
  Bip38CompressionError: Bip38CompressionError,
  Bip38LengthError: Bip38LengthError,
  Bip38PrefixError: Bip38PrefixError,
  Bip38TypeError: Bip38TypeError,
  NetworkVersionError: NetworkVersionError,
  NotImplemented: NotImplemented,
  PrivateKeyLengthError: PrivateKeyLengthError,
  PublicKeyError: PublicKeyError,
  AddressNetworkError: AddressNetworkError,
  TransactionTypeError: TransactionTypeError,
  InvalidTransactionBytesError: InvalidTransactionBytesError,
  TransactionSchemaError: TransactionSchemaError,
  TransactionVersionError: TransactionVersionError,
  UnkownTransactionError: UnkownTransactionError,
  TransactionAlreadyRegisteredError: TransactionAlreadyRegisteredError,
  TransactionKeyAlreadyRegisteredError: TransactionKeyAlreadyRegisteredError,
  TransactionVersionAlreadyRegisteredError: TransactionVersionAlreadyRegisteredError,
  CoreTransactionTypeGroupImmutableError: CoreTransactionTypeGroupImmutableError,
  MissingMilestoneFeeError: MissingMilestoneFeeError,
  MaximumPaymentCountExceededError: MaximumPaymentCountExceededError,
  MinimumPaymentCountSubceededError: MinimumPaymentCountSubceededError,
  VendorFieldLengthExceededError: VendorFieldLengthExceededError,
  MissingTransactionSignatureError: MissingTransactionSignatureError,
  BlockSchemaError: BlockSchemaError,
  PreviousBlockIdFormatError: PreviousBlockIdFormatError,
  InvalidMilestoneConfigurationError: InvalidMilestoneConfigurationError,
  InvalidMultiSignatureAssetError: InvalidMultiSignatureAssetError,
  DuplicateParticipantInMultiSignatureError: DuplicateParticipantInMultiSignatureError
});

var networks = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), networks$1));

class ConfigManager {
  constructor() {
    this.setConfig(devnet);
  }

  setConfig(config) {
    this.config = {
      network: config.network,
      exceptions: config.exceptions,
      milestones: config.milestones,
      genesisBlock: config.genesisBlock
    };
    this.validateMilestones();
    this.buildConstants();
  }

  setFromPreset(network) {
    this.setConfig(this.getPreset(network));
  }

  getPreset(network) {
    return networks[network.toLowerCase()];
  }

  all() {
    return this.config;
  }

  set(key, value) {
    if (!this.config) {
      throw new Error();
    }

    set(this.config, key, value);
  }

  get(key) {
    return get(this.config, key);
  }

  setHeight(value) {
    this.height = value;
  }

  getHeight() {
    return this.height;
  }

  isNewMilestone(height) {
    height = height || this.height;

    if (!this.milestones) {
      throw new Error();
    }

    return this.milestones.some(milestone => milestone.height === height);
  }

  getMilestone(height) {
    if (!this.milestone || !this.milestones) {
      throw new Error();
    }

    if (!height && this.height) {
      height = this.height;
    }

    if (!height) {
      height = 1;
    }

    while (this.milestone.index < this.milestones.length - 1 && height >= this.milestones[this.milestone.index + 1].height) {
      this.milestone.index++;
      this.milestone.data = this.milestones[this.milestone.index];
    }

    while (height < this.milestones[this.milestone.index].height) {
      this.milestone.index--;
      this.milestone.data = this.milestones[this.milestone.index];
    }

    return this.milestone.data;
  }

  getNextMilestoneWithNewKey(previousMilestone, key) {
    if (!this.milestones || !this.milestones.length) {
      throw new Error("Attempted to get next milestone but none were set");
    }

    for (var i = 0; i < this.milestones.length; i++) {
      var milestone = this.milestones[i];

      if (milestone[key] && milestone[key] !== this.getMilestone(previousMilestone)[key] && milestone.height > previousMilestone) {
        return {
          found: true,
          height: milestone.height,
          data: milestone[key]
        };
      }
    }

    return {
      found: false,
      height: previousMilestone,
      data: null
    };
  }

  getMilestones() {
    return this.milestones;
  }

  buildConstants() {
    if (!this.config) {
      throw new Error();
    }

    this.milestones = this.config.milestones.sort((a, b) => a.height - b.height);
    this.milestone = {
      index: 0,
      data: this.milestones[0]
    };
    var lastMerged = 0;

    var overwriteMerge = (dest, source, options) => source;

    while (lastMerged < this.milestones.length - 1) {
      this.milestones[lastMerged + 1] = deepmerge(this.milestones[lastMerged], this.milestones[lastMerged + 1], {
        arrayMerge: overwriteMerge
      });
      lastMerged++;
    }
  }

  validateMilestones() {
    if (!this.config) {
      throw new Error();
    }

    var delegateMilestones = this.config.milestones.sort((a, b) => a.height - b.height).filter(milestone => milestone.activeDelegates);

    for (var i = 1; i < delegateMilestones.length; i++) {
      var previous = delegateMilestones[i - 1];
      var current = delegateMilestones[i];

      if (previous.activeDelegates === current.activeDelegates) {
        continue;
      }

      if ((current.height - previous.height) % previous.activeDelegates !== 0) {
        throw new InvalidMilestoneConfigurationError("Bad milestone at height: ".concat(current.height, ". The number of delegates can only be changed at the beginning of a new round."));
      }
    }
  }

}
var configManager = new ConfigManager();

class NetworkManager {
  static all() {
    // @ts-ignore - the newly generated unitnet doesn't match the old configs because it has things like a nonce field
    return networks;
  }

  static findByName(name) {
    return networks[name.toLowerCase()];
  }

}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  configManager: configManager,
  NetworkManager: NetworkManager
});

var getWifFromNetwork = network => network ? network.wif : configManager.get("network.wif");
var getPubKeyHashFromNetwork = network => network ? network.pubKeyHash : configManager.get("network.pubKeyHash");
var getPubKeyHash = networkVersion => networkVersion || configManager.get("network.pubKeyHash");

class Address {
  static fromPassphrase(passphrase, networkVersion) {
    return Address$1.fromPassphrase(passphrase, {
      pubKeyHash: getPubKeyHash(networkVersion)
    });
  }

  static fromPublicKey(publicKey, networkVersion) {
    return Address$1.fromPublicKey(publicKey, {
      pubKeyHash: getPubKeyHash(networkVersion)
    });
  }

  static fromWIF(wif, network) {
    return Address$1.fromWIF(wif, {
      pubKeyHash: getPubKeyHashFromNetwork(network),
      wif: getWifFromNetwork(network)
    });
  }

  static fromMultiSignatureAsset(asset, networkVersion) {
    return Address$1.fromMultiSignatureAsset(asset, {
      pubKeyHash: getPubKeyHash(networkVersion)
    });
  }

  static fromPrivateKey(privateKey, networkVersion) {
    return Address$1.fromPrivateKey(privateKey, {
      pubKeyHash: getPubKeyHash(networkVersion)
    });
  }

  static fromBuffer(buffer) {
    return Address$1.fromBuffer(buffer);
  }

  static toBuffer(address, networkVersion) {
    return Address$1.toBuffer(address, {
      pubKeyHash: getPubKeyHash(networkVersion)
    });
  }

  static validate(address, networkVersion) {
    return Address$1.validate(address, {
      pubKeyHash: getPubKeyHash(networkVersion)
    });
  }

}

class Keys {
  static fromPassphrase(passphrase) {
    var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return Keys$1.fromPassphrase(passphrase, compressed);
  }

  static fromPrivateKey(privateKey) {
    var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return Keys$1.fromPrivateKey(privateKey, compressed);
  }

  static fromWIF(wifKey, network) {
    return Keys$1.fromWIF(wifKey, {
      wif: getWifFromNetwork(network)
    });
  }

}

class PrivateKey {
  static fromPassphrase(passphrase) {
    return PrivateKey$1.fromPassphrase(passphrase);
  }

  static fromWIF(wif, network) {
    return PrivateKey$1.fromWIF(wif, {
      wif: getWifFromNetwork(network)
    });
  }

}

class PublicKey {
  static fromPassphrase(passphrase) {
    return PublicKey$1.fromPassphrase(passphrase);
  }

  static fromWIF(wif, network) {
    return PublicKey$1.fromWIF(wif, {
      wif: getWifFromNetwork(network)
    });
  }

  static fromMultiSignatureAsset(asset) {
    return PublicKey$1.fromMultiSignatureAsset(asset);
  }

  static verify(publicKey) {
    return PublicKey$1.verify(publicKey);
  }

}

class WIF {
  static fromPassphrase(passphrase, network) {
    return WIF$1.fromPassphrase(passphrase, {
      wif: getWifFromNetwork(network)
    });
  }

  static fromKeys(keys, network) {
    return WIF$1.fromKeys(keys, {
      wif: getWifFromNetwork(network)
    });
  }

}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Address: Address,
  Keys: Keys,
  PrivateKey: PrivateKey,
  PublicKey: PublicKey,
  WIF: WIF
});

var encodeCheck = buffer => {
  var checksum = HashAlgorithms.hash256(buffer);
  return base58.encode(Buffer.concat([buffer, checksum], buffer.length + 4));
};

var decodeCheck = address => {
  var buffer = base58.decode(address);
  var payload = buffer.slice(0, -4);
  var checksum = HashAlgorithms.hash256(payload);

  if (checksum.readUInt32LE(0) !== buffer.slice(-4).readUInt32LE(0)) {
    throw new Error("Invalid checksum");
  }

  return payload;
};

var Base58 = {
  encodeCheck: moize(encodeCheck),
  decodeCheck: moize(decodeCheck)
};

var SCRYPT_PARAMS = {
  N: 16384,
  r: 8,
  p: 8
};
var NULL = Buffer.alloc(0);

var getPublicKey = (buffer, compressed) => {
  return Buffer.from(Keys.fromPrivateKey(buffer, compressed).publicKey, "hex");
};

var getAddressPrivate = (privateKey, compressed) => {
  var publicKey = getPublicKey(privateKey, compressed);
  var buffer = HashAlgorithms.hash160(publicKey);
  var payload = Buffer.alloc(21);
  payload.writeUInt8(0x00, 0);
  buffer.copy(payload, 1);
  return Base58.encodeCheck(payload);
};

var verify = bip38 => {
  var decoded;

  try {
    decoded = Base58.decodeCheck(bip38);
  } catch (_unused) {
    return false;
  }

  if (!decoded) {
    return false;
  }

  if (decoded.length !== 39) {
    return false;
  }

  if (decoded.readUInt8(0) !== 0x01) {
    return false;
  }

  var type = decoded.readUInt8(1);
  var flag = decoded.readUInt8(2); // encrypted WIF

  if (type === 0x42) {
    if (flag !== 0xc0 && flag !== 0xe0) {
      return false;
    } // EC mult

  } else if (type === 0x43) {
    if (flag & ~0x24) {
      return false;
    }
  } else {
    return false;
  }

  return true;
};

var encryptRaw = (buffer, compressed, passphrase) => {
  if (buffer.length !== 32) {
    throw new PrivateKeyLengthError(32, buffer.length);
  }

  var address = getAddressPrivate(buffer, compressed);
  var secret = Buffer.from(passphrase, "utf8");
  var salt = HashAlgorithms.hash256(address).slice(0, 4);
  var scryptBuf = crypto.scryptSync(secret, salt, 64, SCRYPT_PARAMS);
  var derivedHalf1 = scryptBuf.slice(0, 32);
  var derivedHalf2 = scryptBuf.slice(32, 64);
  var xorBuf = inplace(derivedHalf1, buffer);
  var cipher = aes.createCipheriv("aes-256-ecb", derivedHalf2, NULL);
  cipher.setAutoPadding(false);
  cipher.end(xorBuf);
  var cipherText = cipher.read(); // 0x01 | 0x42 | flagByte | salt (4) | cipherText (32)

  var result = Buffer.allocUnsafe(7 + 32);
  result.writeUInt8(0x01, 0);
  result.writeUInt8(0x42, 1);
  result.writeUInt8(compressed ? 0xe0 : 0xc0, 2);
  salt.copy(result, 3);
  cipherText.copy(result, 7);
  return result;
};

var decryptECMult = (buffer, passphrase) => {
  buffer = buffer.slice(1);
  var flag = buffer.readUInt8(1);
  var compressed = (flag & 0x20) !== 0;
  var hasLotSeq = (flag & 0x04) !== 0;
  assert.strictEqual(flag & 0x24, flag, "Invalid private key.");
  var addressHash = buffer.slice(2, 6);
  var ownerEntropy = buffer.slice(6, 14);
  var ownerSalt; // 4 bytes ownerSalt if 4 bytes lot/sequence

  if (hasLotSeq) {
    ownerSalt = ownerEntropy.slice(0, 4); // else, 8 bytes ownerSalt
  } else {
    ownerSalt = ownerEntropy;
  }

  var encryptedPart1 = buffer.slice(14, 22); // First 8 bytes

  var encryptedPart2 = buffer.slice(22, 38); // 16 bytes

  var preFactor = crypto.scryptSync(passphrase, ownerSalt, 32, SCRYPT_PARAMS);
  var passFactor;

  if (hasLotSeq) {
    var hashTarget = Buffer.concat([preFactor, ownerEntropy]);
    passFactor = HashAlgorithms.hash256(hashTarget);
  } else {
    passFactor = preFactor;
  }

  var publicKey = getPublicKey(passFactor, true);
  var seedBPass = crypto.scryptSync(publicKey, Buffer.concat([addressHash, ownerEntropy]), 64, {
    N: 1024,
    r: 1,
    p: 1
  });
  var derivedHalf1 = seedBPass.slice(0, 32);
  var derivedHalf2 = seedBPass.slice(32, 64);
  var decipher = aes.createDecipheriv("aes-256-ecb", derivedHalf2, Buffer.alloc(0));
  decipher.setAutoPadding(false);
  decipher.end(encryptedPart2);
  var decryptedPart2 = decipher.read();
  var tmp = inplace(decryptedPart2, derivedHalf1.slice(16, 32));
  var seedBPart2 = tmp.slice(8, 16);
  var decipher2 = aes.createDecipheriv("aes-256-ecb", derivedHalf2, Buffer.alloc(0));
  decipher2.setAutoPadding(false);
  decipher2.write(encryptedPart1); // first 8 bytes

  decipher2.end(tmp.slice(0, 8)); // last 8 bytes

  var seedBPart1 = inplace(decipher2.read(), derivedHalf1.slice(0, 16));
  var seedB = Buffer.concat([seedBPart1, seedBPart2], 24);
  var privateKey = secp256k1.privateKeyTweakMul(HashAlgorithms.hash256(seedB), passFactor);
  return {
    privateKey,
    compressed
  };
}; // some of the techniques borrowed from: https://github.com/pointbiz/bitaddress.org


var decryptRaw = (buffer, passphrase) => {
  // 39 bytes: 2 bytes prefix, 37 bytes payload
  if (buffer.length !== 39) {
    throw new Bip38LengthError(39, buffer.length);
  }

  if (buffer.readUInt8(0) !== 0x01) {
    throw new Bip38PrefixError(0x01, buffer.readUInt8(0));
  } // check if BIP38 EC multiply


  var type = buffer.readUInt8(1);

  if (type === 0x43) {
    return decryptECMult(buffer, passphrase);
  }

  if (type !== 0x42) {
    throw new Bip38TypeError(0x42, type);
  }

  var flagByte = buffer.readUInt8(2);
  var compressed = flagByte === 0xe0;

  if (!compressed && flagByte !== 0xc0) {
    throw new Bip38CompressionError(0xc0, flagByte);
  }

  var salt = buffer.slice(3, 7);
  var scryptBuf = crypto.scryptSync(passphrase, salt, 64, SCRYPT_PARAMS);
  var derivedHalf1 = scryptBuf.slice(0, 32);
  var derivedHalf2 = scryptBuf.slice(32, 64);
  var privKeyBuf = buffer.slice(7, 7 + 32);
  var decipher = aes.createDecipheriv("aes-256-ecb", derivedHalf2, NULL);
  decipher.setAutoPadding(false);
  decipher.end(privKeyBuf);
  var plainText = decipher.read();
  var privateKey = inplace(derivedHalf1, plainText); // verify salt matches address

  var address = getAddressPrivate(privateKey, compressed);
  var checksum = HashAlgorithms.hash256(address).slice(0, 4);
  assert.deepEqual(salt, checksum);
  return {
    privateKey,
    compressed
  };
};

var encrypt = (privateKey, compressed, passphrase) => {
  return Base58.encodeCheck(encryptRaw(privateKey, compressed, passphrase));
};
var decrypt = (bip38, passphrase) => {
  return decryptRaw(Base58.decodeCheck(bip38), passphrase);
};

var bip38 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  verify: verify,
  encrypt: encrypt,
  decrypt: decrypt
});

class Hash {
  static signECDSA(hash, keys) {
    return secp256k1.signatureExport(secp256k1.sign(hash, Buffer.from(keys.privateKey, "hex"))).toString("hex");
  }

  static verifyECDSA(hash, signature, publicKey) {
    var bufferSignature = signature instanceof Buffer ? signature : Buffer.from(signature, "hex");
    var signatureRS = secp256k1.signatureImport(bufferSignature);

    if (!secp256k1.isLowS(signatureRS)) {
      return false;
    } // check that global signature length matches R and S length, see DER format :
    // <header byte><signature length><integer marker><R length><R><integer marker><S length><S>


    var signatureLength = bufferSignature.readUInt8(1);
    var rLength = bufferSignature.readUInt8(3);
    var sLength = bufferSignature.readUInt8(4 + rLength + 1);

    if (bufferSignature.length !== 4 + rLength + 2 + sLength || signatureLength !== 2 + rLength + 2 + sLength) {
      return false;
    } // check that first byte is positive, if it is then the whole R / S will be positive as required


    var rFirstByte = bufferSignature.readInt8(4);
    var sFirstByte = bufferSignature.readInt8(4 + rLength + 2);

    if (rFirstByte < 0 || sFirstByte < 0) {
      return false;
    } // if first byte is zero it is to make R/S positive, so second byte should be negative


    if (rFirstByte === 0 && bufferSignature.readInt8(4 + 1) >= 0 || sFirstByte === 0 && bufferSignature.readInt8(4 + rLength + 2 + 1) >= 0) {
      return false;
    }

    return secp256k1.verify(hash, signatureRS, publicKey instanceof Buffer ? publicKey : Buffer.from(publicKey, "hex"));
  }

  static signSchnorr(hash, keys) {
    return secp256k1.schnorrSign(hash, Buffer.from(keys.privateKey, "hex")).toString("hex");
  }

  static verifySchnorr(hash, signature, publicKey) {
    return secp256k1.schnorrVerify(hash, signature instanceof Buffer ? signature : Buffer.from(signature, "hex"), publicKey instanceof Buffer ? publicKey : Buffer.from(publicKey, "hex"));
  }

}

class HashAlgorithms {
  static ripemd160(buffer) {
    return RIPEMD160.digest(this.bufferize(buffer));
  }

  static sha1(buffer) {
    return SHA1.digest(this.bufferize(buffer));
  }

  static sha256(buffer) {
    if (Array.isArray(buffer)) {
      var sha256 = SHA256.ctx;
      sha256.init();

      for (var element of buffer) {
        sha256 = sha256.update(element);
      }

      return sha256.final();
    }

    return SHA256.digest(this.bufferize(buffer));
  }

  static hash160(buffer) {
    return Hash160.digest(this.bufferize(buffer));
  }

  static hash256(buffer) {
    return Hash256.digest(this.bufferize(buffer));
  }

  static bufferize(buffer) {
    return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
  }

}

class HDWallet {
  /**
   * Get root node from the given mnemonic with an optional passphrase.
   */
  static fromMnemonic(mnemonic, passphrase) {
    return fromSeed(mnemonicToSeedSync(mnemonic, passphrase), configManager.get("network"));
  }
  /**
   * Get bip32 node from keys.
   */


  static fromKeys(keys, chainCode) {
    if (!keys.compressed) {
      throw new TypeError("BIP32 only allows compressed keys.");
    }

    return fromPrivateKey(Buffer.from(keys.privateKey, "hex"), chainCode, configManager.get("network"));
  }
  /**
   * Get key pair from the given node.
   */


  static getKeys(node) {
    if (!node.privateKey) {
      throw new Error();
    }

    return {
      publicKey: node.publicKey.toString("hex"),
      privateKey: node.privateKey.toString("hex"),
      compressed: true
    };
  }
  /**
   * Derives a node from the coin type as specified by slip44.
   */


  static deriveSlip44(root) {
    var hardened = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return root.derivePath("m/44'/".concat(this.slip44).concat(hardened ? "'" : ""));
  }
  /**
   * Derives a node from the network as specified by AIP20.
   */


  static deriveNetwork(root) {
    return this.deriveSlip44(root).deriveHardened(configManager.get("network.aip20") || 1);
  }

}
HDWallet.slip44 = 111;

class Message {
  static sign(message, passphrase) {
    var keys = Keys.fromPassphrase(passphrase);
    return {
      publicKey: keys.publicKey,
      signature: Hash.signECDSA(this.createHash(message), keys),
      message
    };
  }

  static signWithWif(message, wif, network) {
    if (!network) {
      network = configManager.get("network");
    }

    var keys = Keys.fromWIF(wif, network);
    return {
      publicKey: keys.publicKey,
      signature: Hash.signECDSA(this.createHash(message), keys),
      message
    };
  }

  static verify(_ref) {
    var {
      message,
      publicKey,
      signature
    } = _ref;
    return Hash.verifyECDSA(this.createHash(message), signature, publicKey);
  }

  static createHash(message) {
    return HashAlgorithms.sha256(message);
  }

}

var isNewBlockTime = height => {
  if (height === 1) return true;
  var milestones = configManager.get("milestones");
  var milestone;

  for (var i = milestones.length - 1; i >= 0; i--) {
    var temp = milestones[i];

    if (temp.height > height) {
      continue;
    }

    if (!milestone || temp.blocktime === milestone.blocktime) {
      if (temp.blocktime) {
        milestone = temp;
      }
    } else {
      break;
    }
  }

  if (!milestone) return false;
  return height - milestone.height === 0;
};
var calculateBlockTime = height => {
  var milestones = configManager.get("milestones");

  for (var i = milestones.length - 1; i >= 0; i--) {
    var milestone = milestones[i];

    if (milestone.height <= height) {
      if (milestone.blocktime) {
        return milestone.blocktime;
      }
    }
  }

  throw new Error("No milestones specifying any height were found");
};

class Slots {
  static getTime(time) {
    if (time === undefined) {
      time = dayjs().valueOf();
    }

    var start = dayjs(configManager.getMilestone(1).epoch).valueOf();
    return Math.floor((time - start) / 1000);
  }

  static getTimeInMsUntilNextSlot(getTimeStampForBlock) {
    var nextSlotTime = this.getSlotTime(getTimeStampForBlock, this.getNextSlot(getTimeStampForBlock));
    var now = this.getTime();
    return (nextSlotTime - now) * 1000;
  }

  static getSlotNumber(getTimeStampForBlock, timestamp, height) {
    if (timestamp === undefined) {
      timestamp = this.getTime();
    }

    var latestHeight = this.getLatestHeight(height);
    return this.getSlotInfo(getTimeStampForBlock, timestamp, latestHeight).slotNumber;
  }

  static getSlotTime(getTimeStampForBlock, slot, height) {
    var latestHeight = this.getLatestHeight(height);
    return this.calculateSlotTime(slot, latestHeight, getTimeStampForBlock);
  }

  static getNextSlot(getTimeStampForBlock) {
    return this.getSlotNumber(getTimeStampForBlock) + 1;
  }

  static isForgingAllowed(getTimeStampForBlock, timestamp, height) {
    if (timestamp === undefined) {
      timestamp = this.getTime();
    }

    var latestHeight = this.getLatestHeight(height);
    return this.getSlotInfo(getTimeStampForBlock, timestamp, latestHeight).forgingStatus;
  }

  static getSlotInfo(getTimeStampForBlock, timestamp, height) {
    if (timestamp === undefined) {
      timestamp = this.getTime();
    }

    height = this.getLatestHeight(height);
    var blockTime = calculateBlockTime(1);
    var totalSlotsFromLastSpan = 0;
    var lastSpanEndTime = 0;
    var previousMilestoneHeight = 1;
    var nextMilestone = configManager.getNextMilestoneWithNewKey(1, "blocktime");

    for (var i = 0; i < this.getMilestonesWhichAffectBlockTimes().length - 1; i++) {
      if (height < nextMilestone.height) {
        break;
      }

      var spanStartTimestamp = getTimeStampForBlock(previousMilestoneHeight);
      lastSpanEndTime = getTimeStampForBlock(nextMilestone.height - 1) + blockTime;
      totalSlotsFromLastSpan += Math.floor((lastSpanEndTime - spanStartTimestamp) / blockTime);
      blockTime = nextMilestone.data;
      previousMilestoneHeight = nextMilestone.height;
      nextMilestone = configManager.getNextMilestoneWithNewKey(nextMilestone.height, "blocktime");
    }

    var slotNumberUpUntilThisTimestamp = Math.floor((timestamp - lastSpanEndTime) / blockTime);
    var slotNumber = totalSlotsFromLastSpan + slotNumberUpUntilThisTimestamp;
    var startTime = lastSpanEndTime + slotNumberUpUntilThisTimestamp * blockTime;
    var endTime = startTime + blockTime - 1;
    var forgingStatus = timestamp < startTime + Math.floor(blockTime / 2);
    return {
      blockTime,
      startTime,
      endTime,
      slotNumber,
      forgingStatus
    };
  }

  static getMilestonesWhichAffectBlockTimes() {
    var milestones = [{
      found: true,
      height: 1,
      data: configManager.getMilestone(1).blocktime
    }];
    var nextMilestone = configManager.getNextMilestoneWithNewKey(1, "blocktime");

    while (nextMilestone.found) {
      milestones.push(nextMilestone);
      nextMilestone = configManager.getNextMilestoneWithNewKey(nextMilestone.height, "blocktime");
    }

    return milestones;
  }

  static calculateSlotTime(slotNumber, height, getTimeStampForBlock) {
    var blockTime = calculateBlockTime(1);
    var totalSlotsFromLastSpan = 0;
    var milestoneHeight = 1;
    var lastSpanEndTime = 0;
    var nextMilestone = configManager.getNextMilestoneWithNewKey(1, "blocktime");

    for (var i = 0; i < this.getMilestonesWhichAffectBlockTimes().length - 1; i++) {
      if (height < nextMilestone.height) {
        break;
      }

      var spanStartTimestamp = getTimeStampForBlock(milestoneHeight);
      lastSpanEndTime = getTimeStampForBlock(nextMilestone.height - 1) + blockTime;
      totalSlotsFromLastSpan += Math.floor((lastSpanEndTime - spanStartTimestamp) / blockTime);
      blockTime = nextMilestone.data;
      milestoneHeight = nextMilestone.height;
      nextMilestone = configManager.getNextMilestoneWithNewKey(nextMilestone.height, "blocktime");
    }

    return lastSpanEndTime + (slotNumber - totalSlotsFromLastSpan) * blockTime;
  }

  static getLatestHeight(height) {
    if (!height) {
      // TODO: is the config manager the best way to retrieve most recent height?
      // Or should this class maintain its own cache?
      var configConfiguredHeight = configManager.getHeight();

      if (configConfiguredHeight) {
        return configConfiguredHeight;
      } else {
        return 1;
      }
    }

    return height;
  }

}

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bip38: bip38,
  Hash: Hash,
  HashAlgorithms: HashAlgorithms,
  HDWallet: HDWallet,
  Message: Message,
  Slots: Slots
});

var SATOSHI = 1e8;
var ARKTOSHI = SATOSHI;

var constants = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SATOSHI: SATOSHI,
  ARKTOSHI: ARKTOSHI
});

/*
The MIT License (MIT)

Copyright (c) 2016 CoderPuppy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/
var _endianness;

function endianness() {
  if (typeof _endianness === 'undefined') {
    var a = new ArrayBuffer(2);
    var b = new Uint8Array(a);
    var c = new Uint16Array(a);
    b[0] = 1;
    b[1] = 2;

    if (c[0] === 258) {
      _endianness = 'BE';
    } else if (c[0] === 513) {
      _endianness = 'LE';
    } else {
      throw new Error('unable to figure out endianess');
    }
  }

  return _endianness;
}
function hostname() {
  if (typeof global$1.location !== 'undefined') {
    return global$1.location.hostname;
  } else return '';
}
function loadavg() {
  return [];
}
function uptime$1() {
  return 0;
}
function freemem() {
  return Number.MAX_VALUE;
}
function totalmem() {
  return Number.MAX_VALUE;
}
function cpus() {
  return [];
}
function type() {
  return 'Browser';
}
function release$1() {
  if (typeof global$1.navigator !== 'undefined') {
    return global$1.navigator.appVersion;
  }

  return '';
}
function networkInterfaces() {}
function getNetworkInterfaces() {}
function tmpDir() {
  return '/tmp';
}
var tmpdir = tmpDir;
var EOL = '\n';
var os = {
  EOL: EOL,
  tmpdir: tmpdir,
  tmpDir: tmpDir,
  networkInterfaces: networkInterfaces,
  getNetworkInterfaces: getNetworkInterfaces,
  release: release$1,
  type: type,
  cpus: cpus,
  totalmem: totalmem,
  freemem: freemem,
  uptime: uptime$1,
  loadavg: loadavg,
  hostname: hostname,
  endianness: endianness
};

var isLocalHost = function isLocalHost(ip) {
  var includeNetworkInterfaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  try {
    var parsed = parse(ip);

    if (parsed.range() === "loopback" || ip.startsWith("0") || ["127.0.0.1", "::ffff:127.0.0.1"].includes(ip)) {
      return true;
    }

    if (includeNetworkInterfaces) {
      var interfaces = os.networkInterfaces();
      return Object.keys(interfaces).some(ifname => interfaces[ifname].some(iface => iface.address === ip));
    }

    return false;
  } catch (error) {
    return false;
  }
};

var sanitizeRemoteAddress = ip => {
  try {
    return process$1(ip).toString();
  } catch (error) {
    return undefined;
  }
};

var isValidPeer = function isValidPeer(peer) {
  var includeNetworkInterfaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var sanitizedAddress = sanitizeRemoteAddress(peer.ip);

  if (!sanitizedAddress) {
    return false;
  }

  peer.ip = sanitizedAddress;

  if (isLocalHost(peer.ip, includeNetworkInterfaces)) {
    return false;
  }

  return true;
};

var genesisTransactions;
var whitelistedBlockAndTransactionIds;
var currentNetwork;
/**
 * Get human readable string from satoshis
 */

var formatSatoshi = amount => {
  var localeString = (+amount / SATOSHI).toLocaleString("en", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 8
  });
  return "".concat(localeString, " ").concat(configManager.get("network.client.symbol"));
};
/**
 * Check if the given block or transaction id is an exception.
 */

var isIdException = id => {
  if (!id) {
    return false;
  }

  var network = configManager.get("network.pubKeyHash");

  if (!whitelistedBlockAndTransactionIds || currentNetwork !== network) {
    currentNetwork = network;
    whitelistedBlockAndTransactionIds = [...(configManager.get("exceptions.blocks") || []), ...(configManager.get("exceptions.transactions") || [])].reduce((acc, curr) => Object.assign(acc, {
      [curr]: true
    }), {});
  }

  return !!whitelistedBlockAndTransactionIds[id];
};
var isException = blockOrTransaction => {
  if (typeof blockOrTransaction.id !== "string") {
    return false;
  }

  if (blockOrTransaction.id.length < 64) {
    // old block ids, we check that the transactions inside the block are correct
    var blockExceptionTxIds = (configManager.get("exceptions.blocksTransactions") || {})[blockOrTransaction.id];
    var blockTransactions = blockOrTransaction.transactions || [];

    if (!blockExceptionTxIds || blockExceptionTxIds.length !== blockTransactions.length) {
      return false;
    }

    blockExceptionTxIds.sort();
    var blockToCheckTxIds = blockTransactions.map(tx => tx.id).sort();

    for (var i = 0; i < blockExceptionTxIds.length; i++) {
      if (blockToCheckTxIds[i] !== blockExceptionTxIds[i]) {
        return false;
      }
    }
  }

  return isIdException(blockOrTransaction.id);
};
var isGenesisTransaction = id => {
  var network = configManager.get("network.pubKeyHash");

  if (!genesisTransactions || currentNetwork !== network) {
    currentNetwork = network;
    genesisTransactions = configManager.get("genesisBlock.transactions").reduce((acc, curr) => Object.assign(acc, {
      [curr.id]: true
    }), {});
  }

  return genesisTransactions[id];
};
var numberToHex = function numberToHex(num) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var indexHex = Number(num).toString(16);
  return "0".repeat(padding - indexHex.length) + indexHex;
};
var maxVendorFieldLength = height => configManager.getMilestone(height).vendorFieldLength;
var isSupportedTransactionVersion = version => {
  var aip11 = configManager.getMilestone().aip11;

  if (aip11 && version !== 2) {
    return false;
  }

  if (!aip11 && version !== 1) {
    return false;
  }

  return true;
};

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  formatSatoshi: formatSatoshi,
  isIdException: isIdException,
  isException: isException,
  isGenesisTransaction: isGenesisTransaction,
  numberToHex: numberToHex,
  maxVendorFieldLength: maxVendorFieldLength,
  isSupportedTransactionVersion: isSupportedTransactionVersion,
  Base58: Base58,
  BigNumber: BigNumber,
  isValidPeer: isValidPeer,
  isLocalHost: isLocalHost,
  calculateBlockTime: calculateBlockTime,
  isNewBlockTime: isNewBlockTime
});

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var TransactionType;

(function (TransactionType) {
  TransactionType[TransactionType["Transfer"] = 0] = "Transfer";
  TransactionType[TransactionType["SecondSignature"] = 1] = "SecondSignature";
  TransactionType[TransactionType["DelegateRegistration"] = 2] = "DelegateRegistration";
  TransactionType[TransactionType["Vote"] = 3] = "Vote";
  TransactionType[TransactionType["MultiSignature"] = 4] = "MultiSignature";
  TransactionType[TransactionType["Ipfs"] = 5] = "Ipfs";
  TransactionType[TransactionType["MultiPayment"] = 6] = "MultiPayment";
  TransactionType[TransactionType["DelegateResignation"] = 7] = "DelegateResignation";
  TransactionType[TransactionType["HtlcLock"] = 8] = "HtlcLock";
  TransactionType[TransactionType["HtlcClaim"] = 9] = "HtlcClaim";
  TransactionType[TransactionType["HtlcRefund"] = 10] = "HtlcRefund";
})(TransactionType || (TransactionType = {}));

var TransactionTypeGroup;

(function (TransactionTypeGroup) {
  TransactionTypeGroup[TransactionTypeGroup["Test"] = 0] = "Test";
  TransactionTypeGroup[TransactionTypeGroup["Core"] = 1] = "Core"; // Everything above is available to anyone

  TransactionTypeGroup[TransactionTypeGroup["Reserved"] = 1000] = "Reserved";
})(TransactionTypeGroup || (TransactionTypeGroup = {}));

var HtlcLockExpirationType;

(function (HtlcLockExpirationType) {
  HtlcLockExpirationType[HtlcLockExpirationType["EpochTimestamp"] = 1] = "EpochTimestamp";
  HtlcLockExpirationType[HtlcLockExpirationType["BlockHeight"] = 2] = "BlockHeight";
})(HtlcLockExpirationType || (HtlcLockExpirationType = {}));

var enums = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get TransactionType () { return TransactionType; },
  get TransactionTypeGroup () { return TransactionTypeGroup; },
  get HtlcLockExpirationType () { return HtlcLockExpirationType; }
});

var signedTransaction = {
  anyOf: [{
    required: ["id", "signature"]
  }, {
    required: ["id", "signature", "signatures"]
  }, {
    required: ["id", "signatures"]
  }]
};
var strictTransaction = {
  additionalProperties: false
};
var transactionBaseSchema = {
  $id: undefined,
  type: "object",
  if: {
    properties: {
      version: {
        anyOf: [{
          type: "null"
        }, {
          const: 1
        }]
      }
    }
  },
  then: {
    required: ["type", "senderPublicKey", "fee", "amount", "timestamp"]
  },
  else: {
    required: ["type", "senderPublicKey", "fee", "amount", "nonce"]
  },
  properties: {
    id: {
      anyOf: [{
        $ref: "transactionId"
      }, {
        type: "null"
      }]
    },
    version: {
      enum: [1, 2]
    },
    network: {
      $ref: "networkByte"
    },
    timestamp: {
      type: "integer",
      minimum: 0
    },
    nonce: {
      bignumber: {
        minimum: 0
      }
    },
    typeGroup: {
      type: "integer",
      minimum: 0
    },
    amount: {
      bignumber: {
        minimum: 1,
        bypassGenesis: true
      }
    },
    fee: {
      bignumber: {
        minimum: 0,
        bypassGenesis: true
      }
    },
    senderPublicKey: {
      $ref: "publicKey"
    },
    signature: {
      $ref: "alphanumeric"
    },
    secondSignature: {
      $ref: "alphanumeric"
    },
    signSignature: {
      $ref: "alphanumeric"
    },
    signatures: {
      type: "array",
      minItems: 1,
      maxItems: 16,
      additionalItems: false,
      uniqueItems: true,
      items: {
        allOf: [{
          minLength: 130,
          maxLength: 130
        }, {
          $ref: "alphanumeric"
        }]
      }
    }
  }
};
var extend = (parent, properties) => {
  return deepmerge(parent, properties);
};
var signedSchema = schema => {
  var signed = extend(schema, signedTransaction);
  signed.$id = "".concat(schema.$id, "Signed");
  return signed;
};
var strictSchema = schema => {
  var signed = signedSchema(schema);
  var strict = extend(signed, strictTransaction);
  strict.$id = "".concat(schema.$id, "Strict");
  return strict;
};
var transfer = extend(transactionBaseSchema, {
  $id: "transfer",
  required: ["recipientId"],
  properties: {
    type: {
      transactionType: TransactionType.Transfer
    },
    fee: {
      bignumber: {
        minimum: 1,
        bypassGenesis: true
      }
    },
    vendorField: {
      anyOf: [{
        type: "null"
      }, {
        type: "string",
        format: "vendorField"
      }]
    },
    recipientId: {
      $ref: "address"
    },
    expiration: {
      type: "integer",
      minimum: 0
    }
  }
});
var secondSignature = extend(transactionBaseSchema, {
  $id: "secondSignature",
  required: ["asset"],
  properties: {
    type: {
      transactionType: TransactionType.SecondSignature
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 1
      }
    },
    secondSignature: {
      type: "null"
    },
    asset: {
      type: "object",
      required: ["signature"],
      properties: {
        signature: {
          type: "object",
          required: ["publicKey"],
          properties: {
            publicKey: {
              $ref: "publicKey"
            }
          }
        }
      }
    }
  }
});
var delegateRegistration = extend(transactionBaseSchema, {
  $id: "delegateRegistration",
  required: ["asset"],
  properties: {
    type: {
      transactionType: TransactionType.DelegateRegistration
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 1,
        bypassGenesis: true
      }
    },
    asset: {
      type: "object",
      required: ["delegate"],
      properties: {
        delegate: {
          type: "object",
          required: ["username"],
          properties: {
            username: {
              $ref: "delegateUsername"
            }
          }
        }
      }
    }
  }
});
var vote = extend(transactionBaseSchema, {
  $id: "vote",
  required: ["asset"],
  properties: {
    type: {
      transactionType: TransactionType.Vote
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 1
      }
    },
    recipientId: {
      $ref: "address"
    },
    asset: {
      type: "object",
      required: ["votes"],
      properties: {
        votes: {
          type: "array",
          minItems: 1,
          maxItems: 2,
          additionalItems: false,
          items: {
            $ref: "walletVote"
          }
        }
      }
    }
  }
});
var multiSignature = extend(transactionBaseSchema, {
  $id: "multiSignature",
  required: ["asset", "signatures"],
  properties: {
    type: {
      transactionType: TransactionType.MultiSignature
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 1
      }
    },
    asset: {
      type: "object",
      required: ["multiSignature"],
      properties: {
        multiSignature: {
          type: "object",
          required: ["min", "publicKeys"],
          properties: {
            min: {
              type: "integer",
              minimum: 1,
              maximum: {
                $data: "1/publicKeys/length"
              }
            },
            publicKeys: {
              type: "array",
              minItems: 1,
              maxItems: 16,
              additionalItems: false,
              uniqueItems: true,
              items: {
                $ref: "publicKey"
              }
            }
          }
        }
      }
    },
    signatures: {
      type: "array",
      minItems: {
        $data: "1/asset/multiSignature/min"
      },
      maxItems: {
        $data: "1/asset/multiSignature/publicKeys/length"
      },
      additionalItems: false,
      uniqueItems: true,
      items: {
        allOf: [{
          minLength: 130,
          maxLength: 130
        }, {
          $ref: "alphanumeric"
        }]
      }
    }
  }
}); // Multisignature legacy transactions have a different signatures property.
// Then we delete the "signatures" property definition to implement our own.

var transactionBaseSchemaNoSignatures = extend(transactionBaseSchema, {});
delete transactionBaseSchemaNoSignatures.properties.signatures;
var multiSignatureLegacy = extend(transactionBaseSchemaNoSignatures, {
  $id: "multiSignatureLegacy",
  required: ["asset"],
  properties: {
    version: {
      anyOf: [{
        type: "null"
      }, {
        const: 1
      }]
    },
    type: {
      transactionType: TransactionType.MultiSignature
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 1
      }
    },
    asset: {
      type: "object",
      required: ["multiSignatureLegacy"],
      properties: {
        multiSignatureLegacy: {
          type: "object",
          required: ["keysgroup", "min", "lifetime"],
          properties: {
            min: {
              type: "integer",
              minimum: 1,
              maximum: {
                $data: "1/keysgroup/length"
              }
            },
            lifetime: {
              type: "integer",
              minimum: 1,
              maximum: 72
            },
            keysgroup: {
              type: "array",
              minItems: 1,
              maxItems: 16,
              additionalItems: false,
              items: {
                allOf: [{
                  type: "string",
                  minimum: 67,
                  maximum: 67,
                  transform: ["toLowerCase"]
                }]
              }
            }
          }
        }
      }
    },
    signatures: {
      type: "array",
      minItems: 1,
      maxItems: 1,
      additionalItems: false,
      items: {
        $ref: "alphanumeric"
      }
    }
  }
});
var ipfs = extend(transactionBaseSchema, {
  $id: "ipfs",
  properties: {
    type: {
      transactionType: TransactionType.Ipfs
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 1
      }
    },
    asset: {
      type: "object",
      required: ["ipfs"],
      properties: {
        ipfs: {
          allOf: [{
            minLength: 2,
            maxLength: 90
          }, {
            $ref: "base58"
          }]
        }
      }
    }
  }
});
var htlcLock = extend(transactionBaseSchema, {
  $id: "htlcLock",
  properties: {
    type: {
      transactionType: TransactionType.HtlcLock
    },
    amount: {
      bignumber: {
        minimum: 1
      }
    },
    fee: {
      bignumber: {
        minimum: 1
      }
    },
    recipientId: {
      $ref: "address"
    },
    vendorField: {
      anyOf: [{
        type: "null"
      }, {
        type: "string",
        format: "vendorField"
      }]
    },
    asset: {
      type: "object",
      required: ["lock"],
      properties: {
        lock: {
          type: "object",
          required: ["secretHash", "expiration"],
          properties: {
            secretHash: {
              allOf: [{
                minLength: 64,
                maxLength: 64
              }, {
                $ref: "hex"
              }]
            },
            expiration: {
              type: "object",
              required: ["type", "value"],
              properties: {
                type: {
                  enum: [1, 2]
                },
                value: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        }
      }
    }
  }
});
var htlcClaim = extend(transactionBaseSchema, {
  $id: "htlcClaim",
  properties: {
    type: {
      transactionType: TransactionType.HtlcClaim
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    asset: {
      type: "object",
      required: ["claim"],
      properties: {
        claim: {
          type: "object",
          required: ["lockTransactionId", "unlockSecret"],
          properties: {
            lockTransactionId: {
              $ref: "transactionId"
            },
            unlockSecret: {
              allOf: [{
                minLength: 64,
                maxLength: 64
              }, {
                $ref: "hex"
              }]
            }
          }
        }
      }
    }
  }
});
var htlcRefund = extend(transactionBaseSchema, {
  $id: "htlcRefund",
  properties: {
    type: {
      transactionType: TransactionType.HtlcRefund
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    asset: {
      type: "object",
      required: ["refund"],
      properties: {
        refund: {
          type: "object",
          required: ["lockTransactionId"],
          properties: {
            lockTransactionId: {
              $ref: "transactionId"
            }
          }
        }
      }
    }
  }
});
var multiPayment = extend(transactionBaseSchema, {
  $id: "multiPayment",
  properties: {
    type: {
      transactionType: TransactionType.MultiPayment
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 1
      }
    },
    vendorField: {
      anyOf: [{
        type: "null"
      }, {
        type: "string",
        format: "vendorField"
      }]
    },
    asset: {
      type: "object",
      required: ["payments"],
      properties: {
        payments: {
          type: "array",
          minItems: 2,
          additionalItems: false,
          uniqueItems: false,
          items: {
            type: "object",
            required: ["amount", "recipientId"],
            properties: {
              amount: {
                bignumber: {
                  minimum: 1
                }
              },
              recipientId: {
                $ref: "address"
              }
            }
          }
        }
      }
    }
  }
});
var delegateResignation = extend(transactionBaseSchema, {
  $id: "delegateResignation",
  properties: {
    type: {
      transactionType: TransactionType.DelegateResignation
    },
    amount: {
      bignumber: {
        minimum: 0,
        maximum: 0
      }
    },
    fee: {
      bignumber: {
        minimum: 1
      }
    }
  }
});

var schemas = /*#__PURE__*/Object.freeze({
  __proto__: null,
  transactionBaseSchema: transactionBaseSchema,
  extend: extend,
  signedSchema: signedSchema,
  strictSchema: strictSchema,
  transfer: transfer,
  secondSignature: secondSignature,
  delegateRegistration: delegateRegistration,
  vote: vote,
  multiSignature: multiSignature,
  multiSignatureLegacy: multiSignatureLegacy,
  ipfs: ipfs,
  htlcLock: htlcLock,
  htlcClaim: htlcClaim,
  htlcRefund: htlcRefund,
  multiPayment: multiPayment,
  delegateResignation: delegateResignation
});

var vendorField = ajv => {
  ajv.addFormat("vendorField", data => {
    try {
      return Buffer.from(data, "utf8").length <= maxVendorFieldLength();
    } catch (_unused) {
      return false;
    }
  });
};

var validPeer = ajv => {
  ajv.addFormat("peer", ip => {
    try {
      return isValidPeer({
        ip
      }, false);
    } catch (_unused2) {
      return false;
    }
  });
};

var formats = [vendorField, validPeer];

var maxBytes = ajv => {
  ajv.addKeyword("maxBytes", {
    type: "string",

    compile(schema, parentSchema) {
      return data => {
        if (parentSchema.type !== "string") {
          return false;
        }

        return Buffer.from(data, "utf8").byteLength <= schema;
      };
    },

    errors: false,
    metaSchema: {
      type: "integer",
      minimum: 0
    }
  });
};

var transactionType = ajv => {
  ajv.addKeyword("transactionType", {
    // @ts-ignore
    compile(schema) {
      return (data, dataPath, parentObject) => {
        // Impose dynamic multipayment limit based on milestone
        if (data === TransactionType.MultiPayment && parentObject && (!parentObject.typeGroup || parentObject.typeGroup === 1)) {
          if (parentObject.asset && parentObject.asset.payments) {
            var limit = configManager.getMilestone().multiPaymentLimit || 256;
            return parentObject.asset.payments.length <= limit;
          }
        }

        return data === schema;
      };
    },

    errors: false,
    metaSchema: {
      type: "integer",
      minimum: 0
    }
  });
};

var network = ajv => {
  ajv.addKeyword("network", {
    compile(schema) {
      return data => {
        return schema && data === configManager.get("network.pubKeyHash");
      };
    },

    errors: false,
    metaSchema: {
      type: "boolean"
    }
  });
};

var bignumber = ajv => {
  var instanceOf = ajvKeywords.get("instanceof").definition;
  instanceOf.CONSTRUCTORS.BigNumber = BigNumber;
  ajv.addKeyword("bignumber", {
    compile(schema) {
      return (data, dataPath, parentObject, property) => {
        var minimum = typeof schema.minimum !== "undefined" ? schema.minimum : 0;
        var maximum = typeof schema.maximum !== "undefined" ? schema.maximum : "9223372036854775807"; // 8 byte maximum

        if (data !== 0 && !data) {
          return false;
        }

        var bignum;

        try {
          bignum = BigNumber.make(data);
        } catch (_unused) {
          return false;
        }

        if (parentObject && property) {
          parentObject[property] = bignum;
        }

        var bypassGenesis = false;

        if (schema.bypassGenesis) {
          if (parentObject.id) {
            if (schema.block) {
              bypassGenesis = parentObject.height === 1;
            } else {
              bypassGenesis = isGenesisTransaction(parentObject.id);
            }
          }
        }

        if (bignum.isLessThan(minimum) && !(bignum.isZero() && bypassGenesis)) {
          return false;
        }

        if (bignum.isGreaterThan(maximum) && !bypassGenesis) {
          return false;
        }

        return true;
      };
    },

    errors: false,
    modifying: true,
    metaSchema: {
      type: "object",
      properties: {
        minimum: {
          type: "integer"
        },
        maximum: {
          type: "integer"
        },
        bypassGenesis: {
          type: "boolean"
        },
        block: {
          type: "boolean"
        }
      },
      additionalItems: false
    }
  });
};

var blockId = ajv => {
  ajv.addKeyword("blockId", {
    compile(schema) {
      return (data, dataPath, parentObject) => {
        if (parentObject && parentObject.height === 1 && schema.allowNullWhenGenesis) {
          if (!data || Number(data) === 0) {
            return true;
          }
        }

        if (typeof data !== "string") {
          return false;
        } // Partial SHA256 block id (old/legacy), before the switch to full SHA256.
        // 8 byte integer either decimal without leading zeros or hex with leading zeros.


        var isPartial = /^[0-9]{1,20}$/.test(data) || /^[0-9a-f]{16}$/i.test(data);
        var isFullSha256 = /^[0-9a-f]{64}$/i.test(data);

        if (parentObject && parentObject.height) {
          var height = schema.isPreviousBlock ? parentObject.height - 1 : parentObject.height;
          var constants = configManager.getMilestone(height !== null && height !== void 0 ? height : 1); // if height === 0 set it to 1

          return constants.block.idFullSha256 ? isFullSha256 : isPartial;
        }

        return isPartial || isFullSha256;
      };
    },

    errors: false,
    metaSchema: {
      type: "object",
      properties: {
        allowNullWhenGenesis: {
          type: "boolean"
        },
        isPreviousBlock: {
          type: "boolean"
        }
      },
      additionalItems: false
    }
  });
};

var keywords = [bignumber, blockId, maxBytes, network, transactionType];

var schemas$1 = {
  hex: {
    $id: "hex",
    type: "string",
    pattern: "^[0123456789A-Fa-f]+$"
  },
  base58: {
    $id: "base58",
    type: "string",
    pattern: "^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$"
  },
  alphanumeric: {
    $id: "alphanumeric",
    type: "string",
    pattern: "^[a-zA-Z0-9]+$"
  },
  transactionId: {
    $id: "transactionId",
    allOf: [{
      minLength: 64,
      maxLength: 64
    }, {
      $ref: "hex"
    }]
  },
  networkByte: {
    $id: "networkByte",
    network: true
  },
  address: {
    $id: "address",
    allOf: [{
      minLength: 34,
      maxLength: 34
    }, {
      $ref: "base58"
    }]
  },
  publicKey: {
    $id: "publicKey",
    allOf: [{
      minLength: 66,
      maxLength: 66
    }, {
      $ref: "hex"
    }, {
      transform: ["toLowerCase"]
    }]
  },
  walletVote: {
    $id: "walletVote",
    allOf: [{
      type: "string",
      pattern: "^[+|-][a-zA-Z0-9]{66}$"
    }, {
      transform: ["toLowerCase"]
    }]
  },
  username: {
    $id: "delegateUsername",
    allOf: [{
      type: "string",
      pattern: "^[a-z0-9!@$&_.]+$"
    }, {
      minLength: 1,
      maxLength: 20
    }, {
      transform: ["toLowerCase"]
    }]
  },
  genericName: {
    $id: "genericName",
    allOf: [{
      type: "string",
      pattern: "^[a-zA-Z0-9]+(( - |[ ._-])[a-zA-Z0-9]+)*[.]?$"
    }, {
      minLength: 1,
      maxLength: 40
    }]
  },
  uri: {
    $id: "uri",
    allOf: [{
      format: "uri"
    }, {
      minLength: 4,
      maxLength: 80
    }]
  },
  blockHeader: {
    $id: "blockHeader",
    type: "object",
    required: ["id", "timestamp", "previousBlock", "height", "totalAmount", "totalFee", "reward", "generatorPublicKey", "blockSignature"],
    properties: {
      id: {
        blockId: {}
      },
      idHex: {
        blockId: {}
      },
      version: {
        type: "integer",
        minimum: 0
      },
      timestamp: {
        type: "integer",
        minimum: 0
      },
      previousBlock: {
        blockId: {
          allowNullWhenGenesis: true,
          isPreviousBlock: true
        }
      },
      previousBlockHex: {
        blockId: {
          allowNullWhenGenesis: true,
          isPreviousBlock: true
        }
      },
      height: {
        type: "integer",
        minimum: 1
      },
      numberOfTransactions: {
        type: "integer"
      },
      totalAmount: {
        bignumber: {
          minimum: 0,
          bypassGenesis: true,
          block: true
        }
      },
      totalFee: {
        bignumber: {
          minimum: 0,
          bypassGenesis: true,
          block: true
        }
      },
      reward: {
        bignumber: {
          minimum: 0
        }
      },
      payloadLength: {
        type: "integer",
        minimum: 0
      },
      payloadHash: {
        $ref: "hex"
      },
      generatorPublicKey: {
        $ref: "publicKey"
      },
      blockSignature: {
        $ref: "hex"
      }
    }
  },
  block: {
    $id: "block",
    $ref: "blockHeader",
    properties: {
      transactions: {
        $ref: "transactions",
        minItems: {
          $data: "1/numberOfTransactions"
        },
        maxItems: {
          $data: "1/numberOfTransactions"
        }
      }
    }
  }
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
class Validator {
  constructor(options) {
    this.transactionSchemas = new Map();
    this.ajv = this.instantiateAjv(options);
  }

  static make() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new Validator(options);
  }

  getInstance() {
    return this.ajv;
  }

  validate(schemaKeyRef, data) {
    return this.validateSchema(this.ajv, schemaKeyRef, data);
  }

  validateException(schemaKeyRef, data) {
    var ajv = this.instantiateAjv({
      allErrors: true,
      verbose: true
    });

    for (var schema of this.transactionSchemas.values()) {
      this.extendTransactionSchema(ajv, schema);
    }

    return this.validateSchema(ajv, schemaKeyRef, data);
  }

  addFormat(name, format) {
    this.ajv.addFormat(name, format);
  }

  addKeyword(keyword, definition) {
    this.ajv.addKeyword(keyword, definition);
  }

  addSchema(schema, key) {
    this.ajv.addSchema(schema, key);
  }

  removeKeyword(keyword) {
    this.ajv.removeKeyword(keyword);
  }

  removeSchema(schemaKeyRef) {
    this.ajv.removeSchema(schemaKeyRef);
  }

  extendTransaction(schema, remove) {
    this.extendTransactionSchema(this.ajv, schema, remove);
  }

  validateSchema(ajv, schemaKeyRef, data) {
    try {
      ajv.validate(schemaKeyRef, data);
      var error = ajv.errors ? ajv.errorsText() : undefined;
      return {
        value: data,
        error,
        errors: ajv.errors || undefined
      };
    } catch (error) {
      return {
        value: undefined,
        error: error.stack,
        errors: []
      };
    }
  }

  instantiateAjv(options) {
    var ajv = new Ajv(_objectSpread(_objectSpread({}, {
      $data: true,
      schemas: schemas$1,
      removeAdditional: true,
      extendRefs: true
    }), options));
    ajvKeywords(ajv);

    for (var addKeyword of keywords) {
      addKeyword(ajv);
    }

    for (var addFormat of formats) {
      addFormat(ajv);
    }

    return ajv;
  }

  extendTransactionSchema(ajv, schema, remove) {
    if (ajv.getSchema(schema.$id)) {
      remove = true;
    }

    if (remove) {
      this.transactionSchemas.delete(schema.$id);
      ajv.removeSchema(schema.$id);
      ajv.removeSchema("".concat(schema.$id, "Signed"));
      ajv.removeSchema("".concat(schema.$id, "Strict"));
    }

    this.transactionSchemas.set(schema.$id, schema);
    ajv.addSchema(schema);
    ajv.addSchema(signedSchema(schema));
    ajv.addSchema(strictSchema(schema));
    this.updateTransactionArray(ajv);
  }

  updateTransactionArray(ajv) {
    ajv.removeSchema("block");
    ajv.removeSchema("transactions");
    ajv.addSchema({
      $id: "transactions",
      type: "array",
      additionalItems: false,
      items: {
        anyOf: [...this.transactionSchemas.keys()].map(schema => ({
          $ref: "".concat(schema, "Signed")
        }))
      }
    });
    ajv.addSchema(schemas$1.block);
  }

}
var validator = Validator.make();

var index$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Validator: Validator,
  validator: validator
});

class InternalTransactionType {
  constructor(type, typeGroup) {
    this.type = type;
    this.typeGroup = typeGroup;
  }

  static from(type, typeGroup) {
    if (typeGroup === undefined) {
      typeGroup = TransactionTypeGroup.Core;
    }

    var compositeType = "".concat(typeGroup, "-").concat(type);

    if (!this.types.has(compositeType)) {
      this.types.set(compositeType, new InternalTransactionType(type, typeGroup));
    }

    return this.types.get(compositeType);
  }

  toString() {
    if (this.typeGroup === TransactionTypeGroup.Core) {
      return "Core/".concat(this.type);
    }

    return "".concat(this.typeGroup, "/").concat(this.type);
  }

}
InternalTransactionType.types = new Map();

class TransactionTypeFactory {
  static initialize(transactionTypes) {
    this.transactionTypes = transactionTypes;
  }

  static create(data) {
    var instance = new (this.get(data.type, data.typeGroup, data.version))();
    instance.data = data;
    instance.data.version = data.version || 1;
    return instance;
  }

  static get(type, typeGroup, version) {
    var _this$transactionType;

    var internalType = InternalTransactionType.from(type, typeGroup);

    if (!this.transactionTypes.has(internalType)) {
      throw new UnkownTransactionError(internalType.toString());
    } // Either there is a match for the provided version or use the first available constructor as a fallback


    var constructor = (_this$transactionType = this.transactionTypes.get(internalType)) === null || _this$transactionType === void 0 ? void 0 : _this$transactionType.get(version || 1);
    return constructor !== null && constructor !== void 0 ? constructor : [...this.transactionTypes.get(internalType).values()][0];
  }

}

class Serializer {
  static getBytes(transaction) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var version = transaction.version || 1;

    if (options.acceptLegacyVersion || options.disableVersionCheck || isSupportedTransactionVersion(version)) {
      if (version === 1) {
        return this.getBytesV1(transaction, options);
      }

      return this.serialize(TransactionTypeFactory.create(transaction), options);
    } else {
      throw new TransactionVersionError(version);
    }
  }
  /**
   * Serializes the given transaction according to AIP11.
   */


  static serialize(transaction) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var buffer = new ByteBuffer(512, true);
    this.serializeCommon(transaction.data, buffer);
    this.serializeVendorField(transaction, buffer);
    var serialized = transaction.serialize(options);

    if (!serialized) {
      throw new Error();
    }

    var typeBuffer = serialized.flip();
    buffer.append(typeBuffer);
    this.serializeSignatures(transaction.data, buffer, options);
    var flippedBuffer = buffer.flip().toBuffer();
    transaction.serialized = flippedBuffer;
    return flippedBuffer;
  }
  /**
   * Serializes the given transaction prior to AIP11 (legacy).
   */


  static getBytesV1(transaction) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var assetSize = 0;
    var assetBytes;

    if (transaction.type === TransactionType.SecondSignature && transaction.asset) {
      var {
        signature
      } = transaction.asset;

      var _bb = new ByteBuffer(33, true);

      if (signature && signature.publicKey) {
        var publicKeyBuffer = Buffer.from(signature.publicKey, "hex");

        for (var byte of publicKeyBuffer) {
          _bb.writeByte(byte);
        }
      }

      _bb.flip();

      assetBytes = new Uint8Array(_bb.toArrayBuffer());
      assetSize = assetBytes.length;
    }

    if (transaction.type === TransactionType.DelegateRegistration && transaction.asset && transaction.asset.delegate) {
      assetBytes = Buffer.from(transaction.asset.delegate.username, "utf8");
      assetSize = assetBytes.length;
    }

    if (transaction.type === TransactionType.Vote && transaction.asset && transaction.asset.votes) {
      assetBytes = Buffer.from(transaction.asset.votes.join(""), "utf8");
      assetSize = assetBytes.length;
    }

    if (transaction.type === TransactionType.MultiSignature && transaction.asset && transaction.asset.multiSignatureLegacy) {
      var keysgroupBuffer = Buffer.from(transaction.asset.multiSignatureLegacy.keysgroup.join(""), "utf8");

      var _bb2 = new ByteBuffer(1 + 1 + keysgroupBuffer.length, true);

      _bb2.writeByte(transaction.asset.multiSignatureLegacy.min);

      _bb2.writeByte(transaction.asset.multiSignatureLegacy.lifetime);

      for (var _byte of keysgroupBuffer) {
        _bb2.writeByte(_byte);
      }

      _bb2.flip();

      assetBytes = _bb2.toBuffer();

      if (assetBytes) {
        assetSize = assetBytes.length;
      }
    }

    var bb = new ByteBuffer(1 + 4 + 32 + 8 + 8 + 21 + 64 + 64 + 64 + assetSize, true);
    bb.writeByte(transaction.type);
    bb.writeInt(transaction.timestamp);

    if (transaction.senderPublicKey) {
      var senderPublicKeyBuffer = Buffer.from(transaction.senderPublicKey, "hex");

      for (var _byte2 of senderPublicKeyBuffer) {
        bb.writeByte(_byte2);
      } // Apply fix for broken type 1 and 4 transactions, which were
      // erroneously calculated with a recipient id.


      var {
        transactionIdFixTable
      } = configManager.get("exceptions");
      var isBrokenTransaction = transactionIdFixTable && Object.values(transactionIdFixTable).includes(transaction.id);

      if (isBrokenTransaction || transaction.recipientId && transaction.type !== 1 && transaction.type !== 4) {
        var recipientId = transaction.recipientId || Address.fromPublicKey(transaction.senderPublicKey, transaction.network);
        var recipient = Address.toBuffer(recipientId).addressBuffer;

        for (var _byte3 of recipient) {
          bb.writeByte(_byte3);
        }
      } else {
        for (var i = 0; i < 21; i++) {
          bb.writeByte(0);
        }
      }
    }

    if (transaction.vendorField) {
      var vf = Buffer.from(transaction.vendorField);
      var fillstart = vf.length;

      for (var _i = 0; _i < fillstart; _i++) {
        bb.writeByte(vf[_i]);
      }

      for (var _i2 = fillstart; _i2 < 64; _i2++) {
        bb.writeByte(0);
      }
    } else {
      for (var _i3 = 0; _i3 < 64; _i3++) {
        bb.writeByte(0);
      }
    } // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.


    bb.writeInt64(transaction.amount.toString()); // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.

    bb.writeInt64(transaction.fee.toString());

    if (assetSize > 0 && assetBytes) {
      for (var _i4 = 0; _i4 < assetSize; _i4++) {
        bb.writeByte(assetBytes[_i4]);
      }
    }

    if (!options.excludeSignature && transaction.signature) {
      var signatureBuffer = Buffer.from(transaction.signature, "hex");

      for (var _byte4 of signatureBuffer) {
        bb.writeByte(_byte4);
      }
    }

    if (!options.excludeSecondSignature && transaction.secondSignature) {
      var signSignatureBuffer = Buffer.from(transaction.secondSignature, "hex");

      for (var _byte5 of signSignatureBuffer) {
        bb.writeByte(_byte5);
      }
    }

    bb.flip();
    var arrayBuffer = new Uint8Array(bb.toArrayBuffer());
    var buffer = [];

    for (var _i5 = 0; _i5 < arrayBuffer.length; _i5++) {
      buffer[_i5] = arrayBuffer[_i5];
    }

    return Buffer.from(buffer);
  }

  static serializeCommon(transaction, buffer) {
    transaction.version = transaction.version || 0x01;

    if (transaction.typeGroup === undefined) {
      transaction.typeGroup = TransactionTypeGroup.Core;
    }

    buffer.writeByte(0xff);
    buffer.writeByte(transaction.version);
    buffer.writeByte(transaction.network || configManager.get("network.pubKeyHash"));

    if (transaction.version === 1) {
      buffer.writeByte(transaction.type);
      buffer.writeUint32(transaction.timestamp);
    } else {
      buffer.writeUint32(transaction.typeGroup);
      buffer.writeUint16(transaction.type);

      if (transaction.nonce) {
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        buffer.writeUint64(transaction.nonce.toString());
      }
    }

    if (transaction.senderPublicKey) {
      buffer.append(transaction.senderPublicKey, "hex");
    } // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.


    buffer.writeUint64(transaction.fee.toString());
  }

  static serializeVendorField(transaction, buffer) {
    if (transaction.hasVendorField()) {
      var {
        data
      } = transaction;

      if (data.vendorField) {
        var vf = Buffer.from(data.vendorField, "utf8");
        buffer.writeByte(vf.length);
        buffer.append(vf);
      } else {
        buffer.writeByte(0x00);
      }
    } else {
      buffer.writeByte(0x00);
    }
  }

  static serializeSignatures(transaction, buffer) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (transaction.signature && !options.excludeSignature) {
      buffer.append(transaction.signature, "hex");
    }

    var secondSignature = transaction.secondSignature || transaction.signSignature;

    if (secondSignature && !options.excludeSecondSignature) {
      buffer.append(secondSignature, "hex");
    }

    if (transaction.signatures) {
      if (transaction.version === 1 && isException(transaction)) {
        buffer.append("ff", "hex"); // 0xff separator to signal start of multi-signature transactions

        buffer.append(transaction.signatures.join(""), "hex");
      } else if (!options.excludeMultiSignature) {
        buffer.append(transaction.signatures.join(""), "hex");
      }
    }
  }

}

class Utils {
  static toBytes(data) {
    return Serializer.serialize(TransactionTypeFactory.create(data));
  }

  static toHash(transaction, options) {
    return HashAlgorithms.sha256(Serializer.getBytes(transaction, options));
  }

  static getId(transaction) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var id = Utils.toHash(transaction, options).toString("hex"); // WORKAROUND:
    // A handful of mainnet transactions have an invalid recipient. Due to a
    // refactor of the Address network byte validation it is no longer
    // trivially possible to handle them. If an invalid address is encountered
    // during transfer serialization, the error is bubbled up to defer the
    // `AddressNetworkByteError` until the actual id is available to call
    // `isException`.

    if (options.addressError && !isException({
      id
    })) {
      throw new AddressNetworkError(options.addressError);
    } // Apply fix for broken type 1 and 4 transactions, which were
    // erroneously calculated with a recipient id.


    var {
      transactionIdFixTable
    } = configManager.get("exceptions");

    if (transactionIdFixTable && transactionIdFixTable[id]) {
      return transactionIdFixTable[id];
    }

    return id;
  }

}

class Verifier {
  static verify(data, options) {
    if (isException(data)) {
      return true;
    }

    if (configManager.getMilestone().aip11 && (!data.version || data.version === 1)) {
      return false;
    }

    return Verifier.verifyHash(data, options === null || options === void 0 ? void 0 : options.disableVersionCheck);
  }

  static verifySecondSignature(transaction, publicKey, options) {
    var secondSignature = transaction.secondSignature || transaction.signSignature;

    if (!secondSignature) {
      return false;
    }

    var hash = Utils.toHash(transaction, {
      disableVersionCheck: options === null || options === void 0 ? void 0 : options.disableVersionCheck,
      excludeSecondSignature: true
    });
    return this.internalVerifySignature(hash, secondSignature, publicKey);
  }

  static verifySignatures(transaction, multiSignature) {
    if (!multiSignature) {
      throw new InvalidMultiSignatureAssetError();
    }

    var {
      publicKeys,
      min
    } = multiSignature;
    var {
      signatures
    } = transaction;
    var hash = Utils.toHash(transaction, {
      excludeSignature: true,
      excludeSecondSignature: true,
      excludeMultiSignature: true
    });
    var publicKeyIndexes = {};
    var verified = false;
    var verifiedSignatures = 0;

    if (signatures) {
      for (var i = 0; i < signatures.length; i++) {
        var signature = signatures[i];
        var publicKeyIndex = parseInt(signature.slice(0, 2), 16);

        if (!publicKeyIndexes[publicKeyIndex]) {
          publicKeyIndexes[publicKeyIndex] = true;
        } else {
          throw new DuplicateParticipantInMultiSignatureError();
        }

        var partialSignature = signature.slice(2, 130);
        var publicKey = publicKeys[publicKeyIndex];

        if (Hash.verifySchnorr(hash, partialSignature, publicKey)) {
          verifiedSignatures++;
        }

        if (verifiedSignatures === min) {
          verified = true;
          break;
        } else if (signatures.length - (i + 1 - verifiedSignatures) < min) {
          break;
        }
      }
    }

    return verified;
  }

  static verifyHash(data) {
    var disableVersionCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var {
      signature,
      senderPublicKey
    } = data;

    if (!signature || !senderPublicKey) {
      return false;
    }

    var hash = Utils.toHash(data, {
      disableVersionCheck,
      excludeSignature: true,
      excludeSecondSignature: true
    });
    return this.internalVerifySignature(hash, signature, senderPublicKey);
  }

  static verifySchema(data) {
    var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var transactionType = TransactionTypeFactory.get(data.type, data.typeGroup, data.version);

    if (!transactionType) {
      throw new Error();
    }

    var {
      $id
    } = transactionType.getSchema();
    return validator.validate(strict ? "".concat($id, "Strict") : "".concat($id), data);
  }

  static internalVerifySignature(hash, signature, publicKey) {
    var isSchnorr = Buffer.from(signature, "hex").byteLength === 64;

    if (isSchnorr) {
      return Hash.verifySchnorr(hash, signature, publicKey);
    }

    return Hash.verifyECDSA(hash, signature, publicKey);
  }

}

class Transaction {
  constructor() {
    this.isVerified = false;
  }

  static getSchema() {
    throw new NotImplemented();
  }

  static staticFee() {
    var feeContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var milestones = configManager.getMilestone(feeContext.height);

    if (milestones.fees && milestones.fees.staticFees && this.key) {
      var fee = milestones.fees.staticFees[this.key];

      if (fee !== undefined) {
        return BigNumber.make(fee);
      }
    }

    return this.defaultStaticFee;
  }

  verify(options) {
    return Verifier.verify(this.data, options);
  }

  verifySecondSignature(publicKey) {
    return Verifier.verifySecondSignature(this.data, publicKey);
  }

  verifySchema() {
    return Verifier.verifySchema(this.data);
  }

  toJson() {
    var data = JSON.parse(JSON.stringify(this.data));

    if (data.typeGroup === TransactionTypeGroup.Core) {
      delete data.typeGroup;
    }

    if (data.version === 1) {
      delete data.nonce;
    } else {
      delete data.timestamp;
    }

    return data;
  }

  toString() {
    var parts = [];

    if (this.data.senderPublicKey && this.data.nonce) {
      parts.push("".concat(Address.fromPublicKey(this.data.senderPublicKey), "#").concat(this.data.nonce));
    } else if (this.data.senderPublicKey) {
      parts.push("".concat(Address.fromPublicKey(this.data.senderPublicKey)));
    }

    if (this.data.id) {
      parts.push(this.data.id.slice(-8));
    }

    parts.push("".concat(this.key[0].toUpperCase()).concat(this.key.slice(1), " v").concat(this.data.version));
    return parts.join(" ");
  }

  hasVendorField() {
    return false;
  }

  get id() {
    return this.data.id;
  }

  get type() {
    return this.data.type;
  }

  get typeGroup() {
    return this.data.typeGroup;
  }

  get verified() {
    return this.isVerified;
  }

  get key() {
    return this.__proto__.constructor.key;
  }

  get staticFee() {
    return this.__proto__.constructor.staticFee({
      data: this.data
    });
  }

}
Transaction.type = undefined;
Transaction.typeGroup = undefined;
Transaction.version = 1;
Transaction.key = undefined;
Transaction.defaultStaticFee = BigNumber.ZERO;

class TransferTransaction extends Transaction {
  static getSchema() {
    return transfer;
  }

  hasVendorField() {
    return true;
  }

  serialize(options) {
    var {
      data
    } = this;
    var buffer = new ByteBuffer(24, true); // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.

    buffer.writeUint64(data.amount.toString());
    buffer.writeUint32(data.expiration || 0);

    if (data.recipientId) {
      var {
        addressBuffer,
        addressError
      } = Address.toBuffer(data.recipientId);

      if (options) {
        options.addressError = addressError;
      }

      buffer.append(addressBuffer);
    }

    return buffer;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    data.amount = BigNumber.make(buf.readUint64().toString());
    data.expiration = buf.readUint32();
    data.recipientId = Address.fromBuffer(buf.readBytes(21).toBuffer());
  }

}
TransferTransaction.typeGroup = TransactionTypeGroup.Core;
TransferTransaction.type = TransactionType.Transfer;
TransferTransaction.key = "transfer";
TransferTransaction.version = 1;
TransferTransaction.defaultStaticFee = BigNumber.make("10000000");

class SecondSignatureRegistrationTransaction extends Transaction {
  static getSchema() {
    return secondSignature;
  }

  serialize(options) {
    var {
      data
    } = this;
    var buffer = new ByteBuffer(33, true);

    if (data.asset && data.asset.signature) {
      buffer.append(data.asset.signature.publicKey, "hex");
    }

    return buffer;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    data.asset = {
      signature: {
        publicKey: buf.readBytes(33).toString("hex")
      }
    };
  }

}
SecondSignatureRegistrationTransaction.typeGroup = TransactionTypeGroup.Core;
SecondSignatureRegistrationTransaction.type = TransactionType.SecondSignature;
SecondSignatureRegistrationTransaction.key = "secondSignature";
SecondSignatureRegistrationTransaction.version = 1;
SecondSignatureRegistrationTransaction.defaultStaticFee = BigNumber.make("500000000");

class DelegateRegistrationTransaction extends Transaction {
  static getSchema() {
    return delegateRegistration;
  }

  serialize(options) {
    var {
      data
    } = this;

    if (data.asset && data.asset.delegate) {
      var delegateBytes = Buffer.from(data.asset.delegate.username, "utf8");
      var buffer = new ByteBuffer(delegateBytes.length, true);
      buffer.writeByte(delegateBytes.length);
      buffer.append(delegateBytes, "hex");
      return buffer;
    }

    return undefined;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    var usernamelength = buf.readUint8();
    data.asset = {
      delegate: {
        username: buf.readString(usernamelength)
      }
    };
  }

}
DelegateRegistrationTransaction.typeGroup = TransactionTypeGroup.Core;
DelegateRegistrationTransaction.type = TransactionType.DelegateRegistration;
DelegateRegistrationTransaction.key = "delegateRegistration";
DelegateRegistrationTransaction.version = 1;
DelegateRegistrationTransaction.defaultStaticFee = BigNumber.make("2500000000");

class VoteTransaction extends Transaction {
  static getSchema() {
    return vote;
  }

  serialize(options) {
    var {
      data
    } = this;
    var buffer = new ByteBuffer(24, true);

    if (data.asset && data.asset.votes) {
      var voteBytes = data.asset.votes.map(vote => (vote.startsWith("+") ? "01" : "00") + vote.slice(1)).join("");
      buffer.writeByte(data.asset.votes.length);
      buffer.append(voteBytes, "hex");
    }

    return buffer;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    var votelength = buf.readUint8();
    data.asset = {
      votes: []
    };

    for (var i = 0; i < votelength; i++) {
      var vote = buf.readBytes(34).toString("hex");
      vote = (vote[1] === "1" ? "+" : "-") + vote.slice(2);

      if (data.asset && data.asset.votes) {
        data.asset.votes.push(vote);
      }
    }
  }

}
VoteTransaction.typeGroup = TransactionTypeGroup.Core;
VoteTransaction.type = TransactionType.Vote;
VoteTransaction.key = "vote";
VoteTransaction.version = 1;
VoteTransaction.defaultStaticFee = BigNumber.make("100000000");

class MultiSignatureRegistrationTransaction extends Transaction {
  static getSchema() {
    return multiSignatureLegacy;
  }

  static staticFee() {
    var _feeContext$data, _feeContext$data$asse;

    var feeContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if ((_feeContext$data = feeContext.data) === null || _feeContext$data === void 0 ? void 0 : (_feeContext$data$asse = _feeContext$data.asset) === null || _feeContext$data$asse === void 0 ? void 0 : _feeContext$data$asse.multiSignatureLegacy) {
      return super.staticFee(feeContext).times(feeContext.data.asset.multiSignatureLegacy.keysgroup.length + 1);
    }

    return super.staticFee(feeContext);
  }

  verify() {
    return isException(this.data);
  }

  serialize(options) {
    var {
      data
    } = this;
    var legacyAsset = data.asset.multiSignatureLegacy;
    var joined = legacyAsset.keysgroup.map(k => k.startsWith("+") ? k.slice(1) : k).join("");
    var keysgroupBuffer = Buffer.from(joined, "hex");
    var buffer = new ByteBuffer(keysgroupBuffer.length + 3, true);
    buffer.writeByte(legacyAsset.min);
    buffer.writeByte(legacyAsset.keysgroup.length);
    buffer.writeByte(legacyAsset.lifetime);
    buffer.append(keysgroupBuffer, "hex");
    return buffer;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    var multiSignatureLegacy = {
      keysgroup: [],
      lifetime: 0,
      min: 0
    };
    multiSignatureLegacy.min = buf.readUint8();
    var num = buf.readUint8();
    multiSignatureLegacy.lifetime = buf.readUint8();

    for (var index = 0; index < num; index++) {
      var key = buf.readBytes(33).toString("hex");
      multiSignatureLegacy.keysgroup.push(key);
    }

    data.asset = {
      multiSignatureLegacy
    };
  }

}
MultiSignatureRegistrationTransaction.typeGroup = TransactionTypeGroup.Core;
MultiSignatureRegistrationTransaction.type = TransactionType.MultiSignature;
MultiSignatureRegistrationTransaction.key = "multiSignature";
MultiSignatureRegistrationTransaction.version = 1;
MultiSignatureRegistrationTransaction.defaultStaticFee = BigNumber.make("500000000");

var index$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TransferTransaction: TransferTransaction,
  SecondSignatureRegistrationTransaction: SecondSignatureRegistrationTransaction,
  DelegateRegistrationTransaction: DelegateRegistrationTransaction,
  VoteTransaction: VoteTransaction,
  MultiSignatureRegistrationTransaction: MultiSignatureRegistrationTransaction
});

class TransferTransaction$1 extends TransferTransaction {}
TransferTransaction$1.version = 2;

class SecondSignatureRegistrationTransaction$1 extends SecondSignatureRegistrationTransaction {}
SecondSignatureRegistrationTransaction$1.version = 2;

class DelegateRegistrationTransaction$1 extends DelegateRegistrationTransaction {}
DelegateRegistrationTransaction$1.version = 2;

class VoteTransaction$1 extends VoteTransaction {}
VoteTransaction$1.version = 2;

class MultiSignatureRegistrationTransaction$1 extends Transaction {
  static getSchema() {
    return multiSignature;
  }

  static staticFee() {
    var _feeContext$data, _feeContext$data$asse;

    var feeContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if ((_feeContext$data = feeContext.data) === null || _feeContext$data === void 0 ? void 0 : (_feeContext$data$asse = _feeContext$data.asset) === null || _feeContext$data$asse === void 0 ? void 0 : _feeContext$data$asse.multiSignature) {
      return super.staticFee(feeContext).times(feeContext.data.asset.multiSignature.publicKeys.length + 1);
    }

    return super.staticFee(feeContext);
  }

  verify() {
    return configManager.getMilestone().aip11 && super.verify();
  }

  serialize(options) {
    var {
      data
    } = this;
    var {
      min,
      publicKeys
    } = data.asset.multiSignature;
    var buffer = new ByteBuffer(2 + publicKeys.length * 33);
    buffer.writeUint8(min);
    buffer.writeUint8(publicKeys.length);

    for (var publicKey of publicKeys) {
      buffer.append(publicKey, "hex");
    }

    return buffer;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    var multiSignature = {
      publicKeys: [],
      min: 0
    };
    multiSignature.min = buf.readUint8();
    var count = buf.readUint8();

    for (var i = 0; i < count; i++) {
      var publicKey = buf.readBytes(33).toString("hex");
      multiSignature.publicKeys.push(publicKey);
    }

    data.asset = {
      multiSignature
    };
  }

}
MultiSignatureRegistrationTransaction$1.typeGroup = TransactionTypeGroup.Core;
MultiSignatureRegistrationTransaction$1.type = TransactionType.MultiSignature;
MultiSignatureRegistrationTransaction$1.key = "multiSignature";
MultiSignatureRegistrationTransaction$1.version = 2;
MultiSignatureRegistrationTransaction$1.defaultStaticFee = BigNumber.make("500000000");

class IpfsTransaction extends Transaction {
  static getSchema() {
    return ipfs;
  }

  verify() {
    return configManager.getMilestone().aip11 && super.verify();
  }

  serialize(options) {
    var {
      data
    } = this;

    if (data.asset) {
      var ipfsBuffer = base58.decode(data.asset.ipfs);
      var buffer = new ByteBuffer(ipfsBuffer.length, true);
      buffer.append(ipfsBuffer, "hex");
      return buffer;
    }

    return undefined;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    var hashFunction = buf.readUint8();
    var ipfsHashLength = buf.readUint8();
    var ipfsHash = buf.readBytes(ipfsHashLength).toBuffer();
    var buffer = Buffer.alloc(ipfsHashLength + 2);
    buffer.writeUInt8(hashFunction, 0);
    buffer.writeUInt8(ipfsHashLength, 1);
    buffer.fill(ipfsHash, 2);
    data.asset = {
      ipfs: base58.encode(buffer)
    };
  }

}
IpfsTransaction.typeGroup = TransactionTypeGroup.Core;
IpfsTransaction.type = TransactionType.Ipfs;
IpfsTransaction.key = "ipfs";
IpfsTransaction.version = 2;
IpfsTransaction.defaultStaticFee = BigNumber.make("500000000");

class MultiPaymentTransaction extends Transaction {
  static getSchema() {
    return multiPayment;
  }

  verify() {
    return configManager.getMilestone().aip11 && super.verify();
  }

  hasVendorField() {
    return true;
  }

  serialize() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var {
      data
    } = this;

    if (data.asset && data.asset.payments) {
      var buffer = new ByteBuffer(2 + data.asset.payments.length * 29, true);
      buffer.writeUint16(data.asset.payments.length);

      for (var payment of data.asset.payments) {
        // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.
        buffer.writeUint64(payment.amount.toString());
        var {
          addressBuffer,
          addressError
        } = Address.toBuffer(payment.recipientId);
        options.addressError = addressError || options.addressError;
        buffer.append(addressBuffer);
      }

      return buffer;
    }

    return undefined;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    var payments = [];
    var total = buf.readUint16();

    for (var j = 0; j < total; j++) {
      payments.push({
        amount: BigNumber.make(buf.readUint64().toString()),
        recipientId: Address.fromBuffer(buf.readBytes(21).toBuffer())
      });
    }

    data.amount = BigNumber.ZERO;
    data.asset = {
      payments
    };
  }

}
MultiPaymentTransaction.typeGroup = TransactionTypeGroup.Core;
MultiPaymentTransaction.type = TransactionType.MultiPayment;
MultiPaymentTransaction.key = "multiPayment";
MultiPaymentTransaction.version = 2;
MultiPaymentTransaction.defaultStaticFee = BigNumber.make("10000000");

class DelegateResignationTransaction extends Transaction {
  static getSchema() {
    return delegateResignation;
  }

  verify() {
    return configManager.getMilestone().aip11 && super.verify();
  }

  serialize(options) {
    return new ByteBuffer(0);
  }

  deserialize(buf) {
    return;
  }

}
DelegateResignationTransaction.typeGroup = TransactionTypeGroup.Core;
DelegateResignationTransaction.type = TransactionType.DelegateResignation;
DelegateResignationTransaction.key = "delegateResignation";
DelegateResignationTransaction.version = 2;
DelegateResignationTransaction.defaultStaticFee = BigNumber.make("2500000000");

class HtlcLockTransaction extends Transaction {
  static getSchema() {
    return htlcLock;
  }

  verify() {
    var milestone = configManager.getMilestone();
    return milestone.aip11 === true && milestone.htlcEnabled === true && super.verify();
  }

  hasVendorField() {
    return true;
  }

  serialize(options) {
    var {
      data
    } = this;
    var buffer = new ByteBuffer(8 + 32 + 1 + 4 + 21, true); // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.

    buffer.writeUint64(data.amount.toString());

    if (data.asset && data.asset.lock) {
      buffer.append(Buffer.from(data.asset.lock.secretHash, "hex"));
      buffer.writeUint8(data.asset.lock.expiration.type);
      buffer.writeUint32(data.asset.lock.expiration.value);
    }

    if (data.recipientId) {
      buffer.append(Address.toBuffer(data.recipientId).addressBuffer);
    }

    return buffer;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    var amount = BigNumber.make(buf.readUint64().toString());
    var secretHash = buf.readBytes(32).toString("hex");
    var expirationType = buf.readUint8();
    var expirationValue = buf.readUint32();
    var recipientId = Address.fromBuffer(buf.readBytes(21).toBuffer());
    data.amount = amount;
    data.recipientId = recipientId;
    data.asset = {
      lock: {
        secretHash,
        expiration: {
          type: expirationType,
          value: expirationValue
        }
      }
    };
  }

}
HtlcLockTransaction.typeGroup = TransactionTypeGroup.Core;
HtlcLockTransaction.type = TransactionType.HtlcLock;
HtlcLockTransaction.key = "htlcLock";
HtlcLockTransaction.version = 2;
HtlcLockTransaction.defaultStaticFee = BigNumber.make("10000000");

class HtlcClaimTransaction extends Transaction {
  static getSchema() {
    return htlcClaim;
  }

  verify() {
    var milestone = configManager.getMilestone();
    return milestone.aip11 === true && milestone.htlcEnabled === true && super.verify();
  }

  serialize(options) {
    var {
      data
    } = this;
    var buffer = new ByteBuffer(32 + 32, true);

    if (data.asset && data.asset.claim) {
      buffer.append(Buffer.from(data.asset.claim.lockTransactionId, "hex"));
      buffer.append(Buffer.from(data.asset.claim.unlockSecret, "hex"));
    }

    return buffer;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    var lockTransactionId = buf.readBytes(32).toString("hex");
    var unlockSecret = buf.readBytes(32).toString("hex");
    data.asset = {
      claim: {
        lockTransactionId,
        unlockSecret
      }
    };
  }

}
HtlcClaimTransaction.typeGroup = TransactionTypeGroup.Core;
HtlcClaimTransaction.type = TransactionType.HtlcClaim;
HtlcClaimTransaction.key = "htlcClaim";
HtlcClaimTransaction.version = 2;
HtlcClaimTransaction.defaultStaticFee = BigNumber.ZERO;

class HtlcRefundTransaction extends Transaction {
  static getSchema() {
    return htlcRefund;
  }

  verify() {
    var milestone = configManager.getMilestone();
    return milestone.aip11 === true && milestone.htlcEnabled === true && super.verify();
  }

  serialize(options) {
    var {
      data
    } = this;
    var buffer = new ByteBuffer(32, true);

    if (data.asset && data.asset.refund) {
      buffer.append(Buffer.from(data.asset.refund.lockTransactionId, "hex"));
    }

    return buffer;
  }

  deserialize(buf) {
    var {
      data
    } = this;
    var lockTransactionId = buf.readBytes(32).toString("hex");
    data.asset = {
      refund: {
        lockTransactionId
      }
    };
  }

}
HtlcRefundTransaction.typeGroup = TransactionTypeGroup.Core;
HtlcRefundTransaction.type = TransactionType.HtlcRefund;
HtlcRefundTransaction.key = "htlcRefund";
HtlcRefundTransaction.version = 2;
HtlcRefundTransaction.defaultStaticFee = BigNumber.ZERO;

var index$6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TransferTransaction: TransferTransaction$1,
  SecondSignatureRegistrationTransaction: SecondSignatureRegistrationTransaction$1,
  DelegateRegistrationTransaction: DelegateRegistrationTransaction$1,
  VoteTransaction: VoteTransaction$1,
  MultiSignatureRegistrationTransaction: MultiSignatureRegistrationTransaction$1,
  IpfsTransaction: IpfsTransaction,
  MultiPaymentTransaction: MultiPaymentTransaction,
  DelegateResignationTransaction: DelegateResignationTransaction,
  HtlcLockTransaction: HtlcLockTransaction,
  HtlcClaimTransaction: HtlcClaimTransaction,
  HtlcRefundTransaction: HtlcRefundTransaction
});

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
class Signer {
  static sign(transaction, keys, options) {
    if (!options || options.excludeSignature === undefined && options.excludeSecondSignature === undefined) {
      options = _objectSpread$1({
        excludeSignature: true,
        excludeSecondSignature: true
      }, options);
    }

    var hash = Utils.toHash(transaction, options);
    var signature = transaction.version && transaction.version > 1 ? Hash.signSchnorr(hash, keys) : Hash.signECDSA(hash, keys);

    if (!transaction.signature && !options.excludeMultiSignature) {
      transaction.signature = signature;
    }

    return signature;
  }

  static secondSign(transaction, keys) {
    var hash = Utils.toHash(transaction, {
      excludeSecondSignature: true
    });
    var signature = transaction.version && transaction.version > 1 ? Hash.signSchnorr(hash, keys) : Hash.signECDSA(hash, keys);

    if (!transaction.secondSignature) {
      transaction.secondSignature = signature;
    }

    return signature;
  }

  static multiSign(transaction, keys) {
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

    if (!transaction.signatures) {
      transaction.signatures = [];
    }

    index = index === -1 ? transaction.signatures.length : index;
    var hash = Utils.toHash(transaction, {
      excludeSignature: true,
      excludeSecondSignature: true,
      excludeMultiSignature: true
    });
    var signature = Hash.signSchnorr(hash, keys);
    var indexedSignature = "".concat(numberToHex(index)).concat(signature);
    transaction.signatures.push(indexedSignature);
    return indexedSignature;
  }

}

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
class TransactionBuilder {
  constructor() {
    this.signWithSenderAsRecipient = false;
    this.disableVersionCheck = false;
    this.data = {
      id: undefined,
      timestamp: Slots.getTime(),
      typeGroup: TransactionTypeGroup.Test,
      nonce: BigNumber.ZERO,
      version: configManager.getMilestone().aip11 ? 0x02 : 0x01
    };
  }

  build() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return TransactionFactory.fromData(_objectSpread$2(_objectSpread$2({}, this.data), data), false, {
      disableVersionCheck: this.disableVersionCheck
    });
  }

  version(version) {
    this.data.version = version;
    this.disableVersionCheck = true;
    return this.instance();
  }

  typeGroup(typeGroup) {
    this.data.typeGroup = typeGroup;
    return this.instance();
  }

  nonce(nonce) {
    if (nonce) {
      this.data.nonce = BigNumber.make(nonce);
    }

    return this.instance();
  }

  network(network) {
    this.data.network = network;
    return this.instance();
  }

  fee(fee) {
    if (fee) {
      this.data.fee = BigNumber.make(fee);
    }

    return this.instance();
  }

  amount(amount) {
    this.data.amount = BigNumber.make(amount);
    return this.instance();
  }

  recipientId(recipientId) {
    this.data.recipientId = recipientId;
    return this.instance();
  }

  senderPublicKey(publicKey) {
    this.data.senderPublicKey = publicKey;
    return this.instance();
  }

  vendorField(vendorField) {
    var limit = maxVendorFieldLength();

    if (vendorField) {
      if (Buffer.from(vendorField).length > limit) {
        throw new VendorFieldLengthExceededError(limit);
      }

      this.data.vendorField = vendorField;
    }

    return this.instance();
  }

  sign(passphrase) {
    var keys = Keys.fromPassphrase(passphrase);
    return this.signWithKeyPair(keys);
  }

  signWithWif(wif, networkWif) {
    var keys = Keys.fromWIF(wif, {
      wif: networkWif || configManager.get("network.wif")
    });
    return this.signWithKeyPair(keys);
  }

  secondSign(secondPassphrase) {
    return this.secondSignWithKeyPair(Keys.fromPassphrase(secondPassphrase));
  }

  secondSignWithWif(wif, networkWif) {
    var keys = Keys.fromWIF(wif, {
      wif: networkWif || configManager.get("network.wif")
    });
    return this.secondSignWithKeyPair(keys);
  }

  multiSign(passphrase, index) {
    var keys = Keys.fromPassphrase(passphrase);
    return this.multiSignWithKeyPair(index, keys);
  }

  multiSignWithWif(index, wif, networkWif) {
    var keys = Keys.fromWIF(wif, {
      wif: networkWif || configManager.get("network.wif")
    });
    return this.multiSignWithKeyPair(index, keys);
  }

  verify() {
    return Verifier.verifyHash(this.data, this.disableVersionCheck);
  }

  getStruct() {
    if (!this.data.senderPublicKey || !this.data.signature && !this.data.signatures) {
      throw new MissingTransactionSignatureError();
    }

    var struct = {
      id: Utils.getId(this.data).toString(),
      signature: this.data.signature,
      secondSignature: this.data.secondSignature,
      version: this.data.version,
      type: this.data.type,
      fee: this.data.fee,
      senderPublicKey: this.data.senderPublicKey,
      network: this.data.network
    };

    if (this.data.version === 1) {
      struct.timestamp = this.data.timestamp;
    } else {
      struct.typeGroup = this.data.typeGroup;
      struct.nonce = this.data.nonce;
    }

    if (Array.isArray(this.data.signatures)) {
      struct.signatures = this.data.signatures;
    }

    return struct;
  }

  signWithKeyPair(keys) {
    this.data.senderPublicKey = keys.publicKey;

    if (this.signWithSenderAsRecipient) {
      this.data.recipientId = Address.fromPublicKey(keys.publicKey, this.data.network);
    }

    this.data.signature = Signer.sign(this.getSigningObject(), keys, {
      disableVersionCheck: this.disableVersionCheck
    });
    return this.instance();
  }

  secondSignWithKeyPair(keys) {
    this.data.secondSignature = Signer.secondSign(this.getSigningObject(), keys);
    return this.instance();
  }

  multiSignWithKeyPair(index, keys) {
    if (!this.data.signatures) {
      this.data.signatures = [];
    }

    this.version(2);
    Signer.multiSign(this.getSigningObject(), keys, index);
    return this.instance();
  }

  getSigningObject() {
    var data = _objectSpread$2({}, this.data);

    for (var key of Object.keys(data)) {
      if (["model", "network", "id"].includes(key)) {
        delete data[key];
      }
    }

    return data;
  }

}

class DelegateRegistrationBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = DelegateRegistrationTransaction$1.type;
    this.data.typeGroup = DelegateRegistrationTransaction$1.typeGroup;
    this.data.fee = DelegateRegistrationTransaction$1.staticFee();
    this.data.amount = BigNumber.ZERO;
    this.data.recipientId = undefined;
    this.data.senderPublicKey = undefined;
    this.data.asset = {
      delegate: {}
    };
  }

  usernameAsset(username) {
    if (this.data.asset && this.data.asset.delegate) {
      this.data.asset.delegate.username = username;
    }

    return this;
  }

  getStruct() {
    var struct = super.getStruct();
    struct.amount = this.data.amount;
    struct.recipientId = this.data.recipientId;
    struct.asset = this.data.asset;
    return struct;
  }

  instance() {
    return this;
  }

}

class DelegateResignationBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = DelegateResignationTransaction.type;
    this.data.typeGroup = DelegateResignationTransaction.typeGroup;
    this.data.version = 2;
    this.data.fee = DelegateResignationTransaction.staticFee();
    this.data.amount = BigNumber.ZERO;
    this.data.senderPublicKey = undefined;
  }

  getStruct() {
    var struct = super.getStruct();
    struct.amount = this.data.amount;
    return struct;
  }

  instance() {
    return this;
  }

}

class HtlcClaimBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = HtlcClaimTransaction.type;
    this.data.typeGroup = HtlcClaimTransaction.typeGroup;
    this.data.fee = HtlcClaimTransaction.staticFee();
    this.data.amount = BigNumber.ZERO;
    this.data.asset = {};
  }

  htlcClaimAsset(claimAsset) {
    this.data.asset = {
      claim: claimAsset
    };
    return this;
  }

  getStruct() {
    var struct = super.getStruct();
    struct.amount = this.data.amount;
    struct.asset = this.data.asset;
    return struct;
  }

  instance() {
    return this;
  }

}

class HtlcLockBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = HtlcLockTransaction.type;
    this.data.typeGroup = HtlcLockTransaction.typeGroup;
    this.data.recipientId = undefined;
    this.data.amount = BigNumber.ZERO;
    this.data.fee = HtlcLockTransaction.staticFee();
    this.data.vendorField = undefined;
    this.data.asset = {};
  }

  htlcLockAsset(lockAsset) {
    this.data.asset = {
      lock: lockAsset
    };
    return this;
  }

  getStruct() {
    var struct = super.getStruct();
    struct.recipientId = this.data.recipientId;
    struct.amount = this.data.amount;
    struct.vendorField = this.data.vendorField;
    struct.asset = this.data.asset;
    return struct;
  }

  expiration(expiration) {
    return this;
  }

  instance() {
    return this;
  }

}

class HtlcRefundBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = HtlcRefundTransaction.type;
    this.data.typeGroup = HtlcRefundTransaction.typeGroup;
    this.data.fee = HtlcRefundTransaction.staticFee();
    this.data.amount = BigNumber.ZERO;
    this.data.asset = {};
  }

  htlcRefundAsset(refundAsset) {
    this.data.asset = {
      refund: refundAsset
    };
    return this;
  }

  getStruct() {
    var struct = super.getStruct();
    struct.amount = this.data.amount;
    struct.asset = this.data.asset;
    return struct;
  }

  instance() {
    return this;
  }

}

class IPFSBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = IpfsTransaction.type;
    this.data.typeGroup = IpfsTransaction.typeGroup;
    this.data.fee = IpfsTransaction.staticFee();
    this.data.amount = BigNumber.ZERO;
    this.data.asset = {};
  }

  ipfsAsset(ipfsId) {
    this.data.asset = {
      ipfs: ipfsId
    };
    return this;
  }

  getStruct() {
    var struct = super.getStruct();
    struct.amount = this.data.amount;
    struct.asset = this.data.asset;
    return struct;
  }

  instance() {
    return this;
  }

}

class MultiPaymentBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = MultiPaymentTransaction.type;
    this.data.typeGroup = MultiPaymentTransaction.typeGroup;
    this.data.fee = MultiPaymentTransaction.staticFee();
    this.data.vendorField = undefined;
    this.data.asset = {
      payments: []
    };
    this.data.amount = BigNumber.make(0);
  }

  addPayment(recipientId, amount) {
    if (this.data.asset && this.data.asset.payments) {
      var limit = configManager.getMilestone().multiPaymentLimit || 256;

      if (this.data.asset.payments.length >= limit) {
        throw new MaximumPaymentCountExceededError(limit);
      }

      this.data.asset.payments.push({
        amount: BigNumber.make(amount),
        recipientId
      });
    }

    return this;
  }

  getStruct() {
    if (!this.data.asset || !this.data.asset.payments || !Array.isArray(this.data.asset.payments) || this.data.asset.payments.length <= 1) {
      throw new MinimumPaymentCountSubceededError();
    }

    var struct = super.getStruct();
    struct.senderPublicKey = this.data.senderPublicKey;
    struct.vendorField = this.data.vendorField;
    struct.amount = this.data.amount;
    struct.asset = this.data.asset;
    return struct;
  }

  instance() {
    return this;
  }

}

class MultiSignatureBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = MultiSignatureRegistrationTransaction$1.type;
    this.data.typeGroup = MultiSignatureRegistrationTransaction$1.typeGroup;
    this.data.version = 2;
    this.data.fee = BigNumber.ZERO;
    this.data.amount = BigNumber.ZERO;
    this.data.recipientId = undefined;
    this.data.senderPublicKey = undefined;
    this.data.asset = {
      multiSignature: {
        min: 0,
        publicKeys: []
      }
    };
  }

  participant(publicKey) {
    if (this.data.asset && this.data.asset.multiSignature) {
      var {
        publicKeys
      } = this.data.asset.multiSignature;

      if (publicKeys.length <= 16) {
        publicKeys.push(publicKey);
        this.data.fee = MultiSignatureRegistrationTransaction$1.staticFee({
          data: this.data
        });
      }
    }

    return this;
  }

  min(min) {
    if (this.data.asset && this.data.asset.multiSignature) {
      this.data.asset.multiSignature.min = min;
    }

    return this;
  }

  multiSignatureAsset(multiSignature) {
    if (this.data.asset && this.data.asset.multiSignature) {
      this.data.asset.multiSignature = multiSignature;
      this.data.fee = MultiSignatureRegistrationTransaction$1.staticFee({
        data: this.data
      });
    }

    return this;
  }

  getStruct() {
    var struct = super.getStruct();
    struct.amount = this.data.amount;
    struct.recipientId = this.data.recipientId;
    struct.asset = this.data.asset;
    return struct;
  }

  instance() {
    return this;
  }

}

class SecondSignatureBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = SecondSignatureRegistrationTransaction$1.type;
    this.data.typeGroup = SecondSignatureRegistrationTransaction$1.typeGroup;
    this.data.fee = SecondSignatureRegistrationTransaction$1.staticFee();
    this.data.amount = BigNumber.ZERO;
    this.data.recipientId = undefined;
    this.data.senderPublicKey = undefined;
    this.data.asset = {
      signature: {}
    };
  }

  signatureAsset(secondPassphrase) {
    if (this.data.asset && this.data.asset.signature) {
      this.data.asset.signature.publicKey = Keys.fromPassphrase(secondPassphrase).publicKey;
    }

    return this;
  }

  getStruct() {
    var struct = super.getStruct();
    struct.amount = this.data.amount;
    struct.recipientId = this.data.recipientId;
    struct.asset = this.data.asset;
    return struct;
  }

  instance() {
    return this;
  }

}

class TransferBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = TransferTransaction$1.type;
    this.data.typeGroup = TransferTransaction$1.typeGroup;
    this.data.fee = TransferTransaction$1.staticFee();
    this.data.amount = BigNumber.ZERO;
    this.data.recipientId = undefined;
    this.data.senderPublicKey = undefined;
    this.data.expiration = 0;
  }

  expiration(expiration) {
    this.data.expiration = expiration;
    return this.instance();
  }

  getStruct() {
    var struct = super.getStruct();
    struct.amount = this.data.amount;
    struct.recipientId = this.data.recipientId;
    struct.asset = this.data.asset;
    struct.vendorField = this.data.vendorField;
    struct.expiration = this.data.expiration;
    return struct;
  }

  instance() {
    return this;
  }

}

class VoteBuilder extends TransactionBuilder {
  constructor() {
    super();
    this.data.type = VoteTransaction$1.type;
    this.data.typeGroup = VoteTransaction$1.typeGroup;
    this.data.fee = VoteTransaction$1.staticFee();
    this.data.amount = BigNumber.ZERO;
    this.data.recipientId = undefined;
    this.data.senderPublicKey = undefined;
    this.data.asset = {
      votes: []
    };
    this.signWithSenderAsRecipient = true;
  }

  votesAsset(votes) {
    if (this.data.asset && this.data.asset.votes) {
      this.data.asset.votes = votes;
    }

    return this;
  }

  getStruct() {
    var struct = super.getStruct();
    struct.amount = this.data.amount;
    struct.recipientId = this.data.recipientId;
    struct.asset = this.data.asset;
    return struct;
  }

  instance() {
    return this;
  }

}

class BuilderFactory {
  static transfer() {
    return new TransferBuilder();
  }

  static secondSignature() {
    return new SecondSignatureBuilder();
  }

  static delegateRegistration() {
    return new DelegateRegistrationBuilder();
  }

  static vote() {
    return new VoteBuilder();
  }

  static multiSignature() {
    return new MultiSignatureBuilder();
  }

  static ipfs() {
    return new IPFSBuilder();
  }

  static multiPayment() {
    return new MultiPaymentBuilder();
  }

  static delegateResignation() {
    return new DelegateResignationBuilder();
  }

  static htlcLock() {
    return new HtlcLockBuilder();
  }

  static htlcClaim() {
    return new HtlcClaimBuilder();
  }

  static htlcRefund() {
    return new HtlcRefundBuilder();
  }

}

class Deserializer {
  static applyV1Compatibility(transaction) {
    transaction.secondSignature = transaction.secondSignature || transaction.signSignature;
    transaction.typeGroup = TransactionTypeGroup.Core;

    if (transaction.type === TransactionType.Vote && transaction.senderPublicKey) {
      transaction.recipientId = Address.fromPublicKey(transaction.senderPublicKey, transaction.network);
    } else if (transaction.type === TransactionType.MultiSignature && transaction.asset && transaction.asset.multiSignatureLegacy) {
      transaction.asset.multiSignatureLegacy.keysgroup = transaction.asset.multiSignatureLegacy.keysgroup.map(k => k.startsWith("+") ? k : "+".concat(k));
    }
  }

  static deserialize(serialized) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var data = {};
    var buffer = this.getByteBuffer(serialized);
    this.deserializeCommon(data, buffer);
    var instance = TransactionTypeFactory.create(data);
    this.deserializeVendorField(instance, buffer); // Deserialize type specific parts

    instance.deserialize(buffer);
    this.deserializeSignatures(data, buffer);

    if (data.version) {
      if (options.acceptLegacyVersion || options.disableVersionCheck || isSupportedTransactionVersion(data.version)) {
        if (data.version === 1) {
          this.applyV1Compatibility(data);
        }
      } else {
        throw new TransactionVersionError(data.version);
      }
    }

    instance.serialized = buffer.flip().toBuffer();
    return instance;
  }

  static deserializeCommon(transaction, buf) {
    buf.skip(1); // Skip 0xFF marker

    transaction.version = buf.readUint8();
    transaction.network = buf.readUint8();

    if (transaction.version === 1) {
      transaction.type = buf.readUint8();
      transaction.timestamp = buf.readUint32();
    } else {
      transaction.typeGroup = buf.readUint32();
      transaction.type = buf.readUint16();
      transaction.nonce = BigNumber.make(buf.readUint64().toString());
    }

    transaction.senderPublicKey = buf.readBytes(33).toString("hex");
    transaction.fee = BigNumber.make(buf.readUint64().toString());
    transaction.amount = BigNumber.ZERO;
  }

  static deserializeVendorField(transaction, buf) {
    var vendorFieldLength = buf.readUint8();

    if (vendorFieldLength > 0) {
      if (transaction.hasVendorField()) {
        var vendorFieldBuffer = buf.readBytes(vendorFieldLength).toBuffer();
        transaction.data.vendorField = vendorFieldBuffer.toString("utf8");
      } else {
        buf.skip(vendorFieldLength);
      }
    }
  }

  static deserializeSignatures(transaction, buf) {
    if (transaction.version === 1) {
      this.deserializeECDSA(transaction, buf);
    } else {
      this.deserializeSchnorrOrECDSA(transaction, buf);
    }
  }

  static deserializeSchnorrOrECDSA(transaction, buf) {
    if (this.detectSchnorr(buf)) {
      this.deserializeSchnorr(transaction, buf);
    } else {
      this.deserializeECDSA(transaction, buf);
    }
  }

  static deserializeECDSA(transaction, buf) {
    var currentSignatureLength = () => {
      buf.mark();
      var lengthHex = buf.skip(1).readBytes(1).toString("hex");
      buf.reset();
      return parseInt(lengthHex, 16) + 2;
    }; // Signature


    if (buf.remaining()) {
      var signatureLength = currentSignatureLength();
      transaction.signature = buf.readBytes(signatureLength).toString("hex");
    }

    var beginningMultiSignature = () => {
      buf.mark();
      var marker = buf.readUint8();
      buf.reset();
      return marker === 255;
    }; // Second Signature


    if (buf.remaining() && !beginningMultiSignature()) {
      var secondSignatureLength = currentSignatureLength();
      transaction.secondSignature = buf.readBytes(secondSignatureLength).toString("hex");
    } // Multi Signatures


    if (buf.remaining() && beginningMultiSignature()) {
      buf.skip(1);
      var multiSignature = buf.readBytes(buf.limit - buf.offset).toString("hex");
      transaction.signatures = [multiSignature];
    }

    if (buf.remaining()) {
      throw new InvalidTransactionBytesError("signature buffer not exhausted");
    }
  }

  static deserializeSchnorr(transaction, buf) {
    var canReadNonMultiSignature = () => {
      return buf.remaining() && (buf.remaining() % 64 === 0 || buf.remaining() % 65 !== 0);
    };

    if (canReadNonMultiSignature()) {
      transaction.signature = buf.readBytes(64).toString("hex");
    }

    if (canReadNonMultiSignature()) {
      transaction.secondSignature = buf.readBytes(64).toString("hex");
    }

    if (buf.remaining()) {
      if (buf.remaining() % 65 === 0) {
        transaction.signatures = [];
        var count = buf.remaining() / 65;
        var publicKeyIndexes = {};

        for (var i = 0; i < count; i++) {
          var multiSignaturePart = buf.readBytes(65).toString("hex");
          var publicKeyIndex = parseInt(multiSignaturePart.slice(0, 2), 16);

          if (!publicKeyIndexes[publicKeyIndex]) {
            publicKeyIndexes[publicKeyIndex] = true;
          } else {
            throw new DuplicateParticipantInMultiSignatureError();
          }

          transaction.signatures.push(multiSignaturePart);
        }
      } else {
        throw new InvalidTransactionBytesError("signature buffer not exhausted");
      }
    }
  }

  static detectSchnorr(buf) {
    var remaining = buf.remaining(); // `signature` / `secondSignature`

    if (remaining === 64 || remaining === 128) {
      return true;
    } // `signatures` of a multi signature transaction (type != 4)


    if (remaining % 65 === 0) {
      return true;
    } // only possiblity left is a type 4 transaction with and without a `secondSignature`.


    if ((remaining - 64) % 65 === 0 || (remaining - 128) % 65 === 0) {
      return true;
    }

    return false;
  }

  static getByteBuffer(serialized) {
    if (!(serialized instanceof Buffer)) {
      serialized = Buffer.from(serialized, "hex");
    }

    var buffer = new ByteBuffer(serialized.length, true);
    buffer.append(serialized);
    buffer.reset();
    return buffer;
  }

}

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
class TransactionFactory {
  static fromHex(hex) {
    return this.fromSerialized(hex);
  }

  static fromBytes(buffer) {
    var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.fromSerialized(buffer.toString("hex"), strict, options);
  }
  /**
   * Deserializes a transaction from `buffer` with the given `id`. It is faster
   * than `fromBytes` at the cost of vital safety checks (validation, verification and id calculation).
   *
   * NOTE: Only use this internally when it is safe to assume the buffer has already been
   * verified.
   */


  static fromBytesUnsafe(buffer, id) {
    try {
      var options = {
        acceptLegacyVersion: true
      };
      var transaction = Deserializer.deserialize(buffer, options);
      transaction.data.id = id || Utils.getId(transaction.data, options);
      transaction.isVerified = true;
      return transaction;
    } catch (error) {
      throw new InvalidTransactionBytesError(error.message);
    }
  }

  static fromJson(json) {
    var data = _objectSpread$3({}, json);

    data.amount = BigNumber.make(data.amount);
    data.fee = BigNumber.make(data.fee);
    return this.fromData(data);
  }

  static fromData(data) {
    var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      value,
      error
    } = Verifier.verifySchema(data, strict);

    if (error && !isException(value)) {
      throw new TransactionSchemaError(error);
    }

    var transaction = TransactionTypeFactory.create(value);
    var {
      version
    } = transaction.data;

    if (version === 1) {
      Deserializer.applyV1Compatibility(transaction.data);
    }

    Serializer.serialize(transaction);
    return this.fromBytes(transaction.serialized, strict, options);
  }

  static fromSerialized(serialized) {
    var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    try {
      var transaction = Deserializer.deserialize(serialized, options);
      transaction.data.id = Utils.getId(transaction.data, options);
      var {
        value,
        error
      } = Verifier.verifySchema(transaction.data, strict);

      if (error && !isException(value)) {
        throw new TransactionSchemaError(error);
      }

      transaction.isVerified = transaction.verify(options);
      return transaction;
    } catch (error) {
      if (error instanceof TransactionVersionError || error instanceof TransactionSchemaError || error instanceof DuplicateParticipantInMultiSignatureError) {
        throw error;
      }

      throw new InvalidTransactionBytesError(error.message);
    }
  }

}

class TransactionRegistry {
  constructor() {
    this.transactionTypes = new Map();
    TransactionTypeFactory.initialize(this.transactionTypes);
    this.registerTransactionType(TransferTransaction);
    this.registerTransactionType(TransferTransaction$1);
    this.registerTransactionType(SecondSignatureRegistrationTransaction);
    this.registerTransactionType(SecondSignatureRegistrationTransaction$1);
    this.registerTransactionType(DelegateRegistrationTransaction);
    this.registerTransactionType(DelegateRegistrationTransaction$1);
    this.registerTransactionType(VoteTransaction);
    this.registerTransactionType(VoteTransaction$1);
    this.registerTransactionType(MultiSignatureRegistrationTransaction);
    this.registerTransactionType(MultiSignatureRegistrationTransaction$1);
    this.registerTransactionType(IpfsTransaction);
    this.registerTransactionType(MultiPaymentTransaction);
    this.registerTransactionType(DelegateResignationTransaction);
    this.registerTransactionType(HtlcLockTransaction);
    this.registerTransactionType(HtlcClaimTransaction);
    this.registerTransactionType(HtlcRefundTransaction);
  }

  registerTransactionType(constructor) {
    var _this$transactionType;

    var {
      typeGroup,
      type
    } = constructor;

    if (typeof type === "undefined" || typeof typeGroup === "undefined") {
      throw new Error();
    }

    var internalType = InternalTransactionType.from(type, typeGroup);

    for (var registeredConstructors of this.transactionTypes.values()) {
      if (registeredConstructors.size) {
        var first = [...registeredConstructors.values()][0];

        if (first.key === constructor.key && InternalTransactionType.from(first.type, first.typeGroup) !== internalType) {
          throw new TransactionKeyAlreadyRegisteredError(first.key);
        }

        for (var registeredConstructor of registeredConstructors.values()) {
          if (registeredConstructor === constructor) {
            throw new TransactionAlreadyRegisteredError(constructor.name);
          }
        }
      }
    }

    if (!this.transactionTypes.has(internalType)) {
      this.transactionTypes.set(internalType, new Map());
    } else if ((_this$transactionType = this.transactionTypes.get(internalType)) === null || _this$transactionType === void 0 ? void 0 : _this$transactionType.has(constructor.version)) {
      throw new TransactionVersionAlreadyRegisteredError(constructor.name, constructor.version);
    }

    this.transactionTypes.get(internalType).set(constructor.version, constructor);
    this.updateSchemas(constructor);
  }

  deregisterTransactionType(constructor) {
    var {
      typeGroup,
      type,
      version
    } = constructor;

    if (typeof type === "undefined" || typeof typeGroup === "undefined") {
      throw new Error();
    }

    var internalType = InternalTransactionType.from(type, typeGroup);

    if (!this.transactionTypes.has(internalType)) {
      throw new UnkownTransactionError(internalType.toString());
    }

    this.updateSchemas(constructor, true);
    var constructors = this.transactionTypes.get(internalType);

    if (!constructors.has(version)) {
      throw new UnkownTransactionError(internalType.toString());
    }

    constructors.delete(version);

    if (constructors.size === 0) {
      this.transactionTypes.delete(internalType);
    }
  }

  updateSchemas(transaction, remove) {
    validator.extendTransaction(transaction.getSchema(), remove);
  }

}

var transactionRegistry = new TransactionRegistry();

var index$7 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TransactionRegistry: transactionRegistry,
  TransactionBuilder: TransactionBuilder,
  BuilderFactory: BuilderFactory,
  Deserializer: Deserializer,
  TransactionFactory: TransactionFactory,
  Serializer: Serializer,
  Signer: Signer,
  One: index$5,
  schemas: schemas,
  Two: index$6,
  Transaction: Transaction,
  TransactionTypeFactory: TransactionTypeFactory,
  InternalTransactionType: InternalTransactionType,
  Utils: Utils,
  Verifier: Verifier
});

class Serializer$1 {
  static size(block) {
    var size = this.headerSize(block.data) + block.data.blockSignature.length / 2;

    for (var transaction of block.transactions) {
      size += 4
      /* tx length */
      + transaction.serialized.length;
    }

    return size;
  }

  static serializeWithTransactions(block) {
    var transactions = block.transactions || [];
    block.numberOfTransactions = block.numberOfTransactions || transactions.length;
    var serializedHeader = this.serialize(block);
    var buffer = new ByteBuffer(serializedHeader.length + transactions.length * 4, true).append(serializedHeader).skip(transactions.length * 4);

    for (var i = 0; i < transactions.length; i++) {
      var serialized = Utils.toBytes(transactions[i]);
      buffer.writeUint32(serialized.length, serializedHeader.length + i * 4);
      buffer.append(serialized);
    }

    return buffer.flip().toBuffer();
  }

  static serialize(block) {
    var includeSignature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var buffer = new ByteBuffer(512, true);
    this.serializeHeader(block, buffer);

    if (includeSignature) {
      this.serializeSignature(block, buffer);
    }

    return buffer.flip().toBuffer();
  }

  static headerSize(block) {
    var constants = configManager.getMilestone(block.height - 1 || 1);
    return 4 + // version
    4 + // timestamp
    4 + ( // height
    constants.block.idFullSha256 ? 32 : 8) + // previousBlock
    4 + // numberOfTransactions
    8 + // totalAmount
    8 + // totalFee
    8 + // reward
    4 + // payloadLength
    block.payloadHash.length / 2 + block.generatorPublicKey.length / 2;
  }

  static serializeHeader(block, buffer) {
    var constants = configManager.getMilestone(block.height - 1 || 1);

    if (constants.block.idFullSha256) {
      if (block.previousBlock.length !== 64) {
        throw new PreviousBlockIdFormatError(block.height, block.previousBlock);
      }

      block.previousBlockHex = block.previousBlock;
    } else {
      block.previousBlockHex = Block.toBytesHex(block.previousBlock);
    }

    buffer.writeUint32(block.version);
    buffer.writeUint32(block.timestamp);
    buffer.writeUint32(block.height);
    buffer.append(block.previousBlockHex, "hex");
    buffer.writeUint32(block.numberOfTransactions); // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.

    buffer.writeUint64(block.totalAmount.toString()); // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.

    buffer.writeUint64(block.totalFee.toString()); // @ts-ignore - The ByteBuffer types say we can't use strings but the code actually handles them.

    buffer.writeUint64(block.reward.toString());
    buffer.writeUint32(block.payloadLength);
    buffer.append(block.payloadHash, "hex");
    buffer.append(block.generatorPublicKey, "hex");
    assert.strictEqual(buffer.offset, this.headerSize(block));
  }

  static serializeSignature(block, buffer) {
    if (block.blockSignature) {
      buffer.append(block.blockSignature, "hex");
    }
  }

}

class Block {
  constructor(_ref) {
    var {
      data,
      transactions,
      id
    } = _ref;
    this.data = data; // TODO genesis block calculated id is wrong for some reason

    if (this.data.height === 1) {
      if (id) {
        this.applyGenesisBlockFix(id);
      } else if (data.id) {
        this.applyGenesisBlockFix(data.id);
      }
    } // fix on real timestamp, this is overloading transaction
    // timestamp with block timestamp for storage only
    // also add sequence to keep database sequence


    this.transactions = transactions.map((transaction, index) => {
      transaction.data.blockId = this.data.id;
      transaction.data.blockHeight = this.data.height;
      transaction.data.sequence = index;
      transaction.timestamp = this.data.timestamp;
      return transaction;
    });
    delete this.data.transactions;
    this.verification = this.verify(); // Order of transactions messed up in mainnet V1

    var {
      wrongTransactionOrder
    } = configManager.get("exceptions");

    if (this.data.id && wrongTransactionOrder && wrongTransactionOrder[this.data.id]) {
      var fixedOrderIds = wrongTransactionOrder[this.data.id];
      this.transactions = fixedOrderIds.map(id => this.transactions.find(transaction => transaction.id === id));
    }
  }

  static applySchema(data) {
    var result = validator.validate("block", data);

    if (!result.error) {
      return result.value;
    }

    result = validator.validateException("block", data);

    if (!result.errors) {
      return result.value;
    }

    for (var err of result.errors) {
      var fatal = false;
      var match = err.dataPath.match(/\.transactions\[([0-9]+)\]/);

      if (match === null) {
        if (!isException(data)) {
          fatal = true;
        }
      } else {
        var txIndex = match[1];

        if (data.transactions) {
          var tx = data.transactions[txIndex];

          if (tx.id === undefined || !isException(tx)) {
            fatal = true;
          }
        }
      }

      if (fatal) {
        throw new BlockSchemaError(data.height, "Invalid data".concat(err.dataPath ? " at " + err.dataPath : "", ": ") + "".concat(err.message, ": ").concat(JSON.stringify(err.data)));
      }
    }

    return result.value;
  }

  static getIdHex(data) {
    var constants = configManager.getMilestone(data.height);
    var payloadHash = Serializer$1.serialize(data);
    var hash = HashAlgorithms.sha256(payloadHash);

    if (constants.block.idFullSha256) {
      return hash.toString("hex");
    }

    var temp = Buffer.alloc(8);

    for (var i = 0; i < 8; i++) {
      temp[i] = hash[7 - i];
    }

    return temp.toString("hex");
  }

  static toBytesHex(data) {
    var temp = data ? BigNumber.make(data).toString(16) : "";
    return "0".repeat(16 - temp.length) + temp;
  }

  static getId(data) {
    var constants = configManager.getMilestone(data.height);
    var idHex = Block.getIdHex(data);
    return constants.block.idFullSha256 ? idHex : BigNumber.make("0x".concat(idHex)).toString();
  }

  getHeader() {
    var header = Object.assign({}, this.data);
    delete header.transactions;
    return header;
  }

  verifySignature() {
    var bytes = Serializer$1.serialize(this.data, false);
    var hash = HashAlgorithms.sha256(bytes);

    if (!this.data.blockSignature) {
      throw new Error();
    }

    return Hash.verifyECDSA(hash, this.data.blockSignature, this.data.generatorPublicKey);
  }

  toJson() {
    var data = JSON.parse(JSON.stringify(this.data));
    data.reward = this.data.reward.toString();
    data.totalAmount = this.data.totalAmount.toString();
    data.totalFee = this.data.totalFee.toString();
    data.transactions = this.transactions.map(transaction => transaction.toJson());
    return data;
  }

  verify() {
    var block = this.data;
    var result = {
      verified: false,
      containsMultiSignatures: false,
      errors: []
    };

    try {
      var constants = configManager.getMilestone(block.height);

      if (block.height !== 1) {
        if (!block.previousBlock) {
          result.errors.push("Invalid previous block");
        }
      }

      if (!block.reward.isEqualTo(constants.reward)) {
        result.errors.push(["Invalid block reward:", block.reward, "expected:", constants.reward].join(" "));
      }

      var valid = this.verifySignature();

      if (!valid) {
        result.errors.push("Failed to verify block signature");
      }

      if (block.version !== constants.block.version) {
        result.errors.push("Invalid block version");
      }

      if (block.timestamp > Slots.getTime() + configManager.getMilestone(block.height).blocktime) {
        result.errors.push("Invalid block timestamp");
      }

      var size = Serializer$1.size(this);

      if (size > constants.block.maxPayload) {
        result.errors.push("Payload is too large: ".concat(size, " > ").concat(constants.block.maxPayload));
      }

      var invalidTransactions = this.transactions.filter(tx => !tx.verified);

      if (invalidTransactions.length > 0) {
        result.errors.push("One or more transactions are not verified:");

        for (var invalidTransaction of invalidTransactions) {
          result.errors.push("=> ".concat(invalidTransaction.serialized.toString("hex")));
        }

        result.containsMultiSignatures = invalidTransactions.some(tx => !!tx.data.signatures);
      }

      if (this.transactions.length !== block.numberOfTransactions) {
        result.errors.push("Invalid number of transactions");
      }

      if (this.transactions.length > constants.block.maxTransactions) {
        if (block.height > 1) {
          result.errors.push("Transactions length is too high");
        }
      } // Checking if transactions of the block adds up to block values.


      var appliedTransactions = {};
      var totalAmount = BigNumber.ZERO;
      var totalFee = BigNumber.ZERO;
      var payloadBuffers = [];

      for (var transaction of this.transactions) {
        if (!transaction.data || !transaction.data.id) {
          throw new Error();
        }

        var bytes = Buffer.from(transaction.data.id, "hex");

        if (appliedTransactions[transaction.data.id]) {
          result.errors.push("Encountered duplicate transaction: ".concat(transaction.data.id));
        }

        if (transaction.data.expiration && transaction.data.expiration > 0 && transaction.data.expiration <= this.data.height) {
          var _isException = configManager.get("network.name") === "devnet" && constants.ignoreExpiredTransactions;

          if (!_isException) {
            result.errors.push("Encountered expired transaction: ".concat(transaction.data.id));
          }
        }

        if (transaction.data.version === 1 && !constants.block.acceptExpiredTransactionTimestamps) {
          var now = block.timestamp;

          if (transaction.data.timestamp > now + 3600 + constants.blocktime) {
            result.errors.push("Encountered future transaction: ".concat(transaction.data.id));
          } else if (now - transaction.data.timestamp > 21600) {
            result.errors.push("Encountered expired transaction: ".concat(transaction.data.id));
          }
        }

        appliedTransactions[transaction.data.id] = transaction.data;
        totalAmount = totalAmount.plus(transaction.data.amount);
        totalFee = totalFee.plus(transaction.data.fee);
        payloadBuffers.push(bytes);
      }

      if (!totalAmount.isEqualTo(block.totalAmount)) {
        result.errors.push("Invalid total amount");
      }

      if (!totalFee.isEqualTo(block.totalFee)) {
        result.errors.push("Invalid total fee");
      }

      if (HashAlgorithms.sha256(payloadBuffers).toString("hex") !== block.payloadHash) {
        result.errors.push("Invalid payload hash");
      }
    } catch (error) {
      result.errors.push(error);
    }

    result.verified = result.errors.length === 0;
    return result;
  }

  applyGenesisBlockFix(id) {
    this.data.id = id;
    this.data.idHex = id.length === 64 ? id : Block.toBytesHex(id); // if id.length is 64 it's already hex
  }

}

class Deserializer$1 {
  static deserialize(serialized) {
    var headerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var block = {};
    var transactions = [];
    var buf = new ByteBuffer(serialized.length, true);
    buf.append(serialized);
    buf.reset();
    this.deserializeHeader(block, buf);
    headerOnly = headerOnly || buf.remaining() === 0;

    if (!headerOnly) {
      transactions = this.deserializeTransactions(block, buf, options.deserializeTransactionsUnchecked);
    }

    block.idHex = Block.getIdHex(block);
    block.id = Block.getId(block);
    var {
      outlookTable
    } = configManager.get("exceptions");

    if (outlookTable && outlookTable[block.id]) {
      var constants = configManager.getMilestone(block.height);

      if (constants.block.idFullSha256) {
        block.id = outlookTable[block.id];
        block.idHex = block.id;
      } else {
        block.id = outlookTable[block.id];
        block.idHex = Block.toBytesHex(block.id);
      }
    }

    return {
      data: block,
      transactions
    };
  }

  static deserializeHeader(block, buf) {
    block.version = buf.readUint32();
    block.timestamp = buf.readUint32();
    block.height = buf.readUint32();
    var constants = configManager.getMilestone(block.height - 1 || 1);

    if (constants.block.idFullSha256) {
      var previousBlockFullSha256 = buf.readBytes(32).toString("hex");
      block.previousBlockHex = previousBlockFullSha256;
      block.previousBlock = previousBlockFullSha256;
    } else {
      block.previousBlockHex = buf.readBytes(8).toString("hex");
      block.previousBlock = BigNumber.make("0x".concat(block.previousBlockHex)).toString();
    }

    block.numberOfTransactions = buf.readUint32();
    block.totalAmount = BigNumber.make(buf.readUint64().toString());
    block.totalFee = BigNumber.make(buf.readUint64().toString());
    block.reward = BigNumber.make(buf.readUint64().toString());
    block.payloadLength = buf.readUint32();
    block.payloadHash = buf.readBytes(32).toString("hex");
    block.generatorPublicKey = buf.readBytes(33).toString("hex");

    var signatureLength = () => {
      buf.mark();
      var lengthHex = buf.skip(1).readBytes(1).toString("hex");
      buf.reset();
      return parseInt(lengthHex, 16) + 2;
    };

    block.blockSignature = buf.readBytes(signatureLength()).toString("hex");
  }

  static deserializeTransactions(block, buf) {
    var deserializeTransactionsUnchecked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var transactionLengths = [];

    for (var i = 0; i < block.numberOfTransactions; i++) {
      transactionLengths.push(buf.readUint32());
    }

    var transactions = [];
    block.transactions = [];

    for (var length of transactionLengths) {
      var transactionBytes = buf.readBytes(length).toBuffer();
      var transaction = deserializeTransactionsUnchecked ? TransactionFactory.fromBytesUnsafe(transactionBytes) : TransactionFactory.fromBytes(transactionBytes);
      transactions.push(transaction);
      block.transactions.push(transaction.data);
    }

    return transactions;
  }

}

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
class BlockFactory {
  // @todo: add a proper type hint for data
  static make(data, keys) {
    data.generatorPublicKey = keys.publicKey;
    var payloadHash = Serializer$1.serialize(data, false);
    var hash = HashAlgorithms.sha256(payloadHash);
    data.blockSignature = Hash.signECDSA(hash, keys);
    data.id = Block.getId(data);
    return this.fromData(data);
  }

  static fromHex(hex) {
    return this.fromSerialized(Buffer.from(hex, "hex"));
  }

  static fromBytes(buffer) {
    return this.fromSerialized(buffer);
  }

  static fromJson(json) {
    // @ts-ignore
    var data = _objectSpread$4({}, json);

    data.totalAmount = BigNumber.make(data.totalAmount);
    data.totalFee = BigNumber.make(data.totalFee);
    data.reward = BigNumber.make(data.reward);

    if (data.transactions) {
      for (var transaction of data.transactions) {
        transaction.amount = BigNumber.make(transaction.amount);
        transaction.fee = BigNumber.make(transaction.fee);
      }
    }

    return this.fromData(data);
  }

  static fromData(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var block = Block.applySchema(data);

    if (block) {
      var serialized = Serializer$1.serializeWithTransactions(data);

      var _block = new Block(_objectSpread$4(_objectSpread$4({}, Deserializer$1.deserialize(serialized, false, options)), {}, {
        id: data.id
      }));

      _block.serialized = serialized.toString("hex");
      return _block;
    }

    return undefined;
  }

  static fromSerialized(serialized) {
    var deserialized = Deserializer$1.deserialize(serialized);
    var validated = Block.applySchema(deserialized.data);

    if (validated) {
      deserialized.data = validated;
    }

    var block = new Block(deserialized);
    block.serialized = serialized.toString("hex");
    return block;
  }

}

var index$8 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Block: Block,
  Deserializer: Deserializer$1,
  BlockFactory: BlockFactory,
  Serializer: Serializer$1
});

var index$9 = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var types$1 = /*#__PURE__*/Object.freeze({
  __proto__: null
});

export { index$8 as Blocks, constants as Constants, index$2 as Crypto, enums as Enums, errors as Errors, index$1 as Identities, index$9 as Interfaces, index as Managers, networks as Networks, index$7 as Transactions, types$1 as Types, index$3 as Utils, index$4 as Validation };
